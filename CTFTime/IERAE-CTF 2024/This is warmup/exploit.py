from z3 import *

# Create 64-bit unsigned integer variables for nrow and ncol
nrow = BitVec('nrow', 64)
ncol = BitVec('ncol', 64)

# Define the maximum value for unsigned long long int
MAX_UINT64 = (1 << 64) - 1

# Create 128-bit constant for MAX_UINT64
MAX_UINT64_128 = BitVecVal(MAX_UINT64, 128)

# Create a solver instance
s = Solver()

# Constraints:

# 1. nrow and ncol are greater than zero
s.add(nrow > 0)
s.add(ncol > 0)

# 2. Compute the multiplication with 128-bit precision to detect overflow
nrow_ncol_128 = ZeroExt(64, nrow) * ZeroExt(64, ncol)  # 128-bit multiplication

# 3. Compute the product modulo 2^64 to simulate 64-bit unsigned overflow
nrow_ncol_64 = Extract(63, 0, nrow_ncol_128)  # Get lower 64 bits

# 4. Overflow occurs if the 128-bit product exceeds 2^64 - 1
overflow = nrow_ncol_128 > MAX_UINT64_128
s.add(overflow)

# 5. Overflow check in the program: (nrow * ncol) >= nrow (after overflow)
s.add(nrow_ncol_64 >= nrow)

# 6. Allocated size should be less than or equal to 90064 bytes
MAX_ALLOC_SIZE = 5
s.add(nrow_ncol_64 <= MAX_ALLOC_SIZE)

# 7. The maximum index accessed in the loops should exceed the allocated size
# Compute max_index = (nrow - 1) * ncol + (ncol - 1)
i = nrow - 1
j = ncol - 1

# Zero-extend i, j, and ncol to 128 bits
i_ext = ZeroExt(64, i)
j_ext = ZeroExt(64, j)
ncol_ext = ZeroExt(64, ncol)

# Compute the maximum index accessed as a 128-bit bit-vector
max_index_128 = i_ext * ncol_ext + j_ext  # 128-bit calculation

# Extend nrow_ncol_64 to 128 bits
nrow_ncol_64_ext = ZeroExt(64, nrow_ncol_64)  # Now a 128-bit bit-vector

# The index accessed should be greater than the allocated size
s.add(max_index_128 > nrow_ncol_64_ext)

# Optional: Ensure that the maximum index causes 64-bit overflow
s.add(max_index_128 > MAX_UINT64_128)

# Number of solutions to find
num_solutions = 2
solutions_found = 0

# Set to store found solutions to avoid duplicates
found_solutions = set()

print(f"Searching for up to {num_solutions} solutions with allocated size â‰¤ {MAX_ALLOC_SIZE} bytes...\n")

while solutions_found < num_solutions and s.check() == sat:
    m = s.model()
    nrow_value = m[nrow].as_long()
    ncol_value = m[ncol].as_long()
    alloc_size = (nrow_value * ncol_value) & MAX_UINT64  # Simulate 64-bit overflow

    # Avoid duplicate solutions
    if (nrow_value, ncol_value) in found_solutions:
        # Add a constraint to exclude this solution and continue
        s.add(Or(nrow != nrow_value, ncol != ncol_value))
        continue

    found_solutions.add((nrow_value, ncol_value))
    solutions_found += 1

    print(f"Solution #{solutions_found}:")
    print(f"nrow = {nrow_value}")
    print(f"ncol = {ncol_value}")
    print(f"Allocated size (after overflow) = {alloc_size} bytes\n")

    # Add a constraint to exclude this solution in future searches
    s.add(Or(nrow != nrow_value, ncol != ncol_value))

if solutions_found == 0:
    print("No solutions found.")
