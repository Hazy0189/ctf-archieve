/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_401020();
void sub_401030();
void sub_401040();
void sub_401050();
void sub_401060();
void sub_401070();
void sub_401080();
void sub_401090();
void sub_4010A0();
void sub_4010B0();
void sub_4010C0();
void sub_4010D0();
void sub_4010E0();
// void free(void *ptr);
// int puts(const char *s);
// int printf(const char *format, ...);
// void *memset(void *s, int c, size_t n);
// ssize_t read(int fd, void *buf, size_t nbytes);
// void *calloc(size_t nmemb, size_t size);
// void *memcpy(void *dest, const void *src, size_t n);
// void *malloc(size_t size);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// __int64 __isoc99_scanf(const char *, ...); weak
// __int64 __fastcall getrandom(_QWORD, _QWORD, _QWORD); weak
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)());
void dl_relocate_static_pie();
void *deregister_tm_clones();
__int64 register_tm_clones();
void *_do_global_dtors_aux();
__int64 frame_dummy(); // weak
int menu();
unsigned __int64 create();
unsigned __int64 write_in_allocation();
unsigned __int64 delete();
int __fastcall main(int argc, const char **argv, const char **envp);
void pop_rdi_ret();
__int64 __fastcall gc_alloc(unsigned int a1, __int64 a2);
__int64 __fastcall gc_free(unsigned __int64 a1);
__int64 __fastcall write_to(unsigned __int64 a1, const void *a2, unsigned int a3);
__int64 __fastcall write_to_with_offset(unsigned __int64 a1, const void *a2, unsigned int a3, unsigned int a4);
__int64 __fastcall read_from(unsigned __int64 a1, void *a2, unsigned int a3);
void *init_();
size_t __fastcall init(size_t a1);
_QWORD *__fastcall get_item(_QWORD *a1, unsigned __int64 a2);
__int64 __fastcall store_item(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int64 a7, __int64 a8, __int64 a9);
__int64 __fastcall swap_tree_nodes(_QWORD *a1, _QWORD *a2);
__int64 __fastcall delete_item(unsigned __int64 a1);
void term_proc();
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN _TMC_END__; // weak
FILE *stdout; // idb
FILE *stdin; // idb
FILE *stderr; // idb
char completed_0; // weak
__int64 CACHE; // weak
__int64 size; // weak
__int64 root; // weak


//----- (0000000000401000) ----------------------------------------------------
// Alternative name is '_init'
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 4040E0: using guessed type __int64 _gmon_start__(void);

//----- (0000000000401020) ----------------------------------------------------
void sub_401020()
{
  JUMPOUT(0);
}
// 401026: control flows out of bounds to 0

//----- (0000000000401030) ----------------------------------------------------
void sub_401030()
{
  sub_401020();
}

//----- (0000000000401040) ----------------------------------------------------
void sub_401040()
{
  sub_401020();
}

//----- (0000000000401050) ----------------------------------------------------
void sub_401050()
{
  sub_401020();
}

//----- (0000000000401060) ----------------------------------------------------
void sub_401060()
{
  sub_401020();
}

//----- (0000000000401070) ----------------------------------------------------
void sub_401070()
{
  sub_401020();
}

//----- (0000000000401080) ----------------------------------------------------
void sub_401080()
{
  sub_401020();
}

//----- (0000000000401090) ----------------------------------------------------
void sub_401090()
{
  sub_401020();
}

//----- (00000000004010A0) ----------------------------------------------------
void sub_4010A0()
{
  sub_401020();
}

//----- (00000000004010B0) ----------------------------------------------------
void sub_4010B0()
{
  sub_401020();
}

//----- (00000000004010C0) ----------------------------------------------------
void sub_4010C0()
{
  sub_401020();
}

//----- (00000000004010D0) ----------------------------------------------------
void sub_4010D0()
{
  sub_401020();
}

//----- (00000000004010E0) ----------------------------------------------------
void sub_4010E0()
{
  sub_401020();
}

//----- (00000000004011B0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)())
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (*)(int, char **, char **))main, v4, &retaddr, 0, 0, a3, &v5);
  __halt();
}
// 4011BA: positive sp value 8 has been found
// 4011C1: variable 'v3' is possibly undefined

//----- (00000000004011E0) ----------------------------------------------------
void dl_relocate_static_pie()
{
  ;
}

//----- (00000000004011F0) ----------------------------------------------------
void *deregister_tm_clones()
{
  return &_TMC_END__;
}

//----- (0000000000401220) ----------------------------------------------------
__int64 register_tm_clones()
{
  return 0;
}

//----- (0000000000401260) ----------------------------------------------------
void *_do_global_dtors_aux()
{
  void *result; // rax

  if ( !completed_0 )
  {
    result = deregister_tm_clones();
    completed_0 = 1;
  }
  return result;
}
// 404048: using guessed type char completed_0;

//----- (0000000000401290) ----------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}
// 401290: using guessed type __int64 frame_dummy();

//----- (0000000000401296) ----------------------------------------------------
int menu()
{
  puts("1. Create a new allocation");
  puts("2. Write something");
  puts("3. Delete an allocation");
  return printf("> ");
}

//----- (00000000004012E2) ----------------------------------------------------
unsigned __int64 create()
{
  __int64 v0; // rdx
  unsigned int v2; // [rsp+Ch] [rbp-24h] BYREF
  int v3; // [rsp+10h] [rbp-20h]
  __int64 v4; // [rsp+18h] [rbp-18h]
  unsigned __int64 v5; // [rsp+28h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  v2 = 0;
  printf("Enter size of the allocation: ");
  __isoc99_scanf("%d", &v2);
  v3 = gc_alloc(v2, (__int64)&v2);
  v4 = v0;
  if ( v3 )
    puts("Allocation failed");
  else
    printf("Allocation successfully created: %lu\n", v4);
  return v5 - __readfsqword(0x28u);
}
// 401345: variable 'v0' is possibly undefined
// 401190: using guessed type __int64 __isoc99_scanf(const char *, ...);

//----- (0000000000401392) ----------------------------------------------------
unsigned __int64 write_in_allocation()
{
  unsigned int v1; // [rsp+Ch] [rbp-424h] BYREF
  unsigned __int64 v2; // [rsp+10h] [rbp-420h] BYREF
  ssize_t v3; // [rsp+18h] [rbp-418h]
  _QWORD buf[129]; // [rsp+20h] [rbp-410h] BYREF
  unsigned __int64 v5; // [rsp+428h] [rbp-8h]

  v5 = __readfsqword(0x28u);
  v1 = 0;
  memset(buf, 0, 1024);
  v2 = 0;
  printf("Enter key: ");
  __isoc99_scanf("%lu", &v2);
  printf("Enter offset: ");
  __isoc99_scanf("%d", &v1);
  printf("Enter payload: ");
  v3 = read(0, buf, 0x400u);
  if ( v3 >= 0 )
    write_to_with_offset(v2, buf, v1, v3);
  return v5 - __readfsqword(0x28u);
}
// 401190: using guessed type __int64 __isoc99_scanf(const char *, ...);

//----- (00000000004014D4) ----------------------------------------------------
unsigned __int64 delete()
{
  unsigned __int64 v1; // [rsp+0h] [rbp-10h] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  v1 = 0;
  printf("Enter key: ");
  __isoc99_scanf("%lu", &v1);
  if ( (unsigned int)gc_free(v1) )
    puts("Dellocation failed");
  return v2 - __readfsqword(0x28u);
}
// 401190: using guessed type __int64 __isoc99_scanf(const char *, ...);

//----- (000000000040155C) ----------------------------------------------------
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)
{
  int v3; // [rsp+4h] [rbp-Ch] BYREF
  unsigned __int64 v4; // [rsp+8h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  setvbuf(stdout, 0, 2, 0);
  setvbuf(stderr, 0, 2, 0);
  setvbuf(stdin, 0, 2, 0);
  printf("A gift for you: %p\n", &v3);
  init(0x80u);
  while ( 1 )
  {
    while ( 1 )
    {
      menu();
      __isoc99_scanf("%d", &v3);
      if ( v3 != 3 )
        break;
      delete();
    }
    if ( v3 <= 3 )
    {
      if ( v3 == 1 )
      {
        create();
      }
      else if ( v3 == 2 )
      {
        write_in_allocation();
      }
    }
  }
}
// 401190: using guessed type __int64 __isoc99_scanf(const char *, ...);

//----- (000000000040165B) ----------------------------------------------------
void pop_rdi_ret()
{
  ;
}

//----- (0000000000401668) ----------------------------------------------------
__int64 __fastcall gc_alloc(unsigned int a1, __int64 a2)
{
  __int64 result; // rax
  size_t v3; // rdi
  __int64 v4; // rdx
  __int64 v5; // rcx
  __int64 v6; // r8
  __int64 v7; // r9
  unsigned __int64 v8; // [rsp+18h] [rbp-58h] BYREF
  __int64 v9; // [rsp+20h] [rbp-50h]
  size_t size; // [rsp+28h] [rbp-48h]
  __int64 v11; // [rsp+30h] [rbp-40h]
  unsigned __int64 v12; // [rsp+38h] [rbp-38h]
  unsigned __int64 v13; // [rsp+40h] [rbp-30h]
  size_t v14; // [rsp+48h] [rbp-28h]
  void *ptr; // [rsp+50h] [rbp-20h]
  unsigned __int64 v16; // [rsp+58h] [rbp-18h]

  v16 = __readfsqword(0x28u);
  size = a1;
  v8 = 0;
  v11 = 0;
  v12 = 0;
  while ( !v8 )
  {
    a2 = 8;
    v9 = getrandom(&v8, 8, 1);
  }
  if ( v9 >= 0 )
  {
    v13 = v8;
    v3 = size;
    ptr = malloc(size);
    v14 = size;
    LODWORD(v11) = store_item(v3, a2, v4, v5, v6, v7, v13, size, (__int64)ptr);
    if ( (_DWORD)v11 )
    {
      free(ptr);
      LODWORD(result) = v11;
    }
    else
    {
      v12 = v8;
      LODWORD(result) = 0;
    }
  }
  else
  {
    LODWORD(v11) = 1;
    LODWORD(result) = 1;
  }
  return (unsigned int)result;
}
// 401710: variable 'v4' is possibly undefined
// 401710: variable 'v5' is possibly undefined
// 401710: variable 'v6' is possibly undefined
// 401710: variable 'v7' is possibly undefined
// 4011A0: using guessed type __int64 __fastcall getrandom(_QWORD, _QWORD, _QWORD);

//----- (000000000040176B) ----------------------------------------------------
__int64 __fastcall gc_free(unsigned __int64 a1)
{
  void *v2[6]; // [rsp+10h] [rbp-30h] BYREF

  v2[5] = (void *)__readfsqword(0x28u);
  get_item(v2, a1);
  if ( LODWORD(v2[0]) )
    return 1;
  if ( (unsigned int)delete_item(a1) )
    return 1;
  free(v2[3]);
  return 0;
}

//----- (00000000004017F7) ----------------------------------------------------
__int64 __fastcall write_to(unsigned __int64 a1, const void *a2, unsigned int a3)
{
  void *v5[6]; // [rsp+20h] [rbp-30h] BYREF

  v5[5] = (void *)__readfsqword(0x28u);
  get_item(v5, a1);
  if ( LODWORD(v5[0]) )
    return 0;
  if ( v5[2] < (void *)a3 )
    return 0;
  memcpy(v5[3], a2, a3);
  return a3;
}

//----- (0000000000401880) ----------------------------------------------------
__int64 __fastcall write_to_with_offset(unsigned __int64 a1, const void *a2, unsigned int a3, unsigned int a4)
{
  _QWORD v7[6]; // [rsp+20h] [rbp-30h] BYREF

  v7[5] = __readfsqword(0x28u);
  get_item(v7, a1);
  if ( LODWORD(v7[0]) )
    return 0;
  if ( size_buffer < (unsigned __int64)(len + offset) )
    return 0;
  memcpy((void *)(offset + v7[3]), buffer, len);
  return a4;
}

//----- (0000000000401919) ----------------------------------------------------
__int64 __fastcall read_from(unsigned __int64 a1, void *a2, unsigned int a3)
{
  _QWORD v5[3]; // [rsp+30h] [rbp-30h] BYREF
  __int64 v6; // [rsp+48h] [rbp-18h]
  unsigned __int64 v7; // [rsp+58h] [rbp-8h]

  v7 = __readfsqword(0x28u);
  get_item(v5, a1);
  if ( LODWORD(v5[0]) )
    return 0;
  if ( *(_QWORD *)v6 < (unsigned __int64)a3 )
    return 0;
  memcpy(a2, *(const void **)(v6 + 8), a3);
  return a3;
}

//----- (00000000004019B1) ----------------------------------------------------
void *init_()
{
  void *result; // rax

  result = calloc(0x40u, 0x18u);
  CACHE = (__int64)result;
  size = 64;
  return result;
}
// 404058: using guessed type __int64 CACHE;
// 404060: using guessed type __int64 size;

//----- (00000000004019DD) ----------------------------------------------------
size_t __fastcall init(size_t a1)
{
  CACHE = (__int64)calloc(a1, 0x18u);
  size = a1;
  return a1;
}
// 404058: using guessed type __int64 CACHE;
// 404060: using guessed type __int64 size;

//----- (0000000000401A13) ----------------------------------------------------
_QWORD *__fastcall get_item(_QWORD *a1, unsigned __int64 a2)
{
  __int64 v2; // rdx
  __int64 v3; // rdx
  __int64 *v4; // rcx
  __int64 v5; // rdx
  __int64 v6; // rdx
  _QWORD *v7; // rcx
  __int64 v8; // rdx
  __int64 v9; // rdx
  __int64 v10; // rdx
  __int64 v11; // rdx
  _QWORD *v13; // [rsp+10h] [rbp-60h]
  __int64 v14; // [rsp+20h] [rbp-50h]
  __int64 v15; // [rsp+28h] [rbp-48h]
  __int64 v16; // [rsp+30h] [rbp-40h]
  __int64 v17; // [rsp+40h] [rbp-30h]
  __int64 v18; // [rsp+48h] [rbp-28h] BYREF
  __int64 v19; // [rsp+50h] [rbp-20h]
  __int64 v20; // [rsp+58h] [rbp-18h]
  unsigned __int64 v21; // [rsp+68h] [rbp-8h]

  v21 = __readfsqword(0x28u);
  if ( a2 )
  {
    v4 = (__int64 *)(24 * (a2 % size) + CACHE);
    v14 = *v4;
    v15 = v4[1];
    v16 = v4[2];
    if ( a2 == *v4 )
    {
      v18 = *v4;
      v19 = v15;
      v20 = v16;
      LODWORD(v17) = 0;
      *a1 = v17;
      a1[1] = v14;
      v5 = v20;
      a1[2] = v19;
      a1[3] = v5;
    }
    else
    {
      v13 = (_QWORD *)root;
      while ( v13 )
      {
        if ( a2 == v13[2] )
        {
          v6 = v13[3];
          v18 = v13[2];
          v19 = v6;
          v20 = v13[4];
          LODWORD(v17) = 0;
          v7 = (_QWORD *)(CACHE + 24 * (a2 % size));
          *v7 = v18;
          v7[1] = v6;
          v7[2] = v20;
          v8 = v18;
          *a1 = v17;
          a1[1] = v8;
          v9 = v20;
          a1[2] = v19;
          a1[3] = v9;
          return a1;
        }
        if ( a2 >= v13[2] )
          v13 = (_QWORD *)v13[1];
        else
          v13 = (_QWORD *)*v13;
      }
      LODWORD(v17) = 1;
      memset(&v18, 0, 0x18u);
      v10 = v18;
      *a1 = v17;
      a1[1] = v10;
      v11 = v20;
      a1[2] = v19;
      a1[3] = v11;
    }
  }
  else
  {
    LODWORD(v17) = 1;
    v2 = v18;
    *a1 = v17;
    a1[1] = v2;
    v3 = v20;
    a1[2] = v19;
    a1[3] = v3;
  }
  return a1;
}
// 401A50: variable 'v17' is possibly undefined
// 404058: using guessed type __int64 CACHE;
// 404060: using guessed type __int64 size;
// 404068: using guessed type __int64 root;

//----- (0000000000401C42) ----------------------------------------------------
__int64 __fastcall store_item(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        unsigned __int64 a7,
        __int64 a8,
        __int64 a9)
{
  int v10; // [rsp+4h] [rbp-1Ch]
  _QWORD *v11; // [rsp+8h] [rbp-18h]
  _QWORD *v12; // [rsp+10h] [rbp-10h]
  _QWORD *v13; // [rsp+18h] [rbp-8h]

  v13 = calloc(1u, 0x28u);
  v13[2] = a7;
  v13[3] = a8;
  v13[4] = a9;
  if ( root )
  {
    v11 = (_QWORD *)root;
    v12 = 0;
    v10 = 0;
    while ( v11 )
    {
      if ( v11[2] == a7 )
        return 1;
      v12 = v11;
      if ( a7 >= v11[2] )
      {
        v11 = (_QWORD *)v11[1];
        v10 = 1;
      }
      else
      {
        v11 = (_QWORD *)*v11;
        v10 = 0;
      }
    }
    if ( v10 )
      v12[1] = v13;
    else
      *v12 = v13;
    return 0;
  }
  else
  {
    root = (__int64)v13;
    return 0;
  }
}
// 401D2B: conditional instruction was optimized away because %var_1C.4==1
// 404068: using guessed type __int64 root;

//----- (0000000000401D50) ----------------------------------------------------
__int64 __fastcall swap_tree_nodes(_QWORD *a1, _QWORD *a2)
{
  __int64 v2; // rdx
  __int64 v4; // [rsp+10h] [rbp-20h]
  __int64 v5; // [rsp+18h] [rbp-18h]
  __int64 v6; // [rsp+20h] [rbp-10h]

  v4 = a1[2];
  v5 = a1[3];
  v6 = a1[4];
  v2 = a2[3];
  a1[2] = a2[2];
  a1[3] = v2;
  a1[4] = a2[4];
  a2[2] = v4;
  a2[3] = v5;
  a2[4] = v6;
  return v6;
}

//----- (0000000000401DBB) ----------------------------------------------------
__int64 __fastcall delete_item(unsigned __int64 a1)
{
  int v2; // [rsp+14h] [rbp-1Ch]
  _QWORD *ptr; // [rsp+18h] [rbp-18h]
  _QWORD *ptra; // [rsp+18h] [rbp-18h]
  _QWORD *v5; // [rsp+20h] [rbp-10h]
  _QWORD *v6; // [rsp+20h] [rbp-10h]

  ptr = (_QWORD *)root;
  v5 = 0;
  v2 = 0;
  if ( a1 == *(_QWORD *)(CACHE + 24 * (a1 % size)) )
    *(_QWORD *)(CACHE + 24 * (a1 % size) + 16) = 0;
  while ( ptr && a1 != ptr[2] )
  {
    v5 = ptr;
    if ( a1 >= ptr[2] )
    {
      v2 = 1;
      ptr = (_QWORD *)ptr[1];
    }
    else
    {
      v2 = 0;
      ptr = (_QWORD *)*ptr;
    }
  }
  if ( !ptr )
    return 1;
  if ( ptr[1] || *ptr )
  {
    v6 = ptr;
    for ( ptra = (_QWORD *)ptr[1]; ptra[1]; ptra = (_QWORD *)ptra[1] )
    {
      swap_tree_nodes(v6, ptra);
      v6 = ptra;
    }
    swap_tree_nodes(v6, ptra);
    v6[1] = *ptra;
    free(ptra);
    return 0;
  }
  else if ( ptr == (_QWORD *)root )
  {
    root = 0;
    free(ptr);
    return 0;
  }
  else
  {
    if ( v2 )
      v5[1] = 0;
    else
      *v5 = 0;
    free(ptr);
    return 0;
  }
}
// 401F13: conditional instruction was optimized away because %var_1C.4==1
// 404058: using guessed type __int64 CACHE;
// 404060: using guessed type __int64 size;
// 404068: using guessed type __int64 root;

//----- (0000000000401FC4) ----------------------------------------------------
// Alternative name is '_fini'
void term_proc()
{
  ;
}

// nfuncs=64 queued=38 decompiled=38 lumina nreq=0 worse=0 better=0
// ALL OK, 38 function(s) have been successfully decompiled
