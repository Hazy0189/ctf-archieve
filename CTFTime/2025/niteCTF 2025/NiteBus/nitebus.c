/* This file was generated by the Hex-Rays decompiler version 9.0.0.241217.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 init_proc();
long double (__fastcall *j_memmove())(__int64 a1, __int64 a2, unsigned __int64 a3, long double result);
__int64 (__fastcall *j_memcpy())(__int64 result, __int64 *a2, unsigned __int64 a3);
unsigned __int64 (__fastcall *memchr())(__int64 a1, unsigned int a2, unsigned __int64 a3);
int8x16_t *(__fastcall *memset())(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3);
unsigned __int64 (__fastcall *strlen())(__int64 a1);
void __noreturn abort();
void __noreturn dl_start();
void __fastcall btree_release_tree_recursively(btree *t, btree_node *node);
void __fastcall btree_destroy(btree *t);
void __cdecl release_registered_frames();
__int64 *IO_stdfiles_init();
void __cdecl init_have_lse_atomics();
void __cdecl init_have_sme();
void __fastcall __noreturn start(void (*a1)(void *), __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10);
__int64 __fastcall _wrap_main(int argc, const char **argv, const char **envp);
__int64 dl_relocate_static_pie(void); // weak
__int64 call_weak_fn();
void *deregister_tm_clones();
void *register_tm_clones();
__int64 _do_global_dtors_aux();
void *frame_dummy();
__int64 print_banner();
__int64 init_plc();
__int64 __fastcall handle_diagnostics(__int64 a1);
__int64 __fastcall upload_control_program(__int64 a1);
__int64 __fastcall parse_nitebus_packet(unsigned __int8 *a1, unsigned __int64 a2);
__int64 nitebus_server();
int __fastcall main(int argc, const char **argv, const char **envp);
void call_fini();
__int64 prefer_sve_ifuncs();
void __fastcall __noreturn _libc_start_call_main(__int64 (__fastcall *a1)(_QWORD, __int64, char **), unsigned int a2, __int64 a3);
void __fastcall __noreturn _libc_start_main_impl(__int64 (__fastcall *a1)(_QWORD, __int64, char **), unsigned int a2, __int64 *a3, __int64 a4, __int64 a5, void (*a6)(void *), __int64 a7);
void **_libc_setup_tls();
__int64 __fastcall _tls_get_addr(__int64 a1);
void setjmp();
int setjmp(jmp_buf env);
__int64 __fastcall _sigsetjmp(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
__int64 __fastcall _sigjmp_save(__int64 a1, int a2);
__int64 __fastcall sigprocmask(int a1, const sigset_t *a2, sigset_t *a3);
__int64 _abort_fork_reset_child();
__int64 __fastcall _abort_lock_rdlock(sigset_t *a1);
__int64 __fastcall _abort_lock_wrlock(sigset_t *a1);
int __fastcall _abort_lock_unlock(const sigset_t *a1);
_QWORD *__fastcall _new_exitfn(int8x16_t *(__fastcall **a1)(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3), double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _internal_atexit(__int64 a1, __int64 a2, __int64 a3, int8x16_t *(__fastcall **a4)(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3));
int _cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle);
void __fastcall __noreturn _run_exit_handlers(unsigned int a1, _QWORD **a2, unsigned __int8 a3);
void __fastcall __noreturn exit(unsigned int a1);
__int64 printf(__int64 a1, ...);
unsigned __int64 __fastcall outstring_converted_wide_string(__int64 a1, _DWORD *a2, int a3, void *a4, __int64 a5, _DWORD *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
_BYTE *__fastcall group_number(_BYTE *result, int *a2, char *a3, char *a4, _BYTE *a5, char a6);
void __fastcall printf_positional(unsigned __int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, _DWORD *a13, void *a14, unsigned __int8 *a15, __int64 a16, __int64 a17, __int64 a18, __int64 a19, char a20);
void __fastcall _printf_buffer(unsigned __int64 a1, __int64 a2, __int64 *a3, char a4);
__int64 __fastcall _vfprintf_internal(__int64 a1, __int64 a2, __int128 *a3, char a4);
char *__fastcall _get_errname(signed int a1);
__int64 __fastcall _parse_one_specmb(unsigned __int8 *a1, int a2, __int64 a3, unsigned __int64 *a4, _BYTE *a5);
__int64 __fastcall fflush(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void __fastcall __noreturn sub_406BF0(_Unwind_Exception *exc);
__int64 __fastcall puts(unsigned __int64 a1);
void __fastcall __noreturn sub_406E54(_Unwind_Exception *exc);
__int64 __fastcall setvbuf(__int64 a1, __int64 a2, int a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
void __fastcall __noreturn sub_407180(_Unwind_Exception *exc);
__int64 __fastcall putchar(unsigned int a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void __fastcall __noreturn sub_407394(_Unwind_Exception *exc);
void __noreturn _libc_message_impl(unsigned __int8 *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, ...);
void __fastcall __noreturn _libc_fatal(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 (__fastcall *__fastcall IO_vtable_check(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8))();
__int64 __fastcall new_do_write(__int64 a1, unsigned __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall mmap_remap_check(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void *__fastcall decide_maybe_mmap(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void __fastcall IO_new_file_init_internal(__int64 a1);
void __fastcall IO_new_file_init(__int64 a1);
__int64 __fastcall IO_file_open(__int64 a1, char *a2, int a3, int a4, int a5);
unsigned int *__fastcall IO_new_file_attach(unsigned int *a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall IO_new_file_setbuf(_QWORD *a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall IO_file_setbuf_mmap(_QWORD *a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall IO_new_do_write(__int64 a1, unsigned __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall IO_new_file_close_it(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
__int64 __fastcall IO_new_file_fopen(__int64 a1, char *a2, unsigned __int8 *a3);
void __fastcall IO_new_file_finish(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
__int64 __fastcall IO_new_file_underflow(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void __fastcall __noreturn sub_4087E0(_Unwind_Exception *exc);
__int64 __fastcall IO_file_underflow_mmap(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall IO_file_underflow_maybe_mmap(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall IO_new_file_overflow(int *a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
__int64 __fastcall IO_new_file_sync(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
__int64 __fastcall IO_file_sync_mmap(__int64 a1);
__int64 __fastcall IO_new_file_seekoff(__int64 a1, __int64 a2, unsigned int a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall IO_file_seekoff_mmap(_QWORD *a1, __int64 a2, int a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall IO_file_seekoff_maybe_mmap(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall IO_file_read(__int64 a1, void *a2, void *a3);
unsigned __int64 __fastcall IO_file_seek(__int64 a1, __off_t a2, int a3);
unsigned __int64 __fastcall IO_file_stat(__int64 a1, struct stat *a2);
unsigned __int64 __fastcall IO_file_close_mmap(__int64 a1);
unsigned __int64 __fastcall IO_file_close(__int64 a1);
__int64 __fastcall IO_new_file_write(__int64 a1, char *a2, __int64 a3);
__int64 __fastcall IO_new_file_xsputn(_QWORD *a1, unsigned __int64 a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall IO_file_xsgetn(__int64 a1, char *a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, __int64 a13, __int64 a14, void *a15);
char *__fastcall IO_file_xsgetn_mmap(__int64 a1, char *a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall IO_file_xsgetn_maybe_mmap(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
void flush_cleanup();
__int64 __fastcall save_for_backup(_QWORD *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, void *a15);
void __fastcall IO_un_link_part_0(__int64 a1);
void __fastcall IO_un_link(__int64 a1);
void __fastcall IO_link_in(int *a1);
__int64 __fastcall IO_switch_to_main_get_area(__int64 result);
__int64 __fastcall IO_switch_to_backup_area(__int64 result);
__int64 __fastcall IO_switch_to_get_mode(int *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void __fastcall IO_free_backup_area(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _overflow(__int64 a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall _underflow(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, unsigned __int64 a12, __int64 a13, __int64 a14, void *a15);
__int64 __fastcall _uflow(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, unsigned __int64 a12, __int64 a13, __int64 a14, void *a15);
__int64 __fastcall IO_setb(int *a1, __int64 a2, __int64 a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
void __fastcall IO_doallocbuf(int *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 IO_default_underflow();
__int64 __fastcall IO_default_uflow(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall IO_default_xsputn(_QWORD *a1, unsigned __int8 *a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall IO_sgetn(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
unsigned __int64 __fastcall IO_default_xsgetn(__int64 a1, char *a2, unsigned __int64 a3, unsigned __int64 a4, __int64 a5, __int64 a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
__int64 __fastcall IO_default_setbuf(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall IO_default_seekpos(__int64 a1, __int64 a2, unsigned int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall IO_default_doallocate(unsigned int *a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall IO_init_internal(__int64 result, int a2);
__int64 __fastcall IO_init(__int64 result, int a2);
__int64 *IO_enable_locks();
_QWORD *__fastcall IO_old_init(__int64 a1, int a2);
__int64 __fastcall IO_no_init(__int64 result, int a2, int a3, __int64 a4, __int64 a5);
__int64 IO_default_sync();
void __fastcall IO_default_finish(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 IO_default_seekoff();
__int64 __fastcall IO_sputbackc(unsigned int *a1, unsigned __int8 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall IO_sungetc(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall IO_adjust_column(int a1, unsigned __int64 a2, int a3);
__int64 IO_flush_all();
void flushlbf();
void __fastcall _libio_freemem(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 IO_cleanup();
__int64 __fastcall IO_init_marker(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
_QWORD *__fastcall IO_remove_marker(_QWORD *result);
__int64 __fastcall IO_marker_difference(__int64 a1, __int64 a2);
__int64 __fastcall IO_marker_delta(__int64 a1);
__int64 __fastcall IO_seekmark(int *a1, __int64 a2);
void __fastcall IO_unsave_markers(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall IO_default_pbackfail(__int64 *a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
__int64 IO_default_seek();
__int64 IO_default_stat();
__int64 IO_default_read();
__int64 IO_default_write();
__int64 IO_default_showmanyc();
__int64 *IO_iter_begin();
__int64 IO_iter_end();
__int64 __fastcall IO_iter_next(__int64 a1);
void IO_list_lock();
void IO_list_unlock();
__int64 *IO_list_resetlock();
__int64 __fastcall enlarge_userbuf(_QWORD *a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, __int64 a13, __int64 a14, void *a15, __int64 a16);
unsigned __int64 __fastcall IO_str_init_static_internal(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
unsigned __int64 __fastcall IO_str_init_static(__int64 a1, unsigned __int64 a2, int a3, unsigned __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall IO_str_init_readonly(__int64 a1, unsigned __int64 a2, int a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall IO_str_overflow(__int64 a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, void *a15, __int64 a16);
__int64 __fastcall IO_str_underflow(__int64 a1);
__int64 __fastcall IO_str_count(_QWORD *a1);
__int64 __fastcall IO_str_seekoff(_QWORD *a1, __int64 a2, unsigned int a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall IO_str_pbackfail(__int64 *a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
void __fastcall IO_str_finish(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void __fastcall _libc_cleanup_push_defer(__int64 a1);
void __fastcall _libc_cleanup_pop_restore(__int64 a1);
void __fastcall _lll_lock_wait_private(_DWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, void *a13, void *a14, void *a15);
void __fastcall _lll_lock_wait(_DWORD *a1, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, void *a13, void *a14, void *a15);
signed __int64 __fastcall _lll_lock_wake_private(void *a1, __int64 a2, __int64 a3, __int64 a4, void *a5, void *a6, void *a7);
signed __int64 __fastcall _lll_lock_wake(void *a1, int a2, __int64 a3, __int64 a4, void *a5, void *a6, void *a7);
void __fastcall _nptl_deallocate_tsd(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall _pthread_kill_implementation_constprop_0(__int64 a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7);
__int64 __fastcall _pthread_raise_internal(void *a1, void *a2, __int64 a3, void *a4, void *a5, void *a6, void *a7);
__int64 __fastcall pthread_kill(__int64 a1, void *a2, __int64 a3, void *a4, void *a5, void *a6, void *a7);
__int64 __fastcall pthread_rwlock_init(__int64 a1, _DWORD *a2);
__int64 __fastcall pthread_rwlock_rdlock(unsigned int *a1);
__int64 __fastcall pthread_rwlock_unlock(int *a1);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
__int64 __fastcall pthread_sigmask(int a1, const sigset_t *a2, sigset_t *a3);
__int64 __fastcall dl_tunable_set_mmap_threshold(__int64 *a1);
__int64 __fastcall dl_tunable_set_mmaps_max(_QWORD *a1);
__int64 __fastcall dl_tunable_set_top_pad(__int64 *a1);
void *__fastcall dl_tunable_set_perturb_byte(__int64 *a1);
__int64 __fastcall dl_tunable_set_trim_threshold(__int64 *a1);
__int64 (__fastcall **__fastcall dl_tunable_set_arena_max(__int64 *a1))();
__int64 (__fastcall **__fastcall dl_tunable_set_arena_test(__int64 *a1))();
unsigned __int64 __fastcall dl_tunable_set_tcache_max(unsigned __int64 result);
unsigned __int64 __fastcall dl_tunable_set_tcache_count(unsigned __int64 *a1);
__int64 (__fastcall **__fastcall dl_tunable_set_tcache_unsorted_limit(__int64 *a1))();
unsigned __int64 __fastcall dl_tunable_set_mxfast(unsigned __int64 *a1);
void __fastcall __noreturn malloc_printerr(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
_QWORD *__fastcall tcache_double_free_verify(_QWORD *result, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall int_mallinfo(__int64 result, __int64 *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
int8x16_t *(__fastcall *alloc_perturb())(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3);
unsigned __int64 __fastcall munmap_chunk(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void __noreturn detach_arena_part_0();
unsigned __int64 __fastcall dl_tunable_set_hugetlb(unsigned __int64 *a1);
__int64 __fastcall _malloc_info_part_0(__int64 a1);
_QWORD *__fastcall unlink_chunk_isra_0(_QWORD *result, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void __fastcall malloc_consolidate(__int64 a1);
unsigned __int64 __fastcall int_free_create_chunk(__int64 a1, _QWORD *a2, unsigned __int64 a3, _QWORD *a4, __int64 a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13);
__int64 __fastcall ptmalloc_init_part_0(__int64 a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7);
__int64 __fastcall alloc_new_heap(size_t a1, __int64 a2, __int64 a3, int a4);
__int64 __fastcall new_heap(size_t a1, __int64 a2);
int *__fastcall arena_get2(__int64 a1, int *a2, __int64 a3, __int64 a4, void *a5, void *a6, void *a7, __int64 a8);
int *__fastcall arena_get_retry(int *a1, __int64 a2);
unsigned __int64 __fastcall sysmalloc_mmap_fallback_constprop_0(size_t *a1, size_t a2, __int64 a3, size_t a4, __int64 a5, int a6);
__int64 __fastcall sysmalloc_mmap_isra_0(unsigned __int64 a1, __int64 a2, int a3);
__int64 __fastcall systrim_constprop_0(unsigned __int64 a1);
unsigned __int64 __fastcall int_free_maybe_consolidate_part_0(__int64 a1);
unsigned __int64 __fastcall int_free_merge_chunk(__int64 a1, __int64 *a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
void __fastcall int_free_chunk(_DWORD *a1, __int64 *a2, unsigned __int64 a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall sysmalloc(unsigned __int64 a1, __int64 (__fastcall **a2)());
unsigned __int64 __fastcall int_malloc(int *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
void __fastcall tcache_init_part_0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, void *a5, void *a6, void *a7, __int64 a8);
unsigned __int64 __fastcall int_realloc(int *a1, unsigned __int64 a2, unsigned __int64 a3, unsigned __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
char *__fastcall int_memalign(int *a1, unsigned __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall _glibc_morecore(__int64 a1);
void _malloc_fork_lock_parent();
void _malloc_fork_unlock_parent();
int *_malloc_fork_unlock_child();
unsigned __int64 __fastcall malloc(__int64 a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
unsigned __int64 __fastcall mid_memalign_isra_0(unsigned __int64 a1, __int64 a2, __int64 a3, void *a4, unsigned __int64 a5, unsigned __int64 a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
void __fastcall free(unsigned __int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void __fastcall _malloc_arena_thread_freeres(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
unsigned __int64 __fastcall realloc(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
unsigned __int64 __fastcall memalign(unsigned __int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, void *a12, void *a13, void *a14, void *a15, __int64 a16);
unsigned __int64 __fastcall aligned_alloc(unsigned __int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, void *a12, void *a13, void *a14, void *a15, __int64 a16);
unsigned __int64 __fastcall valloc(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, void *a12, void *a13, void *a14, void *a15, __int64 a16);
unsigned __int64 __fastcall pvalloc(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, void *a12, void *a13, void *a14, void *a15, __int64 a16);
int8x16_t *(__fastcall *__fastcall calloc(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, void *a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, __int64 a13, void *a14, __int64 a15, __int64 a16))(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3);
__int64 __fastcall malloc_trim(unsigned __int64 a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7);
__int64 __fastcall malloc_usable_size(__int64 a1);
// void __usercall mallinfo2(__int64 a1@<X1>, __int64 a2@<X2>, void *a3@<X3>, void *a4@<X4>, void *a5@<X5>, void *a6@<X6>, _OWORD *a7@<X8>);
// long double __usercall mallinfo@<Q0>(__int64 a1@<X1>, __int64 a2@<X2>, void *a3@<X3>, void *a4@<X4>, void *a5@<X5>, void *a6@<X6>, __int64 a7@<X8>);
__int64 *__fastcall malloc_stats(__int64 a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7);
__int64 __fastcall mallopt(int a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7);
__int64 __fastcall posix_memalign(unsigned __int64 *a1, void *a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, __int64 a13, void *a14, void *a15, __int64 a16);
__int64 __fastcall malloc_info(int a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7);
__int64 __fastcall _libc_scratch_buffer_grow_preserve(unsigned __int64 *a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, void *a12, __int64 a13, void *a14, void *a15, __int64 a16);
__int64 __fastcall _libc_scratch_buffer_set_array_size(unsigned __int64 *a1, unsigned __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
unsigned __int64 *__fastcall strerror_r(unsigned int a1, _BYTE *a2, __int64 a3);
__int64 __fastcall memcmp(int8x16_t *a1, int8x16_t *a2, unsigned __int64 a3);
__int64 (__fastcall *memcpy())(__int64 result, __int64 *a2, unsigned __int64 a3);
long double (__fastcall *memmove())(__int64 a1, __int64 a2, unsigned __int64 a3, long double result);
int8x16_t *(__fastcall *memset())(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3);
unsigned __int64 __fastcall strchrnul(__int64 a1, unsigned int a2);
unsigned __int64 (__fastcall *strlen())(__int64 a1);
unsigned __int64 __fastcall strnlen(__int64 a1, unsigned __int64 a2);
__int64 __fastcall two_way_long_needle(__int64 a1, unsigned __int64 a2, int8x16_t *a3, unsigned __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
__int64 __fastcall strstr(__int64 result, int8x16_t *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
long double __fastcall _memcpy_generic(_OWORD *a1, unsigned __int64 a2, unsigned __int64 a3, long double result);
long double __fastcall _memmove_generic(__int64 a1, __int64 a2, unsigned __int64 a3, long double result);
char *__fastcall _memmove_oryon1(char *result, char *a2, unsigned __int64 a3);
__int64 __fastcall _memcpy_oryon1(__int64 result, __int64 *a2, unsigned __int64 a3);
_OWORD *__fastcall sub_415634(_OWORD *result, __int128 *a2, unsigned __int64 a3);
unsigned __int64 *__fastcall _memset_emag(unsigned __int64 *result, unsigned __int8 a2, unsigned __int64 a3);
int8x16_t *__fastcall _memset_generic(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3);
int8x16_t *__fastcall _memset_kunpeng(int8x16_t *result, unsigned int a2, unsigned __int64 a3);
unsigned __int64 *__fastcall _memset_oryon1(unsigned __int64 *result, unsigned __int8 a2, unsigned __int64 a3);
int8x16_t *__fastcall _memset_zva64(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3);
unsigned __int64 __fastcall _strlen_asimd(unsigned __int64 a1);
unsigned __int64 __fastcall _strlen_generic(__int64 a1);
__int64 __fastcall _wcrtomb_internal(__int64 a1, int a2, void *a3, unsigned __int64 a4);
__int64 __fastcall wcrtomb(__int64 a1, int a2, void *a3);
unsigned __int64 __fastcall _wcsmbs_getfct(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 *a3);
__int64 __fastcall _wcsmbs_load_conv(__int64 a1);
void __fastcall _wcsmbs_clone_conv(_OWORD *a1);
__int64 __fastcall _wcsmbs_named_conv(unsigned __int64 *a1, __int64 a2);
void __fastcall nl_cleanup_ctype(__int64 a1);
__int64 __fastcall wcsrtombs(_BYTE *a1, _DWORD **a2, unsigned __int64 a3, __int64 *a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
int __fastcall clock_gettime(clockid_t a1, struct timespec *a2);
void __noreturn exit(int status);
__pid_t getpid();
unsigned __int64 __fastcall uname(struct utsname *a1);
unsigned __int64 __fastcall fstat64(int a1, struct stat *a2);
unsigned __int64 __fastcall lseek64(int a1, __off_t a2, int a3);
__int64 __fastcall open64(void *a1, int a2, int a3);
__int64 __fastcall read(int a1, void *a2, void *a3);
__int64 __fastcall write(int a1, void *a2, void *a3);
unsigned __int64 __fastcall _close_nocancel(int a1);
unsigned __int64 __fastcall _open_nocancel(const char *a1, int a2);
unsigned __int64 __fastcall _read_nocancel(int a1, void *a2, size_t a3);
unsigned __int64 __fastcall _write_nocancel(int a1, const void *a2, size_t a3);
__int64 __fastcall brk(void *a1);
__int64 getpagesize();
char *__fastcall next_line(int a1, char *a2, void **a3, void **a4, char *a5);
__int64 __fastcall read_sysfs_file(const char *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
__int64 __fastcall get_nproc_stat(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
unsigned __int64 _get_nprocs_sched();
__int64 __fastcall get_nprocs(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__int64 __fastcall get_nprocs_conf(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__kernel_ulong_t get_phys_pages();
__kernel_ulong_t get_avphys_pages();
unsigned __int64 __fastcall madvise(void *a1, size_t a2, int a3);
unsigned __int64 __fastcall mmap64(void *a1, size_t a2, int a3, int a4, int a5, __off_t a6);
unsigned __int64 __fastcall mprotect(void *a1, size_t a2, int a3);
unsigned __int64 __fastcall munmap(void *a1, size_t a2);
__int64 __fastcall sbrk(__int64 a1);
unsigned __int64 __fastcall mremap(void *a1, size_t a2, size_t a3, unsigned int a4);
int __fastcall _set_vma_name(void *a1);
unsigned __int64 __fastcall sysinfo(struct sysinfo *a1);
signed __int64 __fastcall gettid(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7);
__int64 _malloc_default_thp_pagesize();
__int64 _malloc_thp_mode();
unsigned __int64 __fastcall _malloc_hugepage_config(unsigned __int64 a1, unsigned __int64 *a2, unsigned int *a3);
void __fastcall __noreturn _chk_fail(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
void __fastcall __noreturn _fortify_fail(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _readonly_area(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall dl_debug_state(_QWORD); // weak
int *__fastcall dl_debug_update(__int64 a1);
int *__fastcall dl_debug_initialize(__int64 a1, __int64 a2);
unsigned __int64 (__fastcall *__fastcall is_dst(_BYTE *a1, unsigned __int64 a2))(__int64 a1);
bool __fastcall is_trusted_path_normalize(unsigned __int8 *a1, __int64 a2);
__int64 __fastcall open_verify_constprop_0(const char *a1, __int64 a2, _BYTE *a3, char a4);
_BYTE *__fastcall add_path_constprop_0_isra_0(_BYTE *result, __int64 *a2);
__int64 __fastcall open_path_isra_0(__int64 *a1, __int64 a2, int a3, __int64 *a4, unsigned __int64 *a5, __int64 a6, __int64 a7, _BYTE *a8);
unsigned __int64 __fastcall add_name_to_object_isra_0(unsigned __int64 *a1, unsigned __int64 *a2);
__int64 __fastcall dl_dst_count(__int64 a1);
unsigned __int8 *__fastcall dl_dst_substitute(__int64 a1, unsigned __int8 *a2, unsigned __int8 *a3);
unsigned __int8 *__fastcall expand_dynamic_string_token(__int64 a1, unsigned __int8 *a2);
__int64 __fastcall fillin_rpath_isra_0(__int64 a1, __int64 a2, unsigned __int8 *a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall decompose_rpath(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4);
__int64 __fastcall cache_rpath(__int64 a1, __int64 *a2, int a3, __int64 a4);
__int64 __fastcall dl_init_paths(_BYTE *a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall dl_process_pt_gnu_property(__int64 result, int a2, _QWORD *a3);
__int64 *__fastcall dl_map_object_from_fd_constprop_0(unsigned __int64 *a1, int a2, __int64 a3, char *a4, __int64 a5, char a6, int a7, _QWORD *a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, __int64 a17);
__int64 *__fastcall dl_map_object(__int64 a1, unsigned __int8 *a2, char a3, int a4, int a5, unsigned __int64 a6);
__int64 __fastcall dl_rtld_di_serinfo(__int64 *a1, __int64 a2, char a3);
__int64 __fastcall dl_sysdep_read_whole_file(const char *a1, size_t *a2, int a3);
__int64 __fastcall dl_name_match_p(unsigned __int64 *a1, __int64 a2);
__int64 __fastcall dl_higher_prime_number(unsigned __int64 a1);
unsigned __int64 __fastcall dl_strtoul(unsigned __int8 *a1, _QWORD *a2);
__int64 __fastcall dl_add_to_namespace_list(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, void *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
int8x16_t *(__fastcall *__fastcall dl_new_object(char *a1, __int64 a2, char a3, __int64 a4, char a5, __int64 a6))(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3);
unsigned __int64 __fastcall dl_get_origin(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, __int64 a9, __int64 a10, __int64 a11, __int64 a12, void *a13, __int64 a14, void *a15, __int64 a16);
ssize_t __fastcall dl_debug_vdprintf(int a1, int a2, unsigned __int8 *a3, __int64 a4);
ssize_t dl_debug_printf(unsigned __int8 *a1, ...);
ssize_t dl_debug_printf_c(unsigned __int8 *a1, ...);
ssize_t dl_dprintf(int a1, unsigned __int8 *a2, ...);
ssize_t dl_printf(unsigned __int8 *a1, ...);
ssize_t dl_error_printf(unsigned __int8 *a1, ...);
void __noreturn dl_fatal_printf(unsigned __int8 *a1, ...);
__int64 __fastcall dl_setup_hash(__int64 result);
__int64 __fastcall dl_allocate_tls_init_part_0(void **a1, unsigned __int8 a2, __int64 a3, __int64 a4, __int64 a5, void *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
__int64 __fastcall dl_tls_static_surplus_init(unsigned __int64 a1);
unsigned __int64 __fastcall dl_assign_tls_modid(unsigned __int64 result);
__int64 dl_count_modids();
__int64 *dl_determine_tlsoffset();
__int64 __fastcall dl_get_tls_static_info(_QWORD *a1, _QWORD *a2);
unsigned __int64 dl_allocate_tls_storage();
void **__fastcall dl_allocate_tls_init(void **result, unsigned __int8 a2, __int64 a3, __int64 a4, __int64 a5, void *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
void **__fastcall dl_allocate_tls(void **a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, void *a12, __int64 a13, void *a14, __int64 a15, __int64 a16);
void __fastcall dl_deallocate_tls(void **a1, char a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall dl_tls_get_addr_soft(__int64 a1);
__int64 dl_tls_initial_modid_limit_setup();
__int64 __fastcall dl_add_to_slotinfo(unsigned __int64 a1, char a2);
void dl_init_static_tls();
__int64 *_tls_pre_init_tp();
__int64 __fastcall _tls_init_tp(__int64 a1, __int64 a2, __int64 a3, __int64 a4, void *a5, void *a6, void *a7);
__int64 __fastcall do_tunable_update_val(__int64 result, unsigned __int64 *a2, unsigned __int64 *a3, signed __int64 *a4);
__int64 __fastcall tunable_initialize(__int64 a1, unsigned __int8 *a2, __int64 a3);
__int64 __fastcall _tunable_is_initialized(unsigned int a1);
__int64 __fastcall _tunable_set_val(unsigned int a1, unsigned __int64 *a2, unsigned __int64 *a3, signed __int64 *a4);
__int64 __fastcall _tunables_init(_BYTE **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
ssize_t _tunables_print();
char *__fastcall _tunable_get_default(unsigned int a1, char **a2);
__int64 __fastcall _tunable_get_val(__int64 result, char **a2, __int64 (__fastcall *a3)(char *));
__int64 __fastcall dl_cache_libcmp(_BYTE *a1, unsigned __int8 *a2);
__int64 __fastcall search_cache(__int64 a1, unsigned int a2, __int64 a3, int a4, unsigned int a5, _BYTE *a6);
__int64 (__fastcall *__fastcall dl_load_cache_lookup(_BYTE *a1))(__int64 result, __int64 *a2, unsigned __int64 a3);
unsigned __int64 dl_unload_cache();
void __fastcall __noreturn bti_failed_isra_0(const char *a1, const char *a2);
unsigned __int64 __fastcall dl_bti_protect(__int64 a1, int a2);
__int64 __fastcall dl_bti_check(__int64 result, const char *a2);
void __fastcall __noreturn fail(__int64 a1, const char *a2);
__int64 *__fastcall check_gcs_depends(__int64 *result, const char *a2, char a3);
__int64 *__fastcall dl_gcs_check(__int64 *result, const char *a2);
void __fastcall __noreturn dl_gcs_enable_failed(int a1);
void *__fastcall dl_early_allocate(__int64 a1);
__int64 *__fastcall dl_aux_init(__int64 a1);
unsigned __int64 __fastcall dl_non_dynamic_init(__int64 a1, __int64 a2, __int64 a3, __int64 a4, void *a5, __int64 a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 *dl_get_dl_main_map();
__int64 __fastcall _libc_early_init(unsigned int a1);
unsigned __int64 __fastcall check_one_fd(int a1, int a2, void *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
unsigned __int64 __fastcall _libc_check_standard_fds(__int64 a1, __int64 a2, void *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
void __fastcall _libc_init_first(__int64 a1, __int64 *a2, char **a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, __int64 a13, __int64 a14, void *a15, __int64 a16);
__int64 __fastcall _syscall_error(int a1);
unsigned __int64 __fastcall _gconv_alias_compare(unsigned __int64 **a1, unsigned __int64 *a2);
void __fastcall free_derivation(unsigned __int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void __fastcall free_modules_db(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall derivation_compare(unsigned __int64 **a1, unsigned __int64 *a2);
__int64 _gconv_get_modules_db();
__int64 _gconv_get_alias_db();
__int64 __fastcall _gconv_release_step(__int64 result);
__int64 __fastcall find_derivation(unsigned __int64 a1, unsigned __int64 *a2, __int64 a3, __int64 a4, unsigned __int64 *a5, unsigned __int64 *a6);
unsigned __int64 __fastcall _gconv_compare_alias(unsigned __int64 *a1, unsigned __int8 *a2);
__int64 __fastcall _gconv_find_transform(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 *a3, __int64 *a4, unsigned __int8 a5);
__int64 __fastcall _gconv_close_transform(unsigned __int64 a1, __int64 a2);
void __fastcall _gconv_db_freemem(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
void _gconv_get_path();
void __fastcall insert_module(unsigned __int64 a1, int a2);
void __fastcall add_module(unsigned __int8 *a1, __int64 a2, __int64 a3, unsigned __int32 a4);
void __fastcall add_alias2_part_0(__int64 a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 *__fastcall read_conf_file_isra_0(char *a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
unsigned __int64 _gconv_read_conf();
__int64 _gconv_load_conf();
void __fastcall _gconv_conf_freemem(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall _gconv_get_builtin_trans(unsigned __int64 *a1, __int64 a2);
__int64 __fastcall _gconv_btwoc_ascii(__int64 a1, unsigned __int8 a2);
__int64 __fastcall _gconv_transform_internal_ucs4(__int64 a1, __int64 a2, __int64 *a3, unsigned __int64 a4, unsigned __int64 *a5, __int64 *a6, unsigned int a7, unsigned int a8);
__int64 __fastcall _gconv_transform_ucs4_internal(__int64 a1, __int64 a2, unsigned __int64 *a3, unsigned __int64 a4, _QWORD *a5, __int64 *a6, int a7, unsigned int a8);
__int64 __fastcall _gconv_transform_internal_ucs4le(__int64 a1, __int64 a2, _BYTE **a3, _BYTE *a4, char **a5, __int64 *a6, unsigned int a7, unsigned int a8);
__int64 __fastcall _gconv_transform_ucs4le_internal(__int64 a1, __int64 a2, unsigned __int64 *a3, unsigned __int64 a4, _QWORD *a5, _QWORD *a6, int a7, unsigned int a8);
__int64 __fastcall _gconv_transform_ascii_internal(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, _QWORD *a5, __int64 *a6, int a7, unsigned int a8);
__int64 __fastcall _gconv_transform_internal_ascii(_QWORD *a1, __int64 a2, __int64 *a3, unsigned __int64 a4, _QWORD *a5, __int64 *a6, unsigned int a7, unsigned int a8);
__int64 __fastcall _gconv_transform_internal_utf8(_QWORD *a1, __int64 a2, __int64 *a3, unsigned __int64 a4, _QWORD *a5, __int64 *a6, unsigned int a7, unsigned int a8);
__int64 __fastcall _gconv_transform_utf8_internal(__int64 a1, __int64 a2, unsigned __int8 **a3, unsigned __int64 a4, unsigned int **a5, _QWORD *a6, int a7, unsigned int a8);
__int64 __fastcall _gconv_transform_ucs2_internal(__int64 a1, __int64 a2, unsigned __int64 *a3, unsigned __int8 *a4, char **a5, _QWORD *a6, unsigned int a7, unsigned int a8);
__int64 __fastcall _gconv_transform_internal_ucs2(_QWORD *a1, __int64 a2, __int64 *a3, unsigned __int64 a4, char **a5, __int64 *a6, unsigned int a7, unsigned int a8);
__int64 __fastcall _gconv_transform_ucs2reverse_internal(__int64 a1, __int64 a2, unsigned __int8 **a3, unsigned __int8 *a4, char **a5, __int64 *a6, unsigned int a7, unsigned int a8);
__int64 __fastcall _gconv_transform_internal_ucs2reverse(_QWORD *a1, __int64 a2, __int64 *a3, unsigned __int64 a4, char **a5, __int64 *a6, unsigned int a7, unsigned int a8);
__int64 __fastcall _gconv_transliterate(_QWORD *a1, __int64 a2, __int64 a3, unsigned int **a4, unsigned __int64 a5, _QWORD *a6, _QWORD *a7);
unsigned __int64 __fastcall find_module_idx(unsigned __int8 *a1, _QWORD *a2);
__int64 __fastcall find_module_constprop_0(__int64 a1, __int64 a2, _QWORD *a3);
__int64 _gconv_get_cache();
__int64 _gconv_load_cache();
__int64 __fastcall _gconv_compare_alias_cache(unsigned __int64 *a1, unsigned __int8 *a2, _DWORD *a3);
__int64 __fastcall _gconv_lookup_cache(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 *a3, __int64 *a4, unsigned __int8 a5);
void __fastcall _gconv_release_cache(unsigned __int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void __fastcall _gconv_cache_freemem(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
unsigned __int64 __fastcall known_compare(unsigned __int64 **a1, unsigned __int64 *a2);
__int64 __fastcall do_release_shlib(__int64 result, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
void __fastcall do_release_all(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
__int64 __fastcall _gconv_find_shlib(__int64 a1);
__int64 __fastcall _gconv_release_shlib(__int64 a1);
void _gconv_dl_freemem();
__int64 (__fastcall *__fastcall new_composite_name(int a1, unsigned __int64 **a2))(__int64 result, __int64 *a2, unsigned __int64 a3);
void __fastcall free_category(int a1, char **a2, char **a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
char **__fastcall setlocale(int a1, unsigned __int64 *a2);
void __fastcall nl_locale_subfreeres(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 nl_postload_ctype();
void __fastcall __noreturn _libc_assert_fail(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
unsigned __int64 _ctype_b_loc();
unsigned __int64 _ctype_toupper_loc();
unsigned __int64 _ctype_tolower_loc();
__int64 _ctype_init();
unsigned __int64 *__fastcall dcgettext(unsigned __int64 *a1, unsigned __int64 *a2, unsigned int a3);
unsigned __int64 __fastcall plural_eval(int *a1, __int64 a2);
unsigned __int64 __fastcall transcmp(__int64 a1, __int64 a2);
__int64 __fastcall nl_find_msg(__int64 a1, __int64 a2, unsigned __int64 *a3, int a4, _QWORD *a5);
unsigned __int64 *__fastcall _dcigettext(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, int a4, __int64 a5, unsigned int a6);
void __fastcall _intl_freemem(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
unsigned __int64 __fastcall nl_find_domain(unsigned __int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4);
void __fastcall nl_finddomain_subfreeres(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
void __fastcall nl_load_domain(__int64 a1, __int64 a2);
void __fastcall nl_unload_domain(unsigned __int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall alias_compare(__int64 *a1, __int64 *a2);
__int64 __fastcall read_alias_file(__int64 a1, int a2);
__int64 __fastcall nl_expand_alias(__int64 a1);
void __fastcall _libc_localealias_freemem(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
unsigned __int64 __fastcall nl_make_l10nflist(unsigned __int64 *a1, unsigned __int64 a2, __int64 a3, int a4, unsigned __int64 a5, unsigned __int64 a6, unsigned __int64 a7, unsigned __int64 a8, unsigned __int64 a9, __int64 a10, int a11);
_DWORD *__fastcall nl_normalize_codeset(int8x16_t *a1, __int64 a2, _WORD *a3, char *a4, unsigned __int64 a5, __int64 a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall nl_explode_name(unsigned __int8 *a1, _QWORD *a2, _WORD *a3, char *a4, unsigned __int64 **a5, _QWORD *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
void __fastcall _gettext_free_exp(unsigned __int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _gettextparse(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, void *a5, __int64 a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall _gettext_extract_plural(__int64 a1, __int64 *a2, unsigned __int64 *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
unsigned __int64 __fastcall _hash_string(unsigned __int8 *a1);
__int64 __fastcall raise(unsigned int a1);
unsigned __int64 __fastcall _libc_sigaction(int a1, _QWORD *a2, __int64 a3);
char *__fastcall getenv(_BYTE *a1);
unsigned __int64 __fastcall getrandom_vdso(void *a1, void *a2, unsigned __int64 a3, char a4, void *a5, void *a6);
__int64 __fastcall _getrandom_early_init(__int64 result);
__int64 __fastcall _getrandom_reset_state(__int64 result);
void __fastcall _getrandom_vdso_release(_QWORD *a1);
void *_getrandom_fork_subprocess();
unsigned __int64 __fastcall _getrandom_nocancel(void *a1, void *a2, unsigned __int64 a3, __int64 a4, void *a5, void *a6);
unsigned __int64 __fastcall getrandom(void *a1, void *a2, unsigned __int64 a3, __int64 a4, void *a5, void *a6);
__int128 *__fastcall do_swap(__int128 *result, __int128 *a2, unsigned __int64 a3, int a4);
__int64 (__fastcall *__fastcall msort_with_tmp_part_0(__int64 *a1, int *a2, unsigned __int64 a3))(__int64 result, __int64 *a2, unsigned __int64 a3);
__int64 *__fastcall indirect_msort_with_tmp(__int64 *result, __int64 a2, unsigned __int64 a3, unsigned __int64 a4);
void __fastcall qsort_r(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 (__fastcall *a4)(_QWORD, _QWORD, _QWORD), void *a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13);
void __fastcall qsort(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 (__fastcall *a4)(_QWORD, _QWORD, _QWORD), double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall _add_to_environ(unsigned __int64 a1, __int64 a2, unsigned __int64 a3, int a4);
__int64 __fastcall setenv(_BYTE *a1, __int64 a2, int a3);
__int64 __fastcall unsetenv(_BYTE *a1);
__int64 clearenv();
void _libc_setenv_freemem();
__int64 __fastcall _strtoll_internal(int8x16_t *a1, int8x16_t **a2, int a3, int a4);
__int64 __fastcall strtoq(int8x16_t *a1, int8x16_t **a2, int a3);
__int64 __fastcall _isoc23_strtoll(int8x16_t *a1, int8x16_t **a2, int a3);
__int64 __fastcall ___strtoll_l_internal(int8x16_t *a1, int8x16_t **a2, int a3, int a4, int a5, __int64 a6);
__int64 __fastcall strtoll_l(int8x16_t *a1, int8x16_t **a2, int a3, __int64 a4);
__int64 __fastcall _isoc23_strtoll_l(int8x16_t *a1, int8x16_t **a2, int a3, __int64 a4);
unsigned __int64 __fastcall _strtoull_internal(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4);
unsigned __int64 __fastcall strtouq(unsigned __int8 *a1, unsigned __int8 **a2, int a3);
unsigned __int64 __fastcall _isoc23_strtoumax(unsigned __int8 *a1, unsigned __int8 **a2, int a3);
unsigned __int64 __fastcall ___strtoull_l_internal(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4, int a5, __int64 a6);
unsigned __int64 __fastcall strtoull_l(unsigned __int8 *a1, unsigned __int8 **a2, int a3, __int64 a4);
unsigned __int64 __fastcall _isoc23_strtoull_l(unsigned __int8 *a1, unsigned __int8 **a2, int a3, __int64 a4);
int8x16_t *__fastcall _correctly_grouped_prefixmb(unsigned __int64 a1, int8x16_t *a2, int8x16_t *a3, unsigned __int8 *a4);
__int64 __fastcall itoa_word(unsigned __int64 a1, __int64 a2, unsigned int a3, int a4);
char *__fastcall fitoa_word(unsigned __int64 a1, __int64 a2, unsigned int a3, int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
__int64 asprintf(unsigned __int64 *a1, __int64 a2, ...);
__int64 fprintf(__int64 a1, __int64 a2, ...);
void __fastcall funlockfile(__int64 a1);
__int64 __fastcall _grouping_iterator_init_none(__int64 a1, int a2);
bool __fastcall _grouping_iterator_init(__int64 a1, int a2, __int64 a3, unsigned int a4);
__int64 __fastcall _grouping_iterator_next(int *a1);
__int64 __fastcall _printf_buffer_done(__int64 a1);
__int64 __fastcall _printf_buffer_pad_1(__int64 a1, __int64 a2, __int64 a3, void *a4, __int64 a5, _DWORD *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
unsigned __int64 __fastcall _printf_buffer_putc_1(unsigned __int64 result, char a2);
__int64 __fastcall _printf_buffer_puts_1(__int64 a1, _BYTE *a2, __int64 a3, void *a4, __int64 a5, _DWORD *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
unsigned __int64 *__fastcall _printf_buffer_to_file_switch(unsigned __int64 *result);
unsigned __int64 __fastcall _printf_buffer_flush_to_file(unsigned __int64 *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _printf_buffer_to_file_init(__int64 result, __int64 a2);
__int64 __fastcall _printf_buffer_to_file_done(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _printf_buffer_write(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall hack_digit(_DWORD *a1);
void __fastcall _printf_fp_buffer_1_isra_0(unsigned __int64 a1, __int64 a2, unsigned __int8 a3, unsigned __int8 a4, __int64 a5, double *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall _printf_buffer_flush_fp(__int64 a1);
void __fastcall _printf_fp_l_buffer(unsigned __int64 a1, __int64 *a2, __int64 a3, double **a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
__int64 __fastcall _printf_buffer_flush_fp_to_wide(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, _DWORD *a14, void *a15);
__int64 __fastcall _wprintf_fp_l_buffer(__int64 a1, __int64 *a2, __int64 a3, double **a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16, char a17);
__int64 __fastcall _printf_fp(__int64 a1, __int64 a2, double **a3);
__int64 __fastcall _printf_fphex_buffer(unsigned __int64 a1, _BYTE *a2, __int64 a3, unsigned __int64 **a4, __int64 a5, unsigned __int64 a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, char a17);
__int64 __fastcall _printf_fphex_l_buffer(unsigned __int64 a1, __int64 a2, __int64 a3, unsigned __int64 **a4, __int64 a5, unsigned __int64 a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, char a17);
__int64 __fastcall _printf_buffer_flush_fphex_to_wide(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, _DWORD *a14, void *a15);
__int64 __fastcall _wprintf_fphex_l_buffer(__int64 a1, __int64 a2, __int64 a3, unsigned __int64 **a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, __int64 a13, unsigned __int64 a14, void *a15, __int64 a16);
__int64 __fastcall _printf_function_invoke(__int64 *a1, __int64 (__fastcall *a2)(_QWORD *, __int64, _BYTE *), __int64 a3, void *a4, __int64 a5, void *a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, __int64 a15, __int64 a16);
__int64 __fastcall register_printf_modifier(unsigned __int8 *a1);
__int64 __fastcall _handle_registered_modifier_mb(unsigned __int8 **a1, __int64 a2);
__int64 __fastcall _handle_registered_modifier_wc(unsigned int **a1, __int64 a2);
void __fastcall _libc_printf_freemem(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall register_printf_specifier(unsigned int a1, __int64 a2, __int64 a3);
__int64 __fastcall register_printf_type(__int64 a1);
__int64 __fastcall snprintf(_BYTE *a1, __int64 a2, long double a3, long double a4, long double a5, long double a6, long double a7, long double a8, long double a9, long double a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
__int64 __fastcall _translated_number_width(__int64 a1, _BYTE *a2, _BYTE *a3);
unsigned __int64 __fastcall _wprintf_buffer_putc_1(unsigned __int64 result, int a2, __int64 a3, unsigned __int64 a4, __int64 a5, _DWORD *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
__int64 __fastcall _wprintf_buffer_flush_to_file(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _wprintf_buffer_to_file_init(__int64 result, __int64 a2);
__int64 __fastcall _wprintf_buffer_to_file_done(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
char *__fastcall _get_errlist(int a1);
__int64 __fastcall IO_file_doallocate(__int64 a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall fclose(__int64 *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, void *a13, void *a14, void *a15, __int64 a16);
void __fastcall __noreturn sub_433B9C(_Unwind_Exception *exc);
__int64 __fastcall _fopen_maybe_mmap(__int64 result);
unsigned __int64 __fastcall _fopen_internal(char *a1, unsigned __int8 *a2, __int64 a3, void *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
unsigned __int64 __fastcall fopen64(char *a1, unsigned __int8 *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, void *a12, void *a13, void *a14, void *a15, __int64 a16);
__int64 __fastcall fputs(__int64 a1, __int64 a2);
void __fastcall __noreturn sub_433EFC(_Unwind_Exception *exc);
unsigned __int64 __fastcall fwrite(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
void __fastcall __noreturn sub_434188(_Unwind_Exception *exc);
__int64 __fastcall getdelim(unsigned __int64 *a1, __int64 a2, __int64 a3, _QWORD *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
void __fastcall __noreturn sub_4344D4(_Unwind_Exception *exc);
__int64 __fastcall save_for_wbackup(__int64 a1, __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
__int64 __fastcall IO_least_wmarker(__int64 a1, __int64 a2);
_QWORD *__fastcall IO_switch_to_main_wget_area(__int64 a1);
_QWORD *__fastcall IO_switch_to_wbackup_area(__int64 a1);
__int64 __fastcall IO_wsetb(__int64 a1, __int64 a2, __int64 a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall IO_wdefault_pbackfail(_QWORD *a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
void __fastcall IO_wdefault_finish(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall IO_wdefault_uflow(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _woverflow(__int64 a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
unsigned __int64 __fastcall IO_wdefault_xsputn(__int64 a1, unsigned int *a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall IO_wdoallocbuf(__int64 result);
__int64 __fastcall IO_wdefault_doallocate(__int64 a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall IO_switch_to_wget_mode(unsigned int *a1);
_QWORD *__fastcall IO_free_wbackup_area(unsigned int *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _wuflow(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, unsigned __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
__int64 __fastcall _wunderflow(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, unsigned __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
unsigned __int64 __fastcall IO_wdefault_xsgetn(__int64 a1, char *a2, unsigned __int64 a3, unsigned __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall IO_sputbackwc(__int64 a1, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall IO_sungetwc(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall IO_adjust_wcolumn(int a1, unsigned __int64 a2, int a3);
__int64 __fastcall IO_init_wmarker(__int64 a1, __int64 a2);
__int64 __fastcall IO_wmarker_delta(__int64 a1);
__int64 __fastcall IO_seekwmark(int *a1, __int64 a2);
_QWORD *__fastcall IO_unsave_wmarkers(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall adjust_wide_data(__int64 a1, char a2);
__int64 __fastcall IO_wdo_write(__int64 a1, __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16, char a17);
__int64 __fastcall IO_wfile_underflow(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, void *a13, void *a14, void *a15, __int64 a16);
__int64 __fastcall IO_wfile_underflow_mmap(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall IO_wfile_underflow_maybe_mmap(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall IO_wfile_overflow(int *a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16, char a17);
__int64 __fastcall IO_wfile_sync(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
__int64 __fastcall IO_wfile_seekoff(__int64 a1, __int64 a2, unsigned int a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
unsigned __int64 __fastcall IO_wfile_xsputn(__int64 a1, unsigned int *a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
__int64 __fastcall IO_fwide(__int64 a1, int a2);
__int64 __fastcall _libio_codecvt_out(_QWORD *a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5, __int64 a6, __int64 a7, _QWORD *a8);
__int64 __fastcall _libio_codecvt_in(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _QWORD *a5, __int64 a6, __int64 a7, _QWORD *a8);
__int64 __fastcall _libio_codecvt_encoding(__int64 *a1);
__int64 __fastcall _libio_codecvt_length(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall _printf_buffer_flush_asprintf(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, void *a12, __int64 a13, void *a14, void *a15, __int64 a16);
__int64 __fastcall _vasprintf_internal(unsigned __int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
__int64 __fastcall vasprintf(unsigned __int64 *a1, __int64 a2, _OWORD *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
_QWORD *__fastcall _printf_buffer_flush_snprintf(_QWORD *result);
__int64 __fastcall _printf_buffer_snprintf_init(__int64 result, _BYTE *a2, __int64 a3);
__int64 __fastcall _printf_buffer_snprintf_done(__int64 a1);
__int64 __fastcall _vsnprintf_internal(_BYTE *a1, __int64 a2);
__int64 __fastcall vsnprintf(_BYTE *a1, __int64 a2, __int64 a3, __int128 *a4);
_BYTE *__fastcall fgets_unlocked(_BYTE *result, int a2, int *a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
bool __fastcall _libc_alloca_cutoff(unsigned __int64 a1);
__int64 _syscall_do_cancel();
__int64 __fastcall _internal_syscall_cancel(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7);
__int64 __fastcall _syscall_cancel(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7);
__int64 __fastcall _futex_abstimed_wait64(void *a1, unsigned int a2, unsigned int a3, _QWORD *a4, int a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, __int64 a14, void *a15);
__int64 __fastcall _futex_abstimed_wait_cancelable64(void *a1, unsigned int a2, unsigned int a3, _QWORD *a4, int a5);
__int64 __fastcall _futex_lock_pi64(void *a1, int a2, void *a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, __int64 a13, void *a14, void *a15);
__int64 *__fastcall dl_tunable_set_mutex_spin_count(__int64 *a1);
__int64 *__fastcall dl_tunable_set_stack_cache_size(__int64 *a1);
int *__fastcall dl_tunable_set_stack_hugetlb(__int64 *a1);
__int64 _pthread_tunables_init();
__int64 __fastcall _pthread_mutex_lock_full(_DWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, void *a13, void *a14, void *a15);
__int64 __fastcall pthread_mutex_lock(_DWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, void *a14, void *a15);
__int64 __fastcall _pthread_mutex_unlock_full(__int64 a1, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall _pthread_mutex_unlock_usercnt(int *a1, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall pthread_mutex_unlock(int *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _pthread_cleanup_combined_routine_voidptr(__int64 a1);
unsigned __int64 __fastcall clear_once_control(_DWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, void *a13, void *a14, void *a15);
void __fastcall _pthread_once_slow_isra_0(unsigned int *a1, void *a2);
void __fastcall __noreturn sub_438D90(_Unwind_Exception *exc, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9, int a10, int a11, int a12, int a13, int a14, int a15, int a16, int a17, void (__fastcall *a18)(__int64), __int64 a19, int a20, char a21);
__int64 __fastcall pthread_once(unsigned int *a1, void *a2);
unsigned __int64 pthread_self();
__int64 __fastcall _syscall_cancel_arch(_DWORD *a1, signed __int64 a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8);
unsigned __int64 _init_sched_fifo_prio();
__int64 __fastcall _pthread_tpp_change_priority(int a1, int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, void *a12, __int64 a13, void *a14, __int64 a15, __int64 a16);
__int64 _pthread_current_priority();
__int64 __fastcall argz_add_sep(unsigned __int64 *a1, _QWORD *a2, unsigned __int8 *a3, int a4);
__int64 __fastcall argz_create_sep(unsigned __int8 *a1, int a2, unsigned __int64 *a3, _QWORD *a4);
unsigned __int64 (__fastcall *memchr())(__int64 a1, unsigned int a2, unsigned __int64 a3);
char *__fastcall stpcpy(_QWORD *a1, unsigned __int64 a2);
__int64 __fastcall strcasecmp_l(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall strchr(__int64 a1, unsigned int a2);
unsigned __int64 __fastcall strcmp(unsigned __int64 *a1, unsigned __int64 a2);
long double __fastcall strcpy(_QWORD *a1, unsigned __int64 a2);
unsigned __int64 __fastcall strcspn(__int64 a1, unsigned __int8 *a2);
__int64 (__fastcall *strdup())(__int64 result, __int64 *a2, unsigned __int64 a3);
unsigned __int64 __fastcall strncmp(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3);
unsigned __int64 __fastcall strrchr(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int64 a7);
__int64 __fastcall strsep(__int64 *a1, unsigned __int8 *a2);
_BYTE *__fastcall strtok_r(_BYTE *a1, unsigned __int8 *a2, _BYTE **a3);
unsigned __int64 __fastcall _memchr_generic(__int64 a1, unsigned int a2, unsigned __int64 a3);
char *__fastcall _memchr_nosimd(__int64 a1, unsigned __int8 a2, __int64 a3);
__int64 __fastcall wcslen(_DWORD *a1);
unsigned __int64 __fastcall wcsnlen(_DWORD *a1, unsigned __int64 a2);
_DWORD *__fastcall wmemchr(_DWORD *a1, int a2, unsigned __int64 a3);
__int64 (__fastcall *wmemcpy())(__int64 result, __int64 *a2, unsigned __int64 a3);
long double (__fastcall *wmemmove())(__int64 a1, __int64 a2, unsigned __int64 a3, long double result);
char *__fastcall wmempcpy(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall closedir(int *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall getdents64(int a1, void *a2, unsigned __int64 a3, __int64 a4, void *a5, void *a6, void *a7);
unsigned __int64 __fastcall opendir_tail(int a1);
unsigned __int64 __fastcall _opendirat(int a1, const char *a2);
unsigned __int64 __fastcall opendir(const char *a1);
unsigned __int64 __fastcall _alloc_dir(int a1, char a2, __int64 a3, unsigned int *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall readdir64(__int64 a1);
unsigned __int64 __fastcall _sched_cpucount(unsigned __int64 result, int8x8_t *a2);
unsigned __int64 __fastcall sched_getparam(__pid_t a1, struct sched_param *a2);
unsigned __int64 __fastcall sched_getscheduler(__pid_t a1);
unsigned __int64 __fastcall sched_get_priority_max(int a1);
unsigned __int64 __fastcall sched_get_priority_min(int a1);
unsigned __int64 __fastcall sched_setscheduler(__pid_t a1, int a2, const struct sched_param *a3);
__int64 __fastcall sysconf(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
unsigned __int64 __fastcall getcwd(unsigned __int64 a1, size_t a2, __int64 a3, void *a4, void *a5, void *a6, void *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
bool __fastcall isatty(int a1);
__int64 __fastcall lstat64(const char *a1, struct stat *a2);
__int64 __fastcall openat64(int a1, void *a2, int a3, unsigned int a4);
__int64 __fastcall stat64(const char *a1, struct stat *a2);
unsigned __int64 __fastcall _fcntl64_nocancel(int a1, int a2, void *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
unsigned __int64 __fastcall _fcntl64_nocancel_adjusted(int a1, int a2, void *a3);
unsigned __int64 __fastcall _openat_nocancel(int a1, const char *a2, int a3);
unsigned __int64 __fastcall _pread64_nocancel(int a1, void *a2, size_t a3, __off64_t a4);
unsigned __int64 __fastcall tcgetattr(int a1, __int64 a2);
unsigned __int64 __fastcall getrlimit64(enum __rlimit_resource a1, struct rlimit64 *a2);
__int64 _getclktck();
__int64 getdtablesize();
__int64 __fastcall trecurse(__int64 a1, void (__fastcall *a2)(__int64, __int64, _QWORD), unsigned int a3);
__int64 __fastcall trecurse_r(__int64 a1, void (__fastcall *a2)(__int64, __int64, __int64), __int64 a3);
void __fastcall tdestroy_recurse(_QWORD *a1, void (__fastcall *a2)(_QWORD));
unsigned __int64 __fastcall maybe_split_for_insert_isra_0(__int64 a1, _QWORD *a2, unsigned __int64 *a3, int a4, int a5, int a6);
_QWORD *__fastcall tsearch(__int64 a1, __int64 *a2, __int64 (__fastcall *a3)(__int64, _QWORD), void *a4, void *a5, void *a6, __int64 *a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
_QWORD *__fastcall tfind(__int64 a1, unsigned __int64 *a2, __int64 (__fastcall *a3)(__int64, _QWORD));
_QWORD *__fastcall tdelete(__int64 a1, unsigned __int64 *a2, __int64 (__fastcall *a3)(__int64, _QWORD));
__int64 __fastcall twalk(__int64 result, void (__fastcall *a2)(__int64, __int64, _QWORD));
__int64 __fastcall twalk_r(__int64 a1, void (__fastcall *a2)(__int64, __int64, __int64), __int64 a3);
void __fastcall tdestroy(_QWORD *a1, void (__fastcall *a2)(_QWORD));
void __fastcall _init_misc(__int64 a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int64 a7);
void __fastcall __noreturn fatal_error(unsigned int a1, const char *a2, const char *a3, const char *a4);
void __fastcall __noreturn dl_signal_exception(unsigned int a1, const char **a2, const char *a3);
void __fastcall __noreturn dl_signal_error(unsigned int a1, __int64 a2, const char *a3, const char *a4);
__int64 __fastcall dl_catch_exception(_QWORD *a1, void (__fastcall *a2)(__int64), __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__int64 __fastcall dl_catch_error(_QWORD *a1, _QWORD *a2, bool *a3, void (__fastcall *a4)(__int64), __int64 a5, __int64 a6, __int64 a7, __int64 a8);
void __noreturn length_mismatch();
void __fastcall dl_error_free(unsigned __int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 (__fastcall *__fastcall dl_exception_create(__int64 (__fastcall **a1)(__int64 result, __int64 *a2, unsigned __int64 a3), __int64 a2))(__int64 result, __int64 *a2, unsigned __int64 a3);
__int64 (__fastcall *dl_exception_create_format(__int64 (__fastcall **a1)(__int64 result, __int64 *a2, unsigned __int64 a3), __int64 a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, ...))(__int64 result, __int64 *a2, unsigned __int64 a3);
void __fastcall dl_exception_free(_QWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall dl_make_stack_executable(_QWORD *a1);
unsigned int *__fastcall check_match(unsigned __int64 a1, unsigned int *a2, __int64 a3, char a4, unsigned __int8 a5, unsigned int *a6, unsigned int a7, __int64 a8, __int64 a9, unsigned int **a10, _DWORD *a11);
__int64 __fastcall do_lookup_x(const char *a1, unsigned int a2, unsigned __int64 *a3, __int64 a4, unsigned int **a5, void **a6, __int64 a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16, char a17, __int64 a18, unsigned __int8 a19, __int64 a20);
__int64 __fastcall dl_lookup_symbol_x(const char *a1, __int64 a2, __int64 *a3, void ***a4, const char **a5, int a6, char a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall dl_try_allocate_static_tls(__int64 a1, char a2);
void __fastcall dl_allocate_static_tls(__int64 a1);
unsigned __int64 __fastcall dl_protect_relro(unsigned __int64 result);
void __fastcall __noreturn dl_reloc_bad_type(__int64 a1, unsigned int a2, int a3);
unsigned __int64 __fastcall dl_relocate_object_no_relro(__int64 a1, void ***a2, int a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
unsigned __int64 __fastcall dl_relocate_object(unsigned __int64 result, void ***a2, int a3, int a4, __int64 a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, __int64 a14, __int64 a15, __int64 a16);
__int64 __fastcall dl_scope_free(unsigned __int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, void *a12, void *a13, void *a14, void *a15, __int64 a16);
void _thread_gscope_wait();
__int64 __fastcall dl_runtime_resolve(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall dl_tlsdesc_return(__int64 a1);
__int64 __fastcall dl_tlsdesc_undefweak(__int64 a1);
ssize_t __fastcall do_dlopen(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall dlerror_run(void (__fastcall *a1)(__int64), __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__int64 __fastcall do_dlsym_private(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall do_dlsym(__int64 *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall do_dlvsym(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall do_dlclose(); // weak
__int64 __fastcall free_slotinfo(unsigned __int64 *a1);
__int64 __fastcall _libc_dlopen_mode(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__int64 __fastcall _libc_dlsym_private(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__int64 __fastcall _libc_dlsym(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__int64 __fastcall _libc_dlvsym(unsigned __int64 a1, __int64 a2, unsigned __int8 *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__int64 __fastcall _libc_dlclose(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
void __fastcall _dl_libc_freemem(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall _gconv_open(__int64 a1, unsigned __int64 *a2, unsigned int a3);
__int64 __fastcall _gconv(_QWORD *a1, __int64 *a2, unsigned __int64 a3, __int64 *a4, __int64 a5, _QWORD *a6);
__int64 __fastcall _gconv_close(__int64 *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall gconv_parse_code(unsigned __int8 **a1);
_BYTE *__fastcall _gconv_create_spec(__int64 a1);
void __fastcall _gconv_destroy_spec(unsigned __int64 *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
char **__fastcall nl_find_locale(const char *a1, __int64 a2, int a3, unsigned __int64 **a4);
void __fastcall nl_remove_locale(int a1, unsigned __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall nl_load_locale_from_archive(int a1, unsigned __int64 **a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
void __fastcall nl_archive_subfreeres(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
unsigned __int64 __fastcall nl_intern_locale_data(int a1, _DWORD *a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, __int64 a13, __int64 a14, void *a15, __int64 a16);
unsigned __int64 __fastcall nl_load_locale(__int64 a1, int a2);
void __fastcall nl_unload_locale(int a1, unsigned __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
__int64 __fastcall _current_locale_name(int a1);
void __noreturn _longjmp(struct __jmp_buf_tag env[1], int val);
__int64 __fastcall _mpn_cmp(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall _mpn_divrem(__int64 a1, __int64 a2, unsigned __int64 *a3, __int64 a4, unsigned __int64 *a5, __int64 a6);
unsigned __int64 __fastcall _mpn_lshift(__int64 a1, __int64 a2, __int64 a3, char a4);
unsigned __int64 __fastcall _mpn_mul(__int64 a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5);
unsigned __int64 __fastcall _mpn_mul_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _mpn_impn_mul_n_basecase(__int64 result, __int64 a2, __int64 *a3, __int64 a4);
__int64 __fastcall _mpn_impn_mul_n(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, __int64 a5);
__int64 __fastcall _mpn_impn_sqr_n_basecase(__int64 result, __int64 *a2, __int64 a3);
__int64 __fastcall _mpn_impn_sqr_n(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4);
__int64 __fastcall _mpn_mul_n(__int64 *a1, __int64 *a2, __int64 *a3, __int64 a4);
unsigned __int64 __fastcall _mpn_rshift(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, int a4);
__int64 __fastcall _mpn_sub_n(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
unsigned __int64 __fastcall _mpn_submul_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall _mpn_extract_double(_QWORD *a1, double a2, __int64 a3, _DWORD *a4, _DWORD *a5);
__int64 __fastcall _mpn_extract_long_double(unsigned __int64 *a1, long double a2, __int64 a3, _DWORD *a4, _DWORD *a5);
__int64 __fastcall _printf_buffer_as_file_commit(_QWORD *a1);
__int64 __fastcall _printf_buffer_as_file_overflow(_QWORD *a1, int a2);
unsigned __int64 __fastcall _printf_buffer_as_file_xsputn(_QWORD *a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall _printf_buffer_as_file_init(_QWORD *a1, __int64 *a2);
__int64 __fastcall _printf_buffer_as_file_terminate(_QWORD *a1);
__int64 __fastcall _printf_buffer_flush(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, void *a12, __int64 a13, _DWORD *a14, void *a15, __int64 a16);
__int64 __fastcall _wprintf_buffer_done(__int64 a1);
__int64 __fastcall _wprintf_buffer_flush(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, unsigned __int64 a12, __int64 a13, _DWORD *a14, void *a15);
_BYTE *__fastcall IO_getline_info(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, __int64 a5, _DWORD *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
_BYTE *__fastcall IO_getline(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, __int64 a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, __int64 a14, void *a15);
_QWORD *__fastcall pthread_cleanup_push(_QWORD *result, __int64 a2, __int64 a3);
__int64 __fastcall pthread_cleanup_pop(__int64 result, int a2);
_QWORD *__fastcall _nptl_stack_list_del(__int64 *a1);
unsigned __int64 __fastcall _nptl_stack_list_add(unsigned __int64 result, unsigned __int64 *a2);
__int64 __fastcall _nptl_free_stacks(__int64 result, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
void __fastcall _nptl_deallocate_stack(__int64 a1);
unsigned __int64 _pthread_get_minstack();
__int64 __fastcall two_way_long_needle_0(__int64 a1, __int64 a2, int8x16_t *a3, unsigned __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
unsigned __int64 (__fastcall *__fastcall memmem(unsigned __int64 (__fastcall *result)(__int64 a1, unsigned int a2, unsigned __int64 a3), unsigned __int64 a2, int8x16_t *a3, unsigned __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9))(__int64 a1, unsigned int a2, unsigned __int64 a3);
__int64 (__fastcall *__fastcall strndup(__int64 a1, unsigned __int64 a2))(__int64 result, __int64 *a2, unsigned __int64 a3);
__int64 __fastcall strspn(unsigned __int64 a1, unsigned __int8 *a2);
void __fastcall nl_cleanup_time(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
unsigned __int64 __fastcall fdopendir(int a1);
void __fastcall rewinddir(__int64 a1);
rlim64_t _get_child_max();
__int64 __fastcall fstatat64(int a1, const char *a2, struct stat *a3, int a4);
__int64 __fastcall remove_slotinfo(__int64 a1, _QWORD *a2, __int64 a3, char a4);
ssize_t __fastcall dl_close_worker(ssize_t result, unsigned __int8 a2);
__int64 __fastcall dl_close(ssize_t a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, void *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
void (__fastcall **__fastcall call_dl_init(__int64 a1))(_QWORD, __int64, __int64);
__int64 *__fastcall add_to_global_update(__int64 a1);
ssize_t __fastcall dl_open_worker(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, void *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
void __fastcall __noreturn add_to_global_resize_failure_isra_0(__int64 *a1);
void __fastcall add_to_global_resize(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 *__fastcall dl_find_dso_for_object(unsigned __int64 a1);
ssize_t __fastcall dl_open(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, void *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
ssize_t __fastcall dl_show_scope(_QWORD *a1, int a2);
ssize_t __fastcall dl_open_worker_begin(__int64 a1);
char *__fastcall dl_fixup(__int64 a1, unsigned int a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10);
_QWORD *__fastcall dfs_traversal_part_0(_QWORD *result, __int64 a2, _BYTE *a3);
int *dl_sort_maps_init();
unsigned __int64 __fastcall dl_sort_maps(unsigned __int64 *a1, unsigned int a2, unsigned __int8 a3, char a4);
__int64 __fastcall dl_check_map_versions(__int64 *a1, int a2, __int64 a3, void *a4, __int64 a5, void *a6, __int64 a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall dl_check_all_versions(__int64 a1, int a2, unsigned int a3, void *a4, __int64 a5, void *a6, __int64 a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
unsigned __int64 __fastcall dl_unmap(__int64 a1);
__int64 __fastcall dl_addr_inside_object(__int64 *a1, __int64 a2);
__int64 __fastcall dl_find_object_from_map(__int64 result, _QWORD *a2);
__int64 dlfo_process_initial();
__int128 *__fastcall dlfo_sort_mappings_part_0(__int128 *result, unsigned __int64 a2);
__int64 __fastcall dl_find_object(unsigned __int64 a1, __int64 a2);
__int128 *__fastcall dlfo_sort_mappings(__int128 *result, unsigned __int64 a2);
__int128 *dl_find_object_init();
__int64 __fastcall dl_find_object_update(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, void *a12, void *a13, void *a14, void *a15, __int64 a16);
unsigned __int64 __fastcall dl_find_object_dlclose(unsigned __int64 result);
void __fastcall dl_find_object_freeres(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall _rtld_static_init(__int64 *a1);
__int64 __fastcall _mpn_add_n(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
unsigned __int64 __fastcall _mpn_addmul_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall dladdr(unsigned __int64 a1, _QWORD *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, __int64 a13, void *a14, void *a15);
__int64 __fastcall dladdr1(unsigned __int64 a1, _QWORD *a2, __int64 **a3, int a4, __int64 a5, void *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
__int64 __fastcall dlclose(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
const char *__fastcall dlerror(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall dlerror_run(void (__fastcall *a1)(__int64), __int64 a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, __int64 a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
void __fastcall dlinfo_doit(__int64 a1);
__int64 __fastcall dlinfo(__int64 a1, int a2, __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
ssize_t __fastcall dlmopen_doit(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _dlmopen(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall dlmopen(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
ssize_t __fastcall dlopen_doit(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _dlopen(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall dlopen(__int64 a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, double a16);
__int64 __fastcall dlsym_doit(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _dlsym(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, void *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
__int64 __fastcall dlsym(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, void *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
__int64 __fastcall dlvsym_doit(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall _dlvsym(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, void *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
__int64 __fastcall dlvsym(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, void *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
void __fastcall _libc_dlerror_result_free(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8);
__int64 __fastcall dl_call_libc_early_init(__int64 result, unsigned int a2);
__int64 __fastcall dl_call_fini(__int64 a1);
__int64 *__fastcall openaux(__int64 a1);
__int64 __fastcall dl_map_object_deps(__int64 a1, __int64 a2, unsigned int a3, int a4, __int64 a5, __int64 a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14);
__int64 __fastcall call_init(__int64 a1, unsigned int a2, __int64 a3, __int64 a4);
void (__fastcall **__fastcall dl_init(__int64 a1, unsigned int a2, __int64 a3, __int64 a4))(_QWORD, __int64, __int64);
unsigned int *__fastcall check_match_0(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3, int a4, unsigned int a5);
unsigned int *__fastcall dl_lookup_direct(__int64 a1, unsigned __int64 a2, unsigned int a3, unsigned __int64 a4, int a5);
__int64 __fastcall dl_addr(unsigned __int64 a1, _QWORD *a2, __int64 **a3, _QWORD *a4, __int64 a5, void *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
__int64 __fastcall call_dl_lookup(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9);
__int64 __fastcall do_sym(__int64 a1, const char *a2, unsigned __int64 a3, const char **a4, int a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12, double a13);
__int64 __fastcall dl_vsym(__int64 a1, const char *a2, const char *a3, unsigned __int64 a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12);
__int64 __fastcall dl_sym(__int64 a1, const char *a2, unsigned __int64 a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11);
void __cdecl _aarch64_cas4_relax();
void __cdecl _aarch64_cas4_acq();
void __cdecl _aarch64_cas8_acq();
void __cdecl _aarch64_cas4_rel();
void __cdecl _aarch64_cas8_rel();
void __cdecl _aarch64_swp4_relax();
void __cdecl _aarch64_ldadd4_relax();
void __cdecl _aarch64_ldset4_relax();
void __cdecl _aarch64_ldadd8_relax();
void __cdecl _aarch64_swp4_acq();
void __cdecl _aarch64_ldadd4_acq();
void __cdecl _aarch64_ldclr4_acq();
void __cdecl _aarch64_ldset4_acq();
void __cdecl _aarch64_swp8_acq();
void __cdecl _aarch64_swp4_rel();
void __fastcall _sfp_handle_exceptions(int _fex);
void __cdecl init_dwarf_reg_size_table();
__int64 __fastcall uw_install_context_1(_Unwind_Context *current, _Unwind_Context *target);
const unsigned __int8 *__fastcall read_encoded_value(_Unwind_Context *context, unsigned __int8 encoding, const unsigned __int8 *p, _Unwind_Ptr *val);
_Unwind_Word __fastcall execute_stack_op(const unsigned __int8 *op_ptr, const unsigned __int8 *op_end, _Unwind_Context *context, _Unwind_Word initial);
void __fastcall uw_update_context_1(_Unwind_Context *context, _Unwind_FrameState *fs);
void __fastcall uw_update_context(_Unwind_Context *context, _Unwind_FrameState *fs);
void __fastcall execute_cfa_program_specialized(const unsigned __int8 *insn_ptr, const unsigned __int8 *insn_end, _Unwind_Context *context, _Unwind_FrameState *fs);
void __fastcall execute_cfa_program_generic(const unsigned __int8 *insn_ptr, const unsigned __int8 *insn_end, _Unwind_Context *context, _Unwind_FrameState *fs);
_Unwind_Reason_Code __fastcall uw_frame_state_for(_Unwind_Context *context, _Unwind_FrameState *fs);
void __fastcall uw_init_context_1(_Unwind_Context *context, void *outer_cfa, void *outer_ra);
_Unwind_Reason_Code __fastcall Unwind_RaiseException_Phase2(_Unwind_Exception *exc, _Unwind_Context *context, unsigned __int64 *frames_p);
_Unwind_Reason_Code __fastcall Unwind_ForcedUnwind_Phase2(_Unwind_Exception *exc, _Unwind_Context *context, unsigned __int64 *frames_p);
_Unwind_Word __fastcall Unwind_GetGR(_Unwind_Context *context, int regno);
_Unwind_Word __fastcall Unwind_GetCFA(_Unwind_Context *context);
void __fastcall Unwind_SetGR(_Unwind_Context *context, int index, _Unwind_Word val);
_Unwind_Ptr __fastcall Unwind_GetIP(_Unwind_Context *context);
_Unwind_Ptr __fastcall Unwind_GetIPInfo(_Unwind_Context *context, int *ip_before_insn);
void __fastcall Unwind_SetIP(_Unwind_Context *context, _Unwind_Ptr val);
void *__fastcall Unwind_GetLanguageSpecificData(_Unwind_Context *context);
_Unwind_Ptr __fastcall Unwind_GetRegionStart(_Unwind_Context *context);
void *__fastcall Unwind_FindEnclosingFunction(void *pc);
_Unwind_Ptr __fastcall Unwind_GetDataRelBase(_Unwind_Context *context);
_Unwind_Ptr __fastcall Unwind_GetTextRelBase(_Unwind_Context *context);
frame_state *__fastcall _frame_state_for(void *pc_target, frame_state *state_in);
void __fastcall Unwind_DebugHook(void *cfa, void *handler);
_Unwind_Reason_Code __fastcall Unwind_RaiseException(_Unwind_Exception *exc);
_Unwind_Reason_Code __fastcall Unwind_ForcedUnwind(_Unwind_Exception *exc, _Unwind_Stop_Fn stop, void *stop_argument);
void __fastcall __noreturn Unwind_Resume(_Unwind_Exception *exc);
_Unwind_Reason_Code __fastcall __noreturn Unwind_Resume_or_Rethrow(_Unwind_Exception *exc);
void __fastcall Unwind_DeleteException(_Unwind_Exception *exc);
_Unwind_Reason_Code __fastcall Unwind_Backtrace(_Unwind_Trace_Fn trace, void *trace_argument);
int __fastcall fde_unencoded_compare(object *ob, const fde *x, const fde *y);
void __fastcall fde_unencoded_extract(object *ob, _Unwind_Ptr *target, const fde **x, int count);
void __fastcall frame_downheap(object *ob, fde_compare_t fde_compare, const fde **a, int lo, int hi);
void __fastcall version_lock_lock_exclusive(version_lock *vl);
const unsigned __int8 *__fastcall read_encoded_value_with_base(unsigned __int8 encoding, _Unwind_Ptr base, const unsigned __int8 *p, _Unwind_Ptr *val);
void __fastcall fde_radixsort(object *ob, fde_extractor_t fde_extractor, fde_vector *v1, fde_vector *v2);
void __fastcall version_lock_unlock_exclusive(version_lock *vl);
btree_node *__fastcall btree_allocate_node(btree *t, bool inner);
void __fastcall btree_handle_root_split(btree *t, btree_node **node, btree_node **parent);
bool __fastcall btree_insert(btree *t, uintptr_type base, uintptr_type size, object *ob);
int __fastcall get_cie_encoding(const dwarf_cie *cie);
object *__fastcall btree_remove(btree *t, uintptr_type base);
void __fastcall fde_mixed_encoding_extract(object *ob, _Unwind_Ptr *target, const fde **x, int count);
size_t __fastcall classify_object_over_fdes(object *ob, const fde *this_fde, uintptr_type *range);
void __fastcall get_pc_range(const object *ob, uintptr_type *range);
void *__fastcall _deregister_frame_info_bases_0(const void *begin);
void __fastcall fde_single_encoding_extract(object *ob, _Unwind_Ptr *target, const fde **x, int count);
int __fastcall fde_single_encoding_compare(object *ob, const fde *x, const fde *y);
int __fastcall fde_mixed_encoding_compare(object *ob, const fde *x, const fde *y);
void __fastcall add_fdes(object *ob, fde_accumulator *accu, const fde *this_fde); // idb
const fde *__fastcall linear_search_fdes(object *ob, const fde *this_fde, void *pc);
void __fastcall _register_frame_info_bases(const void *begin, object *ob, void *tbase, void *dbase);
void __fastcall _register_frame_info(const void *begin, object *ob);
void __fastcall _register_frame(void *begin);
void __fastcall _register_frame_info_table_bases(void *begin, object *ob, void *tbase, void *dbase);
void __fastcall _register_frame_info_table(void *begin, object *ob);
void __fastcall _register_frame_table(void *begin);
void *__fastcall _deregister_frame_info_bases(const void *begin);
void *__fastcall _deregister_frame_info(const void *begin);
void __fastcall _deregister_frame(void *begin);
const fde *__fastcall Unwind_Find_FDE(void *pc, dwarf_eh_bases *bases);
_Unwind_Ptr __fastcall base_of_encoded_value(unsigned __int8 encoding, _Unwind_Context *context);
const unsigned __int8 *__fastcall read_encoded_value_with_base_0(unsigned __int8 encoding, _Unwind_Ptr base, const unsigned __int8 *p, _Unwind_Ptr *val);
_Unwind_Reason_Code __fastcall _gcc_personality_v0(int version, _Unwind_Action actions, _Unwind_Exception_Class exception_class, _Unwind_Exception *ue_header, _Unwind_Context *context);
void __cdecl _arm_za_disable();
void __cdecl _arm_tpidr2_save();
__int64 __fastcall pthread_cond_broadcast(__int64 *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, void *a13, void *a14, void *a15);
unsigned __int64 __fastcall _condvar_confirm_wakeup(__int64 a1, int a2);
unsigned __int64 __fastcall _condvar_release_lock(__int64 a1, int a2);
unsigned __int64 __fastcall _condvar_cancel_waiting(__int64 a1, unsigned __int64 a2, unsigned int a3, int a4, void *a5, void *a6, void *a7, double a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15);
__int64 __fastcall _condvar_cleanup_waiting(__int64 a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, void *a13, void *a14, void *a15);
__int64 __fastcall pthread_cond_wait(__int64 a1, int *a2);
__int64 __fastcall pthread_cond_timedwait(__int64 a1, int *a2, _QWORD *a3);
__int64 __fastcall pthread_cond_clockwait(__int64 a1, int *a2, unsigned int a3, _QWORD *a4);
__int64 __fastcall _pthread_mutex_cond_lock_full(_DWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, void *a13, void *a14, void *a15);
__int64 __fastcall _pthread_mutex_cond_lock(_DWORD *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, void *a13, void *a14, void *a15);
_DWORD *__fastcall _pthread_mutex_cond_lock_adjust(_DWORD *result);
__int64 __fastcall _getauxval2(__int64 a1, __int64 *a2);
__int64 __fastcall getauxval(__int64 a1);
__int64 __fastcall pthread_cond_signal(__int64 *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, __int64 a10, __int64 a11, __int64 a12, void *a13, void *a14, void *a15);
void __cdecl _aarch64_cas8_acq_rel();
void __cdecl _aarch64_ldadd8_acq();
void __cdecl _aarch64_ldadd4_rel();
void __cdecl _aarch64_ldclr4_rel();
void __cdecl _aarch64_ldeor8_rel();
void __cdecl _aarch64_swp8_acq_rel();
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

int dword_400040 = 1; // weak
__int64 (__fastcall **off_4001F0)() = &off_490000; // weak
_UNKNOWN _memcpy_a64fx; // weak
_UNKNOWN _memmove_a64fx; // weak
_UNKNOWN _memcpy_mops; // weak
_UNKNOWN _memcpy_sve; // weak
_UNKNOWN _memmove_sve; // weak
_UNKNOWN _memmove_mops; // weak
_UNKNOWN _memset_a64fx; // weak
_UNKNOWN _memset_mops; // weak
_UNKNOWN _libc_arm_za_disable; // weak
_UNKNOWN dummy_bucket_6; // weak
_UNKNOWN unk_454078; // weak
__int64 qword_454610 = 0LL; // weak
_BYTE algn_4561D4[4] = { 0, 0, 0, 0 }; // weak
_BYTE inmask_9[8] = { -64, -32, -16, -8, -4, 0, 0, 0 }; // weak
unsigned __int8 nl_category_name_sizes[16] = { 8u, 10u, 7u, 10u, 11u, 11u, 6u, 8u, 7u, 10u, 12u, 14u, 17u, 0u, 0u, 0u }; // weak
char yypgoto[8] = { '\xFC', '\xFC', '\xFF', '\0', '\0', '\0', '\0', '\0' }; // weak
_UNKNOWN sigall_set; // weak
_UNKNOWN default_rwlockattr; // weak
_DWORD nl_value_type_LC_MEASUREMENT[2] = { 3, 1 }; // weak
_UNKNOWN unk_45B000; // weak
unsigned __int16 sys_errnameidx[136] =
{
  0u,
  2u,
  8u,
  15u,
  21u,
  27u,
  31u,
  37u,
  43u,
  51u,
  57u,
  229u,
  72u,
  79u,
  86u,
  93u,
  101u,
  107u,
  114u,
  120u,
  127u,
  135u,
  142u,
  156u,
  149u,
  163u,
  170u,
  178u,
  184u,
  191u,
  198u,
  204u,
  211u,
  217u,
  222u,
  64u,
  537u,
  612u,
  619u,
  573u,
  531u,
  0u,
  673u,
  641u,
  762u,
  769u,
  778u,
  785u,
  792u,
  799u,
  807u,
  814u,
  821u,
  827u,
  833u,
  840u,
  847u,
  855u,
  0u,
  863u,
  686u,
  657u,
  710u,
  680u,
  870u,
  877u,
  604u,
  665u,
  884u,
  889u,
  896u,
  703u,
  647u,
  902u,
  633u,
  693u,
  910u,
  919u,
  926u,
  934u,
  942u,
  950u,
  958u,
  966u,
  626u,
  753u,
  975u,
  583u,
  257u,
  472u,
  266u,
  275u,
  286u,
  298u,
  314u,
  330u,
  341u,
  354u,
  367u,
  378u,
  392u,
  401u,
  413u,
  423u,
  436u,
  447u,
  455u,
  463u,
  485u,
  495u,
  508u,
  518u,
  550u,
  560u,
  248u,
  236u,
  597u,
  984u,
  992u,
  1000u,
  1008u,
  1015u,
  590u,
  1025u,
  1035u,
  716u,
  1047u,
  1054u,
  1066u,
  1078u,
  726u,
  737u,
  1091u,
  1099u,
  0u,
  0u
}; // weak
_UNKNOWN sys_errname; // weak
__int128 xmmword_45B770 = 0x0FFFFFFFFFFFFFFFFLL; // weak
__int128 xmmword_45B780 = 0x100000000000000011LL; // weak
__int128 xmmword_45B790 = 0x686361632E6F732E646C2D6362696C67LL; // weak
__int128 xmmword_45B7A0 = 0x10000000000000001LL; // weak
__int128 xmmword_45B7B0 = 0x7FFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFLL; // weak
__int128 xmmword_45B7C0 = 0x0A000000000000000LL; // weak
__int128 xmmword_45B7D0 = 1LL; // weak
__int128 xmmword_45B7E0 = 0x3000000020000000100000000LL; // weak
char yypact[32] =
{
  '\x1B',
  '\x1B',
  '\xFC',
  '\xFC',
  '\x1B',
  '\x01',
  '\'',
  '\xFC',
  '\r',
  '\xFC',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\x1B',
  '\xFC',
  '\x16',
  '\xFD',
  '+',
  '.',
  '\x1A',
  '\xFE',
  '\xFC',
  '\x1B',
  '\'',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char itoa_lower_digits[37] = "0123456789abcdefghijklmnopqrstuvwxyz"; // weak
_UNKNOWN unk_45B959; // weak
_UNKNOWN primes_0; // weak
int dword_45B9D8 = 0; // weak
unsigned int tunable_env_alias_list[8] = { 10u, 11u, 12u, 14u, 15u, 17u, 21u, 22u }; // weak
_UNKNOWN empty_path_elem; // weak
char nl_category_names[11] = "LC_COLLATE"; // weak
char nl_category_name_idxs[4] = "\v +"; // weak
char yytranslate[272] =
{
  '\0',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x06',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x05',
  '\x02',
  '\x0E',
  '\x0F',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\f',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x03',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\r',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x04',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x02',
  '\x01',
  '\x02',
  '\a',
  '\b',
  '\t',
  '\n',
  '\v',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
char yydefact[32] =
{
  '\0',
  '\0',
  '\f',
  '\v',
  '\0',
  '\0',
  '\x02',
  '\n',
  '\0',
  '\x01',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0',
  '\r',
  '\0',
  '\x04',
  '\x05',
  '\x06',
  '\a',
  '\b',
  '\t',
  '\0',
  '\x03',
  '\0',
  '\0',
  '\0',
  '\0',
  '\0'
}; // weak
_BYTE yycheck[64] =
{
  1,
  0,
  5,
  4,
  7,
  8,
  9,
  10,
  10,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  3,
  4,
  5,
  -1,
  7,
  8,
  9,
  10,
  25,
  3,
  4,
  5,
  15,
  7,
  8,
  9,
  10,
  6,
  12,
  9,
  10,
  -1,
  11,
  -1,
  13,
  14,
  3,
  4,
  5,
  -1,
  7,
  8,
  9,
  10,
  7,
  8,
  9,
  10,
  8,
  9,
  10,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
unsigned __int8 _strtol_ul_rem_tab[48] =
{
  1u,
  0u,
  3u,
  0u,
  3u,
  1u,
  7u,
  6u,
  5u,
  4u,
  3u,
  2u,
  1u,
  0u,
  15u,
  0u,
  15u,
  16u,
  15u,
  15u,
  15u,
  5u,
  15u,
  15u,
  15u,
  24u,
  15u,
  23u,
  15u,
  15u,
  31u,
  15u,
  17u,
  15u,
  15u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // weak
_QWORD _strtol_ul_max_tab[35] =
{
  9223372036854775807LL,
  6148914691236517205LL,
  4611686018427387903LL,
  3689348814741910323LL,
  3074457345618258602LL,
  2635249153387078802LL,
  2305843009213693951LL,
  2049638230412172401LL,
  1844674407370955161LL,
  1676976733973595601LL,
  1537228672809129301LL,
  1418980313362273201LL,
  1317624576693539401LL,
  1229782938247303441LL,
  1152921504606846975LL,
  1085102592571150095LL,
  1024819115206086200LL,
  970881267037344821LL,
  922337203685477580LL,
  878416384462359600LL,
  838488366986797800LL,
  802032351030850070LL,
  768614336404564650LL,
  737869762948382064LL,
  709490156681136600LL,
  683212743470724133LL,
  658812288346769700LL,
  636094623231363848LL,
  614891469123651720LL,
  595056260442243600LL,
  576460752303423487LL,
  558992244657865200LL,
  542551296285575047LL,
  527049830677415760LL,
  512409557603043100LL
}; // weak
char msg_0[25] = "unexpected reloc type 0x"; // weak
int codeset_idx_2[16] = { 14, 5, 110, 18, 45, 4, 0, 2, 6, 12, 4, 1, 15, 0, 0, 0 }; // weak
_QWORD nl_category_num_items[14] = { 86LL, 6LL, 159LL, 19LL, 46LL, 5LL, 0LL, 3LL, 7LL, 13LL, 5LL, 2LL, 16LL, 0LL }; // weak
_DWORD nl_value_type_LC_TELEPHONE[6] = { 1, 1, 1, 1, 1, 0 }; // weak
_DWORD dword_45DB40[256] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  91,
  92,
  93,
  94,
  95,
  96,
  97,
  98,
  99,
  100,
  101,
  102,
  103,
  104,
  105,
  106,
  107,
  108,
  109,
  110,
  111,
  112,
  113,
  114,
  115,
  116,
  117,
  118,
  119,
  120,
  121,
  122,
  123,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255
}; // weak
int dword_45E140[256] =
{
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51,
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  62,
  63,
  64,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  91,
  92,
  93,
  94,
  95,
  96,
  65,
  66,
  67,
  68,
  69,
  70,
  71,
  72,
  73,
  74,
  75,
  76,
  77,
  78,
  79,
  80,
  81,
  82,
  83,
  84,
  85,
  86,
  87,
  88,
  89,
  90,
  123,
  124,
  125,
  126,
  127,
  128,
  129,
  130,
  131,
  132,
  133,
  134,
  135,
  136,
  137,
  138,
  139,
  140,
  141,
  142,
  143,
  144,
  145,
  146,
  147,
  148,
  149,
  150,
  151,
  152,
  153,
  154,
  155,
  156,
  157,
  158,
  159,
  160,
  161,
  162,
  163,
  164,
  165,
  166,
  167,
  168,
  169,
  170,
  171,
  172,
  173,
  174,
  175,
  176,
  177,
  178,
  179,
  180,
  181,
  182,
  183,
  184,
  185,
  186,
  187,
  188,
  189,
  190,
  191,
  192,
  193,
  194,
  195,
  196,
  197,
  198,
  199,
  200,
  201,
  202,
  203,
  204,
  205,
  206,
  207,
  208,
  209,
  210,
  211,
  212,
  213,
  214,
  215,
  216,
  217,
  218,
  219,
  220,
  221,
  222,
  223,
  224,
  225,
  226,
  227,
  228,
  229,
  230,
  231,
  232,
  233,
  234,
  235,
  236,
  237,
  238,
  239,
  240,
  241,
  242,
  243,
  244,
  245,
  246,
  247,
  248,
  249,
  250,
  251,
  252,
  253,
  254,
  255
}; // weak
_WORD word_45EA40[256] =
{
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  8195,
  8194,
  8194,
  8194,
  8194,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  24577,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -10232,
  -10232,
  -10232,
  -10232,
  -10232,
  -10232,
  -10232,
  -10232,
  -10232,
  -10232,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -11000,
  -11000,
  -11000,
  -11000,
  -11000,
  -11000,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -15096,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -16380,
  -10744,
  -10744,
  -10744,
  -10744,
  -10744,
  -10744,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -14840,
  -16380,
  -16380,
  -16380,
  -16380,
  2,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int64 qword_46B1D0 = 232LL; // weak
_UNKNOWN unk_46B1E8; // weak
__int64 _tens[1725] =
{
  0LL,
  10LL,
  0LL,
  100LL,
  0LL,
  10000LL,
  0LL,
  100000000LL,
  0LL,
  10000000000000000LL,
  0LL,
  -8814407033341083648LL,
  5421010862427LL,
  0LL,
  0LL,
  7942358959831785217LL,
  -1639316909303818259LL,
  1593091LL,
  0LL,
  0LL,
  0LL,
  279109966635548161LL,
  2554917779393558781LL,
  -4322087811897362964LL,
  -6470688491082764070LL,
  2537941837315LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  -4696261158952338431LL,
  1302999927698857842LL,
  -3509871530456756026LL,
  2788415840139466767LL,
  2095640732773017264LL,
  7205570348933370714LL,
  7348167152523113408LL,
  -9161227676869187342LL,
  6907659600622710236LL,
  349175LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  8643096425819600897LL,
  6743743997439985372LL,
  -4387039464611214697LL,
  -7717384947811220205LL,
  4933048501514368705LL,
  -6188612470538996933LL,
  2172371001088594721LL,
  -4876840743490408670LL,
  -4637601865739972771LL,
  -1730383554671781970LL,
  -8815487149903444331LL,
  -5579802841404447906LL,
  1397931361048440292LL,
  7619627737732970332LL,
  -5721334587426885716LL,
  -6743692630348587706LL,
  -8499665702906465533LL,
  -4480456172261111145LL,
  121923442132LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  -766971542220705791LL,
  2216509366347768155LL,
  1568689219195129479LL,
  5511594616325588277LL,
  1067709417009240089LL,
  9070650952098657518LL,
  -6931458203074693601LL,
  2539561553659505564LL,
  -841854772748459817LL,
  -3935203216855346892LL,
  -6347660734152066145LL,
  7115240299237943815LL,
  313979240050606788LL,
  -8441959408992379421LL,
  -2876475225779420143LL,
  -8087028870873620813LL,
  -761690061594388804LL,
  -5263470690853753859LL,
  7743260039872919062LL,
  -9162150637316978690LL,
  -7340822851643136603LL,
  -247944750308847770LL,
  -2131755689970093296LL,
  4387527177871570570LL,
  8476708682254672590LL,
  4925096874831034057LL,
  -4371056205637524161LL,
  112866656203221926LL,
  -8593913605936321198LL,
  25755239915196746LL,
  2201493076310172510LL,
  8342165458688466438LL,
  -4492737497643172566LL,
  -3252925013806255980LL,
  -5881127354798162085LL,
  3815854855847885129LL,
  -2749981910126010988LL,
  805LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  -2087022168986361855LL,
  5323973632697650495LL,
  -1258787616947550431LL,
  3930387638628283780LL,
  3374723710406992273LL,
  -1562518985046329485LL,
  -7479304022668112462LL,
  -8759827891252831556LL,
  -7892196027397821422LL,
  7390739362393647554LL,
  6316162333127736719LL,
  -324279187125480725LL,
  4044404959645932768LL,
  3801320885861987401LL,
  -6365793420452277026LL,
  -2032419811220560317LL,
  -2051056574873141503LL,
  -6273110132813365356LL,
  -7603558640566919466LL,
  -7398574240979151808LL,
  -5771915138974867900LL,
  -1075935763578969066LL,
  -7945817088276142924LL,
  -8194018915298847061LL,
  -4276635803207484093LL,
  3698946465517688080LL,
  989984870770509463LL,
  -7481142646975608547LL,
  -7056845415271215961LL,
  6901098232861256586LL,
  1921335291173932590LL,
  7662788640922083388LL,
  -8671720240401156186LL,
  4640401278902814207LL,
  -3914693101511138257LL,
  8378549018693130223LL,
  -6774421445314179963LL,
  8930704142764178555LL,
  6275193859483102017LL,
  -2664150769440346529LL,
  8673060659034172558LL,
  8018354414354334043LL,
  1824896661540749038LL,
  -7101180726983991748LL,
  -3487527629228729667LL,
  970189517688324683LL,
  3338835207603007873LL,
  -761779812917813127LL,
  1436466329061721851LL,
  4554134986752476101LL,
  6398757850768963907LL,
  4709779218751158342LL,
  -8413466325127141352LL,
  -514618195030286553LL,
  -8441993185960460176LL,
  256584531835386932LL,
  -4050461332986819988LL,
  3086085133731396950LL,
  -615471988019951552LL,
  -7872817582296986923LL,
  -3558683025850359879LL,
  4570995450261499817LL,
  -8036579051396616350LL,
  5691078631447480790LL,
  8632710455805418155LL,
  790672778942823293LL,
  -1941279967952751069LL,
  2092171438149740401LL,
  -941713399880275738LL,
  1291290830058928444LL,
  -3590552383026318820LL,
  8916773426496500052LL,
  -8294740266130693351LL,
  -5342302879945689902LL,
  649395LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  -3138359622115016703LL,
  -533079999666816281LL,
  6115977719198531863LL,
  5794980608663993169LL,
  -1902393370854444686LL,
  -9192956435928293050LL,
  4977988951675168190LL,
  9087837664087448770LL,
  2098480401110016986LL,
  -2972411532827450904LL,
  -4404610076313010672LL,
  1090855284423485362LL,
  -5806787588358493235LL,
  1454115676006639319LL,
  3180465001342538023LL,
  -3797667521750853887LL,
  -8645451627163640700LL,
  -4894542662882957612LL,
  6101141927469189381LL,
  1881431857880609316LL,
  4907847477899433595LL,
  8714572486973123228LL,
  3514969632331374520LL,
  -6779101786818081522LL,
  2391499697425323350LL,
  -960158394050475573LL,
  -179520311827445974LL,
  2886610765822313148LL,
  -9143909210740651328LL,
  -3200236226975914572LL,
  -2522516554084988776LL,
  -8703002830424853856LL,
  3159780987244964246LL,
  7304816812369628428LL,
  -862141461149833807LL,
  4146812420657846766LL,
  -3921328711028510101LL,
  8477630142371600195LL,
  4380695748062263745LL,
  -6326828079341608443LL,
  -1476113207144066494LL,
  4332724980155264503LL,
  8079943140620527639LL,
  1687908087554405626LL,
  -1395662973875549450LL,
  -5808597803978788386LL,
  -6562994196776105845LL,
  4662462156371383785LL,
  4796962238316531176LL,
  3325504751659868927LL,
  6469595803187862550LL,
  5852556621152583005LL,
  -9217409281261163735LL,
  -467010699770930907LL,
  -4495120539533758860LL,
  -1370864702618512339LL,
  -4234497594251613579LL,
  4008999959804158260LL,
  2414266395366403722LL,
  3252733766253918247LL,
  6382678985007829216LL,
  2245927470982310841LL,
  -4656019571658244315LL,
  -5329807206976403575LL,
  -8728341182402757078LL,
  -4930469673353446741LL,
  -587520197931502213LL,
  4396895129099725471LL,
  3563053650368467915LL,
  -6269898121172578948LL,
  3492050964335269015LL,
  2740656767075170753LL,
  4409704077614761919LL,
  -8208968794112058906LL,
  3314206875098230827LL,
  -2009383045595456168LL,
  -6085007848301895044LL,
  -1654233421919406136LL,
  -6997690930479621681LL,
  -110102336129218480LL,
  6558939822118891088LL,
  4606255756908155300LL,
  2360792578991605004LL,
  160428430149144538LL,
  -6801882852980330105LL,
  -7661565622549811830LL,
  -3523183455677616935LL,
  1902620814992781610LL,
  -4382667078370641204LL,
  -6899725009597338959LL,
  -1599262593743325882LL,
  8331994491163145469LL,
  -6707031091970699731LL,
  8008309968651120619LL,
  -8179774478250516352LL,
  -3271590692491849583LL,
  -6238084721135831371LL,
  7714061140750342961LL,
  2892831567213510541LL,
  -2993029824664534297LL,
  71020323573871677LL,
  -3015606077958948983LL,
  5659146884637671933LL,
  5998809010488554503LL,
  -1894551694410393766LL,
  1192197967194298797LL,
  -2289188280284690092LL,
  -7517372482714911361LL,
  3194469143425738352LL,
  6651586784672005225LL,
  -7384316932921493825LL,
  6834443579468668318LL,
  -2025180875912095694LL,
  6251046422506172884LL,
  -4494440611552757756LL,
  -1814257471838158392LL,
  -7133289713418226444LL,
  5587835232504462834LL,
  3105197524618514637LL,
  -178175542677578627LL,
  2397205535804309313LL,
  59413027864729597LL,
  -6576865948360835906LL,
  -5853942366439028350LL,
  8070632061321113656LL,
  -43096265848900805LL,
  267109013517069093LL,
  6537214311028855260LL,
  5220826919973709902LL,
  3448740582779163661LL,
  -1624504860596666675LL,
  5975299384311048185LL,
  -8152310269278839478LL,
  4739856055412448774LL,
  -6389471035383163719LL,
  -5327741131759495007LL,
  3354445304051737058LL,
  -4853931006210237022LL,
  3890182464434078629LL,
  -626359716243126556LL,
  -8661515954739672236LL,
  1778431746734556271LL,
  -8371430197359496587LL,
  -4452695584308632588LL,
  -498456999509825168LL,
  2815088342305858722LL,
  2676626035777198370LL,
  1174257960026283968LL,
  421714788677LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  -6974859598036500479LL,
  8902860357476377573LL,
  -5096447297870321111LL,
  -7837552287364942728LL,
  7261211985859587338LL,
  -7007071384354688652LL,
  -1657036001408980989LL,
  4607056528866348430LL,
  3202978990421512997LL,
  2024899620433984146LL,
  -779793866469739842LL,
  4233228489390288200LL,
  9137580478688460738LL,
  4060411066587388546LL,
  -7326794267648951492LL,
  867715462473090103LL,
  -4064349132324682006LL,
  4856042377419278489LL,
  8265605599571137921LL,
  538981667666252469LL,
  4270263388700786523LL,
  3281140600308898503LL,
  4121392524544394174LL,
  2077884106245940229LL,
  -8673702116379784042LL,
  7550623316597646685LL,
  8611033926449791714LL,
  -308821118288748823LL,
  2796546741236224013LL,
  -2969647589081104855LL,
  -8929203945595837606LL,
  -8974826103208730238LL,
  -2508173825047068492LL,
  5228016831978462619LL,
  -2725752821122577115LL,
  7662829825220776698LL,
  -1118434005641117268LL,
  3371736428170309730LL,
  3803724952191098855LL,
  -5330817537205174897LL,
  -1694172877556109359LL,
  -1906558605933291736LL,
  3432518182450051120LL,
  5880364967211798870LL,
  -6090995233404158833LL,
  -4250653315173082041LL,
  7370123524686686319LL,
  6819740424617592686LL,
  -5408806060172182863LL,
  -3417470402417624516LL,
  3671312928327205696LL,
  7473228676544792780LL,
  -1212664382396613493LL,
  -4282003225616007197LL,
  -5276839294227675714LL,
  7179036968465894054LL,
  8244653688947194445LL,
  -1266946327635752126LL,
  5591970751047577674LL,
  -916193567441221874LL,
  5965746721852312330LL,
  1604149463243472865LL,
  7734199791463116918LL,
  -7140953677693694902LL,
  4441196105025505137LL,
  -5400312492523886854LL,
  124776524294606713LL,
  1134521334706523966LL,
  -6775015980365075182LL,
  -4343304052736618468LL,
  3966727403013869059LL,
  -8618649565300418795LL,
  4355682486381147287LL,
  -8185336929721070382LL,
  3800455155249557199LL,
  -5745842135772004116LL,
  -262268606814972256LL,
  -5179052921929656204LL,
  4714157123477697445LL,
  -7676383902400966353LL,
  9083344917597998040LL,
  -6368094199899339461LL,
  -227754991663352239LL,
  4454285072780637351LL,
  5287307245618354742LL,
  -2404454371650519886LL,
  4131926574212754010LL,
  217692071448455473LL,
  3624845916216282093LL,
  2901203491797614218LL,
  6679177724033967080LL,
  44561358851332790LL,
  9094639944041587162LL,
  -4755829061433467305LL,
  1408896670826320686LL,
  5359130319612337580LL,
  6148412925099835601LL,
  5211368532286409612LL,
  -7060383248160524242LL,
  -1551561606743756545LL,
  3392940493846427241LL,
  438089879085393580LL,
  4783928372776399972LL,
  6278117363595909959LL,
  -5877263024296876883LL,
  -2798121581138657714LL,
  1966316336235305115LL,
  1603775390515993547LL,
  -4870631063505234907LL,
  -7624989423606711142LL,
  -248521556486648464LL,
  6966163076615302988LL,
  1373932372410129684LL,
  3285839581819684990LL,
  30177575069719475LL,
  -1999696202462244555LL,
  -6828089947034717808LL,
  990072222556306872LL,
  1260682336135768017LL,
  -4584689027020019127LL,
  -2778260980864853184LL,
  1879572630092764264LL,
  -4534716276650925508LL,
  6231679788219816920LL,
  -4588886018865384213LL,
  -345274001174822759LL,
  4144579812461609229LL,
  7048589655616599284LL,
  -8499787574176856986LL,
  -8675440223599677578LL,
  6477823708780339765LL,
  -920496451962509645LL,
  -4920748397856882067LL,
  3928768291901239810LL,
  8094153383078124544LL,
  -7232465405980586064LL,
  -7195196911112719006LL,
  5964946855123292381LL,
  3622548288590237903LL,
  -4976978106559498029LL,
  -647757785186085534LL,
  -3762151254901619357LL,
  -1722666796906587695LL,
  7119877993753121290LL,
  1864571304902781632LL,
  -5574759152324337804LL,
  9065447042604670298LL,
  3987130777300360550LL,
  6890545752116901685LL,
  -1171402362107685866LL,
  6296474927799264658LL,
  1257436973037243463LL,
  -4592462291744250195LL,
  1657132483318662716LL,
  -1137344533692258767LL,
  -5638632443620334374LL,
  1098489625264462071LL,
  -4436285168023187481LL,
  -2312329554227930396LL,
  -4158488173380730141LL,
  3469093466388187882LL,
  -2464033192241255744LL,
  4056765540058056052LL,
  -2501567684613447527LL,
  8625339365793505375LL,
  -6130564104845762703LL,
  -3112620300171497295LL,
  -8910505249488969851LL,
  -2365918353603348345LL,
  6235695225418121745LL,
  -6411551117251532267LL,
  3235835166714703698LL,
  5348960676912581218LL,
  -3131681301000086969LL,
  -1111654365688242954LL,
  -1590888755751137207LL,
  2369751139431140406LL,
  3693542588628609043LL,
  7350405893393987577LL,
  -1044671487367887815LL,
  7007897690013647122LL,
  -2774976201650246858LL,
  -9187253555417203701LL,
  -3610698599303421222LL,
  4654005815464502513LL,
  6487825998330548401LL,
  7013356660323385022LL,
  7136200343936679946LL,
  -3105507215033113900LL,
  3657357368867197449LL,
  -5825668543654943238LL,
  5603868621997066972LL,
  7683447656788439942LL,
  450883379216880060LL,
  -4155249723524606569LL,
  5466258454997635048LL,
  -4239810975276779490LL,
  4775870327277641692LL,
  1864430798867181939LL,
  -4697765808638942823LL,
  -6195921209447975027LL,
  -5884847096210946320LL,
  -2385794479452192288LL,
  -671554960166240087LL,
  -6610778895816624581LL,
  4218664174878121437LL,
  3499000902478111683LL,
  -3276890769350425322LL,
  7076121963053575143LL,
  832652347668916805LL,
  1292148207755194737LL,
  7556838978364207852LL,
  5904021986723518500LL,
  4610244652288570024LL,
  4526508363195533871LL,
  746120481022614726LL,
  737965197247830486LL,
  4006266184415762653LL,
  -9174555833816863566LL,
  -3100508827293841938LL,
  -6596068076362018432LL,
  -7265684405098708915LL,
  6687857983250662774LL,
  2908718488661492818LL,
  4828337780126983225LL,
  -375005427256549432LL,
  -5656556845982353736LL,
  -844260592837928463LL,
  -5923211884087695639LL,
  -7847938360981854900LL,
  2179787555896149376LL,
  2242193929457337594LL,
  -3537820832572809084LL,
  8369182018012550027LL,
  -5061362519666529292LL,
  3332327430110633913LL,
  -2308653289663343124LL,
  -2274419466240504277LL,
  8279089815915615244LL,
  -5573837470973316369LL,
  -7552198783170075995LL,
  -3017987527857646593LL,
  4155747980686992922LL,
  4074479178894544043LL,
  66083965608603584LL,
  -4572957789047283239LL,
  8861183628277687555LL,
  -6327246162413530186LL,
  2154012318305274287LL,
  -2956037759206484304LL,
  -4803598584998943249LL,
  672340241093017103LL,
  6039493278284091973LL,
  -8766946372732115155LL,
  -375948245391380442LL,
  2188146431134935377LL,
  5247392385741514952LL,
  1852539214842869734LL,
  -6211122392075438877LL,
  8812930319623534062LL,
  5585597406294108629LL,
  -7133754859233649752LL,
  1547377291787797995LL,
  8641748937186208205LL,
  -5928595414540927922LL,
  6611379197521520985LL,
  -350152502641543040LL,
  -3359722846609439477LL,
  -5388289231693593198LL,
  1473584652966833794LL,
  4387660670140018168LL,
  8452836916843525402LL,
  -4070660779266187661LL,
  -4448717869740460957LL,
  611968444648172645LL,
  990232438801273845LL,
  -445557748993989687LL,
  -4976152216459374115LL,
  -3565189933470131525LL,
  -1750376236989427121LL,
  6328076032778459673LL,
  -1419246377741047000LL,
  -8254498427447122783LL,
  8282482589527318647LL,
  4319014353374321425LL,
  -4312656802667880636LL,
  5060230880114618599LL,
  -5267234833279493016LL,
  3903514232614801894LL,
  -671994329007386361LL,
  -2998108566678581890LL,
  -2462968835351071407LL,
  -3903911929744063729LL,
  -9061125975670036950LL,
  -4015324461047246773LL,
  730863073501675978LL,
  -1696625693329816801LL,
  9640LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  0LL,
  4734805469491560449LL,
  -8325486223732958354LL,
  -2931114736431325974LL,
  2212915151774210058LL,
  6663637332045858029LL,
  -1339924551535710180LL,
  3033795390447658772LL,
  7718383707400077069LL,
  -6376439006502304790LL,
  -3177545853105786136LL,
  -6424035887981131008LL,
  77444305565097111LL,
  8296127084146860649LL,
  -3869531252920249613LL,
  -4547138759595755867LL,
  8897556787106485718LL,
  7107770150399380644LL,
  1369953078461852783LL,
  6979674467786437514LL,
  2729737685714719189LL,
  9190845266052516846LL,
  6386092840706145984LL,
  -1562634029184043423LL,
  497786295510831247LL,
  -3110672480866801855LL,
  -1290685380913229084LL,
  -1784925412414228250LL,
  -5965254612210698272LL,
  -195347905997225019LL,
  -3210061223950682743LL,
  -2113036211693790634LL,
  -1310522418227524665LL,
  -1188162142170618912LL,
  3160048940096833902LL,
  121625224721269761LL,
  3015482372342246716LL,
  8342191648913931706LL,
  2246028606627019557LL,
  7104930024182662526LL,
  -6716427498967282568LL,
  -1272517676320293229LL,
  3293804579498370401LL,
  -6217083385538550103LL,
  -637805773149631945LL,
  6264083323008108029LL,
  4820815117438024262LL,
  1979000428121124723LL,
  5000774170954614568LL,
  -5046660104014275187LL,
  7428139934551454625LL,
  -227158032510661716LL,
  8109609685913604125LL,
  -7757553851688221125LL,
  3943907756943551137LL,
  -2843511850079409138LL,
  -7840654309312808342LL,
  -9063024310973180841LL,
  -4752007754230651642LL,
  429624420090361397LL,
  227546753412414805LL,
  -7487802088538065308LL,
  -9129298250285722095LL,
  -6583598711289924451LL,
  124380730737735756LL,
  -5894706371584269918LL,
  -8939768751263285454LL,
  6361070452196727670LL,
  5864118314335574899LL,
  -248243582685672201LL,
  693710845576296048LL,
  8428067657989979622LL,
  9190375061780140607LL,
  -8212906993417924652LL,
  4057199436792326716LL,
  -5401258105744638580LL,
  -6629191848285225255LL,
  5663867194179809591LL,
  -2782630945017020160LL,
  6644074694371287637LL,
  -1836285111917876453LL,
  -5014028850169909675LL,
  6940147613714364150LL,
  -185413544034266504LL,
  2770687570340300641LL,
  166471986444296544LL,
  -6225298388866734576LL,
  3714622590696147444LL,
  -5051602777039525818LL,
  -368418271632650319LL,
  -8901965932709169375LL,
  8850914703500200093LL,
  3810737736735386096LL,
  2117555260343410051LL,
  7753203251593962517LL,
  -3094012294002111649LL,
  -8686016012256128891LL,
  2483876614472218676LL,
  -7747622018297867538LL,
  5879369345516927746LL,
  -8626134198175884376LL,
  1291610685003704965LL,
  6744219916322133607LL,
  6377819355385901546LL,
  9082047296049079505LL,
  262618211405078579LL,
  -4954532194480394074LL,
  4724420303847709296LL,
  -9158676104854373900LL,
  -364872505657368172LL,
  -3191172188306330807LL,
  2246442144788530940LL,
  5989308098935123279LL,
  -5831368054133684750LL,
  4096604902035173619LL,
  1905680188673640379LL,
  8808037380749664979LL,
  8867179827953113686LL,
  7941208416960536773LL,
  -99701943013205345LL,
  -2861863148992275582LL,
  -4549019896436702982LL,
  -5894956243168361085LL,
  2110016464489331948LL,
  -3453784842588597961LL,
  5155915500390579529LL,
  -6004597181969337625LL,
  2160740412631082538LL,
  -8715856754645252781LL,
  1978135137454895105LL,
  -2549310930953404419LL,
  -4547806246413117358LL,
  5590837795874025034LL,
  -8961839058199191163LL,
  -1170988391491464837LL,
  -8131892488490248599LL,
  5146514476452997833LL,
  2685838092360807032LL,
  -2698775762856187498LL,
  7575162550584052276LL,
  1821625350956509481LL,
  -7999093180840566501LL,
  -2983157650620814913LL,
  8070960717235237951LL,
  -4578037982724429142LL,
  -5210655000745480792LL,
  5790854297122038982LL,
  2061890046203343898LL,
  5137585270307907960LL,
  -2730877678254250275LL,
  -7432010795306866976LL,
  4568822892720381524LL,
  -6233375079378184164LL,
  5943072258025584213LL,
  7505656341731662881LL,
  -3693323393794125226LL,
  -8782413032580351082LL,
  -1247226273096620667LL,
  5794715994807321562LL,
  8979439602782410600LL,
  4013690875255814327LL,
  4788592446297410452LL,
  7881249861415092932LL,
  977213487573654953LL,
  923062152329155855LL,
  4256185035634640191LL,
  -4539969104033658618LL,
  -4285019307948990128LL,
  6255788174608088660LL,
  -8236730621559234323LL,
  8367282897729021557LL,
  -7584502531387573938LL,
  -7259628708067916899LL,
  3891102563569129293LL,
  7629137599207408133LL,
  7206037909846636727LL,
  2254919723564098762LL,
  345833071429309102LL,
  6402540102058174110LL,
  -8452812291049361889LL,
  -1329695449000320661LL,
  -3095191567168173660LL,
  7713128122863319014LL,
  -5383405755205065679LL,
  8043383629459294916LL,
  4270244130714287096LL,
  4616501241752789289LL,
  -5528774006349000783LL,
  -3229976772822969976LL,
  4002001954492136096LL,
  5582674356224425892LL,
  -2755554746702852885LL,
  496217562383964892LL,
  -5514138697592713354LL,
  -8316745315147641156LL,
  -4581184459339246677LL,
  9217339887777235754LL,
  7243018590514884616LL,
  -151881599306214583LL,
  -2304597988514136473LL,
  -3559872228637531785LL,
  2300006803713887302LL,
  -58804006014967141LL,
  3556096087578066588LL,
  6264767967456942360LL,
  -2764812140617331662LL,
  4390515012152303249LL,
  3076968672531178662LL,
  685494910557321329LL,
  1554506352208529567LL,
  1048563793801477249LL,
  7544257401359168115LL,
  4899780768732861239LL,
  6228153394030153705LL,
  3875228905107521478LL,
  -6233390302119134375LL,
  3665307925385752280LL,
  -7567173301093463825LL,
  -2031697889695090262LL,
  -3644749262389543424LL,
  -7326757003829011840LL,
  -1218410543474253181LL,
  3719945549511708577LL,
  -4406784075835378706LL,
  -3726758719600177625LL,
  -3004037523369225540LL,
  -5398943217582451595LL,
  2288611147839956377LL,
  -8997794178585459225LL,
  -4642615516761506226LL,
  8247673722161199901LL,
  148315241783422880LL,
  -2656944564942979740LL,
  -5569215657887524618LL,
  -8079918451822301200LL,
  -6547929490269302253LL,
  -2375453238411481793LL,
  8389982701544306242LL,
  5531549643251140676LL,
  -5199581202487014967LL,
  7934349776229807266LL,
  4538358977143258963LL,
  3866163666857351430LL,
  8435037624664422256LL,
  3945944434010580332LL,
  -7833748136613022325LL,
  -7605251612591421064LL,
  -4757284932746278133LL,
  -6256865339243455017LL,
  -3752703421080395338LL,
  4909641398634409324LL,
  5780023090082049999LL,
  -3675635985417134609LL,
  8441958620808173734LL,
  5802132159669142617LL,
  3837336995815619849LL,
  -5351897801064744229LL,
  -3604172043774104497LL,
  -7517899987705333118LL,
  8622139958963810291LL,
  4422969696044156012LL,
  -261606450539292764LL,
  -583082973887164484LL,
  8953841731266092224LL,
  36243936373993352LL,
  -1813702953007143325LL,
  7739468521893678775LL,
  5400063286861787915LL,
  5911383954510574696LL,
  -4897176846298655998LL,
  4462297794485792433LL,
  4488813832859891898LL,
  9149453056204172263LL,
  -2374686423772211764LL,
  -3540491497421858734LL,
  8271452853949304499LL,
  -5763765519085619854LL,
  -4285306561644422989LL,
  -4662410708751199374LL,
  -947953254965186747LL,
  4386398306651350959LL,
  -694672904742573947LL,
  -6695622650541005056LL,
  8513311550241749682LL,
  5506446386574490598LL,
  -1630598867463726795LL,
  -3076107125294036646LL,
  -5511669496059679106LL,
  1795701080378382525LL,
  -2025681482128571132LL,
  5877668516262607274LL,
  -3976157495158103636LL,
  615937378094845009LL,
  -5668716993314381212LL,
  3791679676342426565LL,
  4743847784124955223LL,
  3939428438826997938LL,
  -6220277441748113576LL,
  380016710757123738LL,
  -4359327604211787242LL,
  8138182875361518595LL,
  5750736256044723814LL,
  1619983966589145066LL,
  -89109035140538446LL,
  -3632661006598255415LL,
  715413425090626948LL,
  9135518289989772581LL,
  -4521557999167881508LL,
  3364764793476385191LL,
  1508568848530349820LL,
  -3641285811521557415LL,
  2581819420077395771LL,
  6278762597119133640LL,
  3556184041718296984LL,
  5439958548908742630LL,
  7479012800218807592LL,
  7955047275508466584LL,
  4458066949235466665LL,
  -4041124216249100626LL,
  8679876237645706046LL,
  7090760345643478520LL,
  -8025828000478539123LL,
  -4477436573911586118LL,
  -2840135007662617374LL,
  -4971715647509176983LL,
  -3863924134756780409LL,
  -524549181872206535LL,
  4125754028215992048LL,
  8237728046923545536LL,
  -2612054165308809020LL,
  -8964330034419452495LL,
  -2266229662714450555LL,
  6361338485692057877LL,
  4650210388499741911LL,
  3177294050395039042LL,
  -5568021764705652015LL,
  -3669938271248897985LL,
  -6028948659090172173LL,
  8638306631721133406LL,
  -5071750542652522149LL,
  -1652446253101092921LL,
  -5381519347650540149LL,
  -285653507193267733LL,
  -8445752260973857570LL,
  -2720455621929071043LL,
  -4121326417431453559LL,
  -170301211412070624LL,
  -3425485123696764682LL,
  2673275801057568021LL,
  -7466014288139698089LL,
  714465189390498639LL,
  7710723724879456621LL,
  5953251749140717989LL,
  118077562892454633LL,
  6530344183011542391LL,
  4783103019933741530LL,
  8503129753748748176LL,
  1373327054916871614LL,
  6669491806629209052LL,
  4619390691939421970LL,
  5179515648996959200LL,
  -1291556912011696250LL,
  766338409476030181LL,
  6174714569872033076LL,
  -1078410408048643702LL,
  -2326506118595224074LL,
  -8006877427911128498LL,
  6237193887174943905LL,
  7900288714350616477LL,
  5028236635819917577LL,
  -3505089082802326551LL,
  1275793776340190361LL,
  -4849307597447939668LL,
  318366277531347168LL,
  3197935369052220685LL,
  -6266517193172904432LL,
  2504132107801706035LL,
  2093311415691930214LL,
  6922968032991936927LL,
  -6519580264241886151LL,
  6498538161365680020LL,
  5317923361881221976LL,
  1984350716132981565LL,
  -1332339419223824805LL,
  2972873668403553411LL,
  6222876120405539532LL,
  -4662125851921747227LL,
  -6547561928497763977LL,
  4978466172617045902LL,
  5472336470505433178LL,
  7507908464930718658LL,
  4578519326550553428LL,
  -1350511915330098295LL,
  -7470350728563160309LL,
  -5289510981398857861LL,
  5837651449315757829LL,
  3522472294424637525LL,
  -5075501671810809418LL,
  -50171520194054959LL,
  1479883141297090646LL,
  -6212319506764587930LL,
  5420445628202743048LL,
  -7715740849998639631LL,
  -8087757431827137962LL,
  -4308510599342458364LL,
  -8285638770534610761LL,
  5221210355222047774LL,
  -5129820439450634734LL,
  -5451882872599916952LL,
  449688148965171360LL,
  -1034270677327131532LL,
  -8283366839915177643LL,
  8790836677585569327LL,
  -4108072330736708721LL,
  -8810793180751384121LL,
  -8180814649421466956LL,
  6215699239099148302LL,
  6957179226869499802LL,
  8451901963419586670LL,
  -5776683067777219210LL,
  -1720646390650524967LL,
  -2382788985240274674LL,
  -5344346321908207426LL,
  -7029296792233062029LL,
  -5087106347754395272LL,
  8245110187859509816LL,
  7339993977514879941LL,
  -8317348890868743369LL,
  3659997764317471742LL,
  4691598600072034734LL,
  8284964964162430336LL,
  -8879920868203878989LL,
  4189915749727266302LL,
  5308965371519461459LL,
  2054797008891295341LL,
  -319650149512998887LL,
  4299196883765669209LL,
  -6619137023697801572LL,
  4366869471967700896LL,
  -3546636857430334603LL,
  5151825020866902336LL,
  -5595287622004427833LL,
  -3482375302139240969LL,
  -2116609725698177208LL,
  5025013570029662271LL,
  -7172639223957230800LL,
  1053939472501839694LL,
  4221769898647927732LL,
  4357920165500097666LL,
  7834076884326979563LL,
  4272063780046627846LL,
  4039116997058321770LL,
  -2727216782894280388LL,
  1348202375856620388LL,
  2301898783875571271LL,
  6460035136011136646LL,
  -7748983759756528363LL,
  -8689414339246627803LL,
  4584246636790019109LL,
  6885835975334039940LL,
  6249906805861885349LL,
  1725716591743982184LL,
  -6792382586035478995LL,
  -8561921580254818383LL,
  -5458832138150299448LL,
  4902101741859337225LL,
  -96324132248875647LL,
  -3048186007714207786LL,
  -2718787369210832064LL,
  -8671051473484333247LL,
  5118530954824848124LL,
  941859248514608678LL,
  6746433271605450562LL,
  2114129833224464615LL,
  -5900265339832101396LL,
  6395367805235268478LL,
  6351512176232662553LL,
  -6773795135019744219LL,
  -3300035179055311257LL,
  -5734986233923019765LL,
  -8052777049420916502LL,
  1079482412171585708LL,
  1660095950523830107LL,
  4570275898977334110LL,
  -8462406929980588204LL,
  8352020334175620458LL,
  7268817811428017472LL,
  -8260539626125538631LL,
  -1318783296510329730LL,
  -1849045667302279635LL,
  7425334241403613730LL,
  4771374893546118783LL,
  3442128010744075328LL,
  -8419323731279002594LL,
  -6363668833490549255LL,
  588527856080217357LL,
  305227581199019801LL,
  9136966043892137413LL,
  -2278804171854968181LL,
  -9084898579078807092LL,
  8878612434848834319LL,
  -2386595063698322272LL,
  -527549910298244324LL,
  6639113234980662253LL,
  -368423895764240520LL,
  -2900415605637597803LL,
  -4900412317268913386LL,
  -4246800295677146288LL,
  -7816390267356590083LL,
  -302045669661596972LL,
  1197376723885704574LL,
  -2216617767736929576LL,
  -4567633858154319246LL,
  227176813662154075LL,
  -6187464087009419577LL,
  -2010710217563102842LL,
  5277417808893919132LL,
  -3039320223568706266LL,
  -3505726730734280764LL,
  5674047306833804966LL,
  7851051224316364461LL,
  -9021178261541977440LL,
  2943367180561279421LL,
  8105073495705153153LL,
  -291197500659974400LL,
  5697406480502376064LL,
  5877477751337405235LL,
  -1877512547642739308LL,
  -2908859824909079193LL,
  -7989207532104128143LL,
  2223801759201342324LL,
  -4130535894309751748LL,
  -2809397587028191039LL,
  4608566767287318283LL,
  -2873602019459163512LL,
  6547935807155622982LL,
  2358717164769637863LL,
  -1831766156507992882LL,
  -9222738573106816221LL,
  -7731822386500942283LL,
  8671288339249264200LL,
  5608869571866323513LL,
  -2425096370600928448LL,
  7977466863429629561LL,
  -8098333501427963750LL,
  7242289474995514715LL,
  1567169508226279381LL,
  -4586964198220999807LL,
  -6917354203955265500LL,
  -6034243558253485859LL,
  -1093066196934510403LL,
  1025395215826879256LL,
  1615699621365775136LL,
  4321995075701125085LL,
  7179077730157579846LL,
  -6908299121810349261LL,
  4448248277864616299LL,
  8394522697799974727LL,
  7265749836394272542LL,
  562550948483866244LL,
  8433249156541039618LL,
  -5705748218464851718LL,
  6288290551140793701LL,
  -638664576154067418LL,
  5018038877509214997LL,
  18911087437259851LL,
  -1491224301292480121LL,
  7864500398214309565LL,
  975518652973548277LL,
  -644707024441647508LL,
  622187558004557147LL,
  -3128242422379220470LL,
  5598898530851347884LL,
  -3424015153229103804LL,
  7970622010814221179LL,
  -7979253799909259246LL,
  1251993471097504428LL,
  6584765995150877185LL,
  -5671645296507245777LL,
  -8918119472441484173LL,
  6791359573957131238LL,
  8524739724542477550LL,
  5391013523391169218LL,
  -1902378879454495217LL,
  5551858142341314141LL,
  -5296049346219222612LL,
  7884679690313721309LL,
  -4800704299191909797LL,
  -2935508846959076223LL,
  -4138335538995518567LL,
  -1552703094387976148LL,
  -821378450679798352LL,
  -2791034803126633808LL,
  -7318852677545941727LL,
  -8103330200540858616LL,
  92947107LL
}; // weak
_UNKNOWN terminator_0; // weak
_UNKNOWN unk_46E9A0; // weak
__int64 (__fastcall *_init_array_start[6])() =
{
  &init_have_lse_atomics,
  &init_have_sme,
  &frame_dummy,
  &IO_stdfiles_init,
  &_do_global_dtors_aux,
  &release_registered_frames
}; // weak
__int64 (__fastcall *_do_global_dtors_aux_fini_array_entry[2])() = { &_do_global_dtors_aux, &release_registered_frames }; // weak
char *cpu_list = "thunderxt88"; // weak
_UNKNOWN *_wcsmbs_gconv_fcts_c = &to_wc; // weak
char *rfv_0 = "LINUX_2.6.39"; // weak
_UNKNOWN _gettext_germanic_plural; // weak
char *sys_errlist_internal[41] =
{
  "Success",
  "Operation not permitted",
  "No such file or directory",
  "No such process",
  "Interrupted system call",
  "Input/output error",
  "No such device or address",
  "Argument list too long",
  "Exec format error",
  "Bad file descriptor",
  "No child processes",
  "Resource temporarily unavailable",
  "Cannot allocate memory",
  "Permission denied",
  "Bad address",
  "Block device required",
  "Device or resource busy",
  "File exists",
  "Invalid cross-device link",
  "No such device",
  "Not a directory",
  "Is a directory",
  "Invalid argument",
  "Too many open files in system",
  "Too many open files",
  "Inappropriate ioctl for device",
  "Text file busy",
  "File too large",
  "No space left on device",
  "Illegal seek",
  "Read-only file system",
  "Too many links",
  "Broken pipe",
  "Numerical argument out of domain",
  "Numerical result out of range",
  "Resource deadlock avoided",
  "File name too long",
  "No locks available",
  "Function not implemented",
  "Directory not empty",
  "Too many levels of symbolic links"
}; // weak
char *nl_C_LC_CTYPE = "C"; // weak
_UNKNOWN unk_48D000; // weak
char *nl_C_LC_NUMERIC = "C"; // weak
__int64 _stack_chk_guard = 0LL; // weak
__int64 _pointer_chk_guard_local = 0LL; // weak
_UNKNOWN _io_vtables; // weak
_UNKNOWN IO_file_jumps; // weak
_UNKNOWN unk_48DE58; // weak
_UNKNOWN unk_48DF00; // weak
_UNKNOWN IO_wfile_jumps; // weak
_UNKNOWN unk_48E050; // weak
_UNKNOWN unk_48E0F8; // weak
_UNKNOWN unk_48E440; // weak
_UNKNOWN *_rtld_env_path_list = NULL; // weak
int dword_48E668 = 0; // weak
__int64 _rtld_search_dirs = 0LL; // weak
int dword_48E678 = 0; // weak
__int64 dl_tls_initial_modid_limit = 0LL; // weak
char tunable_list[22] = "glibc.cpu.aarch64_gcs"; // weak
_UNKNOWN unk_48EBF1; // weak
_UNKNOWN unk_48F000; // weak
int rseq_size = 0; // weak
__int64 *rseq_offset[6] = { NULL, NULL, NULL, NULL, NULL, NULL }; // weak
_UNKNOWN *dl_random = NULL; // weak
__int64 (*dl_vdso_clock_gettime64)(void) = NULL; // weak
__int64 dl_vdso_gettimeofday = 0LL; // weak
__int64 dl_vdso_clock_getres_time64 = 0LL; // weak
__int64 (__fastcall *dl_vdso_getrandom)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD) = NULL; // weak
__int64 _libc_stack_end = 0LL; // weak
char *map = "=INTERNAL->ucs4"; // weak
_QWORD nl_current_used[14] = { 2LL, 2LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL, 0LL }; // weak
__int64 (__fastcall *nl_category_postload[14])() =
{
  &nl_postload_ctype,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL,
  NULL
}; // weak
char **nl_C_locobj[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
char **nl_C[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
_UNKNOWN *dlfo_nodelete_mappings = NULL; // weak
__int64 dlfo_nodelete_mappings_size = 0LL; // weak
__int128 dlfo_main = 0LL; // weak
__int128 xmmword_48FBA8 = 0LL; // weak
__int64 dlfo_nodelete_mappings_end = 0LL; // weak
__int64 (__fastcall *dlfcn_hook[13])() =
{
  &_dlopen,
  &dlclose,
  &_dlsym,
  &_dlvsym,
  &dlerror,
  &dladdr,
  &dladdr1,
  &dlinfo,
  &_dlmopen,
  &_libc_dlopen_mode,
  &_libc_dlsym,
  &_libc_dlvsym,
  &_libc_dlclose
}; // weak
__int64 (__fastcall *off_490000[5])() = { &memmove, &memcpy, &memchr, &memset, &strlen }; // weak
_UNKNOWN *_exit_funcs = &initial; // weak
__int64 *IO_list_all = &IO_2_1_stderr_; // weak
__int64 IO_2_1_stderr_ = 4222427270LL; // weak
int IO_2_1_stdout_ = -72540028; // weak
_UNKNOWN IO_2_1_stdin_; // weak
__int64 *stderr = &IO_2_1_stderr_; // weak
int *stdout = &IO_2_1_stdout_; // weak
_UNKNOWN *stdin = &IO_2_1_stdin_; // weak
__int64 mp_ = 131072LL; // weak
__int64 qword_4905E0 = 131072LL; // weak
__int64 qword_4905E8 = 131072LL; // weak
__int64 qword_4905F0 = 8LL; // weak
__int64 qword_4905F8 = 0LL; // weak
__int64 qword_490600 = 0LL; // weak
__int64 qword_490608 = 0LL; // weak
int dword_490610 = 0; // weak
int dword_490614 = 0; // weak
int dword_490618 = 65536; // weak
int dword_49061C = 0; // weak
int dword_490620 = 0; // weak
__int64 qword_490628 = 0LL; // weak
__int64 qword_490630 = 0LL; // weak
__int64 qword_490638 = 0LL; // weak
__int64 qword_490640 = 64LL; // weak
_UNKNOWN unk_490648; // weak
__int64 qword_490650 = 7LL; // weak
__int64 qword_490658 = 0LL; // weak
__int64 narenas = 1LL; // weak
int may_shrink_heap_12 = -1; // weak
int main_arena = 0; // weak
int dword_490674 = 0; // weak
int dword_490678 = 0; // weak
_UNKNOWN *off_4906D0 = NULL; // weak
_UNKNOWN unk_490EC0; // weak
int *off_490EE0 = &main_arena; // weak
__int64 qword_490EF8 = 0LL; // weak
char _libc_single_threaded = '\x01'; // weak
int prctl_supported_0 = 1; // weak
__int64 dl_pagesize = 65536LL; // weak
__int64 dl_minsigstacksize = 5120LL; // weak
__int64 dl_nns = 1LL; // weak
int dl_stack_flags = 6; // weak
int dl_load_tls_lock[12] = { 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dl_load_write_lock[12] = { 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dl_load_lock[12] = { 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0 }; // weak
int dl_debug_fd = 2; // weak
__int64 dl_load_adds = 1LL; // weak
__int64 dl_main_map = 0LL; // weak
__int64 qword_491000 = 0LL; // weak
__int64 qword_4912C0 = 0LL; // weak
__int16 word_4912D0 = 0; // weak
__int64 qword_491360 = 0LL; // weak
__int64 qword_491478 = 0LL; // weak
__int64 qword_491480 = 0LL; // weak
__int64 **dl_initial_searchlist = &_compound_literal_3; // weak
int dword_491498 = 1; // weak
__int64 *dl_ns = &dl_main_map; // weak
__int64 ***off_4914B8 = &off_4912D8; // weak
int dword_4914C0 = 0; // weak
int _libc_enable_secure = 1; // weak
_UNKNOWN *builtin_modules = (_UNKNOWN *)0x4571B0LL; // weak
_UNKNOWN unk_491818; // weak
char **nl_global_locale[6] =
{
  &nl_C_LC_CTYPE,
  &nl_C_LC_NUMERIC,
  &nl_C_LC_TIME,
  &nl_C_LC_COLLATE,
  &nl_C_LC_MONETARY,
  &nl_C_LC_MESSAGES
}; // weak
_UNKNOWN *off_491888 = &word_45EA40; // weak
_UNKNOWN *off_491890 = &dword_45DB40; // weak
_UNKNOWN *off_491898 = &dword_45E140; // weak
char *off_4918D0[8] = { "C", "C", "C", "C", "C", "C", "C", "messages" }; // weak
__int64 nl_current_default_domain = 4552872LL; // weak
int pa_next_type = 8; // weak
int _mutex_aconf = 100; // weak
int _sched_fifo_max_prio = -1; // weak
int _sched_fifo_min_prio = -1; // weak
__int64 *program_invocation_short_name[2] = { &qword_454610, &qword_454610 }; // weak
__int64 *program_invocation_name = &qword_454610; // weak
__int64 _nptl_stack_cache_maxsize = 41943040LL; // weak
int _nptl_stack_hugetlb = 1; // weak
_UNKNOWN _TMC_END__; // weak
char _bss_start; // weak
object object_0; // weak
char plc; // weak
__int64 qword_491D8A[8]; // weak
__int64 static_slotinfo; // weak
__int64 qword_491DF8; // weak
_UNKNOWN unk_492000; // weak
__int64 dl_tls_max_dtv_idx; // weak
__int64 dl_tls_dtv_slotinfo_list; // weak
__int64 dl_tls_static_nelem; // weak
__int64 dl_tls_static_align; // weak
__int64 dl_tls_static_size; // weak
_UNKNOWN dl_static_dtv; // weak
_UNKNOWN unk_492218; // weak
__int64 dl_tls_generation; // weak
__int64 dl_tls_static_optional; // weak
__int64 dl_tls_static_surplus; // weak
__int64 dl_tls_static_used; // weak
char dl_tls_dtv_gaps; // weak
pthread_rwlock_t lock; // weak
__int64 _new_exitfn_called; // weak
_DWORD _exit_funcs_lock[2]; // weak
_DWORD _exit_lock; // weak
int dword_492A94; // weak
__int64 qword_492A98; // weak
char _exit_funcs_done; // weak
__int64 run_fp; // weak
__int64 list_all_lock; // weak
__int64 qword_492AB8; // weak
int stdio_needs_locking; // weak
char dealloc_buffers; // weak
__int64 freeres_list; // weak
__int64 _pthread_keys; // weak
_UNKNOWN unk_496000; // weak
int perturb_byte; // weak
char global_max_fast; // weak
char _malloc_initialized; // weak
__int64 tcache_key; // weak
char _always_fail_morecore; // weak
__int64 aligned_heap_area; // weak
__int64 free_list; // weak
int free_list_lock; // weak
__int64 narenas_limit_2; // weak
int list_lock; // weak
__int64 next_to_use_5; // weak
_UNKNOWN state; // weak
_UNKNOWN state_0; // weak
char **environ;
__int64 _curbrk; // weak
int r_debug_extended; // weak
__int64 qword_496B70; // weak
__int64 qword_496B78; // weak
__int64 qword_496B88; // weak
_UNKNOWN unk_496B90; // weak
__int64 max_dirnamelen; // weak
char _nptl_initial_report_events; // weak
__int64 rseq_align; // weak
__int64 cache; // weak
__int64 cachesize; // weak
__int64 cache_new; // weak
__int64 dl_auxv; // weak
__int64 dl_platform; // weak
__int64 dl_hwcap; // weak
__int64 dl_hwcap2; // weak
__int64 dl_hwcap3; // weak
__int64 dl_hwcap4; // weak
int dl_clktck; // weak
int dl_fpu_control; // weak
__int64 dl_sysinfo_dso; // weak
__int64 dl_phdr; // weak
__int64 dl_phnum; // weak
__int64 dl_debug_mask; // weak
__int64 dl_sysinfo_map; // weak
__int64 dl_verbose; // weak
__int64 dl_init_all_dirs; // weak
__int64 dl_all_dirs; // weak
int dl_lazy; // weak
int dl_bind_not; // weak
int dl_dynamic_weak; // weak
__int64 dl_platformlen; // weak
__int64 dl_scope_free_list; // weak
_DWORD dl_stack_cache_lock[2]; // weak
__int64 dl_in_flight_stack; // weak
__int64 dl_stack_cache_actsize; // weak
__int64 dl_stack_cache; // weak
__int64 qword_496C88; // weak
__int64 dl_stack_user; // weak
_BYTE algn_496C98[8]; // weak
__int64 dl_stack_used; // weak
_BYTE algn_496CA8[8]; // weak
int dl_dso_sort_algo; // weak
__int64 dl_initfirst; // weak
int dl_inhibit_cache; // weak
__int64 dl_aarch64_cpu_features; // weak
int dword_496CD0; // weak
char byte_496CD4; // weak
char byte_496CD5; // weak
char byte_496CD6; // weak
char byte_496CD7; // weak
char byte_496CD8; // weak
__int64 dl_aarch64_gcs; // weak
__int64 dl_origin_path; // weak
__int64 dl_inhibit_rpath; // weak
int _libc_argc; // weak
__int64 _libc_argv; // weak
__int64 _gconv_modules_db; // weak
__int64 _gconv_alias_db; // weak
__int64 known_derivations; // weak
_DWORD _gconv_lock[2]; // weak
__int64 _gconv_path_elem; // weak
__int64 _gconv_path_envvar; // weak
__int64 _gconv_max_path_elem_len; // weak
int modcounter_0; // weak
unsigned int once; // weak
__int64 gconv_cache; // weak
__int64 cache_size; // weak
int cache_malloced; // weak
__int64 loaded; // weak
unsigned int _libc_setlocale_lock[14]; // weak
int output_charset_cached_1; // weak
__int64 output_charset_cache_0; // weak
_DWORD lock_4[2]; // weak
__int64 freemem_3; // weak
__int64 freemem_size_2; // weak
__int64 transmem_list; // weak
unsigned int nl_state_lock[14]; // weak
pthread_rwlock_t tree_lock; // weak
__int64 root; // weak
__int64 nl_domain_bindings; // weak
pthread_rwlock_t lock_0; // weak
__int64 nl_loaded_domains; // weak
_DWORD lock_0_0; // weak
int dword_496EA4; // weak
__int64 qword_496EA8; // weak
int nl_msg_cat_cntr; // weak
__int64 nmap; // weak
__int64 maxmap; // weak
__int64 map_0; // weak
__int64 string_space_act; // weak
__int64 string_space_max; // weak
__int64 string_space; // weak
_DWORD lock_0[2]; // weak
__int64 locale_alias_path_1; // weak
__int64 _environ_counter; // weak
__int64 _environ_array_list; // weak
int state_size; // weak
int grnd_alloc; // weak
__int64 qword_496F18; // weak
__int64 qword_496F20; // weak
__int64 qword_496F28; // weak
__int64 qword_496F30; // weak
int state_size_cache_aligned; // weak
int mmap_flags; // weak
_UNKNOWN mmap_prot; // weak
_DWORD envlock[2]; // weak
__int64 known_values; // weak
int next_bit; // weak
_DWORD lock_1; // weak
__int64 _printf_modifier_table; // weak
__int64 lock_2; // weak
__int64 _printf_function_table; // weak
__int64 _printf_arginfo_table; // weak
_DWORD lock_3[2]; // weak
__int64 _printf_va_arg_table; // weak
__int64 _fork_generation; // weak
__int64 qword_496FB0; // weak
__int64 qword_496FC0; // weak
_QWORD nl_locale_file_list[2]; // weak
_UNKNOWN unk_497000; // weak
__int64 archloaded; // weak
__int64 archmapped; // weak
__int64 headmap; // weak
int dword_497064; // weak
_UNKNOWN archive_stat; // weak
__int64 qword_4970A0; // weak
int dl_close_state_2; // weak
__int64 dlfo_loaded_mappings[]; // weak
__int64 qword_497108; // weak
__int64 dlfo_loaded_mappings_version; // weak
bool _aarch64_have_lse_atomics; // idb
unsigned __int8 dwarf_reg_size_table[98]; // idb
__gthread_once_t once_regsizes_0; // idb
__gthread_mutex_t version_lock_mutex; // idb
__gthread_cond_t version_lock_cond; // idb
btree registered_objects; // idb
btree registered_frames; // idb
bool in_shutdown; // idb
__gthread_mutex_t object_mutex; // idb
bool _aarch64_have_sme; // idb
__int64 static_TP; // weak
__int64 qword_497268; // weak
__thread int nl_current_LC_CTYPE = 4790304; // weak


//----- (0000000000400268) ----------------------------------------------------
__int64 init_proc()
{
  return call_weak_fn();
}

//----- (0000000000400280) ----------------------------------------------------
// attributes: thunk
long double (__fastcall *j_memmove())(__int64 a1, __int64 a2, unsigned __int64 a3, long double result)
{
  return memmove();
}
// 490000: using guessed type __int64 (__fastcall *off_490000[5])();

//----- (0000000000400290) ----------------------------------------------------
// attributes: thunk
__int64 (__fastcall *j_memcpy())(__int64 result, __int64 *a2, unsigned __int64 a3)
{
  return memcpy();
}

//----- (00000000004002A0) ----------------------------------------------------
// attributes: thunk
unsigned __int64 (__fastcall *memchr())(__int64 a1, unsigned int a2, unsigned __int64 a3)
{
  return memchr();
}

//----- (00000000004002B0) ----------------------------------------------------
// attributes: thunk
int8x16_t *(__fastcall *memset())(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3)
{
  return memset();
}

//----- (00000000004002C0) ----------------------------------------------------
// attributes: thunk
unsigned __int64 (__fastcall *strlen())(__int64 a1)
{
  return strlen();
}

//----- (0000000000400300) ----------------------------------------------------
void __noreturn abort()
{
  int8x16_t *(__fastcall *v0)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  void *v1; // x1
  __int64 v2; // x2
  void *v3; // x3
  void *v4; // x4
  void *v5; // x5
  void *v6; // x6
  int v7; // w0
  sigset_t v8; // [xsp+10h] [xbp+10h] BYREF

  raise(6u);
  _abort_lock_wrlock(0LL);
  v0 = memset();
  v8.__val[2] = -1LL;
  _libc_sigaction(6, v0, 0LL);
  _pthread_raise_internal((void *)6, v1, v2, v3, v4, v5, v6);
  v8.__val[0] = 32LL;
  v7 = linux_eabi_syscall(__NR_rt_sigprocmask, 1, &v8, 0LL);
  __break(0x3E8u);
  exit(127);
}
// 400344: variable 'v1' is possibly undefined
// 400344: variable 'v2' is possibly undefined
// 400344: variable 'v3' is possibly undefined
// 400344: variable 'v4' is possibly undefined
// 400344: variable 'v5' is possibly undefined
// 400344: variable 'v6' is possibly undefined

//----- (0000000000400374) ----------------------------------------------------
void __noreturn dl_start()
{
  abort();
}

//----- (0000000000400380) ----------------------------------------------------
void __fastcall btree_release_tree_recursively(btree *t, btree_node *node)
{
  node_type type; // w20
  btree_node **v5; // x0
  uintptr_type v6; // x20
  uintptr_type v7; // x0
  bool v8; // zf

  version_lock_lock_exclusive(&node->version_lock);
  type = node->type;
  if ( type == node_type::btree_node_inner && node->entry_count )
  {
    do
    {
      v5 = (btree_node **)node + 2 * (unsigned int)type++;
      btree_release_tree_recursively(t, v5[3]);
    }
    while ( node->entry_count > type );
  }
  node->type = node_type::btree_node_free;
  v6 = atomic_load((unsigned __int64 *)&t->free_list);
  do
  {
    node->content.entries[0].size = v6;
    _aarch64_cas8_acq_rel();
    v8 = v7 == v6;
    v6 = v7;
  }
  while ( !v8 );
  version_lock_unlock_exclusive(&node->version_lock);
}
// 4003F4: variable 'v7' is possibly undefined

//----- (0000000000400420) ----------------------------------------------------
void __fastcall btree_destroy(btree *t)
{
  btree_node *v2; // x0
  double v3; // d0
  double v4; // d1
  double v5; // d2
  double v6; // d3
  double v7; // d4
  double v8; // d5
  double v9; // d6
  double v10; // d7
  btree_node *i; // x19
  unsigned __int64 v12; // x0

  _aarch64_swp8_acq_rel();
  if ( v2 )
    btree_release_tree_recursively(t, v2);
  for ( i = t->free_list; i; t->free_list = i )
  {
    v12 = (unsigned __int64)i;
    i = i->content.children[0].child;
    free(v12, v3, v4, v5, v6, v7, v8, v9, v10);
  }
}
// 40043C: variable 'v2' is possibly undefined
// 400450: variable 'v3' is possibly undefined
// 400450: variable 'v4' is possibly undefined
// 400450: variable 'v5' is possibly undefined
// 400450: variable 'v6' is possibly undefined
// 400450: variable 'v7' is possibly undefined
// 400450: variable 'v8' is possibly undefined
// 400450: variable 'v9' is possibly undefined
// 400450: variable 'v10' is possibly undefined

//----- (0000000000400480) ----------------------------------------------------
void __cdecl release_registered_frames()
{
  btree_destroy(&registered_frames);
  btree_destroy(&registered_objects);
  in_shutdown = 1;
}

//----- (00000000004004C0) ----------------------------------------------------
__int64 *IO_stdfiles_init()
{
  __int64 *result; // x0
  __int64 **v1; // x1

  result = IO_list_all;
  if ( IO_list_all )
  {
    v1 = &IO_list_all;
    do
    {
      result[23] = (__int64)v1;
      v1 = (__int64 **)(result + 13);
      result = (__int64 *)result[13];
    }
    while ( result );
  }
  return result;
}
// 490058: using guessed type __int64 *IO_list_all;

//----- (0000000000400500) ----------------------------------------------------
void __cdecl init_have_lse_atomics()
{
  _aarch64_have_lse_atomics = ((unsigned __int16)getauxval(16LL) >> 8) & 1;
}

//----- (0000000000400540) ----------------------------------------------------
void __cdecl init_have_sme()
{
  _aarch64_have_sme = (getauxval(26LL) & 0x800000) != 0;
}

//----- (0000000000400580) ----------------------------------------------------
void __fastcall __noreturn start(
        void (*a1)(void *),
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9,
        __int64 a10)
{
  _libc_start_main_impl(
    (__int64 (__fastcall *)(_QWORD, __int64, char **))_wrap_main,
    a9,
    &a10,
    0LL,
    0LL,
    a1,
    (__int64)&a9);
}

//----- (00000000004005B4) ----------------------------------------------------
__int64 __fastcall _wrap_main(int argc, const char **argv, const char **envp)
{
  return main(argc, argv, envp);
}

//----- (00000000004005C4) ----------------------------------------------------
__int64 call_weak_fn()
{
  return 0LL;
}

//----- (00000000004005E0) ----------------------------------------------------
void *deregister_tm_clones()
{
  return &_TMC_END__;
}

//----- (0000000000400610) ----------------------------------------------------
void *register_tm_clones()
{
  return &_TMC_END__;
}

//----- (000000000040064C) ----------------------------------------------------
__int64 _do_global_dtors_aux()
{
  __int64 result; // x0

  result = (unsigned __int8)_bss_start;
  if ( (_bss_start & 1) == 0 )
  {
    deregister_tm_clones();
    if ( _deregister_frame_info )
      _deregister_frame_info(&unk_46E9A0);
    result = 1LL;
    _bss_start = 1;
  }
  return result;
}
// 491950: using guessed type char _bss_start;

//----- (00000000004006A0) ----------------------------------------------------
void *frame_dummy()
{
  if ( _register_frame_info )
    _register_frame_info(&unk_46E9A0, &object_0);
  return register_tm_clones();
}
// 491958: using guessed type object object_0;

//----- (00000000004006D4) ----------------------------------------------------
__int64 print_banner()
{
  puts((unsigned __int64)"       _  _ ___ _____ ___ ___ _   _ ___ ");
  puts((unsigned __int64)"      | \\| |_ _|_   _| __| _ ) | | / __|");
  puts((unsigned __int64)"      | .` || |  | | | _|| _ \\ |_| \\__ \\");
  puts((unsigned __int64)"      |_|\\_|___| |_| |___|___/\\___/|___/");
  return puts((unsigned __int64)"                                        ");
}

//----- (0000000000400724) ----------------------------------------------------
__int64 init_plc()
{
  plc = 1;
  memset();
  memset();
  strcpy((char *)qword_491D8A, "PLC-001-FACTORY-MAIN");
  puts((unsigned __int64)"[+] PLC initialized successfully");
  printf((__int64)"[+] Device ID: %s\n", (const char *)qword_491D8A);
  return puts((unsigned __int64)"[+] nitebus slave address: 0x01\n");
}
// 491988: using guessed type char plc;
// 491D8A: using guessed type __int64 qword_491D8A[8];

//----- (00000000004007C4) ----------------------------------------------------
__int64 __fastcall handle_diagnostics(__int64 a1)
{
  double v1; // d0
  double v2; // d1
  double v3; // d2
  double v4; // d3
  double v5; // d4
  double v6; // d5
  double v7; // d6
  double v8; // d7

  printf((__int64)"[DIAGNOSTICS] ");
  printf(a1);
  return putchar(0xAu, v1, v2, v3, v4, v5, v6, v7, v8);
}
// 4007E8: variable 'v1' is possibly undefined
// 4007E8: variable 'v2' is possibly undefined
// 4007E8: variable 'v3' is possibly undefined
// 4007E8: variable 'v4' is possibly undefined
// 4007E8: variable 'v5' is possibly undefined
// 4007E8: variable 'v6' is possibly undefined
// 4007E8: variable 'v7' is possibly undefined
// 4007E8: variable 'v8' is possibly undefined

//----- (00000000004007F8) ----------------------------------------------------
__int64 __fastcall upload_control_program(__int64 a1)
{
  double v1; // d0
  double v2; // d1
  double v3; // d2
  double v4; // d3
  double v5; // d4
  double v6; // d5
  double v7; // d6
  double v8; // d7
  _BYTE v10[128]; // [xsp+20h] [xbp+20h] BYREF
  __int64 v11; // [xsp+A0h] [xbp+A0h]
  unsigned __int16 v12; // [xsp+AEh] [xbp+AEh]

  v12 = *(_WORD *)(a1 + 2);
  puts((unsigned __int64)"[*] Uploading control program...");
  printf((__int64)"[*] Program size from packet: %u bytes\n", v12);
  printf((__int64)"[*] Enter program data: ");
  fflush((__int64)stdout, v1, v2, v3, v4, v5, v6, v7, v8);
  v11 = read(0, v10, (void *)v12);
  if ( v11 < 0 )
    return puts((unsigned __int64)"[-] Error reading program data");
  printf((__int64)"[+] Control program received (%zd bytes)\n", v11);
  return puts((unsigned __int64)&unk_454078);
}
// 400848: variable 'v1' is possibly undefined
// 400848: variable 'v2' is possibly undefined
// 400848: variable 'v3' is possibly undefined
// 400848: variable 'v4' is possibly undefined
// 400848: variable 'v5' is possibly undefined
// 400848: variable 'v6' is possibly undefined
// 400848: variable 'v7' is possibly undefined
// 400848: variable 'v8' is possibly undefined
// 4905C0: using guessed type int *stdout;

//----- (00000000004008A8) ----------------------------------------------------
__int64 __fastcall parse_nitebus_packet(unsigned __int8 *a1, unsigned __int64 a2)
{
  int v3; // w0

  if ( a2 <= 3 )
    return puts((unsigned __int64)"[-] Error: Packet too small");
  printf((__int64)"\n[*] nitebus Packet Received (%zu bytes)\n", a2);
  printf((__int64)"[*] Slave ID: 0x%02X\n", *a1);
  printf((__int64)"[*] Function Code: 0x%02X\n", a1[1]);
  if ( *a1 != 1 && *a1 )
    return puts((unsigned __int64)"[-] Wrong slave ID");
  v3 = a1[1];
  if ( v3 == 66 )
  {
    puts((unsigned __int64)"[*] Function: Upload Control Program ");
    return upload_control_program((__int64)a1);
  }
  else
  {
    if ( a1[1] <= 0x42u )
    {
      if ( v3 == 8 )
      {
        puts((unsigned __int64)"[*] Function: Diagnostics");
        return handle_diagnostics((__int64)(a1 + 4));
      }
      if ( a1[1] <= 8u )
      {
        if ( v3 == 6 )
        {
          puts((unsigned __int64)"[*] Function: Write Single Register");
          return puts((unsigned __int64)"[+] Register updated");
        }
        if ( a1[1] <= 6u )
        {
          if ( v3 == 1 )
          {
            puts((unsigned __int64)"[*] Function: Read Coils");
            return puts((unsigned __int64)"[+] Returning coil states");
          }
          if ( v3 == 3 )
          {
            puts((unsigned __int64)"[*] Function: Read Holding Registers");
            return puts((unsigned __int64)"[+] Returning register values");
          }
        }
      }
    }
    return printf((__int64)"[-] Error: Unsupported function code 0x%02X\n", a1[1]);
  }
}

//----- (0000000000400A44) ----------------------------------------------------
__int64 nitebus_server()
{
  unsigned __int8 v1[1032]; // [xsp+10h] [xbp+10h] BYREF
  signed __int64 v2; // [xsp+418h] [xbp+418h]

  puts((unsigned __int64)"[*] nitebus server listening...");
  puts((unsigned __int64)"[*] Supported function codes:");
  puts((unsigned __int64)"    0x01 - Read Coils");
  puts((unsigned __int64)"    0x03 - Read Holding Registers");
  puts((unsigned __int64)"    0x06 - Write Single Register");
  puts((unsigned __int64)"    0x08 - Diagnostics");
  puts((unsigned __int64)"    0x42 - Upload Control Program\n");
  while ( 1 )
  {
    puts((unsigned __int64)"[*] Waiting for nitebus packet...\n");
    v2 = read(0, v1, (void *)0x400);
    if ( v2 <= 0 )
      break;
    parse_nitebus_packet(v1, v2);
    puts((unsigned __int64)"\n[*] Transaction completed");
  }
  puts((unsigned __int64)"[-] Connection closed");
  return puts((unsigned __int64)"[*] PLC shutting down...");
}

//----- (0000000000400B1C) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  __int64 v3; // x0
  __int64 v4; // x0
  __int64 v5; // x0

  setvbuf(stdin, 0LL, 2LL, 0LL);
  setvbuf(stdout, 0LL, 2LL, 0LL);
  v3 = setvbuf(stderr, 0LL, 2LL, 0LL);
  v4 = print_banner(v3);
  init_plc(v4);
  v5 = puts("-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_\n");
  nitebus_server(v5);
  return 0;
}
// 4006D4: using guessed type __int64 __fastcall print_banner(_QWORD);
// 400724: using guessed type __int64 __fastcall init_plc(_QWORD);
// 400A44: using guessed type __int64 __fastcall nitebus_server(_QWORD);
// 406C60: using guessed type __int64 __fastcall puts(_QWORD);
// 406EE0: using guessed type __int64 __fastcall setvbuf(_QWORD, _QWORD, _QWORD, _QWORD);
// 4905B8: using guessed type __int64 *stderr;
// 4905C0: using guessed type int *stdout;
// 4905C8: using guessed type _UNKNOWN *stdin;

//----- (0000000000400BC0) ----------------------------------------------------
void call_fini()
{
  signed __int64 i; // x19

  for ( i = ((char *)&cpu_list - (char *)_do_global_dtors_aux_fini_array_entry) >> 3; i; --i )
    _do_global_dtors_aux_fini_array_entry[i - 1]();
  term_proc();
}
// 48C1C0: using guessed type __int64 (__fastcall *_do_global_dtors_aux_fini_array_entry[2])();
// 48C1D0: using guessed type char *cpu_list;

//----- (0000000000400C08) ----------------------------------------------------
__int64 prefer_sve_ifuncs()
{
  int v0; // w0
  unsigned int v1; // w1
  char *release; // x3
  int v3; // w4
  int v4; // w5
  int v5; // w2
  int v6; // w0
  int v7; // w0
  int v8; // t1
  struct utsname v11; // [xsp+18h] [xbp+18h] BYREF

  v0 = uname(&v11);
  v1 = 1;
  if ( (v0 & 0x80000000) == 0 )
  {
    release = v11.release;
    v3 = 16;
    v4 = 0;
    do
    {
      v5 = (unsigned __int8)*release;
      v6 = 0;
      if ( (unsigned __int8)(v5 - 48) <= 9u )
      {
        do
        {
          v7 = v5 + 10 * v6;
          v8 = (unsigned __int8)*++release;
          v5 = v8;
          v6 = v7 - 48;
        }
        while ( (unsigned __int8)(v8 - 48) <= 9u );
      }
      v4 |= (unsigned __int8)v6 << v3;
      if ( v5 != 46 )
        break;
      v3 -= 8;
      ++release;
    }
    while ( v3 != -8 );
    return (unsigned int)(v4 - 265984) > 0x1F2FF || v4 == 331264;
  }
  return v1;
}

//----- (0000000000400CC0) ----------------------------------------------------
void __fastcall __noreturn _libc_start_call_main(
        __int64 (__fastcall *a1)(_QWORD, __int64, char **),
        unsigned int a2,
        __int64 a3)
{
  double v3; // d0
  double v4; // d1
  double v5; // d2
  double v6; // d3
  double v7; // d4
  double v8; // d5
  double v9; // d6
  double v10; // d7
  unsigned __int64 StatusReg; // x0
  int8x16_t v12; // q31
  unsigned int v13; // w0
  int v14; // w0
  jmp_buf env; // [xsp+30h] [xbp+30h] BYREF

  if ( !setjmp(env) )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v12 = *(int8x16_t *)(StatusReg - 1576);
    *(_QWORD *)(StatusReg - 1824 + 0x100) = env;
    *(int8x16_t *)&env[0].__saved_mask.__val[14] = vextq_s8(v12, v12, 8uLL);
    v13 = a1(a2, a3, environ);
    exit(v13);
  }
  _nptl_deallocate_tsd(v3, v4, v5, v6, v7, v8, v9, v10);
  _aarch64_ldadd4_relax();
  if ( v14 != 1 )
  {
    while ( 1 )
    {
      linux_eabi_syscall(__NR_exit, 0);
      linux_eabi_syscall(__NR_exit, 0);
    }
  }
  exit(0);
}
// 400D1C: variable 'v3' is possibly undefined
// 400D1C: variable 'v4' is possibly undefined
// 400D1C: variable 'v5' is possibly undefined
// 400D1C: variable 'v6' is possibly undefined
// 400D1C: variable 'v7' is possibly undefined
// 400D1C: variable 'v8' is possibly undefined
// 400D1C: variable 'v9' is possibly undefined
// 400D1C: variable 'v10' is possibly undefined
// 400D34: variable 'v14' is possibly undefined

//----- (0000000000400D60) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
void __fastcall __noreturn _libc_start_main_impl(
        __int64 (__fastcall *a1)(_QWORD, __int64, char **),
        unsigned int a2,
        __int64 *a3,
        __int64 a4,
        __int64 a5,
        void (*a6)(void *),
        __int64 a7)
{
  char **v9; // x0
  __int64 v11; // x1
  __int64 v12; // x2
  __int64 v13; // x3
  __int64 v14; // x4
  __int64 v15; // x5
  __int64 v16; // x6
  __int64 v17; // x7
  int8x16_t **v18; // x28
  unsigned __int64 v19; // x27
  char **v20; // x26
  int v21; // w19
  _QWORD *v22; // x23
  char *StatusReg; // x0
  char v24; // w0
  __int64 v25; // x0
  __int64 v26; // x1
  __int64 (__fastcall ***v27)(); // x19
  double v28; // d0
  double v29; // d1
  double v30; // d2
  double v31; // d3
  double v32; // d4
  double v33; // d5
  double v34; // d6
  double v35; // d7
  __int64 (__fastcall **v36)(); // x28
  __int64 (__fastcall *v37)(unsigned __int64, char **); // x2
  char *v38; // x0
  __int64 *dl_main_map; // x19
  _QWORD *v40; // x2
  unsigned __int64 v41; // x3
  const char *v42; // x25
  unsigned __int64 v43; // x0
  int v44; // w1
  __int64 v45; // x3
  __int64 v46; // x4
  __int64 v47; // x5
  void *v48; // x6
  __int64 v49; // x7
  double v50; // d0
  double v51; // d1
  double v52; // d2
  double v53; // d3
  double v54; // d4
  double v55; // d5
  double v56; // d6
  double v57; // d7
  __int64 v58; // x1
  void *v59; // x2
  __int64 v60; // x3
  __int64 v61; // x4
  __int64 v62; // x5
  __int64 v63; // x6
  __int64 v64; // x7
  char **v65; // x22
  unsigned __int64 v66; // x19
  __int64 (__fastcall *v67)(); // x3
  char v68; // [xsp+0h] [xbp+0h]
  char *v71[3]; // [xsp+78h] [xbp+78h] BYREF

  v9 = (char **)&a3[(int)a2 + 1];
  _libc_stack_end = a7;
  environ = v9;
  while ( *v9++ )
    ;
  dl_aux_init((__int64)v9);
  _tunables_init(environ, v11, v12, v13, v14, v15, v16, v17, v68);
  _tunable_get_val(1LL, v71, 0LL);
  v18 = (int8x16_t **)v71[0];
  if ( !v71[0] )
    goto LABEL_7;
  v19 = *((_QWORD *)v71[0] + 1);
  v20 = &cpu_list;
  v21 = 0;
  while ( v20[1] != (char *)v19 || (unsigned int)memcmp(*v18, (int8x16_t *)*v20, v19) )
  {
    ++v21;
    v20 += 3;
    if ( v21 == 8 )
      goto LABEL_7;
  }
  StatusReg = (&cpu_list)[3 * v21 + 2];
  if ( StatusReg == (char *)-1LL )
  {
LABEL_7:
    v22 = &unk_496000;
    StatusReg = (char *)(dl_hwcap & 0x800);
    if ( (dl_hwcap & 0x800) != 0 )
      StatusReg = (char *)_ReadStatusReg(ARM64_SYSREG(3, 0, 0, 0, 0));
  }
  else
  {
    v22 = (_QWORD *)&unk_496000;
  }
  dl_aarch64_cpu_features = (__int64)StatusReg;
  v24 = _ReadStatusReg(ARM64_SYSREG(3, 3, 0, 0, 7));
  if ( (v24 & 0x10) == 0 )
    dword_496CD0 = 4 << (v24 & 0xF);
  v25 = dl_hwcap2;
  byte_496CD5 = 0;
  byte_496CD4 = (dl_hwcap2 & 0x20000) != 0;
  v26 = v22[380];
  byte_496CD6 = (v26 & 0x400000) != 0;
  byte_496CD7 = (v26 & 0x400000) != 0;
  if ( (v26 & 0x400000) != 0 )
  {
    byte_496CD7 = prefer_sve_ifuncs();
    v26 = v22[380];
    v25 = dl_hwcap2;
  }
  byte_496CD8 = (v25 & 0x80000000000LL) != 0;
  if ( (v26 & 0x100000000LL) != 0 )
  {
    _tunable_get_val(0LL, v71, 0LL);
    dl_aarch64_gcs = (__int64)v71[0];
  }
  v27 = &off_4001F0;
  dl_relocate_static_pie();
  if ( &off_4001F0 < (__int64 (__fastcall ***)())init_proc )
  {
    do
    {
      if ( *((_DWORD *)v27 + 2) != 1032LL )
        _libc_fatal((__int64)"Unexpected reloc type in static binary.\n", v28, v29, v30, v31, v32, v33, v34, v35);
      v36 = *v27;
      v27 += 3;
      v37 = (__int64 (__fastcall *)(unsigned __int64, char **))*(v27 - 1);
      v38 = (char *)v22[380];
      v71[0] = (char *)24;
      v71[1] = v38;
      v71[2] = (char *)dl_hwcap2;
      *v36 = (__int64 (__fastcall *)())v37((unsigned __int64)v38 | 0x4000000000000000LL, v71);
    }
    while ( v27 < (__int64 (__fastcall ***)())init_proc );
  }
  _libc_setup_tls();
  dl_main_map = dl_get_dl_main_map();
  v40 = (_QWORD *)dl_phdr;
  v41 = dl_phdr + 56 * dl_phnum;
  if ( v41 > dl_phdr )
  {
    while ( *(_DWORD *)v40 != 1685382483 )
    {
      v40 += 7;
      if ( v41 <= (unsigned __int64)v40 )
        goto LABEL_28;
    }
    dl_process_pt_gnu_property((__int64)dl_main_map, -1, v40);
    v42 = (const char *)program_invocation_short_name[0];
    dl_bti_check((__int64)dl_main_map, (const char *)program_invocation_short_name[0]);
    dl_gcs_check(dl_main_map, v42);
  }
LABEL_28:
  if ( dl_aarch64_gcs )
  {
    v43 = linux_eabi_syscall(__NR_prctl, 75, (void *)1, 0LL);
    if ( v43 > 0xFFFFFFFFFFFFF000LL )
    {
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)v43;
      v44 = -1;
    }
    else
    {
      v44 = v43;
      if ( !(_DWORD)v43 )
        goto LABEL_31;
    }
    dl_fatal_printf("failed to enable GCS: %d\n", -v44);
  }
LABEL_31:
  _stack_chk_guard = *(_QWORD *)dl_random & 0xFFFFFFFFFFFFFF00LL;
  _pointer_chk_guard_local = *((_QWORD *)dl_random + 1);
  if ( a6 )
    _cxa_atexit(a6, 0LL, 0LL);
  _libc_early_init(1u);
  _libc_init_first(a2, a3, environ, v50, v51, v52, v53, v54, v55, v56, v57, v45, v46, v47, v48, v49);
  _cxa_atexit((void (*)(void *))call_fini, 0LL, 0LL);
  if ( _libc_enable_secure )
    _libc_check_standard_fds((unsigned int)_libc_enable_secure, v58, v59, v60, v61, v62, v63, v64);
  v65 = environ;
  init_proc();
  if ( _do_global_dtors_aux_fini_array_entry != _init_array_start )
  {
    v66 = 0LL;
    do
    {
      v67 = _init_array_start[v66++];
      ((void (__fastcall *)(_QWORD, __int64 *, char **))v67)(a2, a3, v65);
    }
    while ( _do_global_dtors_aux_fini_array_entry - _init_array_start > v66 );
  }
  dl_debug_initialize(0LL, 0LL);
  _libc_start_call_main(a1, a2, (__int64)a3);
}
// 400D90: write access to const memory at 48F7C8 has been detected
// 400FE8: write access to const memory at 48DC50 has been detected
// 401008: write access to const memory at 48DC58 has been detected
// 400DB4: variable 'v11' is possibly undefined
// 400DB4: variable 'v12' is possibly undefined
// 400DB4: variable 'v13' is possibly undefined
// 400DB4: variable 'v14' is possibly undefined
// 400DB4: variable 'v15' is possibly undefined
// 400DB4: variable 'v16' is possibly undefined
// 400DB4: variable 'v17' is possibly undefined
// 400DB4: variable 'v68' is possibly undefined
// 400ED8: variable 'v28' is possibly undefined
// 400ED8: variable 'v29' is possibly undefined
// 400ED8: variable 'v30' is possibly undefined
// 400ED8: variable 'v31' is possibly undefined
// 400ED8: variable 'v32' is possibly undefined
// 400ED8: variable 'v33' is possibly undefined
// 400ED8: variable 'v34' is possibly undefined
// 400ED8: variable 'v35' is possibly undefined
// 401034: variable 'v50' is possibly undefined
// 401034: variable 'v51' is possibly undefined
// 401034: variable 'v52' is possibly undefined
// 401034: variable 'v53' is possibly undefined
// 401034: variable 'v54' is possibly undefined
// 401034: variable 'v55' is possibly undefined
// 401034: variable 'v56' is possibly undefined
// 401034: variable 'v57' is possibly undefined
// 401034: variable 'v45' is possibly undefined
// 401034: variable 'v46' is possibly undefined
// 401034: variable 'v47' is possibly undefined
// 401034: variable 'v48' is possibly undefined
// 401034: variable 'v49' is possibly undefined
// 401138: variable 'v58' is possibly undefined
// 401138: variable 'v59' is possibly undefined
// 401138: variable 'v60' is possibly undefined
// 401138: variable 'v61' is possibly undefined
// 401138: variable 'v62' is possibly undefined
// 401138: variable 'v63' is possibly undefined
// 401138: variable 'v64' is possibly undefined
// 4001F0: using guessed type __int64 (__fastcall **off_4001F0)();
// 4005C0: using guessed type __int64 dl_relocate_static_pie(void);
// 48C1A0: using guessed type __int64 (__fastcall *_init_array_start[6])();
// 48C1C0: using guessed type __int64 (__fastcall *_do_global_dtors_aux_fini_array_entry[2])();
// 48C1D0: using guessed type char *cpu_list;
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;
// 48F798: using guessed type _UNKNOWN *dl_random;
// 48F7C8: using guessed type __int64 _libc_stack_end;
// 491570: using guessed type int _libc_enable_secure;
// 491928: using guessed type __int64 *program_invocation_short_name[2];
// 496BE0: using guessed type __int64 dl_hwcap;
// 496BE8: using guessed type __int64 dl_hwcap2;
// 496C10: using guessed type __int64 dl_phdr;
// 496C18: using guessed type __int64 dl_phnum;
// 496CC8: using guessed type __int64 dl_aarch64_cpu_features;
// 496CD0: using guessed type int dword_496CD0;
// 496CD4: using guessed type char byte_496CD4;
// 496CD5: using guessed type char byte_496CD5;
// 496CD6: using guessed type char byte_496CD6;
// 496CD7: using guessed type char byte_496CD7;
// 496CD8: using guessed type char byte_496CD8;
// 496CE0: using guessed type __int64 dl_aarch64_gcs;

//----- (0000000000401180) ----------------------------------------------------
void **_libc_setup_tls()
{
  __int64 *v0; // x20
  unsigned __int64 v1; // x0
  unsigned __int64 v2; // x2
  __int128 v3; // q31
  __int64 v4; // x1
  __int64 v5; // x0
  __int64 v6; // x0
  void *v7; // x3
  void *v8; // x4
  void *v9; // x5
  void *v10; // x6
  unsigned __int64 v11; // x19
  __int64 v12; // x1
  __int64 v13; // x2
  __int64 v14; // x3
  void *v15; // x4
  void *v16; // x5
  void *v17; // x6
  __int64 v18; // x2
  __int64 v19; // x3
  __int64 v20; // x4
  void *v21; // x5
  void *v22; // x6
  double v23; // d0
  double v24; // d1
  double v25; // d2
  double v26; // d3
  double v27; // d4
  double v28; // d5
  double v29; // d6
  double v30; // d7
  ssize_t v32; // x0
  signed __int64 v33; // x0

  v0 = dl_ns;
  _tls_pre_init_tp();
  v1 = dl_phdr;
  v2 = dl_phdr + 56 * dl_phnum;
  if ( dl_phdr < v2 )
  {
    while ( *(_DWORD *)v1 != 7 )
    {
      v1 += 56LL;
      if ( v1 >= v2 )
        goto LABEL_6;
    }
    v3 = *(_OWORD *)(v1 + 32);
    v4 = *v0 + *(_QWORD *)(v1 + 16);
    v5 = *(_QWORD *)(v1 + 48);
    v0[141] = v4;
    v0[144] = v5;
    static_slotinfo = 64LL;
    v6 = 1LL;
    *((_OWORD *)v0 + 71) = v3;
    qword_491DF8 = (__int64)v0;
    v0[147] = 1LL;
    *((_BYTE *)v0 + 870) |= 0x80u;
    dl_tls_max_dtv_idx = 1LL;
    dl_tls_dtv_slotinfo_list = (__int64)&static_slotinfo;
  }
  else
  {
LABEL_6:
    v6 = dl_tls_max_dtv_idx;
  }
  dl_tls_static_nelem = v6;
  dl_tls_static_surplus_init(0LL);
  dl_determine_tlsoffset();
  v7 = dl_early_allocate(dl_tls_static_align + dl_tls_static_size + 1824);
  if ( !v7 )
  {
    v32 = linux_eabi_syscall(__NR_write, 2, "Fatal glibc error: Cannot allocate TLS block\n", 0x2DuLL);
    v33 = linux_eabi_syscall(
            __NR_exit_group,
            (void *)0x7F,
            "Fatal glibc error: Cannot allocate TLS block\n",
            (void *)0x2D,
            0LL,
            v8,
            v9,
            v10);
  }
  v11 = ((unsigned __int64)v7 + dl_tls_static_align + 1831) / dl_tls_static_align * dl_tls_static_align;
  memset();
  dl_static_dtv = 62LL;
  *(_QWORD *)v11 = &unk_492218;
  _WriteStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2), v11);
  _tls_init_tp(62LL, v12, v13, v14, v15, v16, v17);
  return dl_allocate_tls_init((void **)v11, 1u, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30);
}
// 4012E8: variable 'v8' is possibly undefined
// 4012E8: variable 'v9' is possibly undefined
// 4012E8: variable 'v10' is possibly undefined
// 4012B0: variable 'v12' is possibly undefined
// 4012B0: variable 'v13' is possibly undefined
// 4012B0: variable 'v14' is possibly undefined
// 4012B0: variable 'v15' is possibly undefined
// 4012B0: variable 'v16' is possibly undefined
// 4012B0: variable 'v17' is possibly undefined
// 4012C4: variable 'v18' is possibly undefined
// 4012C4: variable 'v19' is possibly undefined
// 4012C4: variable 'v20' is possibly undefined
// 4012C4: variable 'v21' is possibly undefined
// 4012C4: variable 'v22' is possibly undefined
// 4012C4: variable 'v23' is possibly undefined
// 4012C4: variable 'v24' is possibly undefined
// 4012C4: variable 'v25' is possibly undefined
// 4012C4: variable 'v26' is possibly undefined
// 4012C4: variable 'v27' is possibly undefined
// 4012C4: variable 'v28' is possibly undefined
// 4012C4: variable 'v29' is possibly undefined
// 4012C4: variable 'v30' is possibly undefined
// 4914A8: using guessed type __int64 *dl_ns;
// 491DD0: using guessed type __int64 static_slotinfo;
// 491DF8: using guessed type __int64 qword_491DF8;
// 4921E0: using guessed type __int64 dl_tls_max_dtv_idx;
// 4921E8: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 4921F0: using guessed type __int64 dl_tls_static_nelem;
// 4921F8: using guessed type __int64 dl_tls_static_align;
// 492200: using guessed type __int64 dl_tls_static_size;
// 496C10: using guessed type __int64 dl_phdr;
// 496C18: using guessed type __int64 dl_phnum;

//----- (00000000004012F0) ----------------------------------------------------
__int64 __fastcall _tls_get_addr(__int64 a1)
{
  return *(_QWORD *)(*(_QWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 16LL) + *(_QWORD *)(a1 + 8);
}

//----- (0000000000401340) ----------------------------------------------------
void setjmp()
{
  JUMPOUT(0x4013C4LL);
}
// 401348: control flows out of bounds to 4013C4

//----- (0000000000401380) ----------------------------------------------------
int setjmp(jmp_buf env)
{
  JUMPOUT(0x4013C4LL);
}
// 401388: control flows out of bounds to 4013C4

//----- (00000000004013C0) ----------------------------------------------------
__int64 __fastcall _sigsetjmp(
        __int64 a1,
        int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        __int64 a9)
{
  __int64 v9; // x19
  __int64 v10; // x20
  __int64 v11; // x21
  __int64 v12; // x22
  __int64 v13; // x23
  __int64 v14; // x24
  __int64 v15; // x25
  __int64 v16; // x26
  __int64 v17; // x27
  __int64 v18; // x28
  __int64 v19; // x29
  __int64 v20; // x30
  __int64 v21; // d8
  __int64 v22; // d9
  __int64 v23; // d10
  __int64 v24; // d11
  __int64 v25; // d12
  __int64 v26; // d13
  __int64 v27; // d14
  __int64 v28; // d15

  *(_QWORD *)a1 = v9;
  *(_QWORD *)(a1 + 8) = v10;
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(a1 + 24) = v12;
  *(_QWORD *)(a1 + 32) = v13;
  *(_QWORD *)(a1 + 40) = v14;
  *(_QWORD *)(a1 + 48) = v15;
  *(_QWORD *)(a1 + 56) = v16;
  *(_QWORD *)(a1 + 64) = v17;
  *(_QWORD *)(a1 + 72) = v18;
  *(_QWORD *)(a1 + 80) = v19;
  *(_QWORD *)(a1 + 88) = v20 ^ _pointer_chk_guard_local;
  *(_QWORD *)(a1 + 112) = v21;
  *(_QWORD *)(a1 + 120) = v22;
  *(_QWORD *)(a1 + 128) = v23;
  *(_QWORD *)(a1 + 136) = v24;
  *(_QWORD *)(a1 + 144) = v25;
  *(_QWORD *)(a1 + 152) = v26;
  *(_QWORD *)(a1 + 160) = v27;
  *(_QWORD *)(a1 + 168) = v28;
  __asm { HINT            #0x28 ; '(' }
  *(_QWORD *)(a1 + 104) = (unsigned __int64)&a9 ^ _pointer_chk_guard_local;
  return _sigjmp_save(a1, a2);
}
// 4013C4: variable 'v9' is possibly undefined
// 4013C4: variable 'v10' is possibly undefined
// 4013C8: variable 'v11' is possibly undefined
// 4013C8: variable 'v12' is possibly undefined
// 4013CC: variable 'v13' is possibly undefined
// 4013CC: variable 'v14' is possibly undefined
// 4013D0: variable 'v15' is possibly undefined
// 4013D0: variable 'v16' is possibly undefined
// 4013D4: variable 'v17' is possibly undefined
// 4013D4: variable 'v18' is possibly undefined
// 4013E4: variable 'v19' is possibly undefined
// 4013E0: variable 'v20' is possibly undefined
// 4013E8: variable 'v21' is possibly undefined
// 4013E8: variable 'v22' is possibly undefined
// 4013EC: variable 'v23' is possibly undefined
// 4013EC: variable 'v24' is possibly undefined
// 4013F0: variable 'v25' is possibly undefined
// 4013F0: variable 'v26' is possibly undefined
// 4013F4: variable 'v27' is possibly undefined
// 4013F4: variable 'v28' is possibly undefined
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000401440) ----------------------------------------------------
__int64 __fastcall _sigjmp_save(__int64 a1, int a2)
{
  __int64 result; // x0
  _BOOL4 v4; // w1

  if ( a2 )
  {
    v4 = sigprocmask(0, 0LL, (sigset_t *)(a1 + 184)) == 0;
    result = 0LL;
    *(_DWORD *)(a1 + 176) = v4;
  }
  else
  {
    result = 0LL;
    *(_DWORD *)(a1 + 176) = 0;
  }
  return result;
}

//----- (00000000004014A0) ----------------------------------------------------
__int64 __fastcall sigprocmask(int a1, const sigset_t *a2, sigset_t *a3)
{
  __int64 result; // x0

  result = pthread_sigmask(a1, a2, a3);
  if ( (_DWORD)result )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = result;
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (00000000004014E0) ----------------------------------------------------
__int64 _abort_fork_reset_child()
{
  return pthread_rwlock_init((__int64)&lock, 0LL);
}
// 492630: using guessed type pthread_rwlock_t lock;

//----- (00000000004014F0) ----------------------------------------------------
__int64 __fastcall _abort_lock_rdlock(sigset_t *a1)
{
  int v1; // w0

  v1 = linux_eabi_syscall(__NR_rt_sigprocmask, 0, (const sigset_t *)&sigall_set, a1);
  return pthread_rwlock_rdlock((unsigned int *)&lock);
}
// 492630: using guessed type pthread_rwlock_t lock;

//----- (0000000000401520) ----------------------------------------------------
__int64 __fastcall _abort_lock_wrlock(sigset_t *a1)
{
  int v1; // w0

  v1 = linux_eabi_syscall(__NR_rt_sigprocmask, 0, (const sigset_t *)&sigall_set, a1);
  return pthread_rwlock_wrlock(&lock);
}
// 492630: using guessed type pthread_rwlock_t lock;

//----- (0000000000401548) ----------------------------------------------------
int __fastcall _abort_lock_unlock(const sigset_t *a1)
{
  pthread_rwlock_unlock(&lock.__lock);
  return linux_eabi_syscall(__NR_rt_sigprocmask, 2, a1, 0LL);
}
// 492630: using guessed type pthread_rwlock_t lock;

//----- (00000000004015A0) ----------------------------------------------------
_QWORD *__fastcall _new_exitfn(
        int8x16_t *(__fastcall **a1)(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3),
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  int8x16_t *(__fastcall *v9)(int8x16_t *, unsigned __int8, unsigned __int64); // x6
  int8x16_t *(__fastcall *v10)(int8x16_t *, unsigned __int8, unsigned __int64); // x8
  int8x16_t *(__fastcall *v11)(int8x16_t *, unsigned __int8, unsigned __int64); // x5
  __int64 v12; // x1
  __int64 v13; // x4
  __int64 v14; // x2
  void *v15; // x3
  int8x16_t *(__fastcall *v16)(int8x16_t *, unsigned __int8, unsigned __int64); // x1
  _QWORD *result; // x0
  int8x16_t *(__fastcall *v18)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  int8x16_t *(__fastcall *v19)(int8x16_t *, unsigned __int8, unsigned __int64); // [xsp+10h] [xbp+10h]

  if ( (_exit_funcs_done & 1) != 0 )
    return 0LL;
  v9 = 0LL;
  v10 = *a1;
  v11 = *a1;
  if ( !*a1 )
    _libc_assert_fail((__int64)"l != NULL", (__int64)"cxa_atexit.c", 0x6Eu, (__int64)"__new_exitfn");
  while ( 1 )
  {
    v12 = *((_QWORD *)v11 + 1);
    v13 = (__int64)v11 + 16;
    if ( v12 )
      break;
LABEL_6:
    v16 = *(int8x16_t *(__fastcall **)(int8x16_t *, unsigned __int8, unsigned __int64))v11;
    *((_QWORD *)v11 + 1) = 0LL;
    v9 = v11;
    if ( !v16 )
      goto LABEL_14;
    v11 = v16;
  }
  while ( 1 )
  {
    v14 = v12 - 1;
    v15 = *(void **)(v13 + 32 * (v12 - 1));
    if ( v15 )
      break;
    --v12;
    if ( !v14 )
      goto LABEL_6;
  }
  if ( v12 != 32 )
  {
    result = (_QWORD *)((char *)v11 + 32 * v12 + 16);
    *((_QWORD *)v11 + 1) = v12 + 1;
LABEL_10:
    *result = 1LL;
    ++_new_exitfn_called;
    return result;
  }
  if ( v9 )
  {
    v11 = v9;
    goto LABEL_14;
  }
  v19 = v10;
  v18 = calloc(1uLL, 0x410uLL, v14, v15, a2, a3, a4, a5, a6, a7, a8, a9, v13, v11, 0LL, (__int64)a1);
  v11 = v18;
  if ( v18 )
  {
    *(_QWORD *)v18 = v19;
    *a1 = v18;
LABEL_14:
    result = (_QWORD *)((char *)v11 + 16);
    *((_QWORD *)v11 + 1) = 1LL;
    goto LABEL_10;
  }
  return 0LL;
}
// 492670: using guessed type __int64 _new_exitfn_called;
// 492AA0: using guessed type char _exit_funcs_done;

//----- (00000000004016C0) ----------------------------------------------------
__int64 __fastcall _internal_atexit(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        int8x16_t *(__fastcall **a4)(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3))
{
  __int64 v8; // x1
  __int64 v9; // x2
  __int64 v10; // x3
  void *v11; // x4
  void *v12; // x5
  void *v13; // x6
  double v14; // d0
  double v15; // d1
  double v16; // d2
  double v17; // d3
  double v18; // d4
  double v19; // d5
  double v20; // d6
  double v21; // d7
  int v22; // w0
  _QWORD *v23; // x0
  __int64 v24; // x1
  __int64 v25; // x2
  __int64 v26; // x3
  void *v27; // x4
  void *v28; // x5
  void *v29; // x6
  int v30; // w0
  __int64 v32; // x1
  __int64 v33; // x2
  __int64 v34; // x3
  void *v35; // x4
  void *v36; // x5
  void *v37; // x6
  int v38; // w0

  if ( !a1 )
    _libc_assert_fail((__int64)"func != NULL", (__int64)"cxa_atexit.c", 0x29u, (__int64)"__internal_atexit");
  _aarch64_cas4_acq();
  if ( v22 )
    _lll_lock_wait_private(_exit_funcs_lock, v14, v15, v16, v17, v18, v19, v20, v21, v8, v9, v10, v11, v12, v13);
  v23 = _new_exitfn(a4, v14, v15, v16, v17, v18, v19, v20, v21);
  if ( v23 )
  {
    v23[2] = a2;
    v23[3] = a3;
    *v23 = 4LL;
    v23[1] = a1 ^ _pointer_chk_guard_local;
    _aarch64_swp4_rel();
    if ( v30 > 1 )
      _lll_lock_wake_private(_exit_funcs_lock, v24, v25, v26, v27, v28, v29);
    return 0LL;
  }
  else
  {
    _aarch64_swp4_rel();
    if ( v38 > 1 )
      _lll_lock_wake_private(_exit_funcs_lock, v32, v33, v34, v35, v36, v37);
    return 0xFFFFFFFFLL;
  }
}
// 401700: variable 'v22' is possibly undefined
// 401768: variable 'v14' is possibly undefined
// 401768: variable 'v15' is possibly undefined
// 401768: variable 'v16' is possibly undefined
// 401768: variable 'v17' is possibly undefined
// 401768: variable 'v18' is possibly undefined
// 401768: variable 'v19' is possibly undefined
// 401768: variable 'v20' is possibly undefined
// 401768: variable 'v21' is possibly undefined
// 401768: variable 'v8' is possibly undefined
// 401768: variable 'v9' is possibly undefined
// 401768: variable 'v10' is possibly undefined
// 401768: variable 'v11' is possibly undefined
// 401768: variable 'v12' is possibly undefined
// 401768: variable 'v13' is possibly undefined
// 40173C: variable 'v30' is possibly undefined
// 40175C: variable 'v24' is possibly undefined
// 40175C: variable 'v25' is possibly undefined
// 40175C: variable 'v26' is possibly undefined
// 40175C: variable 'v27' is possibly undefined
// 40175C: variable 'v28' is possibly undefined
// 40175C: variable 'v29' is possibly undefined
// 401784: variable 'v38' is possibly undefined
// 401794: variable 'v32' is possibly undefined
// 401794: variable 'v33' is possibly undefined
// 401794: variable 'v34' is possibly undefined
// 401794: variable 'v35' is possibly undefined
// 401794: variable 'v36' is possibly undefined
// 401794: variable 'v37' is possibly undefined
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;
// 492678: using guessed type _DWORD _exit_funcs_lock[2];

//----- (00000000004017C0) ----------------------------------------------------
int _cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return _internal_atexit(
           (__int64)lpfunc,
           (__int64)obj,
           (__int64)lpdso_handle,
           (int8x16_t *(__fastcall **)(int8x16_t *, unsigned __int8, unsigned __int64))&_exit_funcs);
}
// 490048: using guessed type _UNKNOWN *_exit_funcs;

//----- (00000000004017E0) ----------------------------------------------------
void __fastcall __noreturn _run_exit_handlers(unsigned int a1, _QWORD **a2, unsigned __int8 a3)
{
  unsigned __int64 v3; // x19
  __int64 v6; // x1
  __int64 v7; // x2
  __int64 v8; // x3
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  int v20; // w0
  __int64 v21; // x1
  __int64 v22; // x2
  __int64 v23; // x3
  void *v24; // x4
  void *v25; // x5
  void *v26; // x6
  double v27; // d0
  double v28; // d1
  double v29; // d2
  double v30; // d3
  double v31; // d4
  double v32; // d5
  double v33; // d6
  double v34; // d7
  int v35; // w0
  _QWORD *v36; // x25
  __int64 v37; // x0
  __int64 v38; // x0
  __int64 v39; // x26
  _QWORD *v40; // x0
  __int64 v41; // x1
  __int64 v42; // x28
  void (__fastcall *v43)(_QWORD, __int64); // x27
  __int64 v44; // x1
  __int64 v45; // x2
  __int64 v46; // x3
  void *v47; // x4
  void *v48; // x5
  void *v49; // x6
  int v50; // w0
  __int64 v51; // x1
  __int64 v52; // x2
  __int64 v53; // x3
  void *v54; // x4
  void *v55; // x5
  void *v56; // x6
  int v57; // w0
  __int64 v58; // x1
  __int64 v59; // x2
  __int64 v60; // x3
  void *v61; // x4
  void *v62; // x5
  void *v63; // x6
  int v64; // w0
  bool v65; // zf
  __int64 v66; // x27
  __int64 v67; // x28
  void (__fastcall *v68)(__int64, _QWORD); // x27
  __int64 v69; // x1
  __int64 v70; // x2
  __int64 v71; // x3
  void *v72; // x4
  void *v73; // x5
  void *v74; // x6
  int v75; // w0
  int v76; // w0
  void (*v77)(void); // x27
  __int64 v78; // x1
  __int64 v79; // x2
  __int64 v80; // x3
  void *v81; // x4
  void *v82; // x5
  void *v83; // x6
  int v84; // w0
  signed __int64 v85; // x0
  _QWORD *v86; // x0
  int v87; // [xsp+6Ch] [xbp+6Ch]

  v3 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
  v87 = a3;
  if ( qword_492A98 != v3 )
  {
    _aarch64_cas4_acq();
    if ( v20 )
      _lll_lock_wait_private(&_exit_lock, v12, v13, v14, v15, v16, v17, v18, v19, v6, v7, v8, v9, v10, v11);
    qword_492A98 = v3;
  }
  ++dword_492A94;
  _aarch64_cas4_acq();
  if ( v35 )
    _lll_lock_wait_private(_exit_funcs_lock, v27, v28, v29, v30, v31, v32, v33, v34, v21, v22, v23, v24, v25, v26);
  v36 = *a2;
  if ( !*a2 )
  {
LABEL_18:
    _exit_funcs_done = 1;
    _aarch64_swp4_rel();
    if ( v64 > 1 )
      _lll_lock_wake_private(_exit_funcs_lock, v58, v59, v60, v61, v62, v63);
    if ( IO_cleanup )
      v65 = v87 == 0;
    else
      v65 = 1;
    if ( !v65 )
      IO_cleanup();
    exit(a1);
  }
  while ( 1 )
  {
    while ( 1 )
    {
      v37 = v36[1];
      if ( v37 )
        break;
      v86 = (_QWORD *)*v36;
      *a2 = (_QWORD *)*v36;
      if ( v86 )
      {
        free((unsigned __int64)v36, v27, v28, v29, v30, v31, v32, v33, v34);
        v36 = *a2;
        if ( *a2 )
          continue;
      }
      goto LABEL_18;
    }
    v38 = v37 - 1;
    v36[1] = v38;
    v39 = _new_exitfn_called;
    v40 = &v36[4 * v38];
    v41 = v40[2];
    if ( v41 == 3 )
      break;
    if ( v41 == 4 )
    {
      v66 = v40[3];
      v67 = v40[4];
      v40[2] = 0LL;
      v68 = (void (__fastcall *)(__int64, _QWORD))(v66 ^ _pointer_chk_guard_local);
      _aarch64_swp4_rel();
      if ( v75 > 1 )
        _lll_lock_wake_private(_exit_funcs_lock, v69, v70, v71, v72, v73, v74);
      v68(v67, a1);
      _aarch64_cas4_acq();
      if ( !v76 )
        goto LABEL_16;
LABEL_29:
      _lll_lock_wait_private(_exit_funcs_lock, v27, v28, v29, v30, v31, v32, v33, v34, v51, v52, v53, v54, v55, v56);
LABEL_16:
      if ( _new_exitfn_called != v39 )
      {
        v36 = *a2;
        if ( !*a2 )
          goto LABEL_18;
      }
    }
    else if ( v41 == 2 )
    {
      v42 = v40[4];
      v43 = (void (__fastcall *)(_QWORD, __int64))(v40[3] ^ _pointer_chk_guard_local);
      _aarch64_swp4_rel();
      if ( v50 > 1 )
        _lll_lock_wake_private(_exit_funcs_lock, v44, v45, v46, v47, v48, v49);
      v43(a1, v42);
LABEL_15:
      _aarch64_cas4_acq();
      if ( !v57 )
        goto LABEL_16;
      goto LABEL_29;
    }
  }
  v77 = (void (*)(void))(v40[3] ^ _pointer_chk_guard_local);
  _aarch64_swp4_rel();
  if ( v84 > 1 )
  {
    v85 = _lll_lock_wake_private(_exit_funcs_lock, v78, v79, v80, v81, v82, v83);
    ((void (__fastcall *)(signed __int64))v77)(v85);
  }
  else
  {
    v77();
  }
  goto LABEL_15;
}
// 40183C: variable 'v20' is possibly undefined
// 401A60: variable 'v12' is possibly undefined
// 401A60: variable 'v13' is possibly undefined
// 401A60: variable 'v14' is possibly undefined
// 401A60: variable 'v15' is possibly undefined
// 401A60: variable 'v16' is possibly undefined
// 401A60: variable 'v17' is possibly undefined
// 401A60: variable 'v18' is possibly undefined
// 401A60: variable 'v19' is possibly undefined
// 401A60: variable 'v6' is possibly undefined
// 401A60: variable 'v7' is possibly undefined
// 401A60: variable 'v8' is possibly undefined
// 401A60: variable 'v9' is possibly undefined
// 401A60: variable 'v10' is possibly undefined
// 401A60: variable 'v11' is possibly undefined
// 401880: variable 'v35' is possibly undefined
// 401A54: variable 'v27' is possibly undefined
// 401A54: variable 'v28' is possibly undefined
// 401A54: variable 'v29' is possibly undefined
// 401A54: variable 'v30' is possibly undefined
// 401A54: variable 'v31' is possibly undefined
// 401A54: variable 'v32' is possibly undefined
// 401A54: variable 'v33' is possibly undefined
// 401A54: variable 'v34' is possibly undefined
// 401A54: variable 'v21' is possibly undefined
// 401A54: variable 'v22' is possibly undefined
// 401A54: variable 'v23' is possibly undefined
// 401A54: variable 'v24' is possibly undefined
// 401A54: variable 'v25' is possibly undefined
// 401A54: variable 'v26' is possibly undefined
// 4018F0: variable 'v50' is possibly undefined
// 401A24: variable 'v44' is possibly undefined
// 401A24: variable 'v45' is possibly undefined
// 401A24: variable 'v46' is possibly undefined
// 401A24: variable 'v47' is possibly undefined
// 401A24: variable 'v48' is possibly undefined
// 401A24: variable 'v49' is possibly undefined
// 401910: variable 'v57' is possibly undefined
// 401948: variable 'v64' is possibly undefined
// 401A44: variable 'v58' is possibly undefined
// 401A44: variable 'v59' is possibly undefined
// 401A44: variable 'v60' is possibly undefined
// 401A44: variable 'v61' is possibly undefined
// 401A44: variable 'v62' is possibly undefined
// 401A44: variable 'v63' is possibly undefined
// 40198C: variable 'v75' is possibly undefined
// 401A18: variable 'v69' is possibly undefined
// 401A18: variable 'v70' is possibly undefined
// 401A18: variable 'v71' is possibly undefined
// 401A18: variable 'v72' is possibly undefined
// 401A18: variable 'v73' is possibly undefined
// 401A18: variable 'v74' is possibly undefined
// 4019AC: variable 'v76' is possibly undefined
// 4019B4: variable 'v51' is possibly undefined
// 4019B4: variable 'v52' is possibly undefined
// 4019B4: variable 'v53' is possibly undefined
// 4019B4: variable 'v54' is possibly undefined
// 4019B4: variable 'v55' is possibly undefined
// 4019B4: variable 'v56' is possibly undefined
// 4019D8: variable 'v84' is possibly undefined
// 4019E8: variable 'v78' is possibly undefined
// 4019E8: variable 'v79' is possibly undefined
// 4019E8: variable 'v80' is possibly undefined
// 4019E8: variable 'v81' is possibly undefined
// 4019E8: variable 'v82' is possibly undefined
// 4019E8: variable 'v83' is possibly undefined
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;
// 492670: using guessed type __int64 _new_exitfn_called;
// 492678: using guessed type _DWORD _exit_funcs_lock[2];
// 492A90: using guessed type _DWORD _exit_lock;
// 492A94: using guessed type int dword_492A94;
// 492A98: using guessed type __int64 qword_492A98;
// 492AA0: using guessed type char _exit_funcs_done;

//----- (0000000000401A68) ----------------------------------------------------
void __fastcall __noreturn exit(unsigned int a1)
{
  _run_exit_handlers(a1, (_QWORD **)&_exit_funcs, 1u);
}
// 490048: using guessed type _UNKNOWN *_exit_funcs;

//----- (0000000000401AA0) ----------------------------------------------------
__int64 printf(__int64 a1, ...)
{
  gcc_va_list va1; // [xsp+10h] [xbp+10h] BYREF
  gcc_va_list va; // [xsp+30h] [xbp+30h] BYREF
  __int64 vars88; // [xsp+D8h] [xbp+D8h]
  __int64 vars90; // [xsp+E0h] [xbp+E0h]
  __int64 vars98; // [xsp+E8h] [xbp+E8h]
  __int64 varsA0; // [xsp+F0h] [xbp+F0h]
  __int64 varsA8; // [xsp+F8h] [xbp+F8h]
  __int64 varsB0; // [xsp+100h] [xbp+100h]

  va_start(va, a1);
  vars88 = va_arg(va, _QWORD);
  vars90 = va_arg(va, _QWORD);
  vars98 = va_arg(va, _QWORD);
  varsA0 = va_arg(va, _QWORD);
  varsA8 = va_arg(va, _QWORD);
  varsB0 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a1);
  va_copy(va1, va);
  return _vfprintf_internal((__int64)stdout, a1, (__int128 *)va1, 0);
}
// 4905C0: using guessed type int *stdout;

//----- (0000000000401B20) ----------------------------------------------------
unsigned __int64 __fastcall outstring_converted_wide_string(
        __int64 a1,
        _DWORD *a2,
        int a3,
        void *a4,
        __int64 a5,
        _DWORD *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  _BOOL4 v18; // w28
  unsigned __int64 v19; // x27
  __int64 v20; // x19
  unsigned __int64 v21; // x26
  unsigned __int64 v22; // x2
  unsigned __int64 result; // x0
  __int64 v24; // x2
  unsigned __int64 v25; // x26
  _BOOL4 v26; // w1
  bool v27; // zf
  __int64 v28; // x20
  _BOOL4 v29; // w0
  unsigned __int64 v31; // x2
  unsigned __int64 v32; // x27
  bool v33; // zf
  char v34; // [xsp+0h] [xbp+0h]
  int v35; // [xsp+60h] [xbp+60h]
  unsigned int v36; // [xsp+64h] [xbp+64h]
  _DWORD *v37; // [xsp+68h] [xbp+68h] BYREF
  __int64 v38; // [xsp+70h] [xbp+70h] BYREF
  _DWORD *v39; // [xsp+78h] [xbp+78h] BYREF
  _BYTE v40[256]; // [xsp+80h] [xbp+80h] BYREF

  v18 = (int)a4 > 0;
  v35 = (int)a4;
  v36 = (unsigned __int8)a5;
  v37 = a2;
  if ( (v18 & ((unsigned __int8)a5 ^ 1)) != 0 )
  {
    v38 = 0LL;
    v39 = a2;
    if ( a3 < 0 )
    {
      v24 = (int)a4 - wcsrtombs(0LL, &v39, 0LL, &v38, a5, (__int64)a6, (__int64)a7, a8, v34);
      if ( v24 <= 0 )
      {
        result = *(unsigned int *)(a1 + 32);
        if ( !(_DWORD)result )
          return result;
        result = (unsigned __int64)v37;
        v39 = 0LL;
        v25 = -1LL;
        if ( !v37 )
          return result;
        goto LABEL_21;
      }
    }
    else
    {
      v19 = a3;
      v20 = 0LL;
      v21 = a3;
      if ( a3 )
      {
        while ( a2 )
        {
          if ( v21 > 0x100 )
            v22 = 256LL;
          else
            v22 = v21;
          result = wcsrtombs(v40, &v39, v22, &v38, a5, (__int64)a6, (__int64)a7, a8, v34);
          if ( result == -1LL )
            goto LABEL_33;
          if ( !result )
            break;
          v20 += result;
          v21 -= result;
          if ( !v21 )
            break;
          a2 = v39;
        }
        v24 = v35 - v20;
        if ( v24 <= 0 )
        {
          result = *(unsigned int *)(a1 + 32);
          if ( !(_DWORD)result )
            return result;
          v39 = 0LL;
          goto LABEL_16;
        }
      }
      else
      {
        v24 = (int)a4;
      }
    }
    _printf_buffer_pad_1(a1, 32LL, v24, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
    result = *(unsigned int *)(a1 + 32);
    if ( !(_DWORD)result )
      return result;
  }
  v39 = 0LL;
  if ( (a3 & 0x80000000) == 0 )
  {
    v19 = a3;
LABEL_16:
    v25 = v19;
    v26 = a3 != 0;
    goto LABEL_17;
  }
  v26 = 1;
  v25 = -1LL;
LABEL_17:
  if ( v37 )
    v27 = !v26;
  else
    v27 = 1;
  if ( v27 )
  {
    v28 = 0LL;
LABEL_37:
    result = v36;
    v33 = !v18 || v36 == 0;
    if ( !v33 && v35 - v28 > 0 )
      return _printf_buffer_pad_1(a1, 32LL, v35 - v28, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
    return result;
  }
LABEL_21:
  v28 = 0LL;
  while ( 1 )
  {
    v31 = v25 > 0x100 ? 256LL : v25;
    result = wcsrtombs(v40, &v37, v31, (__int64 *)&v39, a5, (__int64)a6, (__int64)a7, a8, v34);
    v32 = result;
    if ( result == -1LL )
      break;
    if ( result )
    {
      _printf_buffer_write(a1, (__int64)v40, result);
      v28 += v32;
      v29 = 1;
      if ( (a3 & 0x80000000) == 0 )
      {
        v25 -= v32;
        v29 = v25 != 0;
      }
      if ( v37 && v29 )
        continue;
    }
    goto LABEL_37;
  }
LABEL_33:
  *(_DWORD *)(a1 + 32) = 0;
  return result;
}
// 401B98: variable 'a5' is possibly undefined
// 401B98: variable 'a6' is possibly undefined
// 401B98: variable 'a7' is possibly undefined
// 401B98: variable 'a8' is possibly undefined
// 401B98: variable 'v34' is possibly undefined
// 401BD4: variable 'a4' is possibly undefined
// 401BD4: variable 'a9' is possibly undefined
// 401BD4: variable 'a10' is possibly undefined
// 401BD4: variable 'a11' is possibly undefined
// 401BD4: variable 'a12' is possibly undefined
// 401BD4: variable 'a13' is possibly undefined
// 401BD4: variable 'a14' is possibly undefined
// 401BD4: variable 'a15' is possibly undefined
// 401BD4: variable 'a16' is possibly undefined

//----- (0000000000401D4C) ----------------------------------------------------
_BYTE *__fastcall group_number(_BYTE *result, int *a2, char *a3, char *a4, _BYTE *a5, char a6)
{
  unsigned __int64 v6; // x20
  char *v7; // x19
  unsigned __int64 StatusReg; // x25
  __int16 v12; // t1
  __int64 v13; // x2
  void *v14; // x3
  __int64 v15; // x4
  _DWORD *v16; // x5
  void *v17; // x6
  __int64 v18; // x7
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7
  __int64 v27; // x2
  void *v28; // x3
  __int64 v29; // x4
  _DWORD *v30; // x5
  void *v31; // x6
  __int64 v32; // x7
  double v33; // d0
  double v34; // d1
  double v35; // d2
  double v36; // d3
  double v37; // d4
  double v38; // d5
  double v39; // d6
  double v40; // d7
  char v41; // w1

  v6 = (unsigned __int64)result;
  v7 = a3;
  if ( (a6 & 1) != 0 )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    if ( a3 != a4 )
    {
      do
      {
        if ( (_grouping_iterator_next(a2) & 1) != 0 )
          _printf_buffer_puts_1(v6, a5, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26);
        v12 = (unsigned __int8)*v7++;
        result = (_BYTE *)_printf_buffer_puts_1(
                            v6,
                            *(_BYTE **)(**(_QWORD **)(StatusReg + 16) + 8LL * (unsigned __int16)(v12 - 7) + 56),
                            v13,
                            v14,
                            v15,
                            v16,
                            v17,
                            v18,
                            v19,
                            v20,
                            v21,
                            v22,
                            v23,
                            v24,
                            v25,
                            v26);
      }
      while ( a4 != v7 );
    }
  }
  else if ( a3 != a4 )
  {
    if ( (_grouping_iterator_next(a2) & 1) != 0 )
      goto LABEL_13;
LABEL_9:
    result = *(_BYTE **)(v6 + 8);
    v41 = *v7;
    if ( result != *(_BYTE **)(v6 + 16) )
    {
LABEL_10:
      *(_QWORD *)(v6 + 8) = result + 1;
      *result = v41;
      goto LABEL_11;
    }
    while ( 1 )
    {
      result = (_BYTE *)_printf_buffer_putc_1(v6, v41);
LABEL_11:
      if ( a4 == ++v7 )
        break;
      if ( (_grouping_iterator_next(a2) & 1) == 0 )
        goto LABEL_9;
LABEL_13:
      _printf_buffer_puts_1(v6, a5, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40);
      result = *(_BYTE **)(v6 + 8);
      v41 = *v7;
      if ( result != *(_BYTE **)(v6 + 16) )
        goto LABEL_10;
    }
  }
  return result;
}
// 401DD0: variable 'v13' is possibly undefined
// 401DD0: variable 'v14' is possibly undefined
// 401DD0: variable 'v15' is possibly undefined
// 401DD0: variable 'v16' is possibly undefined
// 401DD0: variable 'v17' is possibly undefined
// 401DD0: variable 'v18' is possibly undefined
// 401DD0: variable 'v19' is possibly undefined
// 401DD0: variable 'v20' is possibly undefined
// 401DD0: variable 'v21' is possibly undefined
// 401DD0: variable 'v22' is possibly undefined
// 401DD0: variable 'v23' is possibly undefined
// 401DD0: variable 'v24' is possibly undefined
// 401DD0: variable 'v25' is possibly undefined
// 401DD0: variable 'v26' is possibly undefined
// 401E3C: variable 'v27' is possibly undefined
// 401E3C: variable 'v28' is possibly undefined
// 401E3C: variable 'v29' is possibly undefined
// 401E3C: variable 'v30' is possibly undefined
// 401E3C: variable 'v31' is possibly undefined
// 401E3C: variable 'v32' is possibly undefined
// 401E3C: variable 'v33' is possibly undefined
// 401E3C: variable 'v34' is possibly undefined
// 401E3C: variable 'v35' is possibly undefined
// 401E3C: variable 'v36' is possibly undefined
// 401E3C: variable 'v37' is possibly undefined
// 401E3C: variable 'v38' is possibly undefined
// 401E3C: variable 'v39' is possibly undefined
// 401E3C: variable 'v40' is possibly undefined

//----- (0000000000401E60) ----------------------------------------------------
void __fastcall printf_positional(
        unsigned __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        _DWORD *a13,
        void *a14,
        unsigned __int8 *a15,
        __int64 a16,
        __int64 a17,
        __int64 a18,
        __int64 a19,
        char a20)
{
  _DWORD *v21; // x24
  unsigned __int8 *v22; // x25
  unsigned __int64 v23; // x23
  unsigned __int64 v24; // x28
  _BYTE *v25; // x24
  unsigned __int64 v26; // x20
  __int64 v27; // x0
  __int64 v28; // x2
  void *v29; // x3
  unsigned __int64 v30; // x25
  _BYTE *v31; // x20
  void *v32; // x3
  char v33; // w0
  void *v34; // x3
  unsigned __int64 v35; // x22
  _BYTE *v36; // x19
  _BYTE *v37; // x21
  void *v38; // x6
  __int64 v39; // x7
  unsigned __int64 v40; // x28
  void *v41; // x3
  unsigned __int64 v42; // x0
  _BYTE *v43; // x26
  _BYTE *v44; // x23
  unsigned __int64 v45; // x21
  _BYTE *v46; // x20
  __int64 v47; // x19
  int v48; // w0
  int v49; // w0
  __int64 v50; // x1
  __int64 v51; // x2
  void (__fastcall *v52)(_BYTE *, __int64, _BYTE *, _BYTE *); // x6
  _BYTE *v53; // x0
  unsigned __int64 v54; // x0
  __int64 v55; // x25
  unsigned __int64 v56; // x26
  __int64 v57; // x28
  int v58; // w0
  int v59; // w1
  _DWORD *v60; // x0
  int v61; // w1
  _QWORD *v62; // x0
  unsigned __int64 v63; // x25
  __int64 v64; // x6
  unsigned __int64 v65; // x0
  int *v66; // x27
  unsigned __int64 v67; // x24
  int v68; // w21
  int v69; // w0
  int v70; // w28
  __int64 (__fastcall *v71)(_QWORD *, __int64, _BYTE *); // x1
  int v72; // w0
  unsigned __int64 v73; // x5
  __int64 v74; // x1
  __int64 v75; // x2
  int v76; // w0
  int v77; // w1
  _QWORD *v78; // x0
  _QWORD *v79; // x4
  _QWORD *v80; // x2
  int v81; // w0
  _OWORD *v82; // x0
  _QWORD *v83; // x1
  _QWORD *v84; // x0
  _BYTE *v85; // x0
  __int16 v86; // w0
  int v87; // w0
  _BYTE *v88; // x0
  char *v89; // x19
  char *v90; // x2
  char v91; // w1
  char v92; // t1
  __int16 v93; // w0
  _BYTE *v94; // x0
  _BYTE *v95; // x0
  _BYTE *v96; // x0
  _BYTE *v97; // x0
  int v98; // w0
  _BYTE *v99; // x1
  char *v100; // x19
  char *v101; // x2
  char v102; // w1
  char v103; // t1
  _BYTE *v104; // x0
  _BYTE *v105; // x0
  _BYTE *v106; // x0
  int *v107; // x4
  void *v108; // x5
  unsigned __int64 i; // x2
  __int64 v110; // x0
  void *v111; // [xsp+60h] [xbp+60h]
  __int64 v112; // [xsp+60h] [xbp+60h]
  void *v114; // [xsp+78h] [xbp+78h]
  _BYTE *v115; // [xsp+78h] [xbp+78h]
  __int64 v116; // [xsp+78h] [xbp+78h]
  __int64 v117; // [xsp+78h] [xbp+78h]
  int v118; // [xsp+80h] [xbp+80h]
  void *v119; // [xsp+90h] [xbp+90h]
  void *v120; // [xsp+90h] [xbp+90h]
  void *v121; // [xsp+90h] [xbp+90h]
  __int64 v122; // [xsp+A8h] [xbp+A8h]
  char v123; // [xsp+B8h] [xbp+B8h]
  void *v124; // [xsp+118h] [xbp+118h] BYREF
  __int64 v125; // [xsp+128h] [xbp+128h] BYREF
  char v126[8]; // [xsp+134h] [xbp+134h] BYREF
  _BYTE *v127; // [xsp+140h] [xbp+140h] BYREF
  unsigned __int64 v128; // [xsp+148h] [xbp+148h]
  _BYTE v129[1024]; // [xsp+150h] [xbp+150h] BYREF
  _BYTE *v130; // [xsp+550h] [xbp+550h] BYREF
  __int64 v131; // [xsp+558h] [xbp+558h]
  _BYTE v132[1024]; // [xsp+560h] [xbp+560h] BYREF

  v127 = v129;
  v128 = 1024LL;
  v131 = 1024LL;
  v21 = a13;
  v22 = a15;
  v118 = (int)a14;
  v124 = 0LL;
  v130 = v132;
  if ( a18 == -1 )
    _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( *a15 )
  {
    v23 = 0LL;
    v24 = 0LL;
    v25 = v129;
    v26 = 14LL;
    while ( 1 )
    {
      v27 = _parse_one_specmb(v22, v24, (__int64)&v25[72 * v23], (unsigned __int64 *)&v124, &v125);
      if ( (v125 & 1) != 0 )
        goto LABEL_11;
      v22 = *(unsigned __int8 **)&v25[72 * v23 + 32];
      v24 += v27;
      ++v23;
      if ( !*v22 )
        break;
      if ( v26 == v23 )
      {
        if ( (_libc_scratch_buffer_grow_preserve(
                (unsigned __int64 *)&v127,
                (unsigned __int8)v125,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                v28,
                v29,
                (__int64)a13,
                a14,
                a15,
                a16) & 1) == 0 )
          goto LABEL_11;
        v25 = v127;
        v26 = v128 / 0x48;
      }
    }
    v30 = (unsigned __int64)v124;
    v31 = v25;
    v21 = a13;
    if ( v24 < (unsigned __int64)v124 )
      v32 = v124;
    else
      v32 = (void *)v24;
  }
  else
  {
    v31 = v129;
    v32 = 0LL;
    v30 = 0LL;
    v23 = 0LL;
    v24 = 0LL;
  }
  v111 = v32;
  v33 = _libc_scratch_buffer_set_array_size(
          (unsigned __int64 *)&v130,
          (unsigned __int64)v32,
          24LL,
          v32,
          a13,
          a14,
          a15,
          a16,
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          a9);
  v34 = v111;
  if ( (v33 & 1) == 0 )
  {
LABEL_11:
    *(_DWORD *)(a1 + 32) = 0;
    goto LABEL_12;
  }
  v35 = (unsigned __int64)v130;
  v122 = 16LL * (_QWORD)v111;
  v36 = &v130[16 * (_QWORD)v111];
  v112 = 4LL * (_QWORD)v111;
  v37 = &v36[4 * (_QWORD)v34];
  v114 = v34;
  memset();
  v40 = v24 | v30;
  v41 = v114;
  if ( !v23 )
  {
    if ( !v40 )
      goto LABEL_12;
LABEL_33:
    v55 = 0LL;
    v56 = 0LL;
    v39 = (__int64)&v37[v112];
    while ( 1 )
    {
      v57 = 4 * v56;
      v58 = *(_DWORD *)&v37[4 * v56];
      if ( v58 > 7 )
      {
        if ( v58 == 263 )
        {
          v79 = (_QWORD *)(v35 + v55);
          v80 = *(_QWORD **)v21;
          v81 = v21[7];
          if ( (a20 & 1) != 0 )
          {
            if ( v81 < 0 && (v21[7] = v81 + 16, v81 + 16 <= 0) )
              v80 = (_QWORD *)(*((_QWORD *)v21 + 2) + v81);
            else
              *(_QWORD *)v21 = ((unsigned __int64)v80 + 15) & 0xFFFFFFFFFFFFFFF8LL;
            *v79 = *v80;
            *(_DWORD *)&v37[4 * v56] &= ~0x100u;
          }
          else
          {
            if ( v81 < 0 && (v21[7] = v81 + 16, v81 + 16 <= 0) )
            {
              v82 = (_OWORD *)(*((_QWORD *)v21 + 2) + v81);
            }
            else
            {
              v82 = (_OWORD *)(((unsigned __int64)v80 + 15) & 0xFFFFFFFFFFFFFFF0LL);
              *(_QWORD *)v21 = v82 + 1;
            }
            *(_OWORD *)v79 = *v82;
          }
          goto LABEL_52;
        }
        if ( v58 <= 263 )
        {
          if ( v58 == 256 )
            goto LABEL_49;
          goto LABEL_86;
        }
        if ( v58 == 512 )
          goto LABEL_49;
        if ( v58 == 1024 )
          goto LABEL_45;
      }
      else
      {
        if ( v58 > 5 )
        {
          v77 = v21[7];
          v78 = *(_QWORD **)v21;
          if ( v77 < 0 && (v21[7] = v77 + 16, v77 + 16 <= 0) )
            v78 = (_QWORD *)(*((_QWORD *)v21 + 2) + v77);
          else
            *(_QWORD *)v21 = ((unsigned __int64)v78 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *(_QWORD *)(v35 + v55) = *v78;
          goto LABEL_52;
        }
        if ( v58 == 2 )
        {
LABEL_45:
          v59 = v21[6];
          v60 = *(_DWORD **)v21;
          if ( v59 < 0 && (v21[6] = v59 + 8, v59 + 8 <= 0) )
            v60 = (_DWORD *)(*((_QWORD *)v21 + 1) + v59);
          else
            *(_QWORD *)v21 = ((unsigned __int64)v60 + 11) & 0xFFFFFFFFFFFFFFF8LL;
          *(_DWORD *)(v35 + v55) = *v60;
          goto LABEL_52;
        }
        if ( v58 > 2 )
        {
LABEL_49:
          v61 = v21[6];
          v62 = *(_QWORD **)v21;
          if ( v61 < 0 && (v21[6] = v61 + 8, v61 + 8 <= 0) )
            v62 = (_QWORD *)(*((_QWORD *)v21 + 1) + v61);
          else
            *(_QWORD *)v21 = ((unsigned __int64)v62 + 15) & 0xFFFFFFFFFFFFFFF8LL;
          *(_QWORD *)(v35 + v55) = *v62;
          goto LABEL_52;
        }
        if ( v58 == -1 )
        {
          if ( (a20 & 2) != 0 )
            _libc_fatal((__int64)"*** invalid %N$ use detected ***\n", a2, a3, a4, a5, a6, a7, a8, a9);
          _libc_assert_fail(
            (__int64)"(mode_flags & PRINTF_FORTIFY) != 0",
            (__int64)"vfprintf-internal.c",
            0x4F5u,
            (__int64)"printf_positional");
        }
        if ( (unsigned int)v58 <= 1 )
          goto LABEL_45;
      }
      if ( (v58 & 0x800) != 0 )
        goto LABEL_49;
LABEL_86:
      v83 = &unk_496000;
      if ( _printf_va_arg_table && *(_QWORD *)(_printf_va_arg_table + 8LL * v58 - 64) )
      {
        v107 = (int *)&v36[v57];
        v108 = (void *)v131;
        for ( i = v39 + *(int *)&v36[4 * v56];
              i > (unsigned __int64)&v130[v131];
              i = (unsigned __int64)&v37[v110 + *(int *)&v130[4 * v56 + v122]] )
        {
          v116 = v39;
          v120 = v41;
          if ( (_libc_scratch_buffer_grow_preserve(
                  (unsigned __int64 *)&v130,
                  (__int64)v83,
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  a9,
                  i,
                  v41,
                  (__int64)v107,
                  v108,
                  v38,
                  v39) & 1) == 0 )
            goto LABEL_11;
          v35 = (unsigned __int64)v130;
          v110 = v116 - (_QWORD)v37;
          v41 = v120;
          v36 = &v130[v122];
          v37 = &v130[v122 + v112];
          v107 = (int *)&v130[v122 + v57];
          v39 = (__int64)&v37[v110];
          v83 = (_QWORD *)&unk_496000;
        }
        *(_QWORD *)(v35 + v55) = v39;
        v121 = v41;
        v117 = v39 + *v107;
        (*(void (__fastcall **)(__int64, _DWORD *))(v83[497] + 8 * (*(int *)&v37[4 * v56] - 8LL)))(v39, v21);
        v39 = v117;
        v41 = v121;
      }
      else
      {
        v84 = (_QWORD *)(v35 + v55);
        *v84 = 0LL;
        v84[1] = 0LL;
      }
LABEL_52:
      ++v56;
      v55 += 16LL;
      if ( v56 >= (unsigned __int64)v41 )
        goto LABEL_53;
    }
  }
  v42 = v23;
  v43 = v31;
  v44 = v37;
  v45 = v42;
  v115 = v31;
  v46 = v36;
  v47 = 0LL;
  v119 = v41;
  do
  {
    while ( 1 )
    {
      v48 = *((_DWORD *)v43 + 11);
      if ( v48 != -1 )
        *(_DWORD *)&v44[4 * v48] = 0;
      v49 = *((_DWORD *)v43 + 10);
      if ( v49 != -1 )
        *(_DWORD *)&v44[4 * v49] = 0;
      v50 = *((_QWORD *)v43 + 7);
      if ( !v50 )
        goto LABEL_24;
      if ( v50 != 1 )
        break;
      *(_DWORD *)&v44[4 * *((int *)v43 + 12)] = *((_DWORD *)v43 + 13);
      *(_DWORD *)&v46[4 * *((int *)v43 + 12)] = *((_DWORD *)v43 + 16);
LABEL_24:
      ++v47;
      v43 += 72;
      if ( v47 == v45 )
        goto LABEL_32;
    }
    ++v47;
    v51 = *((int *)v43 + 12);
    v52 = *(void (__fastcall **)(_BYTE *, __int64, _BYTE *, _BYTE *))(_printf_arginfo_table
                                                                    + 8LL * *((unsigned int *)v43 + 2));
    v53 = v43;
    v43 += 72;
    v52(v53, v50, &v44[4 * v51], &v46[4 * v51]);
  }
  while ( v47 != v45 );
LABEL_32:
  v54 = v45;
  v36 = v46;
  v31 = v115;
  v37 = v44;
  v41 = v119;
  v23 = v54;
  if ( v40 )
    goto LABEL_33;
LABEL_53:
  v63 = v118;
  if ( v118 < v23 )
  {
    v64 = 72LL;
    v65 = a1;
    v66 = (int *)&v31[72 * v118];
    v67 = v65;
    while ( 1 )
    {
      if ( !*(_DWORD *)(v67 + 32) )
        goto LABEL_12;
      v73 = (unsigned int)v66[2];
      v76 = v66[11];
      if ( v76 != -1 )
      {
        v68 = *(_DWORD *)(v35 + 16LL * v76);
        if ( v68 < 0 )
        {
          v93 = *((_WORD *)v66 + 6);
          v66[1] = -v68;
          *((_WORD *)v66 + 6) = v93 | 0x20;
        }
        else
        {
          v66[1] = v68;
        }
      }
      v69 = v66[10];
      if ( v69 != -1 )
      {
        if ( *(int *)(v35 + 16LL * v69) < 0 )
          v70 = -1;
        else
          v70 = *(_DWORD *)(v35 + 16LL * v69);
        *v66 = v70;
      }
      if ( !_printf_function_table )
        break;
      v71 = *(__int64 (__fastcall **)(_QWORD *, __int64, _BYTE *))(_printf_function_table + 8LL * (unsigned __int8)v73);
      if ( !v71 )
        break;
      v123 = v73;
      v72 = _printf_function_invoke(
              (__int64 *)v67,
              v71,
              v35 + 16LL * v66[12],
              *((void **)v66 + 7),
              (__int64)v66,
              (void *)v73,
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              a9,
              v64,
              v39);
      LOBYTE(v73) = v123;
      if ( v72 == -2 )
        break;
      if ( v72 < 0 )
      {
        a1 = v67;
        goto LABEL_11;
      }
LABEL_66:
      v74 = *((_QWORD *)v66 + 3);
      v75 = *((_QWORD *)v66 + 4);
      ++v63;
      v66 += 18;
      _printf_buffer_write(v67, v74, v75 - v74);
      if ( v63 >= v23 )
        goto LABEL_12;
    }
    if ( (unsigned __int8)(v73 - 32) <= 0x5Au )
      __asm { BR              X0 }
    v85 = *(_BYTE **)(v67 + 8);
    if ( v85 == *(_BYTE **)(v67 + 16) )
    {
      _printf_buffer_putc_1(v67, 37);
    }
    else
    {
      *(_QWORD *)(v67 + 8) = v85 + 1;
      *v85 = 37;
    }
    v86 = *((_WORD *)v66 + 6);
    if ( (v86 & 8) != 0 )
    {
      v95 = *(_BYTE **)(v67 + 8);
      if ( v95 == *(_BYTE **)(v67 + 16) )
      {
        _printf_buffer_putc_1(v67, 35);
        v86 = *((_WORD *)v66 + 6);
        if ( (v86 & 0x80) != 0 )
          goto LABEL_117;
      }
      else
      {
        *(_QWORD *)(v67 + 8) = v95 + 1;
        *v95 = 35;
        v86 = *((_WORD *)v66 + 6);
        if ( (v86 & 0x80) != 0 )
          goto LABEL_117;
      }
LABEL_93:
      if ( (v86 & 0x40) == 0 )
        goto LABEL_94;
    }
    else
    {
      if ( (v86 & 0x80) == 0 )
        goto LABEL_93;
LABEL_117:
      v96 = *(_BYTE **)(v67 + 8);
      if ( v96 != *(_BYTE **)(v67 + 16) )
      {
        *(_QWORD *)(v67 + 8) = v96 + 1;
        *v96 = 39;
        v86 = *((_WORD *)v66 + 6);
        if ( (v86 & 0x40) != 0 )
          goto LABEL_112;
LABEL_94:
        if ( (v86 & 0x10) != 0 )
        {
          v97 = *(_BYTE **)(v67 + 8);
          if ( v97 == *(_BYTE **)(v67 + 16) )
          {
            _printf_buffer_putc_1(v67, 32);
          }
          else
          {
            *(_QWORD *)(v67 + 8) = v97 + 1;
            *v97 = 32;
          }
          v86 = *((_WORD *)v66 + 6);
        }
LABEL_95:
        if ( (v86 & 0x20) != 0 )
        {
          v105 = *(_BYTE **)(v67 + 8);
          if ( v105 == *(_BYTE **)(v67 + 16) )
          {
            _printf_buffer_putc_1(v67, 45);
          }
          else
          {
            *(_QWORD *)(v67 + 8) = v105 + 1;
            *v105 = 45;
          }
        }
        if ( v66[4] == 48 )
        {
          v106 = *(_BYTE **)(v67 + 8);
          if ( v106 == *(_BYTE **)(v67 + 16) )
          {
            _printf_buffer_putc_1(v67, 48);
          }
          else
          {
            *(_QWORD *)(v67 + 8) = v106 + 1;
            *v106 = 48;
          }
        }
        if ( (v66[3] & 0x800) != 0 )
        {
          v104 = *(_BYTE **)(v67 + 8);
          if ( v104 == *(_BYTE **)(v67 + 16) )
          {
            _printf_buffer_putc_1(v67, 73);
          }
          else
          {
            *(_QWORD *)(v67 + 8) = v104 + 1;
            *v104 = 73;
          }
        }
        v87 = v66[1];
        if ( v87 )
        {
          v100 = (char *)itoa_word(v87, (__int64)v126, 0xAu, 0);
          if ( v100 < v126 )
          {
            do
            {
              v101 = *(char **)(v67 + 8);
              v103 = *v100++;
              v102 = v103;
              if ( v101 == *(char **)(v67 + 16) )
              {
                _printf_buffer_putc_1(v67, v102);
              }
              else
              {
                *(_QWORD *)(v67 + 8) = v101 + 1;
                *v101 = v102;
              }
            }
            while ( v100 != v126 );
          }
        }
        if ( *v66 != -1 )
        {
          v88 = *(_BYTE **)(v67 + 8);
          if ( v88 == *(_BYTE **)(v67 + 16) )
          {
            _printf_buffer_putc_1(v67, 46);
          }
          else
          {
            *(_QWORD *)(v67 + 8) = v88 + 1;
            *v88 = 46;
          }
          v89 = (char *)itoa_word(*v66, (__int64)v126, 0xAu, 0);
          if ( v89 < v126 )
          {
            do
            {
              v90 = *(char **)(v67 + 8);
              v92 = *v89++;
              v91 = v92;
              if ( v90 == *(char **)(v67 + 16) )
              {
                _printf_buffer_putc_1(v67, v91);
              }
              else
              {
                *(_QWORD *)(v67 + 8) = v90 + 1;
                *v90 = v91;
              }
            }
            while ( v89 != v126 );
          }
        }
        v98 = v66[2];
        if ( v98 )
        {
          v99 = *(_BYTE **)(v67 + 8);
          if ( v99 == *(_BYTE **)(v67 + 16) )
          {
            _printf_buffer_putc_1(v67, v98);
          }
          else
          {
            *(_QWORD *)(v67 + 8) = v99 + 1;
            *v99 = v98;
          }
        }
        goto LABEL_66;
      }
      _printf_buffer_putc_1(v67, 39);
      v86 = *((_WORD *)v66 + 6);
      if ( (v86 & 0x40) == 0 )
        goto LABEL_94;
    }
LABEL_112:
    v94 = *(_BYTE **)(v67 + 8);
    if ( v94 == *(_BYTE **)(v67 + 16) )
    {
      _printf_buffer_putc_1(v67, 43);
    }
    else
    {
      *(_QWORD *)(v67 + 8) = v94 + 1;
      *v94 = 43;
    }
    v86 = *((_WORD *)v66 + 6);
    goto LABEL_95;
  }
LABEL_12:
  if ( v130 != v132 )
    free((unsigned __int64)v130, a2, a3, a4, a5, a6, a7, a8, a9);
  if ( v127 != v129 )
    free((unsigned __int64)v127, a2, a3, a4, a5, a6, a7, a8, a9);
}
// 401F58: variable 'a2' is possibly undefined
// 401F58: variable 'a3' is possibly undefined
// 401F58: variable 'a4' is possibly undefined
// 401F58: variable 'a5' is possibly undefined
// 401F58: variable 'a6' is possibly undefined
// 401F58: variable 'a7' is possibly undefined
// 401F58: variable 'a8' is possibly undefined
// 401F58: variable 'a9' is possibly undefined
// 401F58: variable 'v28' is possibly undefined
// 401F58: variable 'v29' is possibly undefined
// 401F58: variable 'a13' is possibly undefined
// 401F58: variable 'a14' is possibly undefined
// 401F58: variable 'a15' is possibly undefined
// 401F58: variable 'a16' is possibly undefined
// 4022C4: variable 'v64' is possibly undefined
// 4022C4: variable 'v39' is possibly undefined
// 403650: variable 'v108' is possibly undefined
// 403650: variable 'v38' is possibly undefined
// 496F70: using guessed type __int64 _printf_function_table;
// 496F78: using guessed type __int64 _printf_arginfo_table;
// 496F88: using guessed type __int64 _printf_va_arg_table;

//----- (00000000004039F0) ----------------------------------------------------
void __fastcall _printf_buffer(unsigned __int64 a1, __int64 a2, __int64 *a3, char a4)
{
  __int64 v7; // x22
  __int128 v8; // q30
  unsigned __int8 *v9; // x26
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7
  int v18; // w4
  __int128 v19; // q31
  __int64 v20; // [xsp+0h] [xbp-20h]
  int v21; // [xsp+88h] [xbp+68h]
  unsigned __int64 StatusReg; // [xsp+A0h] [xbp+80h]
  int v23; // [xsp+ACh] [xbp+8Ch]
  __int64 v25; // [xsp+D8h] [xbp+B8h]
  int v26; // [xsp+F4h] [xbp+D4h]
  __int64 v27; // [xsp+F8h] [xbp+D8h]
  _OWORD v29[2]; // [xsp+130h] [xbp+110h] BYREF
  _OWORD v30[2]; // [xsp+188h] [xbp+168h] BYREF
  _BYTE v31[999]; // [xsp+1A8h] [xbp+188h] BYREF

  v7 = *a3;
  v25 = a3[1];
  v27 = a3[2];
  v23 = *((_DWORD *)a3 + 7);
  v21 = *((_DWORD *)a3 + 6);
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v26 = *(_DWORD *)(StatusReg + 40);
  v8 = *((_OWORD *)a3 + 1);
  v30[0] = *(_OWORD *)a3;
  v30[1] = v8;
  v9 = (unsigned __int8 *)strchrnul(a2, 0x25u);
  _printf_buffer_write(a1, a2, (unsigned __int64)&v9[-a2]);
  if ( *(_DWORD *)(a1 + 32) && *v9 )
  {
    if ( _printf_function_table || _printf_modifier_table || _printf_va_arg_table )
      goto LABEL_8;
    v18 = v9[1];
    if ( (unsigned __int8)(v18 - 32) <= 0x5Au )
      __asm { BR              X0 }
    if ( v9[1] )
    {
LABEL_8:
      *a3 = v7;
      a3[1] = v25;
      a3[2] = v27;
      *((_DWORD *)a3 + 6) = v21;
      *((_DWORD *)a3 + 7) = v23;
      v19 = *((_OWORD *)a3 + 1);
      v29[0] = *(_OWORD *)a3;
      v29[1] = v19;
      LODWORD(v20) = v26;
      printf_positional(
        a1,
        v10,
        v11,
        v12,
        v13,
        v14,
        v15,
        v16,
        v17,
        a2,
        0LL,
        (__int64)v29,
        v30,
        0LL,
        v9,
        (__int64)v31,
        v20,
        -1LL,
        0LL,
        a4);
    }
    else
    {
      *(_DWORD *)(StatusReg + 40) = 22;
      *(_DWORD *)(a1 + 32) = 0;
    }
  }
}
// 403B80: variable 'v10' is possibly undefined
// 403B80: variable 'v11' is possibly undefined
// 403B80: variable 'v12' is possibly undefined
// 403B80: variable 'v13' is possibly undefined
// 403B80: variable 'v14' is possibly undefined
// 403B80: variable 'v15' is possibly undefined
// 403B80: variable 'v16' is possibly undefined
// 403B80: variable 'v17' is possibly undefined
// 403B80: variable 'v20' is possibly undefined
// 496F60: using guessed type __int64 _printf_modifier_table;
// 496F70: using guessed type __int64 _printf_function_table;
// 496F88: using guessed type __int64 _printf_va_arg_table;

//----- (0000000000405B68) ----------------------------------------------------
__int64 __fastcall _vfprintf_internal(__int64 a1, __int64 a2, __int128 *a3, char a4)
{
  int v5; // w0
  int v6; // w0
  int v10; // w23
  __int128 v11; // q31
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  unsigned int v20; // w20
  __int64 v22; // x1
  int v23; // w0
  unsigned __int64 StatusReg; // x20
  __int64 v25; // x23
  unsigned __int64 v26; // x20
  __int64 v27; // x0
  __int64 v28; // x1
  __int64 v29; // x2
  __int64 v30; // x3
  void *v31; // x4
  void *v32; // x5
  void *v33; // x6
  double v34; // d0
  double v35; // d1
  double v36; // d2
  double v37; // d3
  double v38; // d4
  double v39; // d5
  double v40; // d6
  double v41; // d7
  int v42; // w0
  void *v43; // x19
  __int64 v44; // x1
  __int64 v45; // x2
  __int64 v46; // x3
  void *v47; // x4
  void *v48; // x5
  void *v49; // x6
  int v50; // w0
  __int128 v51; // q31
  double v52; // d0
  double v53; // d1
  double v54; // d2
  double v55; // d3
  double v56; // d4
  double v57; // d5
  double v58; // d6
  double v59; // d7
  __int128 v60; // [xsp+40h] [xbp+40h] BYREF
  __int128 v61; // [xsp+50h] [xbp+50h]
  _QWORD v62[4]; // [xsp+60h] [xbp+60h] BYREF
  _BYTE v63[176]; // [xsp+80h] [xbp+80h] BYREF

  v5 = *(_DWORD *)(a1 + 192);
  if ( v5 )
  {
    if ( v5 != -1 )
      return (unsigned int)-1;
  }
  else
  {
    *(_DWORD *)(a1 + 192) = -1;
  }
  v6 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 8) != 0 )
  {
    *(_DWORD *)a1 = v6 | 0x20;
    v20 = -1;
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 9;
    return v20;
  }
  if ( !a2 )
  {
    v20 = -1;
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return v20;
  }
  if ( (*(_QWORD *)(a1 + 112) & 0x8000000000LL) != 0 )
  {
    v62[1] = a1;
    v10 = 0;
    if ( (v6 & 0x8000) != 0 )
      goto LABEL_7;
    v62[0] = funlockfile;
    _libc_cleanup_push_defer((__int64)v62);
    if ( (*(_DWORD *)a1 & 0x8000) == 0 )
    {
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
      v25 = *(_QWORD *)(a1 + 136);
      v26 = StatusReg - 1824;
      v27 = *(_QWORD *)(v25 + 8);
      if ( _libc_single_threaded && !v27 )
      {
        *(_DWORD *)v25 = 1;
        *(_QWORD *)(v25 + 8) = v26;
        v10 = 1;
        goto LABEL_7;
      }
      if ( v27 == v26 )
      {
        ++*(_DWORD *)(v25 + 4);
        v10 = 1;
LABEL_7:
        _printf_buffer_to_file_init((__int64)v63, a1);
        v11 = a3[1];
        v60 = *a3;
        v61 = v11;
        _printf_buffer((unsigned __int64)v63, a2, (__int64 *)&v60, a4);
        v20 = _printf_buffer_to_file_done((__int64)v63, v12, v13, v14, v15, v16, v17, v18, v19);
        if ( (*(_DWORD *)a1 & 0x8000) != 0 )
          goto LABEL_8;
        v22 = *(_QWORD *)(a1 + 136);
        v23 = *(_DWORD *)(v22 + 4);
        if ( _libc_single_threaded )
        {
          if ( !v23 )
          {
            *(_QWORD *)(v22 + 8) = 0LL;
            **(_DWORD **)(a1 + 136) = 0;
            if ( !v10 )
              return v20;
LABEL_15:
            _libc_cleanup_pop_restore((__int64)v62);
            return v20;
          }
        }
        else if ( !v23 )
        {
          *(_QWORD *)(v22 + 8) = 0LL;
          v43 = *(void **)(a1 + 136);
          _aarch64_swp4_rel();
          if ( v50 > 1 )
            _lll_lock_wake_private(v43, v44, v45, v46, v47, v48, v49);
LABEL_8:
          if ( !v10 )
            return v20;
          goto LABEL_15;
        }
        *(_DWORD *)(v22 + 4) = v23 - 1;
        goto LABEL_8;
      }
      _aarch64_cas4_acq();
      if ( v42 )
        _lll_lock_wait_private((_DWORD *)v25, v34, v35, v36, v37, v38, v39, v40, v41, v28, v29, v30, v31, v32, v33);
      *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8LL) = v26;
    }
    v10 = 1;
    goto LABEL_7;
  }
  _printf_buffer_to_file_init((__int64)v63, a1);
  v51 = a3[1];
  v60 = *a3;
  v61 = v51;
  _printf_buffer((unsigned __int64)v63, a2, (__int64 *)&v60, a4);
  return (unsigned int)_printf_buffer_to_file_done((__int64)v63, v52, v53, v54, v55, v56, v57, v58, v59);
}
// 405BEC: variable 'v12' is possibly undefined
// 405BEC: variable 'v13' is possibly undefined
// 405BEC: variable 'v14' is possibly undefined
// 405BEC: variable 'v15' is possibly undefined
// 405BEC: variable 'v16' is possibly undefined
// 405BEC: variable 'v17' is possibly undefined
// 405BEC: variable 'v18' is possibly undefined
// 405BEC: variable 'v19' is possibly undefined
// 405CC8: variable 'v42' is possibly undefined
// 405D94: variable 'v34' is possibly undefined
// 405D94: variable 'v35' is possibly undefined
// 405D94: variable 'v36' is possibly undefined
// 405D94: variable 'v37' is possibly undefined
// 405D94: variable 'v38' is possibly undefined
// 405D94: variable 'v39' is possibly undefined
// 405D94: variable 'v40' is possibly undefined
// 405D94: variable 'v41' is possibly undefined
// 405D94: variable 'v28' is possibly undefined
// 405D94: variable 'v29' is possibly undefined
// 405D94: variable 'v30' is possibly undefined
// 405D94: variable 'v31' is possibly undefined
// 405D94: variable 'v32' is possibly undefined
// 405D94: variable 'v33' is possibly undefined
// 405D0C: variable 'v50' is possibly undefined
// 405D14: variable 'v44' is possibly undefined
// 405D14: variable 'v45' is possibly undefined
// 405D14: variable 'v46' is possibly undefined
// 405D14: variable 'v47' is possibly undefined
// 405D14: variable 'v48' is possibly undefined
// 405D14: variable 'v49' is possibly undefined
// 405D50: variable 'v52' is possibly undefined
// 405D50: variable 'v53' is possibly undefined
// 405D50: variable 'v54' is possibly undefined
// 405D50: variable 'v55' is possibly undefined
// 405D50: variable 'v56' is possibly undefined
// 405D50: variable 'v57' is possibly undefined
// 405D50: variable 'v58' is possibly undefined
// 405D50: variable 'v59' is possibly undefined
// 42FB60: using guessed type __int64 __fastcall funlockfile();
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000405DE0) ----------------------------------------------------
char *__fastcall _get_errname(signed int a1)
{
  if ( (unsigned int)a1 > 0x85 || a1 && !sys_errnameidx[a1] )
    return 0LL;
  else
    return (char *)&sys_errname + sys_errnameidx[a1];
}
// 45B190: using guessed type unsigned __int16 sys_errnameidx[136];

//----- (0000000000405E20) ----------------------------------------------------
__int64 __fastcall _parse_one_specmb(unsigned __int8 *a1, int a2, __int64 a3, unsigned __int64 *a4, _BYTE *a5)
{
  __int64 v5; // x6
  __int16 v7; // w2
  unsigned __int8 *v8; // x5
  unsigned int v9; // w2
  unsigned int v10; // w1
  int v11; // w0
  int v12; // w0
  __int64 v13; // x8
  __int64 v14; // x0
  unsigned __int8 *v15; // x0
  unsigned int v16; // w1
  unsigned __int8 *v17; // x1
  int v18; // w1
  int v19; // w3
  unsigned __int8 *v20; // x0
  __int64 (__fastcall *v22)(__int64, __int64, __int64, __int64); // x4
  int v23; // w0
  __int64 v24; // x2
  unsigned __int8 *v25; // x2
  int v26; // w1
  unsigned int v27; // w1
  int v28; // w0
  int v29; // w0
  int v30; // w0
  int v31; // w0
  int v32; // w0
  unsigned __int8 *v33; // x2
  int v34; // w10
  int v35; // w9
  unsigned __int8 *v36; // x8
  int v37; // w2
  int v38; // w10
  int v39; // w9
  int v40; // w2
  unsigned __int8 *v41; // x1
  int v42; // w10
  unsigned __int8 *v43; // x2
  int v44; // w9
  int v45; // w8
  __int16 v46; // w0
  int v47; // w0
  unsigned __int8 *v48; // x0
  unsigned __int8 *v49; // x2
  int v50; // w1
  unsigned int v51; // w1
  int v52; // w0
  int v53; // w1
  int v54; // w2
  __int16 v55; // w2
  __int16 v56; // w1
  unsigned __int8 *v57; // x2
  int v58; // w11
  int v59; // w9
  unsigned __int8 *v60; // x1
  unsigned __int64 v61; // x0
  int v62; // w11
  int v63; // w8
  int v64; // w0
  int v65; // w11
  unsigned __int8 *v66; // x0
  int v67; // w10
  unsigned int v68; // w1
  unsigned __int8 *j; // x3
  int v70; // w2
  int v71; // t1
  unsigned __int64 v73; // x1
  unsigned __int8 *v74; // x1
  int v75; // w0
  int v76; // w12
  int v77; // w10
  int v78; // w0
  int v79; // w12
  unsigned __int8 *v80; // x0
  unsigned __int64 v83; // x2
  unsigned __int64 v85; // x0
  unsigned __int64 v87; // x2
  unsigned __int64 v89; // x0
  __int64 v90; // [xsp+18h] [xbp+18h]
  __int64 v91; // [xsp+18h] [xbp+18h]
  __int64 v92; // [xsp+20h] [xbp+20h]
  __int64 v93; // [xsp+20h] [xbp+20h]
  __int64 v94; // [xsp+20h] [xbp+20h]
  int v95; // [xsp+28h] [xbp+28h]
  int v96; // [xsp+28h] [xbp+28h]
  _BYTE *v97; // [xsp+30h] [xbp+30h]
  unsigned __int8 *i; // [xsp+38h] [xbp+38h] BYREF

  v5 = a3;
  *(_DWORD *)(a3 + 48) = -1;
  *(_DWORD *)(a3 + 16) = 32;
  v7 = *(_WORD *)(a3 + 12);
  v8 = a1 + 1;
  i = a1 + 1;
  *(_WORD *)(v5 + 12) = v7 & 0xE207;
  *a5 = 0;
  v9 = a1[1];
  v10 = v9 - 48;
  if ( v9 - 48 > 9 )
    goto LABEL_8;
  v36 = a1 + 2;
  i = a1 + 2;
  v37 = v9 - 48;
  v38 = a1[2];
  v39 = v38 - 48;
  if ( (unsigned int)(v38 - 48) > 9 )
  {
    if ( v38 != 36 || v10 == 0 )
      goto LABEL_71;
    v8 = a1 + 3;
  }
  else
  {
    while ( 1 )
    {
      v40 = 10 * v37;
      if ( v40 > 0x7FFFFFFF - v39 )
      {
        v43 = v36 + 1;
        i = v36 + 1;
        v44 = v36[1];
        if ( (unsigned int)(v44 - 48) > 9 )
        {
          v41 = v36;
          goto LABEL_74;
        }
        do
        {
LABEL_69:
          v41 = v43++;
          i = v43;
          v45 = v41[1];
        }
        while ( (unsigned int)(v45 - 48) <= 9 );
        if ( v45 == 36 )
        {
LABEL_75:
          v8 = v41 + 2;
          i = v41 + 2;
          v9 = v41[2];
          goto LABEL_8;
        }
LABEL_71:
        i = a1 + 1;
        v9 = a1[1];
        goto LABEL_8;
      }
      v41 = v36 + 1;
      i = v36 + 1;
      v37 = v39 + v40;
      v42 = v36[1];
      v39 = v42 - 48;
      if ( (unsigned int)(v42 - 48) > 9 )
        break;
      if ( v37 > 214748364 )
      {
        v43 = v36 + 2;
        i = v36 + 2;
        v44 = v36[2];
        if ( (unsigned int)(v44 - 48) <= 9 )
          goto LABEL_69;
LABEL_74:
        if ( v44 == 36 )
          goto LABEL_75;
        goto LABEL_71;
      }
      ++v36;
    }
    if ( v42 != 36 || v37 == 0 )
      goto LABEL_71;
    v8 = v36 + 2;
  }
  v73 = *a4;
  *(_DWORD *)(v5 + 48) = v37 - 1;
  i = v8;
  if ( v73 < (unsigned int)v37 )
    v73 = (unsigned int)v37;
  *a4 = v73;
  v9 = *v8;
  do
  {
LABEL_8:
    while ( v9 == 43 )
    {
      *(_WORD *)(v5 + 12) |= 0x40u;
LABEL_7:
      i = ++v8;
      v9 = *v8;
      if ( !*v8 )
        goto LABEL_14;
    }
    if ( v9 <= 0x2B )
    {
      switch ( v9 )
      {
        case '#':
          *(_WORD *)(v5 + 12) |= 8u;
          break;
        case '\'':
          *(_WORD *)(v5 + 12) |= 0x80u;
          break;
        case ' ':
          *(_WORD *)(v5 + 12) |= 0x10u;
          break;
        default:
          goto LABEL_14;
      }
      goto LABEL_7;
    }
    if ( v9 == 48 )
    {
      *(_DWORD *)(v5 + 16) = 48;
      goto LABEL_7;
    }
    if ( v9 == 73 )
    {
      *(_WORD *)(v5 + 12) |= 0x800u;
      goto LABEL_7;
    }
    if ( v9 != 45 )
      break;
    ++v8;
    *(_WORD *)(v5 + 12) |= 0x20u;
    i = v8;
    v9 = *v8;
  }
  while ( *v8 );
LABEL_14:
  if ( (*(_WORD *)(v5 + 12) & 0x20) != 0 )
    *(_DWORD *)(v5 + 16) = 32;
  *(_DWORD *)(v5 + 4) = 0;
  *(_DWORD *)(v5 + 44) = -1;
  v11 = *v8;
  if ( v11 == 42 )
  {
    v33 = v8 + 1;
    i = v8 + 1;
    v34 = v8[1];
    v35 = v34 - 48;
    if ( (unsigned int)(v34 - 48) > 9 )
    {
LABEL_63:
      ++v8;
      v13 = 1LL;
      *(_DWORD *)(v5 + 44) = a2++;
      i = v33;
      goto LABEL_18;
    }
    v60 = v8 + 2;
    i = v8 + 2;
    LODWORD(v61) = v34 - 48;
    v62 = v8[2];
    v63 = v62 - 48;
    if ( (unsigned int)(v62 - 48) > 9 )
    {
      if ( v62 != 36 || v34 == 48 )
        goto LABEL_63;
      v85 = *a4;
      *(_DWORD *)(v5 + 44) = v34 - 49;
      v8 += 3;
      if ( v85 < v35 )
        v85 = v35;
      v13 = 0LL;
      *a4 = v85;
      i = v8;
    }
    else
    {
      while ( 1 )
      {
        v64 = 10 * v61;
        if ( v64 > 0x7FFFFFFF - v63 )
        {
          v66 = v60 + 1;
          i = v60 + 1;
          if ( (unsigned int)v60[1] - 48 > 9 )
            goto LABEL_63;
          goto LABEL_117;
        }
        i = v60 + 1;
        v61 = (unsigned int)(v63 + v64);
        v65 = v60[1];
        v63 = v65 - 48;
        if ( (unsigned int)(v65 - 48) > 9 )
          break;
        if ( (int)v61 > 214748364 )
        {
          v66 = v60 + 2;
          i = v60 + 2;
          if ( (unsigned int)v60[2] - 48 > 9 )
            goto LABEL_63;
          do
LABEL_117:
            i = ++v66;
          while ( (unsigned int)*v66 - 48 <= 9 );
          goto LABEL_63;
        }
        ++v60;
      }
      if ( v65 != 36 || (_DWORD)v61 == 0 )
        goto LABEL_63;
      *(_DWORD *)(v5 + 44) = v61 - 1;
      v83 = *a4;
      v8 = v60 + 2;
      v13 = 0LL;
      i = v60 + 2;
      if ( v83 < v61 )
        v83 = v61;
      *a4 = v83;
    }
LABEL_18:
    *(_DWORD *)v5 = -1;
    *(_DWORD *)(v5 + 40) = -1;
    if ( *v8 == 46 )
      goto LABEL_56;
    goto LABEL_19;
  }
  v12 = v11 - 48;
  v13 = 0LL;
  if ( (unsigned int)v12 > 9 )
    goto LABEL_18;
  v25 = v8 + 1;
  i = v8 + 1;
  v26 = *++v8;
  v27 = v26 - 48;
  if ( v27 > 9 )
  {
LABEL_99:
    v13 = 0LL;
    *(_DWORD *)(v5 + 4) = v12;
  }
  else
  {
    while ( 1 )
    {
      v28 = 10 * v12;
      if ( v28 > (int)(0x7FFFFFFF - v27) )
        break;
      v8 = v25 + 1;
      i = v25 + 1;
      v12 = v27 + v28;
      v27 = v25[1] - 48;
      if ( v27 > 9 )
        goto LABEL_99;
      if ( v12 > 214748364 )
      {
        v8 = v25 + 2;
        for ( i = v25 + 2; (unsigned int)*v8 - 48 <= 9; i = v8 )
LABEL_53:
          ++v8;
        v13 = 0LL;
        goto LABEL_55;
      }
      ++v25;
    }
    v8 = v25 + 1;
    i = v25 + 1;
    if ( (unsigned int)v25[1] - 48 <= 9 )
      goto LABEL_53;
    v13 = 0LL;
  }
LABEL_55:
  *(_DWORD *)v5 = -1;
  *(_DWORD *)(v5 + 40) = -1;
  if ( *v8 == 46 )
  {
LABEL_56:
    i = v8 + 1;
    v29 = v8[1];
    if ( v29 == 42 )
    {
      v57 = v8 + 2;
      i = v8 + 2;
      v58 = v8[2];
      v59 = v58 - 48;
      if ( (unsigned int)(v58 - 48) <= 9 )
      {
        v74 = v8 + 3;
        i = v8 + 3;
        v75 = v58 - 48;
        v76 = v8[3];
        v77 = v76 - 48;
        if ( (unsigned int)(v76 - 48) > 9 )
        {
          if ( v76 == 36 && v58 != 48 )
          {
            v89 = *a4;
            *(_DWORD *)(v5 + 40) = v58 - 49;
            v8 += 4;
            i = v8;
            if ( v89 < v59 )
              v89 = v59;
            *a4 = v89;
            goto LABEL_19;
          }
        }
        else
        {
          while ( 1 )
          {
            v78 = 10 * v75;
            if ( v78 > 0x7FFFFFFF - v77 )
            {
              v80 = v74 + 1;
              i = v74 + 1;
              if ( (unsigned int)v74[1] - 48 > 9 )
                goto LABEL_111;
              goto LABEL_169;
            }
            i = v74 + 1;
            v75 = v77 + v78;
            v79 = v74[1];
            v77 = v79 - 48;
            if ( (unsigned int)(v79 - 48) > 9 )
              break;
            if ( v75 > 214748364 )
            {
              v80 = v74 + 2;
              i = v74 + 2;
              if ( (unsigned int)v74[2] - 48 > 9 )
                goto LABEL_111;
              do
LABEL_169:
                i = ++v80;
              while ( (unsigned int)*v80 - 48 <= 9 );
              goto LABEL_111;
            }
            ++v74;
          }
          if ( v79 == 36 && v75 != 0 )
          {
            *(_DWORD *)(v5 + 40) = v75 - 1;
            v87 = *a4;
            if ( *a4 < (unsigned int)v75 )
              v87 = (unsigned int)v75;
            v8 = v74 + 2;
            *a4 = v87;
            i = v74 + 2;
            goto LABEL_19;
          }
        }
      }
LABEL_111:
      ++v13;
      v8 += 2;
      *(_DWORD *)(v5 + 40) = a2++;
      i = v57;
      goto LABEL_19;
    }
    v30 = v29 - 48;
    if ( (unsigned int)v30 > 9 )
    {
      v31 = *(_DWORD *)(v5 + 12);
      ++v8;
      *(_DWORD *)v5 = 0;
      *(_DWORD *)(v5 + 12) = v31 & 0xFDF8;
      v14 = _printf_modifier_table;
      if ( _printf_modifier_table )
        goto LABEL_59;
      goto LABEL_20;
    }
    v49 = v8 + 2;
    i = v8 + 2;
    v50 = v8[2];
    v8 += 2;
    v51 = v50 - 48;
    if ( v51 > 9 )
    {
LABEL_148:
      *(_DWORD *)v5 = v30;
    }
    else
    {
      while ( 1 )
      {
        v52 = 10 * v30;
        if ( v52 > (int)(0x7FFFFFFF - v51) )
          break;
        v8 = v49 + 1;
        i = v49 + 1;
        v30 = v51 + v52;
        v51 = v49[1] - 48;
        if ( v51 > 9 )
          goto LABEL_148;
        if ( v30 > 214748364 )
        {
          v8 = v49 + 2;
          i = v49 + 2;
          if ( (unsigned int)v49[2] - 48 > 9 )
            goto LABEL_19;
          goto LABEL_97;
        }
        ++v49;
      }
      v8 = v49 + 1;
      i = v49 + 1;
      if ( (unsigned int)v49[1] - 48 > 9 )
        goto LABEL_19;
      do
LABEL_97:
        i = ++v8;
      while ( (unsigned int)*v8 - 48 <= 9 );
    }
  }
LABEL_19:
  *(_DWORD *)(v5 + 12) &= 0xFDF8u;
  v14 = _printf_modifier_table;
  if ( !_printf_modifier_table )
    goto LABEL_20;
LABEL_59:
  if ( *(_QWORD *)(v14 + 8LL * *v8) )
  {
    v91 = v5;
    v93 = v13;
    v96 = a2;
    v97 = a5;
    v32 = _handle_registered_modifier_mb(&i, v5);
    v8 = i;
    v5 = v91;
    v13 = v93;
    a2 = v96;
    a5 = v97;
    if ( !v32 )
    {
      v17 = i + 1;
      v15 = i;
      goto LABEL_28;
    }
  }
LABEL_20:
  v15 = v8 + 1;
  i = v8 + 1;
  v16 = *v8;
  if ( v16 == 108 )
  {
    v55 = *(_WORD *)(v5 + 12) | 4;
    *(_WORD *)(v5 + 12) = v55;
    v56 = v55;
    if ( v8[1] == 108 )
    {
      v15 = v8 + 2;
LABEL_107:
      *(_WORD *)(v5 + 12) = v56 | 1;
      v17 = v15 + 1;
      goto LABEL_28;
    }
LABEL_27:
    v17 = v8 + 2;
    goto LABEL_28;
  }
  if ( v16 > 0x6C )
  {
    if ( v16 != 119 )
    {
      if ( v16 > 0x77 )
      {
        if ( v16 != 122 )
          goto LABEL_42;
      }
      else
      {
        if ( v16 == 113 )
          goto LABEL_106;
        if ( v16 != 116 )
          goto LABEL_42;
      }
      goto LABEL_26;
    }
    v53 = v8[1];
    if ( v53 == 102 )
    {
      v15 = v8 + 2;
      i = v8 + 2;
      v17 = v8 + 3;
      v54 = v8[2] - 48;
      if ( (unsigned int)v54 > 9 )
        goto LABEL_103;
      v15 = v8 + 3;
      i = v8 + 3;
      v67 = 1;
      v68 = v8[3] - 48;
      if ( v68 <= 9 )
        goto LABEL_126;
LABEL_161:
      if ( v54 != 8 )
        goto LABEL_102;
    }
    else
    {
      v54 = v53 - 48;
      if ( (unsigned int)(v53 - 48) > 9 )
      {
LABEL_102:
        v17 = v15 + 1;
        goto LABEL_103;
      }
      v15 = v8 + 2;
      i = v8 + 2;
      v67 = 0;
      v68 = v8[2] - 48;
      if ( v68 <= 9 )
      {
LABEL_126:
        for ( j = v15 + 1; ; ++j )
        {
          v70 = 10 * v54;
          if ( (int)(0x7FFFFFFF - v68) < v70 )
          {
            i = j;
            v15 = j;
            if ( (unsigned int)*j - 48 > 9 )
              goto LABEL_102;
            v17 = j + 1;
            do
            {
LABEL_132:
              i = v17;
              v15 = v17;
              v71 = *v17++;
            }
            while ( (unsigned int)(v71 - 48) <= 9 );
            goto LABEL_103;
          }
          i = j;
          v54 = v70 + v68;
          v15 = j;
          v68 = *j - 48;
          if ( v68 > 9 )
            break;
          v15 = j + 1;
          if ( v54 > 214748364 )
          {
            i = j + 1;
            if ( (unsigned int)j[1] - 48 > 9 )
              goto LABEL_102;
            v17 = j + 2;
            goto LABEL_132;
          }
        }
        if ( v67 )
        {
          if ( v54 != 16 )
          {
            if ( v54 <= 16 )
              goto LABEL_161;
            if ( ((v54 - 32) & 0xFFFFFFDF) != 0 )
            {
              v17 = j + 1;
              goto LABEL_197;
            }
          }
LABEL_202:
          *(_BYTE *)(v5 + 12) |= 5u;
          v17 = j + 1;
          goto LABEL_28;
        }
        v17 = j + 1;
        if ( v54 == 32 )
        {
LABEL_28:
          i = v17;
          v18 = *v15;
          *(_DWORD *)(v5 + 64) = -1;
          *(_DWORD *)(v5 + 8) = v18;
          if ( _printf_function_table )
            goto LABEL_43;
          goto LABEL_29;
        }
LABEL_197:
        if ( v54 <= 32 )
          goto LABEL_198;
        v17 = j + 1;
        if ( v54 == 64 )
          goto LABEL_202;
LABEL_103:
        *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
        *a5 = 1;
        goto LABEL_28;
      }
      v17 = v8 + 3;
LABEL_198:
      if ( v54 != 8 )
      {
        if ( v54 == 16 )
        {
          *(_WORD *)(v5 + 12) |= 2u;
          goto LABEL_28;
        }
        goto LABEL_102;
      }
    }
    *(_WORD *)(v5 + 12) |= 0x200u;
    v17 = v15 + 1;
    goto LABEL_28;
  }
  if ( v16 == 104 )
  {
    if ( v8[1] == 104 )
    {
      v15 = v8 + 2;
      *(_WORD *)(v5 + 12) |= 0x200u;
      v17 = v8 + 3;
    }
    else
    {
      *(_WORD *)(v5 + 12) |= 2u;
      v17 = v8 + 2;
    }
    goto LABEL_28;
  }
  if ( v16 > 0x68 )
  {
    if ( v16 != 106 )
      goto LABEL_42;
LABEL_26:
    *(_WORD *)(v5 + 12) |= 4u;
    goto LABEL_27;
  }
  if ( v16 == 76 )
  {
LABEL_106:
    v56 = *(_WORD *)(v5 + 12);
    goto LABEL_107;
  }
  if ( v16 == 90 )
    goto LABEL_26;
LABEL_42:
  i = v8 + 1;
  v18 = *v8;
  *(_DWORD *)(v5 + 64) = -1;
  *(_DWORD *)(v5 + 8) = v18;
  if ( _printf_function_table )
  {
LABEL_43:
    v22 = *(__int64 (__fastcall **)(__int64, __int64, __int64, __int64))(_printf_arginfo_table
                                                                       + 8LL * (unsigned __int8)v18);
    if ( v22 )
    {
      v90 = v5;
      v92 = v13;
      v95 = a2;
      v23 = v22(v5, 1LL, v5 + 52, v5 + 64);
      v5 = v90;
      v13 = v92;
      v24 = v23;
      *(_QWORD *)(v90 + 56) = v23;
      a2 = v95;
      v18 = *(_DWORD *)(v90 + 8);
      if ( (v23 & 0x80000000) == 0 )
      {
        if ( *(_DWORD *)(v90 + 48) == -1 && v23 )
          goto LABEL_47;
        goto LABEL_31;
      }
    }
  }
LABEL_29:
  *(_QWORD *)(v5 + 56) = 1LL;
  v19 = *(_DWORD *)(v5 + 48);
  switch ( v18 )
  {
    case 'A':
    case 'E':
    case 'F':
    case 'G':
    case 'a':
    case 'e':
    case 'f':
    case 'g':
      if ( (*(_WORD *)(v5 + 12) & 1) != 0 )
        v47 = 263;
      else
        v47 = 7;
      goto LABEL_90;
    case 'B':
    case 'X':
    case 'b':
    case 'd':
    case 'i':
    case 'o':
    case 'u':
    case 'x':
      v46 = *(_WORD *)(v5 + 12);
      if ( (v46 & 4) != 0 )
      {
        v47 = 512;
      }
      else if ( (v46 & 2) != 0 )
      {
        v47 = 1024;
      }
      else
      {
        if ( (*(_WORD *)(v5 + 12) & 0x200) == 0 )
        {
          *(_DWORD *)(v5 + 52) = 0;
          if ( v19 == -1 )
          {
LABEL_135:
            ++v13;
            *(_DWORD *)(v5 + 48) = a2;
          }
          goto LABEL_91;
        }
        v47 = 1;
      }
LABEL_90:
      *(_DWORD *)(v5 + 52) = v47;
      if ( v19 != -1 )
        goto LABEL_91;
      v18 = *(_DWORD *)(v5 + 8);
      v24 = 1LL;
      break;
    case 'C':
      *(_DWORD *)(v5 + 52) = 2;
      if ( v19 != -1 )
        goto LABEL_91;
      goto LABEL_135;
    case 'S':
      *(_DWORD *)(v5 + 52) = 4;
      if ( v19 != -1 )
        goto LABEL_91;
      goto LABEL_135;
    case 'c':
      *(_DWORD *)(v5 + 52) = 1;
      if ( v19 != -1 )
        goto LABEL_91;
      goto LABEL_135;
    case 'n':
      *(_DWORD *)(v5 + 52) = 2048;
      if ( v19 != -1 )
        goto LABEL_91;
      goto LABEL_135;
    case 'p':
      *(_DWORD *)(v5 + 52) = 5;
      if ( v19 != -1 )
        goto LABEL_91;
      goto LABEL_135;
    case 's':
      *(_DWORD *)(v5 + 52) = 3;
      if ( v19 != -1 )
        goto LABEL_91;
      goto LABEL_135;
    default:
      *(_QWORD *)(v5 + 56) = 0LL;
      goto LABEL_31;
  }
LABEL_47:
  v13 += v24;
  *(_DWORD *)(v5 + 48) = a2;
LABEL_31:
  if ( v18 )
  {
LABEL_91:
    v48 = i;
    *(_QWORD *)(v5 + 24) = i;
    v94 = v13;
    *(_QWORD *)(v5 + 32) = strchrnul((__int64)v48, 0x25u);
    return v94;
  }
  else
  {
    v20 = i - 1;
    *(_QWORD *)(v5 + 24) = i - 1;
    *(_QWORD *)(v5 + 32) = v20;
    return v13;
  }
}
// 496F60: using guessed type __int64 _printf_modifier_table;
// 496F70: using guessed type __int64 _printf_function_table;
// 496F78: using guessed type __int64 _printf_arginfo_table;

//----- (0000000000406A80) ----------------------------------------------------
__int64 __fastcall fflush(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v10; // x1
  unsigned int v11; // w2
  __int64 v12; // x1
  int v13; // w0
  unsigned __int64 StatusReg; // x3
  __int64 v16; // x2
  __int64 v17; // x3
  __int64 v18; // x0
  __int64 v19; // x1
  __int64 v20; // x2
  void *v21; // x4
  void *v22; // x5
  void *v23; // x6
  __int64 v24; // x3
  int v25; // w0
  void *v26; // x19
  __int64 v27; // x1
  __int64 v28; // x3
  void *v29; // x4
  void *v30; // x5
  void *v31; // x6
  int v32; // w0
  _DWORD *v33; // [xsp+20h] [xbp+20h]
  unsigned int v34; // [xsp+20h] [xbp+20h]
  __int64 v35; // [xsp+20h] [xbp+20h]
  __int64 v36; // [xsp+28h] [xbp+28h]

  if ( !a1 )
    return IO_flush_all();
  if ( (*(_DWORD *)a1 & 0x8000) == 0 )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v16 = *(_QWORD *)(a1 + 136);
    v17 = StatusReg - 1824;
    v18 = *(_QWORD *)(v16 + 8);
    if ( _libc_single_threaded && !v18 )
    {
      *(_DWORD *)v16 = 1;
      *(_QWORD *)(v16 + 8) = v17;
    }
    else if ( v17 == v18 )
    {
      ++*(_DWORD *)(v16 + 4);
    }
    else
    {
      v33 = *(_DWORD **)(a1 + 136);
      v36 = v17;
      _aarch64_cas4_acq();
      v24 = v36;
      if ( v25 )
      {
        _lll_lock_wait_private(v33, a2, a3, a4, a5, a6, a7, a8, a9, v19, v20, v36, v21, v22, v23);
        v24 = v36;
      }
      *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8LL) = v24;
    }
  }
  v10 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v10 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v35 = *(_QWORD *)(a1 + 216);
    IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
    v10 = v35;
  }
  if ( (*(unsigned int (__fastcall **)(__int64))(v10 + 96))(a1) )
    v11 = -1;
  else
    v11 = 0;
  if ( (*(_DWORD *)a1 & 0x8000) != 0 )
    return v11;
  v12 = *(_QWORD *)(a1 + 136);
  v13 = *(_DWORD *)(v12 + 4);
  if ( _libc_single_threaded )
  {
    if ( !v13 )
    {
      *(_QWORD *)(v12 + 8) = 0LL;
      **(_DWORD **)(a1 + 136) = 0;
      return v11;
    }
  }
  else if ( !v13 )
  {
    *(_QWORD *)(v12 + 8) = 0LL;
    v34 = v11;
    v26 = *(void **)(a1 + 136);
    _aarch64_swp4_rel();
    v11 = v34;
    if ( v32 > 1 )
    {
      _lll_lock_wake_private(v26, v27, v34, v28, v29, v30, v31);
      return v34;
    }
    return v11;
  }
  *(_DWORD *)(v12 + 4) = v13 - 1;
  return v11;
}
// 406BD0: variable 'a2' is possibly undefined
// 406BD0: variable 'a3' is possibly undefined
// 406BD0: variable 'a4' is possibly undefined
// 406BD0: variable 'a5' is possibly undefined
// 406BD0: variable 'a6' is possibly undefined
// 406BD0: variable 'a7' is possibly undefined
// 406BD0: variable 'a8' is possibly undefined
// 406BD0: variable 'a9' is possibly undefined
// 406B48: variable 'v25' is possibly undefined
// 406BE4: variable 'v19' is possibly undefined
// 406BE4: variable 'v20' is possibly undefined
// 406BE4: variable 'v21' is possibly undefined
// 406BE4: variable 'v22' is possibly undefined
// 406BE4: variable 'v23' is possibly undefined
// 406B90: variable 'v32' is possibly undefined
// 406B9C: variable 'v27' is possibly undefined
// 406B9C: variable 'v28' is possibly undefined
// 406B9C: variable 'v29' is possibly undefined
// 406B9C: variable 'v30' is possibly undefined
// 406B9C: variable 'v31' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000406BF0) ----------------------------------------------------
void __fastcall __noreturn sub_406BF0(_Unwind_Exception *exc)
{
  __int64 v1; // x19
  __int64 v3; // x1
  int v4; // w0
  void *v5; // x19
  __int64 v6; // x1
  __int64 v7; // x2
  __int64 v8; // x3
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  int v12; // w0

  if ( (*(_DWORD *)v1 & 0x8000) == 0 )
  {
    v3 = *(_QWORD *)(v1 + 136);
    v4 = *(_DWORD *)(v3 + 4);
    if ( _libc_single_threaded )
    {
      if ( !v4 )
      {
        *(_QWORD *)(v3 + 8) = 0LL;
        **(_DWORD **)(v1 + 136) = 0;
        goto LABEL_5;
      }
      goto LABEL_9;
    }
    if ( v4 )
    {
LABEL_9:
      *(_DWORD *)(v3 + 4) = v4 - 1;
      goto LABEL_5;
    }
    *(_QWORD *)(v3 + 8) = 0LL;
    v5 = *(void **)(v1 + 136);
    _aarch64_swp4_rel();
    if ( v12 > 1 )
      _lll_lock_wake_private(v5, v6, v7, v8, v9, v10, v11);
  }
LABEL_5:
  Unwind_Resume(exc);
}
// 406BF8: variable 'v1' is possibly undefined
// 406C44: variable 'v12' is possibly undefined
// 406C4C: variable 'v6' is possibly undefined
// 406C4C: variable 'v7' is possibly undefined
// 406C4C: variable 'v8' is possibly undefined
// 406C4C: variable 'v9' is possibly undefined
// 406C4C: variable 'v10' is possibly undefined
// 406C4C: variable 'v11' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000406C60) ----------------------------------------------------
__int64 __fastcall puts(unsigned __int64 a1)
{
  unsigned __int64 (__fastcall *v2)(__int64); // x19
  double v3; // d0
  double v4; // d1
  double v5; // d2
  double v6; // d3
  double v7; // d4
  double v8; // d5
  double v9; // d6
  double v10; // d7
  int *v11; // x20
  int *v12; // x0
  int v13; // w1
  __int64 v14; // x2
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  _BYTE *v23; // x1
  unsigned __int64 v24; // x19
  __int64 v25; // x1
  int v26; // w0
  unsigned __int64 StatusReg; // x3
  __int64 v29; // x2
  __int64 v30; // x3
  __int64 v31; // x0
  __int64 v32; // x1
  __int64 v33; // x2
  void *v34; // x4
  void *v35; // x5
  void *v36; // x6
  __int64 v37; // x3
  int v38; // w0
  void *v39; // x20
  __int64 v40; // x1
  __int64 v41; // x2
  __int64 v42; // x3
  void *v43; // x4
  void *v44; // x5
  void *v45; // x6
  int v46; // w0
  _DWORD *v47; // [xsp+30h] [xbp+30h]
  __int64 v48; // [xsp+30h] [xbp+30h]
  __int64 v49; // [xsp+38h] [xbp+38h]

  v2 = strlen();
  v11 = stdout;
  if ( (*stdout & 0x8000) == 0 )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v29 = *((_QWORD *)v11 + 17);
    v30 = StatusReg - 1824;
    v31 = *(_QWORD *)(v29 + 8);
    if ( !_libc_single_threaded || v31 )
    {
      if ( v30 != v31 )
      {
        v47 = (_DWORD *)*((_QWORD *)v11 + 17);
        v49 = v30;
        _aarch64_cas4_acq();
        v37 = v49;
        if ( v38 )
        {
          _lll_lock_wait_private(v47, v3, v4, v5, v6, v7, v8, v9, v10, v32, v33, v49, v34, v35, v36);
          v37 = v49;
        }
        *(_QWORD *)(*((_QWORD *)v11 + 17) + 8LL) = v37;
        v12 = stdout;
        v13 = stdout[48];
        if ( !v13 )
          goto LABEL_3;
        goto LABEL_21;
      }
      ++*(_DWORD *)(v29 + 4);
    }
    else
    {
      *(_DWORD *)v29 = 1;
      *(_QWORD *)(v29 + 8) = v30;
    }
  }
  v12 = v11;
  v13 = v11[48];
  if ( !v13 )
  {
LABEL_3:
    v12[48] = -1;
    goto LABEL_4;
  }
LABEL_21:
  if ( v13 != -1 )
  {
LABEL_22:
    LODWORD(v24) = -1;
    goto LABEL_11;
  }
LABEL_4:
  v14 = *((_QWORD *)v12 + 27);
  if ( (unsigned __int64)(v14 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v48 = *((_QWORD *)v12 + 27);
    IO_vtable_check(v3, v4, v5, v6, v7, v8, v9, v10);
    v12 = stdout;
    v14 = v48;
  }
  if ( v2 != (unsigned __int64 (__fastcall *)(__int64))(*(__int64 (__fastcall **)(_QWORD *, unsigned __int64, unsigned __int64, double, double, double, double, double, double, double, double))(v14 + 56))(
                                                         v12,
                                                         a1,
                                                         (unsigned __int64)v2,
                                                         v3,
                                                         v4,
                                                         v5,
                                                         v6,
                                                         v7,
                                                         v8,
                                                         v9,
                                                         v10) )
    goto LABEL_22;
  v23 = (_BYTE *)*((_QWORD *)stdout + 5);
  if ( (unsigned __int64)v23 >= *((_QWORD *)stdout + 6) )
  {
    if ( (unsigned int)_overflow((__int64)stdout, 0xAu, v15, v16, v17, v18, v19, v20, v21, v22) == -1 )
    {
      LODWORD(v24) = -1;
      goto LABEL_11;
    }
  }
  else
  {
    *((_QWORD *)stdout + 5) = v23 + 1;
    *v23 = 10;
  }
  v24 = (unsigned __int64)v2 + 1;
  if ( v24 > 0x7FFFFFFF )
    LODWORD(v24) = 0x7FFFFFFF;
LABEL_11:
  if ( (*v11 & 0x8000) != 0 )
    return (unsigned int)v24;
  v25 = *((_QWORD *)v11 + 17);
  v26 = *(_DWORD *)(v25 + 4);
  if ( !_libc_single_threaded )
  {
    if ( !v26 )
    {
      *(_QWORD *)(v25 + 8) = 0LL;
      v39 = (void *)*((_QWORD *)v11 + 17);
      _aarch64_swp4_rel();
      if ( v46 > 1 )
        _lll_lock_wake_private(v39, v40, v41, v42, v43, v44, v45);
      return (unsigned int)v24;
    }
    goto LABEL_14;
  }
  if ( v26 )
  {
LABEL_14:
    *(_DWORD *)(v25 + 4) = v26 - 1;
    return (unsigned int)v24;
  }
  *(_QWORD *)(v25 + 8) = 0LL;
  **((_DWORD **)v11 + 17) = 0;
  return (unsigned int)v24;
}
// 406E18: variable 'v3' is possibly undefined
// 406E18: variable 'v4' is possibly undefined
// 406E18: variable 'v5' is possibly undefined
// 406E18: variable 'v6' is possibly undefined
// 406E18: variable 'v7' is possibly undefined
// 406E18: variable 'v8' is possibly undefined
// 406E18: variable 'v9' is possibly undefined
// 406E18: variable 'v10' is possibly undefined
// 406D80: variable 'v38' is possibly undefined
// 406E48: variable 'v32' is possibly undefined
// 406E48: variable 'v33' is possibly undefined
// 406E48: variable 'v34' is possibly undefined
// 406E48: variable 'v35' is possibly undefined
// 406E48: variable 'v36' is possibly undefined
// 406DD4: variable 'v46' is possibly undefined
// 406DDC: variable 'v40' is possibly undefined
// 406DDC: variable 'v41' is possibly undefined
// 406DDC: variable 'v42' is possibly undefined
// 406DDC: variable 'v43' is possibly undefined
// 406DDC: variable 'v44' is possibly undefined
// 406DDC: variable 'v45' is possibly undefined
// 406E2C: variable 'v15' is possibly undefined
// 406E2C: variable 'v16' is possibly undefined
// 406E2C: variable 'v17' is possibly undefined
// 406E2C: variable 'v18' is possibly undefined
// 406E2C: variable 'v19' is possibly undefined
// 406E2C: variable 'v20' is possibly undefined
// 406E2C: variable 'v21' is possibly undefined
// 406E2C: variable 'v22' is possibly undefined
// 4905C0: using guessed type int *stdout;
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000406E54) ----------------------------------------------------
void __fastcall __noreturn sub_406E54(_Unwind_Exception *exc)
{
  __int64 v1; // x20
  __int64 v3; // x1
  int v4; // w0
  void *v5; // x19
  __int64 v6; // x1
  __int64 v7; // x2
  __int64 v8; // x3
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  int v12; // w0

  if ( (*(_DWORD *)v1 & 0x8000) == 0 )
  {
    v3 = *(_QWORD *)(v1 + 136);
    v4 = *(_DWORD *)(v3 + 4);
    if ( _libc_single_threaded )
    {
      if ( !v4 )
      {
        *(_QWORD *)(v3 + 8) = 0LL;
        **(_DWORD **)(v1 + 136) = 0;
        goto LABEL_5;
      }
      goto LABEL_9;
    }
    if ( v4 )
    {
LABEL_9:
      *(_DWORD *)(v3 + 4) = v4 - 1;
      goto LABEL_5;
    }
    *(_QWORD *)(v3 + 8) = 0LL;
    v5 = *(void **)(v1 + 136);
    _aarch64_swp4_rel();
    if ( v12 > 1 )
      _lll_lock_wake_private(v5, v6, v7, v8, v9, v10, v11);
  }
LABEL_5:
  Unwind_Resume(exc);
}
// 406E5C: variable 'v1' is possibly undefined
// 406EA8: variable 'v12' is possibly undefined
// 406EB0: variable 'v6' is possibly undefined
// 406EB0: variable 'v7' is possibly undefined
// 406EB0: variable 'v8' is possibly undefined
// 406EB0: variable 'v9' is possibly undefined
// 406EB0: variable 'v10' is possibly undefined
// 406EB0: variable 'v11' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000406EE0) ----------------------------------------------------
__int64 __fastcall setvbuf(
        __int64 a1,
        __int64 a2,
        int a3,
        __int64 a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  int v12; // w5
  __int64 v14; // x20
  unsigned int v15; // w4
  unsigned int v16; // w6
  __int64 v17; // x2
  unsigned __int64 v18; // x4
  __int64 v19; // x0
  __int64 v20; // x1
  __int64 v21; // x2
  void *v22; // x4
  int v23; // w0
  __int64 v24; // x1
  int v25; // w0
  __int64 v27; // x1
  __int64 v28; // x0
  void *v29; // x19
  __int64 v30; // x1
  __int64 v31; // x2
  __int64 v32; // x3
  void *v33; // x4
  void *v34; // x5
  int v35; // w0
  __int64 v36; // x20
  int v37; // w0
  _DWORD *v38; // [xsp+28h] [xbp+28h]
  unsigned int v39; // [xsp+28h] [xbp+28h]
  __int64 v40; // [xsp+28h] [xbp+28h]
  unsigned int v41; // [xsp+30h] [xbp+30h]
  __int64 v42; // [xsp+30h] [xbp+30h]
  __int64 v43; // [xsp+38h] [xbp+38h]
  unsigned int v44; // [xsp+44h] [xbp+44h]
  void *v45; // [xsp+48h] [xbp+48h]

  v12 = a3;
  v14 = a2;
  v15 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x8000) != 0 )
  {
    if ( a3 == 1 )
    {
      *(_DWORD *)a1 = v15 & 0xFFFFFDFD | 0x200;
      if ( !a2 )
        return 0;
      goto LABEL_23;
    }
    if ( a3 != 2 )
    {
      if ( a3 )
        return 0xFFFFFFFFLL;
      goto LABEL_22;
    }
LABEL_31:
    a4 = 0LL;
    v14 = 0LL;
    *(_DWORD *)a1 = v15 & 0xFFFFFDFD | 2;
    goto LABEL_23;
  }
  v16 = *(_DWORD *)a1 & 0x8000;
  v17 = *(_QWORD *)(a1 + 136);
  v18 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
  v19 = *(_QWORD *)(v17 + 8);
  if ( _libc_single_threaded && !v19 )
  {
    *(_DWORD *)v17 = 1;
    *(_QWORD *)(v17 + 8) = v18;
    goto LABEL_7;
  }
  if ( v18 != v19 )
  {
    v38 = (_DWORD *)v17;
    v41 = v16;
    v43 = a4;
    v44 = v12;
    v45 = (void *)v18;
    _aarch64_cas4_acq();
    a4 = v43;
    v22 = v45;
    v16 = v41;
    v12 = v44;
    if ( v23 )
    {
      _lll_lock_wait_private(v38, a5, a6, a7, a8, a9, a10, a11, a12, v20, v21, v43, v45, (void *)v44, (void *)v41);
      v22 = v45;
      a4 = v43;
      v16 = v41;
      v12 = v44;
    }
    *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8LL) = v22;
LABEL_7:
    v15 = *(_DWORD *)a1;
    if ( v12 != 1 )
      goto LABEL_8;
LABEL_41:
    v15 = v15 & 0xFFFFFDFD | 0x200;
    *(_DWORD *)a1 = v15;
    if ( !v14 )
      goto LABEL_11;
LABEL_23:
    v27 = *(_QWORD *)(a1 + 216);
    if ( (unsigned __int64)(v27 - (_QWORD)&_io_vtables) > 0x92F )
    {
      v40 = *(_QWORD *)(a1 + 216);
      v42 = a4;
      IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
      v27 = v40;
      a4 = v42;
    }
    v28 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v27 + 88))(a1, v14, a4);
    v15 = *(_DWORD *)a1;
    if ( v28 )
      v16 = 0;
    else
      v16 = -1;
    goto LABEL_11;
  }
  ++*(_DWORD *)(v17 + 4);
  v15 = *(_DWORD *)a1;
  if ( v12 == 1 )
    goto LABEL_41;
LABEL_8:
  if ( v12 == 2 )
    goto LABEL_31;
  if ( v12 )
    goto LABEL_10;
LABEL_22:
  v15 &= 0xFFFFFDFD;
  *(_DWORD *)a1 = v15;
  if ( v14 )
    goto LABEL_23;
  v16 = 0;
  if ( *(_QWORD *)(a1 + 56) )
    goto LABEL_11;
  v36 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v36 - (_QWORD)&_io_vtables) > 0x92F )
    IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
  v37 = (*(__int64 (__fastcall **)(__int64))(v36 + 104))(a1);
  v15 = *(_DWORD *)a1;
  if ( (v37 & 0x80000000) == 0 )
  {
    v15 &= ~0x200u;
    v16 = 0;
    *(_DWORD *)a1 = v15;
    goto LABEL_11;
  }
LABEL_10:
  v16 = -1;
LABEL_11:
  if ( (v15 & 0x8000) != 0 )
    return v16;
  v24 = *(_QWORD *)(a1 + 136);
  v25 = *(_DWORD *)(v24 + 4);
  if ( !_libc_single_threaded )
  {
    if ( !v25 )
    {
      *(_QWORD *)(v24 + 8) = 0LL;
      v39 = v16;
      v29 = *(void **)(a1 + 136);
      _aarch64_swp4_rel();
      v16 = v39;
      if ( v35 > 1 )
      {
        _lll_lock_wake_private(v29, v30, v31, v32, v33, v34, (void *)v39);
        return v39;
      }
      return v16;
    }
    goto LABEL_14;
  }
  if ( v25 )
  {
LABEL_14:
    *(_DWORD *)(v24 + 4) = v25 - 1;
    return v16;
  }
  *(_QWORD *)(v24 + 8) = 0LL;
  **(_DWORD **)(a1 + 136) = 0;
  return v16;
}
// 406F5C: variable 'v23' is possibly undefined
// 407160: variable 'a5' is possibly undefined
// 407160: variable 'a6' is possibly undefined
// 407160: variable 'a7' is possibly undefined
// 407160: variable 'a8' is possibly undefined
// 407160: variable 'a9' is possibly undefined
// 407160: variable 'a10' is possibly undefined
// 407160: variable 'a11' is possibly undefined
// 407160: variable 'a12' is possibly undefined
// 407160: variable 'v20' is possibly undefined
// 407160: variable 'v21' is possibly undefined
// 407064: variable 'v35' is possibly undefined
// 407070: variable 'v30' is possibly undefined
// 407070: variable 'v31' is possibly undefined
// 407070: variable 'v32' is possibly undefined
// 407070: variable 'v33' is possibly undefined
// 407070: variable 'v34' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000407180) ----------------------------------------------------
void __fastcall __noreturn sub_407180(_Unwind_Exception *exc)
{
  __int64 v1; // x19
  __int64 v3; // x1
  int v4; // w0
  void *v5; // x19
  __int64 v6; // x1
  __int64 v7; // x2
  __int64 v8; // x3
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  int v12; // w0

  if ( (*(_DWORD *)v1 & 0x8000) == 0 )
  {
    v3 = *(_QWORD *)(v1 + 136);
    v4 = *(_DWORD *)(v3 + 4);
    if ( _libc_single_threaded )
    {
      if ( !v4 )
      {
        *(_QWORD *)(v3 + 8) = 0LL;
        **(_DWORD **)(v1 + 136) = 0;
        goto LABEL_5;
      }
      goto LABEL_9;
    }
    if ( v4 )
    {
LABEL_9:
      *(_DWORD *)(v3 + 4) = v4 - 1;
      goto LABEL_5;
    }
    *(_QWORD *)(v3 + 8) = 0LL;
    v5 = *(void **)(v1 + 136);
    _aarch64_swp4_rel();
    if ( v12 > 1 )
      _lll_lock_wake_private(v5, v6, v7, v8, v9, v10, v11);
  }
LABEL_5:
  Unwind_Resume(exc);
}
// 407188: variable 'v1' is possibly undefined
// 4071D4: variable 'v12' is possibly undefined
// 4071DC: variable 'v6' is possibly undefined
// 4071DC: variable 'v7' is possibly undefined
// 4071DC: variable 'v8' is possibly undefined
// 4071DC: variable 'v9' is possibly undefined
// 4071DC: variable 'v10' is possibly undefined
// 4071DC: variable 'v11' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000407200) ----------------------------------------------------
__int64 __fastcall putchar(
        unsigned int a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  int *v10; // x19
  int *v11; // x0
  unsigned int v12; // w2
  _BYTE *v13; // x1
  __int64 v14; // x1
  int v15; // w0
  unsigned __int64 StatusReg; // x4
  __int64 v18; // x2
  void *v19; // x4
  void *v20; // x0
  __int64 v21; // x1
  __int64 v22; // x2
  void *v23; // x6
  void *v24; // x4
  int v25; // w0
  void *v26; // x19
  __int64 v27; // x1
  __int64 v28; // x3
  void *v29; // x4
  void *v30; // x5
  void *v31; // x6
  int v32; // w0
  _DWORD *v33; // [xsp+20h] [xbp+20h]
  unsigned int v34; // [xsp+20h] [xbp+20h]
  unsigned int v35; // [xsp+2Ch] [xbp+2Ch]
  void *v36; // [xsp+30h] [xbp+30h]

  v10 = stdout;
  if ( (*stdout & 0x8000) == 0 )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v18 = *((_QWORD *)v10 + 17);
    v19 = (void *)(StatusReg - 1824);
    v20 = *(void **)(v18 + 8);
    if ( !_libc_single_threaded || v20 )
    {
      if ( v19 != v20 )
      {
        v33 = (_DWORD *)*((_QWORD *)v10 + 17);
        v35 = a1;
        v36 = v19;
        _aarch64_cas4_acq();
        LOBYTE(a1) = v35;
        v24 = v36;
        if ( v25 )
        {
          _lll_lock_wait_private(v33, a2, a3, a4, a5, a6, a7, a8, a9, v21, v22, v35, v36, &stdout, v23);
          v24 = v36;
          LOBYTE(a1) = v35;
        }
        v12 = (unsigned __int8)a1;
        *(_QWORD *)(*((_QWORD *)v10 + 17) + 8LL) = v24;
        v11 = stdout;
        v13 = (_BYTE *)*((_QWORD *)stdout + 5);
        if ( (unsigned __int64)v13 < *((_QWORD *)stdout + 6) )
          goto LABEL_3;
        goto LABEL_14;
      }
      ++*(_DWORD *)(v18 + 4);
    }
    else
    {
      *(_DWORD *)v18 = 1;
      *(_QWORD *)(v18 + 8) = v19;
    }
  }
  v11 = v10;
  v12 = (unsigned __int8)a1;
  v13 = (_BYTE *)*((_QWORD *)v10 + 5);
  if ( (unsigned __int64)v13 < *((_QWORD *)v10 + 6) )
  {
LABEL_3:
    *((_QWORD *)v11 + 5) = v13 + 1;
    *v13 = a1;
    goto LABEL_4;
  }
LABEL_14:
  v12 = _overflow((__int64)v11, v12, a2, a3, a4, a5, a6, a7, a8, a9);
LABEL_4:
  if ( (*v10 & 0x8000) != 0 )
    return v12;
  v14 = *((_QWORD *)v10 + 17);
  v15 = *(_DWORD *)(v14 + 4);
  if ( !_libc_single_threaded )
  {
    if ( !v15 )
    {
      *(_QWORD *)(v14 + 8) = 0LL;
      v34 = v12;
      v26 = (void *)*((_QWORD *)v10 + 17);
      _aarch64_swp4_rel();
      v12 = v34;
      if ( v32 > 1 )
      {
        _lll_lock_wake_private(v26, v27, v34, v28, v29, v30, v31);
        return v34;
      }
      return v12;
    }
    goto LABEL_7;
  }
  if ( v15 )
  {
LABEL_7:
    *(_DWORD *)(v14 + 4) = v15 - 1;
    return v12;
  }
  *(_QWORD *)(v14 + 8) = 0LL;
  **((_DWORD **)v10 + 17) = 0;
  return v12;
}
// 4072C8: variable 'v25' is possibly undefined
// 407380: variable 'a2' is possibly undefined
// 407380: variable 'a3' is possibly undefined
// 407380: variable 'a4' is possibly undefined
// 407380: variable 'a5' is possibly undefined
// 407380: variable 'a6' is possibly undefined
// 407380: variable 'a7' is possibly undefined
// 407380: variable 'a8' is possibly undefined
// 407380: variable 'a9' is possibly undefined
// 407380: variable 'v21' is possibly undefined
// 407380: variable 'v22' is possibly undefined
// 407380: variable 'v23' is possibly undefined
// 40732C: variable 'v32' is possibly undefined
// 407338: variable 'v27' is possibly undefined
// 407338: variable 'v28' is possibly undefined
// 407338: variable 'v29' is possibly undefined
// 407338: variable 'v30' is possibly undefined
// 407338: variable 'v31' is possibly undefined
// 4905C0: using guessed type int *stdout;
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000407394) ----------------------------------------------------
void __fastcall __noreturn sub_407394(_Unwind_Exception *exc)
{
  __int64 v1; // x19
  __int64 v3; // x1
  int v4; // w0
  void *v5; // x19
  __int64 v6; // x1
  __int64 v7; // x2
  __int64 v8; // x3
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  int v12; // w0

  if ( (*(_DWORD *)v1 & 0x8000) == 0 )
  {
    v3 = *(_QWORD *)(v1 + 136);
    v4 = *(_DWORD *)(v3 + 4);
    if ( _libc_single_threaded )
    {
      if ( !v4 )
      {
        *(_QWORD *)(v3 + 8) = 0LL;
        **(_DWORD **)(v1 + 136) = 0;
        goto LABEL_5;
      }
      goto LABEL_9;
    }
    if ( v4 )
    {
LABEL_9:
      *(_DWORD *)(v3 + 4) = v4 - 1;
      goto LABEL_5;
    }
    *(_QWORD *)(v3 + 8) = 0LL;
    v5 = *(void **)(v1 + 136);
    _aarch64_swp4_rel();
    if ( v12 > 1 )
      _lll_lock_wake_private(v5, v6, v7, v8, v9, v10, v11);
  }
LABEL_5:
  Unwind_Resume(exc);
}
// 40739C: variable 'v1' is possibly undefined
// 4073E8: variable 'v12' is possibly undefined
// 4073F0: variable 'v6' is possibly undefined
// 4073F0: variable 'v7' is possibly undefined
// 4073F0: variable 'v8' is possibly undefined
// 4073F0: variable 'v9' is possibly undefined
// 4073F0: variable 'v10' is possibly undefined
// 4073F0: variable 'v11' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000407420) ----------------------------------------------------
void __noreturn _libc_message_impl(
        unsigned __int8 *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        ...)
{
  unsigned __int8 *v9; // x20
  int v10; // w21
  struct iovec *v11; // x22
  struct iovec *v12; // x23
  __int64 v13; // x25
  int i; // w24
  int v15; // w1
  unsigned __int8 *v16; // x0
  size_t v17; // x1
  unsigned __int8 *v18; // x21
  int v19; // w0
  int gr_offs; // w0
  void **stack; // x1
  void *v22; // x21
  size_t v23; // x0
  int v24; // w2
  size_t v25; // x20
  _DWORD *v26; // x0
  void *v27; // x21
  struct iovec *v28; // x19
  struct iovec *v29; // x24
  __int64 (__fastcall *v30)(__int64, __int64 *, unsigned __int64); // x1
  size_t iov_len; // x2
  unsigned int *v32; // x0
  gcc_va_list va; // [xsp+50h] [xbp+50h] BYREF
  struct iovec v34; // [xsp+70h] [xbp+70h] BYREF
  _OWORD v35[6]; // [xsp+80h] [xbp+80h] BYREF
  __int64 vars0; // [xsp+E8h] [xbp+E8h]
  __int64 vars8; // [xsp+F0h] [xbp+F0h]
  __int64 vars10; // [xsp+F8h] [xbp+F8h]
  __int64 vars18; // [xsp+100h] [xbp+100h]
  __int64 vars20; // [xsp+108h] [xbp+108h]
  __int64 vars28; // [xsp+110h] [xbp+110h]
  char v42; // [xsp+120h] [xbp+120h] BYREF

  va_start(va, a9);
  vars0 = va_arg(va, _QWORD);
  vars8 = va_arg(va, _QWORD);
  vars10 = va_arg(va, _QWORD);
  vars18 = va_arg(va, _QWORD);
  vars20 = va_arg(va, _QWORD);
  vars28 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a9);
  v9 = a1;
  v10 = *a1;
  va[0].__gr_offs = -56;
  if ( !*a1 )
    goto LABEL_22;
  v11 = &v34;
  v12 = &v34;
  v13 = 0LL;
  for ( i = 0; ; i = v19 )
  {
    v15 = v10;
    v16 = v9;
    do
    {
      if ( v15 == 37 && v16[1] == 115 )
        break;
      v16 = (unsigned __int8 *)strchrnul((__int64)(v16 + 1), 0x25u);
      v15 = *v16;
    }
    while ( *v16 );
    if ( v10 == 37 && v9[1] == 115 )
    {
      gr_offs = va[0].__gr_offs;
      stack = (void **)va[0].__stack;
      if ( va[0].__gr_offs < 0 && (va[0].__gr_offs += 8, gr_offs + 8 <= 0) )
        stack = (void **)(&v42 + gr_offs);
      else
        va[0].__stack = (void *)(((unsigned __int64)va[0].__stack + 15) & 0xFFFFFFFFFFFFFFF8LL);
      v22 = *stack;
      v9 += 2;
      v23 = (size_t)strlen();
      v12->iov_base = v22;
      v12->iov_len = v23;
      ++v12;
      v13 += v23;
      v10 = *v9;
      v19 = i + 1;
      if ( !*v9 )
      {
LABEL_14:
        v24 = v19;
        while ( linux_eabi_syscall(__NR_writev, 2, &v34, v24) == -4 )
          ;
        v25 = (dl_pagesize + 4 + v13) & -dl_pagesize;
        v26 = (_DWORD *)mmap64(0LL, v25, 3, 34, -1, 0LL);
        v27 = v26;
        if ( v26 != (_DWORD *)-1LL )
        {
          v28 = (struct iovec *)v35;
          *v26 = v25;
          v29 = (struct iovec *)&v35[i];
          while ( 1 )
          {
            v30 = j_memcpy();
            iov_len = v11->iov_len;
            v11 = v28;
            if ( v28 == v29 )
              break;
            ++v28;
          }
          *((_BYTE *)v30 + iov_len) = 0;
          _set_vma_name(v27);
          _aarch64_swp8_acq();
          if ( v32 )
            munmap(v32, *v32);
        }
LABEL_22:
        abort();
      }
    }
    else
    {
      v17 = v16 - v9;
      v18 = v9;
      v9 = v16;
      v12->iov_base = v18;
      v12->iov_len = v17;
      ++v12;
      v13 += v17;
      v19 = i + 1;
      v10 = *v9;
      if ( !*v9 )
        goto LABEL_14;
    }
  }
}
// 4075F8: variable 'v32' is possibly undefined
// 400300: using guessed type void __noreturn abort(void);
// 490F10: using guessed type __int64 dl_pagesize;

//----- (0000000000407624) ----------------------------------------------------
void __fastcall __noreturn _libc_fatal(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  _libc_message_impl("%s", a2, a3, a4, a5, a6, a7, a8, a9, a1);
}
// 407640: using guessed type __int64 IO_vtable_check(void);

//----- (0000000000407640) ----------------------------------------------------
__int64 (__fastcall *__fastcall IO_vtable_check(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8))()
{
  __int64 (__fastcall *result)(); // x0

  result = _dlopen;
  if ( !_dlopen )
    _libc_fatal((__int64)"Fatal error: glibc detected an invalid stdio handle\n", a1, a2, a3, a4, a5, a6, a7, a8);
  return result;
}
// 449900: using guessed type __int64 __fastcall _dlopen();

//----- (0000000000407680) ----------------------------------------------------
__int64 __fastcall new_do_write(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  __int64 v14; // x0
  __int64 v15; // x3
  int v16; // w0
  bool v17; // zf
  __int64 v18; // x1
  int v19; // w0
  __int64 v21; // x0
  __int64 v22; // x1
  __int64 v23; // x2
  __int64 v24; // x0
  __int16 v25; // w0
  __int64 v26; // [xsp+30h] [xbp+30h]
  __int64 v27; // [xsp+30h] [xbp+30h]
  __int64 v28; // [xsp+30h] [xbp+30h]
  __int64 v29; // [xsp+30h] [xbp+30h]
  __int64 v30; // [xsp+38h] [xbp+38h]
  __int64 v31; // [xsp+38h] [xbp+38h]

  if ( (*(_DWORD *)a1 & 0x1000) != 0 )
  {
    *(_QWORD *)(a1 + 144) = -1LL;
LABEL_3:
    v14 = *(_QWORD *)(a1 + 216);
    if ( (unsigned __int64)(v14 - (_QWORD)&_io_vtables) > 0x92F )
    {
      v28 = *(_QWORD *)(a1 + 216);
      v30 = a3;
      IO_vtable_check(a4, a5, a6, a7, a8, a9, a10, a11);
      v14 = v28;
      a3 = v30;
    }
    v15 = (*(__int64 (__fastcall **)(__int64, unsigned __int64, __int64))(v14 + 120))(a1, a2, a3);
    v16 = *(unsigned __int16 *)(a1 + 128);
    if ( v15 )
      v17 = v16 == 0;
    else
      v17 = 1;
    if ( !v17 )
    {
      v27 = v15;
      v25 = IO_adjust_column(v16 - 1, a2, v15);
      v15 = v27;
      *(_WORD *)(a1 + 128) = v25 + 1;
    }
    v18 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 8) = v18;
    *(_QWORD *)(a1 + 16) = v18;
    v19 = *(_DWORD *)(a1 + 192);
    *(_QWORD *)(a1 + 24) = v18;
    *(_QWORD *)(a1 + 32) = v18;
    *(_QWORD *)(a1 + 40) = v18;
    if ( v19 <= 0 )
    {
      if ( (*(_DWORD *)a1 & 0x202) == 0 )
        v18 = *(_QWORD *)(a1 + 64);
    }
    else
    {
      v18 = *(_QWORD *)(a1 + 64);
    }
    *(_QWORD *)(a1 + 48) = v18;
    return v15;
  }
  v21 = *(_QWORD *)(a1 + 16);
  v22 = *(_QWORD *)(a1 + 32);
  if ( v21 == v22 )
    goto LABEL_3;
  v23 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v23 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v29 = *(_QWORD *)(a1 + 216);
    v31 = a3;
    IO_vtable_check(a4, a5, a6, a7, a8, a9, a10, a11);
    v21 = *(_QWORD *)(a1 + 16);
    v22 = *(_QWORD *)(a1 + 32);
    v23 = v29;
    a3 = v31;
  }
  v26 = a3;
  v24 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v23 + 128))(a1, v22 - v21, 1LL);
  v15 = 0LL;
  if ( v24 != -1 )
  {
    a3 = v26;
    *(_QWORD *)(a1 + 144) = v24;
    goto LABEL_3;
  }
  return v15;
}
// 4077B4: variable 'a4' is possibly undefined
// 4077B4: variable 'a5' is possibly undefined
// 4077B4: variable 'a6' is possibly undefined
// 4077B4: variable 'a7' is possibly undefined
// 4077B4: variable 'a8' is possibly undefined
// 4077B4: variable 'a9' is possibly undefined
// 4077B4: variable 'a10' is possibly undefined
// 4077B4: variable 'a11' is possibly undefined

//----- (00000000004077E0) ----------------------------------------------------
__int64 __fastcall mmap_remap_check(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v10; // x20
  unsigned int v11; // w20
  __int64 v12; // x3
  char *v13; // x0
  __off_t v14; // x1
  size_t v15; // x2
  unsigned __int64 v16; // x4
  char *v17; // x5
  __int64 v18; // x2
  __int64 v19; // x3
  __off_t v20; // x2
  unsigned __int64 v21; // x0
  __int64 v22; // x1
  void *v23; // x1
  __int64 v24; // x1
  __off_t v26; // [xsp+28h] [xbp+28h]
  char v27[16]; // [xsp+30h] [xbp+30h] BYREF
  int v28; // [xsp+40h] [xbp+40h]
  __off_t v29; // [xsp+60h] [xbp+60h]

  v10 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v10 - (_QWORD)&_io_vtables) > 0x92F )
    IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
  v11 = (*(__int64 (__fastcall **)(__int64, char *))(v10 + 144))(a1, v27);
  if ( v11 || (v28 & 0xF000) != 0x8000 || !v29 )
    goto LABEL_11;
  v26 = v29;
  v12 = (int)getpagesize();
  v13 = *(char **)(a1 + 56);
  v14 = v26;
  v15 = (v26 - 1 + v12) & -v12;
  v16 = (*(_QWORD *)(a1 + 64) - (_QWORD)v13 - 1LL + v12) & -v12;
  if ( v15 >= v16 )
  {
    v17 = &v13[v26];
    if ( v15 <= v16 )
      goto LABEL_8;
    v13 = (char *)mremap(v13, (*(_QWORD *)(a1 + 64) - (_QWORD)v13 - 1LL + v12) & -v12, v15, 1u);
    if ( v13 != (char *)-1LL )
    {
      v14 = v29;
      *(_QWORD *)(a1 + 56) = v13;
      v17 = &v13[v14];
      goto LABEL_8;
    }
LABEL_11:
    v11 = 1;
    munmap(*(void **)(a1 + 56), *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56));
    v23 = &IO_wfile_jumps;
    if ( *(int *)(a1 + 192) <= 0 )
      v23 = &IO_file_jumps;
    *(_QWORD *)(a1 + 216) = v23;
    v24 = *(_QWORD *)(a1 + 160);
    *(_QWORD *)(a1 + 24) = 0LL;
    *(_OWORD *)(a1 + 8) = 0uLL;
    *(_OWORD *)(a1 + 56) = 0uLL;
    *(_QWORD *)(v24 + 224) = &IO_wfile_jumps;
    return v11;
  }
  munmap(&v13[v15], v16 - v15);
  v13 = *(char **)(a1 + 56);
  v14 = v29;
  v17 = &v13[v29];
LABEL_8:
  v18 = *(_QWORD *)(a1 + 8);
  v19 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 24) = v13;
  *(_QWORD *)(a1 + 64) = v17;
  v20 = *(_QWORD *)(a1 + 144) - (v19 - v18);
  *(_QWORD *)(a1 + 144) = v20;
  if ( v20 < v14 )
  {
    *(_QWORD *)(a1 + 8) = &v13[v20];
    *(_QWORD *)(a1 + 16) = v17;
    v21 = lseek64(*(_DWORD *)(a1 + 112), v14, 0);
    v22 = *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56);
    if ( v22 == v21 )
      *(_QWORD *)(a1 + 144) = v22;
    else
      *(_DWORD *)a1 |= 0x20u;
    return v11;
  }
  *(_QWORD *)(a1 + 8) = v17;
  *(_QWORD *)(a1 + 16) = v17;
  return 0LL;
}

//----- (00000000004079A0) ----------------------------------------------------
void *__fastcall decide_maybe_mmap(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v9; // x1
  void *v11; // x1
  void *result; // x0
  __off_t v13; // x0
  bool v14; // zf
  unsigned __int64 v15; // x4
  unsigned __int64 v16; // x0
  double v17; // d0
  double v18; // d1
  double v19; // d2
  double v20; // d3
  double v21; // d4
  double v22; // d5
  double v23; // d6
  double v24; // d7
  __int64 v25; // x1
  int v26; // w3
  char *v27; // x0
  __off_t v28; // x1
  void *v29; // x1
  char *v30; // [xsp+28h] [xbp+28h]
  __int64 v31; // [xsp+28h] [xbp+28h]
  char v32[16]; // [xsp+30h] [xbp+30h] BYREF
  int v33; // [xsp+40h] [xbp+40h]
  __off_t v34; // [xsp+60h] [xbp+60h]

  v9 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v9 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v31 = *(_QWORD *)(a1 + 216);
    IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
    v9 = v31;
  }
  if ( (*(unsigned int (__fastcall **)(__int64, char *))(v9 + 144))(a1, v32) || (v33 & 0xF000) != 0x8000 || !v34 )
    goto LABEL_5;
  v13 = *(_QWORD *)(a1 + 144);
  v14 = v34 >= v13 || v13 == -1;
  if ( !v14 )
    goto LABEL_5;
  v15 = mmap64(0LL, v34, 1, 1, *(_DWORD *)(a1 + 112), 0LL);
  if ( v15 == -1LL )
    goto LABEL_5;
  v30 = (char *)v15;
  v16 = lseek64(*(_DWORD *)(a1 + 112), v34, 0);
  if ( v34 != v16 )
  {
    munmap(v30, v34);
    *(_QWORD *)(a1 + 144) = -1LL;
LABEL_5:
    v11 = &IO_wfile_jumps;
    if ( *(int *)(a1 + 192) <= 0 )
      v11 = &IO_file_jumps;
    *(_QWORD *)(a1 + 216) = v11;
    result = &IO_wfile_jumps;
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 224LL) = &IO_wfile_jumps;
    return result;
  }
  IO_setb((int *)a1, (__int64)v30, (__int64)&v30[v34], 0, v17, v18, v19, v20, v21, v22, v23, v24);
  v25 = *(_QWORD *)(a1 + 144);
  v26 = *(_DWORD *)(a1 + 192);
  v14 = v25 == -1;
  v27 = &v30[v25];
  v28 = v34;
  if ( v14 )
    v27 = v30;
  *(_QWORD *)(a1 + 24) = v30;
  *(_QWORD *)(a1 + 8) = v27;
  *(_QWORD *)(a1 + 16) = &v30[v28];
  *(_QWORD *)(a1 + 144) = v28;
  v29 = &unk_48E050;
  if ( v26 <= 0 )
    v29 = &unk_48DE58;
  *(_QWORD *)(a1 + 216) = v29;
  result = &unk_48E050;
  *(_QWORD *)(*(_QWORD *)(a1 + 160) + 224LL) = &unk_48E050;
  return result;
}
// 407ABC: variable 'v17' is possibly undefined
// 407ABC: variable 'v18' is possibly undefined
// 407ABC: variable 'v19' is possibly undefined
// 407ABC: variable 'v20' is possibly undefined
// 407ABC: variable 'v21' is possibly undefined
// 407ABC: variable 'v22' is possibly undefined
// 407ABC: variable 'v23' is possibly undefined
// 407ABC: variable 'v24' is possibly undefined

//----- (0000000000407B20) ----------------------------------------------------
void __fastcall IO_new_file_init_internal(__int64 a1)
{
  *(_DWORD *)a1 |= 0x240Cu;
  *(_QWORD *)(a1 + 144) = -1LL;
  IO_link_in((int *)a1);
  *(_DWORD *)(a1 + 112) = -1;
}

//----- (0000000000407B60) ----------------------------------------------------
void __fastcall IO_new_file_init(__int64 a1)
{
  *(_DWORD *)a1 |= 0x240Cu;
  *(_QWORD *)(a1 + 144) = -1LL;
  IO_link_in((int *)a1);
  *(_DWORD *)(a1 + 112) = -1;
}

//----- (0000000000407BA0) ----------------------------------------------------
__int64 __fastcall IO_file_open(__int64 a1, char *a2, int a3, int a4, int a5)
{
  int v6; // w20
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  int v15; // w1
  __int64 v16; // x1
  __int64 v19; // [xsp+28h] [xbp+28h]

  if ( (*(_QWORD *)(a1 + 112) & 0x200000000LL) != 0 )
    v6 = _open_nocancel(a2, a3);
  else
    v6 = open64(a2, a3, a4);
  if ( (v6 & 0x80000000) == 0 )
  {
    v15 = *(_DWORD *)a1;
    *(_DWORD *)(a1 + 112) = v6;
    *(_DWORD *)a1 = v15 & 0xFFFFEFF3 | a5 & 0x100C;
    if ( (~a5 & 0x1004) != 0 )
      goto LABEL_8;
    v16 = *(_QWORD *)(a1 + 216);
    if ( (unsigned __int64)(v16 - (_QWORD)&_io_vtables) > 0x92F )
    {
      v19 = *(_QWORD *)(a1 + 216);
      IO_vtable_check(v7, v8, v9, v10, v11, v12, v13, v14);
      v16 = v19;
    }
    if ( (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(v16 + 128))(a1, 0LL, 2LL) != -1
      || *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == 29 )
    {
LABEL_8:
      IO_link_in((int *)a1);
      return a1;
    }
    _close_nocancel(v6);
  }
  return 0LL;
}
// 407C94: variable 'v7' is possibly undefined
// 407C94: variable 'v8' is possibly undefined
// 407C94: variable 'v9' is possibly undefined
// 407C94: variable 'v10' is possibly undefined
// 407C94: variable 'v11' is possibly undefined
// 407C94: variable 'v12' is possibly undefined
// 407C94: variable 'v13' is possibly undefined
// 407C94: variable 'v14' is possibly undefined

//----- (0000000000407CA0) ----------------------------------------------------
unsigned int *__fastcall IO_new_file_attach(
        unsigned int *a1,
        unsigned int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  unsigned int *v10; // x4
  unsigned __int64 StatusReg; // x6
  unsigned int v12; // w0
  __int64 v13; // x1
  int v14; // w19
  unsigned int *v16; // [xsp+20h] [xbp-20h]
  __int64 v17; // [xsp+20h] [xbp-20h]
  unsigned __int64 v18; // [xsp+28h] [xbp-18h]
  unsigned int *v19; // [xsp+28h] [xbp-18h]
  unsigned __int64 v20; // [xsp+30h] [xbp-10h]

  v10 = a1;
  if ( a1[28] != -1 )
    return 0LL;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v12 = *a1;
  v10[28] = a2;
  v13 = *((_QWORD *)v10 + 27);
  *v10 = v12 & 0xFFFFFFB3 | 0x40;
  *((_QWORD *)v10 + 18) = -1LL;
  v14 = *(_DWORD *)(StatusReg + 40);
  if ( (unsigned __int64)(v13 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v17 = v13;
    v19 = v10;
    v20 = StatusReg;
    IO_vtable_check(a3, a4, a5, a6, a7, a8, a9, a10);
    v13 = v17;
    v10 = v19;
    StatusReg = v20;
  }
  v16 = v10;
  v18 = StatusReg;
  if ( (*(__int64 (__fastcall **)(unsigned int *, _QWORD, __int64, __int64))(v13 + 72))(v10, 0LL, 1LL, 3LL) == -1
    && *(_DWORD *)(v18 + 40) != 29 )
  {
    return 0LL;
  }
  *(_DWORD *)(v18 + 40) = v14;
  return v16;
}

//----- (0000000000407D80) ----------------------------------------------------
__int64 __fastcall IO_new_file_setbuf(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  __int64 result; // x0
  __int64 v13; // x0

  result = IO_default_setbuf((__int64)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  if ( result )
  {
    v13 = a1[7];
    a1[1] = v13;
    a1[2] = v13;
    a1[3] = v13;
    a1[4] = v13;
    a1[5] = v13;
    a1[6] = v13;
    return (__int64)a1;
  }
  return result;
}

//----- (0000000000407DC0) ----------------------------------------------------
__int64 __fastcall IO_file_setbuf_mmap(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  __int64 v11; // x4
  __int64 result; // x0
  __int64 v14; // x0
  __int64 v15; // x2

  v11 = a1[20];
  a1[27] = &IO_file_jumps;
  *(_QWORD *)(v11 + 224) = &IO_wfile_jumps;
  result = IO_default_setbuf((__int64)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
  if ( result )
  {
    v14 = a1[7];
    a1[1] = v14;
    a1[2] = v14;
    a1[3] = v14;
    a1[4] = v14;
    a1[5] = v14;
    a1[6] = v14;
    return (__int64)a1;
  }
  else
  {
    v15 = a1[20];
    a1[27] = &unk_48DE58;
    *(_QWORD *)(v15 + 224) = &unk_48E050;
  }
  return result;
}

//----- (0000000000407E40) ----------------------------------------------------
__int64 __fastcall IO_new_do_write(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  if ( !a3 )
    return 0LL;
  if ( a3 == new_do_write(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11) )
    return 0LL;
  return 0xFFFFFFFFLL;
}

//----- (0000000000407E70) ----------------------------------------------------
__int64 __fastcall IO_new_file_close_it(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  unsigned int v16; // w20
  double v18; // d0
  double v19; // d1
  double v20; // d2
  double v21; // d3
  double v22; // d4
  double v23; // d5
  double v24; // d6
  double v25; // d7
  unsigned int v26; // w21
  __int64 v27; // x21
  _OWORD *v28; // x0
  char v30; // [xsp+0h] [xbp+0h]

  v16 = *(_DWORD *)(a1 + 112);
  if ( v16 != -1 )
  {
    v16 = 0;
    if ( (*(_QWORD *)a1 & 0x808LL) == 0x800 )
    {
      if ( *(int *)(a1 + 192) <= 0 )
        v16 = IO_new_do_write(
                a1,
                *(_QWORD *)(a1 + 32),
                *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32),
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9);
      else
        v16 = IO_wdo_write(
                a1,
                *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL),
                (__int64)(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 32LL) - *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL)) >> 2,
                a2,
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a12,
                a13,
                a14,
                a15,
                a16,
                v30);
    }
    IO_unsave_markers((_QWORD *)a1, a2, a3, a4, a5, a6, a7, a8, a9);
    v26 = 0;
    if ( (*(_QWORD *)(a1 + 112) & 0x2000000000LL) == 0 )
    {
      v27 = *(_QWORD *)(a1 + 216);
      if ( (unsigned __int64)(v27 - (_QWORD)&_io_vtables) > 0x92F )
        IO_vtable_check(v18, v19, v20, v21, v22, v23, v24, v25);
      v26 = (*(__int64 (__fastcall **)(__int64))(v27 + 136))(a1);
    }
    if ( *(int *)(a1 + 192) > 0 )
    {
      if ( *(_QWORD *)(*(_QWORD *)(a1 + 160) + 72LL) )
        IO_free_wbackup_area((unsigned int *)a1, v18, v19, v20, v21, v22, v23, v24, v25);
      IO_wsetb(a1, 0LL, 0LL, 0, v18, v19, v20, v21, v22, v23, v24, v25);
      v28 = *(_OWORD **)(a1 + 160);
      *v28 = 0u;
      v28[1] = 0u;
      v28[2] = 0u;
    }
    IO_setb((int *)a1, 0LL, 0LL, 0, v18, v19, v20, v21, v22, v23, v24, v25);
    *(_OWORD *)(a1 + 8) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 40) = 0u;
    IO_un_link(a1);
    if ( v26 )
      v16 = v26;
    *(_DWORD *)a1 = -72539124;
    *(_DWORD *)(a1 + 112) = -1;
    *(_QWORD *)(a1 + 144) = -1LL;
  }
  return v16;
}
// 407EAC: variable 'a2' is possibly undefined
// 407EAC: variable 'a3' is possibly undefined
// 407EAC: variable 'a4' is possibly undefined
// 407EAC: variable 'a5' is possibly undefined
// 407EAC: variable 'a6' is possibly undefined
// 407EAC: variable 'a7' is possibly undefined
// 407EAC: variable 'a8' is possibly undefined
// 407EAC: variable 'a9' is possibly undefined
// 407FC8: variable 'v18' is possibly undefined
// 407FC8: variable 'v19' is possibly undefined
// 407FC8: variable 'v20' is possibly undefined
// 407FC8: variable 'v21' is possibly undefined
// 407FC8: variable 'v22' is possibly undefined
// 407FC8: variable 'v23' is possibly undefined
// 407FC8: variable 'v24' is possibly undefined
// 407FC8: variable 'v25' is possibly undefined
// 407FA8: variable 'v30' is possibly undefined

//----- (0000000000407FD0) ----------------------------------------------------
__int64 __fastcall IO_new_file_fopen(__int64 a1, char *a2, unsigned __int8 *a3)
{
  int v4; // w0
  int v5; // w4
  int v6; // w8
  int v7; // w7
  unsigned __int8 *v8; // x5
  unsigned __int8 *v9; // x6
  unsigned int v10; // w0
  unsigned int v11; // t1
  bool v12; // cc
  __int64 v13; // x2
  __int64 v14; // x3
  __int64 v15; // x4
  __int64 v16; // x5
  __int64 v17; // x7
  __int64 v18; // x20
  __int64 v19; // x0
  unsigned __int64 v20; // x0
  __int64 v21; // x9
  __int64 v22; // x1
  void *v23; // x3
  void *v24; // x4
  void *v25; // x5
  void *v26; // x6
  __int64 v27; // x7
  double v28; // d0
  double v29; // d1
  double v30; // d2
  double v31; // d3
  double v32; // d4
  double v33; // d5
  double v34; // d6
  double v35; // d7
  unsigned __int64 v36; // x0
  __int64 v37; // x3
  __int64 v38; // x4
  __int64 v39; // x5
  __int64 v40; // x6
  __int64 v41; // x7
  double v42; // d0
  double v43; // d1
  double v44; // d2
  double v45; // d3
  double v46; // d4
  double v47; // d5
  double v48; // d6
  double v49; // d7
  __int64 v50; // x2
  __int64 (__fastcall *v51)(__int64, __int64 *, unsigned __int64); // x0
  __int64 v52; // x9
  __int64 v53; // x8
  int v54; // w2
  _BYTE *v55; // x5
  _BYTE *v56; // x4
  int v57; // w11
  int v58; // t1
  unsigned int v59; // w1
  __int64 result; // x0
  int v61; // w0
  int v62; // w0
  int v63; // w0
  int v64; // w11
  int8x16_t *(__fastcall *v65)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  __int64 v66; // x2
  int v67; // w1
  __int64 v68; // x1
  __int64 v69; // x2
  __int64 v70; // x3
  __int64 v71; // x4
  __int64 v72; // x5
  __int64 v73; // x6
  __int64 v74; // x7
  double v75; // d0
  double v76; // d1
  double v77; // d2
  double v78; // d3
  double v79; // d4
  double v80; // d5
  double v81; // d6
  double v82; // d7
  _QWORD *v83; // x0
  unsigned __int64 v84; // x3
  __int64 v85; // x1
  unsigned __int64 v86; // x4
  __int64 v87; // x1
  __int64 v88; // x0
  __int64 v89; // x3
  double v90; // d0
  double v91; // d1
  double v92; // d2
  double v93; // d3
  double v94; // d4
  double v95; // d5
  double v96; // d6
  double v97; // d7
  char v98; // [xsp+0h] [xbp+0h]
  __int64 v99; // [xsp+28h] [xbp+28h]
  __int64 v100; // [xsp+28h] [xbp+28h]
  __int64 v101; // [xsp+28h] [xbp+28h]
  __int64 v102; // [xsp+28h] [xbp+28h]
  __int64 v103; // [xsp+28h] [xbp+28h]
  unsigned __int64 v104; // [xsp+28h] [xbp+28h]
  unsigned int v105; // [xsp+28h] [xbp+28h]
  __int64 v106; // [xsp+30h] [xbp+30h]
  __int64 v107; // [xsp+30h] [xbp+30h]
  __int64 v108; // [xsp+30h] [xbp+30h]
  __int64 StatusReg; // [xsp+30h] [xbp+30h]
  _BYTE *v110; // [xsp+38h] [xbp+38h]
  unsigned __int64 v111[4]; // [xsp+40h] [xbp+40h] BYREF

  if ( *(_DWORD *)(a1 + 112) != -1 )
    return 0LL;
  v4 = *a3;
  switch ( v4 )
  {
    case 'r':
      v5 = 8;
      v6 = 0;
      v7 = 0;
      break;
    case 'w':
      v5 = 4;
      v6 = 1;
      v7 = 576;
      break;
    case 'a':
      v5 = 4100;
      v6 = 1;
      v7 = 1088;
      break;
    default:
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
      return 0LL;
  }
  v8 = a3 + 6;
  v9 = a3;
  do
  {
    v11 = *++a3;
    v10 = v11;
    v12 = v11 > 0x63;
    if ( v11 == 99 )
    {
      v62 = ((int)(*(_QWORD *)(a1 + 112) >> 24) >> 8) | 2;
      *(_WORD *)(a1 + 116) = ((int)(*(_QWORD *)(a1 + 112) >> 24) >> 8) | 2;
      *(_BYTE *)(a1 + 118) = BYTE2(v62);
    }
    else if ( v12 )
    {
      switch ( v10 )
      {
        case 'm':
          v63 = ((int)(*(_QWORD *)(a1 + 112) >> 24) >> 8) | 1;
          *(_WORD *)(a1 + 116) = ((int)(*(_QWORD *)(a1 + 112) >> 24) >> 8) | 1;
          *(_BYTE *)(a1 + 118) = BYTE2(v63);
          break;
        case 'x':
          v7 |= 0x80u;
          v9 = a3;
          break;
        case 'e':
          v7 |= 0x80000u;
          v61 = ((int)(*(_QWORD *)(a1 + 112) >> 24) >> 8) | 0x40;
          *(_WORD *)(a1 + 116) = ((int)(*(_QWORD *)(a1 + 112) >> 24) >> 8) | 0x40;
          *(_BYTE *)(a1 + 118) = BYTE2(v61);
          break;
      }
    }
    else
    {
      if ( v10 == 44 )
        break;
      if ( v10 > 0x2C )
      {
        if ( v10 == 98 )
          v9 = a3;
      }
      else
      {
        if ( !v10 )
          break;
        if ( v10 == 43 )
        {
          v5 &= 0x1000u;
          v9 = a3;
          v6 = 2;
        }
      }
    }
  }
  while ( a3 != v8 );
  v99 = (__int64)v9;
  v18 = IO_file_open(a1, a2, v7 | (unsigned int)v6, 438, v5);
  if ( !v18 )
    return 0LL;
  v19 = strstr(v99 + 1, (int8x16_t *)",ccs=", v13, v14, v15, v16, v99, v17, v98);
  if ( !v19 )
    return v18;
  v100 = v19 + 5;
  v20 = strchrnul(v19 + 5, 0x2Cu);
  v21 = v100;
  v101 = v20 - v100;
  v106 = v21;
  v36 = malloc(v101 + 3, v22, v101, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35);
  v50 = v101;
  if ( !v36 )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v105 = *(_DWORD *)(StatusReg + 40);
    IO_new_file_close_it(a1, v42, v43, v44, v45, v46, v47, v48, v49, StatusReg, v105, v37, v38, v39, v40, v41);
    *(_DWORD *)(StatusReg + 40) = v105;
    return 0LL;
  }
  v102 = v106;
  v107 = v50;
  v110 = (_BYTE *)v36;
  v51 = j_memcpy();
  v52 = v102;
  v53 = (__int64)v110;
  *((_BYTE *)v51 + v107) = 0;
  v54 = (unsigned __int8)*v110;
  if ( *v110 )
  {
    v55 = v110;
    v56 = v110;
    v57 = 0;
    while ( 1 )
    {
      v59 = (unsigned __int8)(v54 - 44);
      if ( v59 <= 0x33 )
        break;
      if ( (word_45EA40[(unsigned __int8)v54] & 8) != 0 )
        goto LABEL_21;
LABEL_22:
      v58 = (unsigned __int8)*++v55;
      v54 = v58;
      if ( !v58 )
      {
        if ( v57 <= 1 )
        {
          v64 = v57 + 1;
          goto LABEL_44;
        }
        goto LABEL_45;
      }
    }
    if ( ((__int64)0xFFF7FFFFFFFFBFF8LL >> v59) & 1 && (word_45EA40[(unsigned __int8)v54] & 8) == 0 )
    {
      if ( v54 == 47 )
      {
        if ( v57 == 2 )
          goto LABEL_45;
        ++v57;
        *v56++ = 47;
      }
      goto LABEL_22;
    }
LABEL_21:
    *v56++ = dword_45E140[v54];
    goto LABEL_22;
  }
  v64 = 1;
LABEL_44:
  v103 = (unsigned int)(2 - v64);
  v108 = v52;
  v65 = memset();
  v52 = v108;
  v53 = (__int64)v110;
  v56 = (char *)v65 + v103 + 1;
LABEL_45:
  *v56 = 0;
  if ( !*(_BYTE *)(v53 + 2) )
  {
    v66 = 0LL;
    do
    {
      v67 = (unsigned __int8)dword_45E140[*(unsigned __int8 *)(v52 + v66)];
      *(_BYTE *)(v53 + v66++) = v67;
    }
    while ( v67 );
  }
  v104 = v53;
  if ( (unsigned int)_wcsmbs_named_conv(v111, v53) )
  {
    IO_new_file_close_it(a1, v75, v76, v77, v78, v79, v80, v81, v82, v68, v69, v70, v71, v72, v73, v74);
    free(v104, v90, v91, v92, v93, v94, v95, v96, v97);
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return 0LL;
  }
  free(v104, v75, v76, v77, v78, v79, v80, v81, v82);
  if ( v111[1] != 1 )
    _libc_assert_fail((__int64)"fcts.towc_nsteps == 1", (__int64)"fileops.c", 0x143u, (__int64)"_IO_new_file_fopen");
  if ( v111[3] != 1 )
    _libc_assert_fail((__int64)"fcts.tomb_nsteps == 1", (__int64)"fileops.c", 0x144u, (__int64)"_IO_new_file_fopen");
  v83 = *(_QWORD **)(a1 + 160);
  v84 = v111[0];
  v85 = v83[1];
  v83[11] = 0LL;
  v86 = v111[2];
  *v83 = v85;
  v83[4] = v83[3];
  *(_QWORD *)(*(_QWORD *)(a1 + 160) + 96LL) = 0LL;
  v87 = *(_QWORD *)(a1 + 160);
  *(_QWORD *)(a1 + 152) = v87 + 104;
  *(_QWORD *)(v87 + 104) = v84;
  v88 = *(_QWORD *)(v87 + 224);
  *(_DWORD *)(v87 + 136) = 1;
  v89 = *(_QWORD *)(v18 + 160);
  *(_QWORD *)(v87 + 160) = v86;
  *(_QWORD *)(v87 + 128) = 1LL;
  v89 += 88LL;
  *(_QWORD *)(v87 + 144) = v89;
  *(_DWORD *)(v87 + 192) = 1;
  *(_QWORD *)(v87 + 200) = v89;
  *(_QWORD *)(v87 + 184) = 9LL;
  *(_QWORD *)(a1 + 216) = v88;
  result = v18;
  *(_DWORD *)(v18 + 192) = 1;
  return result;
}
// 408098: variable 'v13' is possibly undefined
// 408098: variable 'v14' is possibly undefined
// 408098: variable 'v15' is possibly undefined
// 408098: variable 'v16' is possibly undefined
// 408098: variable 'v17' is possibly undefined
// 408098: variable 'v98' is possibly undefined
// 4080C4: variable 'v22' is possibly undefined
// 4080C4: variable 'v23' is possibly undefined
// 4080C4: variable 'v24' is possibly undefined
// 4080C4: variable 'v25' is possibly undefined
// 4080C4: variable 'v26' is possibly undefined
// 4080C4: variable 'v27' is possibly undefined
// 4080C4: variable 'v28' is possibly undefined
// 4080C4: variable 'v29' is possibly undefined
// 4080C4: variable 'v30' is possibly undefined
// 4080C4: variable 'v31' is possibly undefined
// 4080C4: variable 'v32' is possibly undefined
// 4080C4: variable 'v33' is possibly undefined
// 4080C4: variable 'v34' is possibly undefined
// 4080C4: variable 'v35' is possibly undefined
// 4082DC: variable 'v75' is possibly undefined
// 4082DC: variable 'v76' is possibly undefined
// 4082DC: variable 'v77' is possibly undefined
// 4082DC: variable 'v78' is possibly undefined
// 4082DC: variable 'v79' is possibly undefined
// 4082DC: variable 'v80' is possibly undefined
// 4082DC: variable 'v81' is possibly undefined
// 4082DC: variable 'v82' is possibly undefined
// 408398: variable 'v68' is possibly undefined
// 408398: variable 'v69' is possibly undefined
// 408398: variable 'v70' is possibly undefined
// 408398: variable 'v71' is possibly undefined
// 408398: variable 'v72' is possibly undefined
// 408398: variable 'v73' is possibly undefined
// 408398: variable 'v74' is possibly undefined
// 4083A8: variable 'v90' is possibly undefined
// 4083A8: variable 'v91' is possibly undefined
// 4083A8: variable 'v92' is possibly undefined
// 4083A8: variable 'v93' is possibly undefined
// 4083A8: variable 'v94' is possibly undefined
// 4083A8: variable 'v95' is possibly undefined
// 4083A8: variable 'v96' is possibly undefined
// 4083A8: variable 'v97' is possibly undefined
// 4083E4: variable 'v42' is possibly undefined
// 4083E4: variable 'v43' is possibly undefined
// 4083E4: variable 'v44' is possibly undefined
// 4083E4: variable 'v45' is possibly undefined
// 4083E4: variable 'v46' is possibly undefined
// 4083E4: variable 'v47' is possibly undefined
// 4083E4: variable 'v48' is possibly undefined
// 4083E4: variable 'v49' is possibly undefined
// 4083E4: variable 'v37' is possibly undefined
// 4083E4: variable 'v38' is possibly undefined
// 4083E4: variable 'v39' is possibly undefined
// 4083E4: variable 'v40' is possibly undefined
// 4083E4: variable 'v41' is possibly undefined
// 408440: using guessed type __int64 IO_new_file_finish(void);
// 45E140: using guessed type int dword_45E140[256];
// 45EA40: using guessed type _WORD word_45EA40[256];

//----- (0000000000408440) ----------------------------------------------------
void __fastcall IO_new_file_finish(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  __int64 v17; // x1
  char v18; // [xsp+0h] [xbp+0h]
  __int64 v19; // [xsp+28h] [xbp+28h]

  if ( *(_DWORD *)(a1 + 112) != -1 )
  {
    if ( *(int *)(a1 + 192) <= 0 )
      IO_new_do_write(
        a1,
        *(_QWORD *)(a1 + 32),
        *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32),
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9);
    else
      IO_wdo_write(
        a1,
        *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL),
        (__int64)(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 32LL) - *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL)) >> 2,
        a2,
        a3,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9,
        a12,
        a13,
        a14,
        a15,
        a16,
        v18);
    if ( (*(_DWORD *)a1 & 0x40) == 0 )
    {
      v17 = *(_QWORD *)(a1 + 216);
      if ( (unsigned __int64)(v17 - (_QWORD)&_io_vtables) > 0x92F )
      {
        v19 = *(_QWORD *)(a1 + 216);
        IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
        v17 = v19;
      }
      a2 = (*(double (__fastcall **)(__int64))(v17 + 136))(a1);
    }
  }
  IO_default_finish(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}
// 408478: variable 'v18' is possibly undefined
// 4084D0: variable 'a2' is possibly undefined
// 4084D0: variable 'a3' is possibly undefined
// 4084D0: variable 'a4' is possibly undefined
// 4084D0: variable 'a5' is possibly undefined
// 4084D0: variable 'a6' is possibly undefined
// 4084D0: variable 'a7' is possibly undefined
// 4084D0: variable 'a8' is possibly undefined
// 4084D0: variable 'a9' is possibly undefined

//----- (00000000004084E0) ----------------------------------------------------
__int64 __fastcall IO_new_file_underflow(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  int v9; // w1
  unsigned __int8 *v11; // x0
  __int64 v12; // t2
  int *v13; // x21
  unsigned __int64 StatusReg; // x20
  __int64 v15; // x2
  unsigned __int64 v16; // x20
  __int64 v17; // x0
  __int64 v18; // x1
  __int64 v19; // x2
  void *v20; // x4
  void *v21; // x5
  void *v22; // x6
  int v23; // w0
  int *v24; // x1
  __int64 v25; // x1
  int v26; // w0
  double v27; // d0
  double v28; // d1
  double v29; // d2
  double v30; // d3
  double v31; // d4
  double v32; // d5
  double v33; // d6
  double v34; // d7
  __int64 v35; // x21
  __int64 v36; // x1
  __int64 v37; // x0
  bool v38; // zf
  __int64 v39; // x1
  int v41; // w0
  unsigned __int64 v42; // x0
  __int64 v43; // x0
  void *v44; // x21
  __int64 v45; // x1
  __int64 v46; // x3
  void *v47; // x4
  void *v48; // x5
  void *v49; // x6
  int v50; // w0
  _DWORD *v51; // [xsp+38h] [xbp+38h]
  __int64 v52; // [xsp+38h] [xbp+38h]

  v9 = *(_DWORD *)a1;
  if ( (*(_DWORD *)a1 & 0x10) != 0 )
    return 0xFFFFFFFFLL;
  if ( (v9 & 4) != 0 )
  {
    *(_DWORD *)a1 = v9 | 0x20;
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 9;
    return 0xFFFFFFFFLL;
  }
  v12 = a1 + 8;
  v11 = *(unsigned __int8 **)(a1 + 8);
  if ( (unsigned __int64)v11 < *(_QWORD *)(v12 + 8) )
    return *v11;
  if ( *(_QWORD *)(a1 + 56) )
  {
    if ( (v9 & 0x202) == 0 )
      goto LABEL_18;
  }
  else
  {
    v42 = *(_QWORD *)(a1 + 72);
    if ( v42 )
    {
      if ( v42 != a1 + 119 )
      {
        free(v42, a2, a3, a4, a5, a6, a7, a8, a9);
        v9 = *(_DWORD *)a1;
      }
      *(_DWORD *)a1 = v9 & 0xFFFFFEFF;
    }
    IO_doallocbuf((int *)a1, a2, a3, a4, a5, a6, a7, a8, a9);
    if ( (*(_DWORD *)a1 & 0x202) == 0 )
      goto LABEL_18;
  }
  v13 = stdout;
  if ( (*stdout & 0x8000) != 0 )
  {
    if ( (*stdout & 0x288) != 0x280 )
      goto LABEL_18;
    v24 = stdout;
    goto LABEL_38;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v15 = *((_QWORD *)v13 + 17);
  v16 = StatusReg - 1824;
  v17 = *(_QWORD *)(v15 + 8);
  if ( !_libc_single_threaded || v17 )
  {
    if ( v16 == v17 )
    {
      v24 = v13;
      ++*(_DWORD *)(v15 + 4);
    }
    else
    {
      v51 = (_DWORD *)*((_QWORD *)v13 + 17);
      _aarch64_cas4_acq();
      if ( v23 )
        _lll_lock_wait_private(v51, a2, a3, a4, a5, a6, a7, a8, a9, v18, v19, (__int64)&stdout, v20, v21, v22);
      v24 = stdout;
      *(_QWORD *)(*((_QWORD *)v13 + 17) + 8LL) = v16;
    }
  }
  else
  {
    v24 = v13;
    *(_DWORD *)v15 = 1;
    *(_QWORD *)(v15 + 8) = v16;
  }
  if ( (*v24 & 0x288) == 0x280 )
  {
LABEL_38:
    v43 = *((_QWORD *)v24 + 27);
    if ( (unsigned __int64)(v43 - (_QWORD)&_io_vtables) > 0x92F )
    {
      v52 = *((_QWORD *)v24 + 27);
      IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
      v43 = v52;
    }
    (*(void (__fastcall **)(int *, __int64))(v43 + 24))(stdout, 0xFFFFFFFFLL);
  }
  if ( (*v13 & 0x8000) == 0 )
  {
    v25 = *((_QWORD *)v13 + 17);
    v26 = *(_DWORD *)(v25 + 4);
    if ( _libc_single_threaded )
    {
      if ( !v26 )
      {
        *(_QWORD *)(v25 + 8) = 0LL;
        **((_DWORD **)v13 + 17) = 0;
        goto LABEL_18;
      }
    }
    else if ( !v26 )
    {
      *(_QWORD *)(v25 + 8) = 0LL;
      v44 = (void *)*((_QWORD *)v13 + 17);
      _aarch64_swp4_rel();
      if ( v50 > 1 )
        _lll_lock_wake_private(v44, v45, (__int64)&unk_48D000, v46, v47, v48, v49);
      goto LABEL_18;
    }
    *(_DWORD *)(v25 + 4) = v26 - 1;
  }
LABEL_18:
  IO_switch_to_get_mode((int *)a1, a2, a3, a4, a5, a6, a7, a8, a9);
  v35 = *(_QWORD *)(a1 + 216);
  v36 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 8) = v36;
  *(_QWORD *)(a1 + 16) = v36;
  *(_QWORD *)(a1 + 24) = v36;
  *(_QWORD *)(a1 + 32) = v36;
  *(_QWORD *)(a1 + 40) = v36;
  *(_QWORD *)(a1 + 48) = v36;
  if ( (unsigned __int64)(v35 - (_QWORD)&_io_vtables) > 0x92F )
  {
    IO_vtable_check(v27, v28, v29, v30, v31, v32, v33, v34);
    v36 = *(_QWORD *)(a1 + 56);
  }
  v37 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v35 + 112))(a1, v36, *(_QWORD *)(a1 + 64) - v36);
  v38 = v37 == 0;
  if ( v37 <= 0 )
  {
    v41 = *(_DWORD *)a1 | 0x20;
    if ( v38 )
      v41 = *(_DWORD *)a1 | 0x10;
    *(_DWORD *)a1 = v41;
    *(_QWORD *)(a1 + 144) = -1LL;
    return 0xFFFFFFFFLL;
  }
  else
  {
    *(_QWORD *)(a1 + 16) += v37;
    v39 = *(_QWORD *)(a1 + 144);
    if ( v39 != -1 )
      *(_QWORD *)(a1 + 144) = v39 + v37;
    return **(unsigned __int8 **)(a1 + 8);
  }
}
// 408570: variable 'v23' is possibly undefined
// 4087A8: variable 'a2' is possibly undefined
// 4087A8: variable 'a3' is possibly undefined
// 4087A8: variable 'a4' is possibly undefined
// 4087A8: variable 'a5' is possibly undefined
// 4087A8: variable 'a6' is possibly undefined
// 4087A8: variable 'a7' is possibly undefined
// 4087A8: variable 'a8' is possibly undefined
// 4087A8: variable 'a9' is possibly undefined
// 4087A8: variable 'v18' is possibly undefined
// 4087A8: variable 'v19' is possibly undefined
// 4087A8: variable 'v20' is possibly undefined
// 4087A8: variable 'v21' is possibly undefined
// 4087A8: variable 'v22' is possibly undefined
// 408768: variable 'v27' is possibly undefined
// 408768: variable 'v28' is possibly undefined
// 408768: variable 'v29' is possibly undefined
// 408768: variable 'v30' is possibly undefined
// 408768: variable 'v31' is possibly undefined
// 408768: variable 'v32' is possibly undefined
// 408768: variable 'v33' is possibly undefined
// 408768: variable 'v34' is possibly undefined
// 408758: variable 'v50' is possibly undefined
// 408760: variable 'v45' is possibly undefined
// 408760: variable 'v46' is possibly undefined
// 408760: variable 'v47' is possibly undefined
// 408760: variable 'v48' is possibly undefined
// 408760: variable 'v49' is possibly undefined
// 4905C0: using guessed type int *stdout;
// 490F08: using guessed type char _libc_single_threaded;

//----- (00000000004087E0) ----------------------------------------------------
void __fastcall __noreturn sub_4087E0(_Unwind_Exception *exc)
{
  __int64 v1; // x21
  __int64 v3; // x1
  int v4; // w0
  void *v5; // x19
  __int64 v6; // x1
  __int64 v7; // x2
  __int64 v8; // x3
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  int v12; // w0

  if ( (*(_DWORD *)v1 & 0x8000) == 0 )
  {
    v3 = *(_QWORD *)(v1 + 136);
    v4 = *(_DWORD *)(v3 + 4);
    if ( _libc_single_threaded )
    {
      if ( !v4 )
      {
        *(_QWORD *)(v3 + 8) = 0LL;
        **(_DWORD **)(v1 + 136) = 0;
        goto LABEL_5;
      }
      goto LABEL_9;
    }
    if ( v4 )
    {
LABEL_9:
      *(_DWORD *)(v3 + 4) = v4 - 1;
      goto LABEL_5;
    }
    *(_QWORD *)(v3 + 8) = 0LL;
    v5 = *(void **)(v1 + 136);
    _aarch64_swp4_rel();
    if ( v12 > 1 )
      _lll_lock_wake_private(v5, v6, v7, v8, v9, v10, v11);
  }
LABEL_5:
  Unwind_Resume(exc);
}
// 4087E8: variable 'v1' is possibly undefined
// 408834: variable 'v12' is possibly undefined
// 40883C: variable 'v6' is possibly undefined
// 40883C: variable 'v7' is possibly undefined
// 40883C: variable 'v8' is possibly undefined
// 40883C: variable 'v9' is possibly undefined
// 40883C: variable 'v10' is possibly undefined
// 40883C: variable 'v11' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000408850) ----------------------------------------------------
__int64 __fastcall IO_file_underflow_mmap(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  unsigned __int8 *v9; // x2
  int v11; // w0
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  __int64 v20; // x1
  unsigned __int8 *v21; // x0
  __int64 v22; // x2
  __int64 v24; // [xsp+10h] [xbp-10h]
  __int64 v25; // [xsp+18h] [xbp-8h]

  v9 = *(unsigned __int8 **)(a1 + 8);
  if ( (unsigned __int64)v9 < *(_QWORD *)(a1 + 16) )
    return *v9;
  v11 = mmap_remap_check(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  v20 = a1;
  if ( v11 )
  {
    v22 = *(_QWORD *)(a1 + 216);
    if ( (unsigned __int64)(v22 - (_QWORD)&_io_vtables) > 0x92F )
    {
      v24 = *(_QWORD *)(a1 + 216);
      v25 = v20;
      IO_vtable_check(v12, v13, v14, v15, v16, v17, v18, v19);
      return (*(__int64 (__fastcall **)(__int64))(v24 + 32))(v25);
    }
    else
    {
      return (*(__int64 (__fastcall **)(__int64))(v22 + 32))(a1);
    }
  }
  else
  {
    v21 = *(unsigned __int8 **)(a1 + 8);
    if ( (unsigned __int64)v21 >= *(_QWORD *)(a1 + 16) )
    {
      *(_DWORD *)a1 |= 0x10u;
      return 0xFFFFFFFFLL;
    }
    else
    {
      return *v21;
    }
  }
}
// 4088D8: variable 'v12' is possibly undefined
// 4088D8: variable 'v13' is possibly undefined
// 4088D8: variable 'v14' is possibly undefined
// 4088D8: variable 'v15' is possibly undefined
// 4088D8: variable 'v16' is possibly undefined
// 4088D8: variable 'v17' is possibly undefined
// 4088D8: variable 'v18' is possibly undefined
// 4088D8: variable 'v19' is possibly undefined

//----- (00000000004088E4) ----------------------------------------------------
__int64 __fastcall IO_file_underflow_maybe_mmap(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  __int64 v17; // x0
  __int64 v18; // x2
  __int64 v21; // [xsp+10h] [xbp+10h]
  __int64 v22; // [xsp+18h] [xbp+18h]

  decide_maybe_mmap(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  v17 = a1;
  v18 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v18 - (_QWORD)&_io_vtables) <= 0x92F )
    return (*(__int64 (**)(void))(v18 + 32))();
  v21 = *(_QWORD *)(a1 + 216);
  v22 = v17;
  IO_vtable_check(v9, v10, v11, v12, v13, v14, v15, v16);
  return (*(__int64 (__fastcall **)(__int64))(v21 + 32))(v22);
}
// 408924: variable 'v9' is possibly undefined
// 408924: variable 'v10' is possibly undefined
// 408924: variable 'v11' is possibly undefined
// 408924: variable 'v12' is possibly undefined
// 408924: variable 'v13' is possibly undefined
// 408924: variable 'v14' is possibly undefined
// 408924: variable 'v15' is possibly undefined
// 408924: variable 'v16' is possibly undefined

//----- (0000000000408940) ----------------------------------------------------
__int64 __fastcall IO_new_file_overflow(
        int *a1,
        unsigned int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  __int64 v16; // x3
  int v17; // w0
  __int64 v18; // x4
  __int64 v19; // x1
  _BYTE *v20; // x2
  _BYTE *v23; // x1
  int v24; // w1
  int v25; // w0
  __int64 v26; // x2
  unsigned __int64 v27; // x0
  char v28; // [xsp+0h] [xbp+0h]
  char v29; // [xsp+18h] [xbp+18h]
  __int64 v30; // [xsp+18h] [xbp+18h]
  __int64 v31; // [xsp+18h] [xbp+18h]
  __int64 v32; // [xsp+18h] [xbp+18h]
  int v33; // [xsp+20h] [xbp+20h]
  unsigned int v34; // [xsp+20h] [xbp+20h]
  unsigned __int64 v35; // [xsp+20h] [xbp+20h]
  unsigned int v36; // [xsp+2Ch] [xbp+2Ch]

  v16 = (__int64)a1;
  v17 = *a1;
  if ( (v17 & 8) != 0 )
  {
    *(_DWORD *)v16 = v17 | 0x20;
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 9;
    return 0xFFFFFFFFLL;
  }
  v18 = a2;
  v19 = *(_QWORD *)(v16 + 32);
  if ( (v17 & 0x800) != 0 )
  {
    if ( v19 )
    {
      v20 = *(_BYTE **)(v16 + 40);
      goto LABEL_5;
    }
  }
  else if ( v19 )
  {
    v20 = *(_BYTE **)(v16 + 8);
    goto LABEL_15;
  }
  v31 = v16;
  v34 = v18;
  IO_doallocbuf((int *)v16, a3, a4, a5, a6, a7, a8, a9, a10);
  v16 = v31;
  v20 = *(_BYTE **)(v31 + 56);
  *(_QWORD *)(v31 + 8) = v20;
  *(_QWORD *)(v31 + 16) = v20;
  v17 = *(_DWORD *)v31;
  v18 = v34;
  *(_QWORD *)(v31 + 24) = v20;
LABEL_15:
  if ( (v17 & 0x100) != 0 )
  {
    v36 = v18;
    v32 = v16;
    v35 = *(_QWORD *)(v16 + 16) - (_QWORD)v20;
    IO_free_backup_area((_QWORD *)v16, a3, a4, a5, a6, a7, a8, a9, a10);
    v16 = v32;
    v18 = v36;
    v26 = *(_QWORD *)(v32 + 24);
    v27 = v26 - *(_QWORD *)(v32 + 56);
    if ( v27 > v35 )
      v27 = v35;
    v20 = (_BYTE *)(v26 - v27);
    v17 = *(_DWORD *)v32;
  }
  a14 = *(_QWORD *)(v16 + 64);
  if ( (_BYTE *)a14 == v20 )
  {
    v20 = *(_BYTE **)(v16 + 56);
    *(_QWORD *)(v16 + 16) = v20;
    v23 = v20;
  }
  else
  {
    v23 = *(_BYTE **)(v16 + 16);
  }
  *(_QWORD *)(v16 + 8) = v23;
  *(_QWORD *)(v16 + 24) = v23;
  *(_QWORD *)(v16 + 32) = v20;
  *(_DWORD *)v16 = v17 | 0x800;
  v24 = *(_DWORD *)(v16 + 192);
  *(_QWORD *)(v16 + 40) = v20;
  *(_QWORD *)(v16 + 48) = a14;
  if ( v24 <= 0 && (v17 & 0x202) != 0 )
  {
    *(_QWORD *)(v16 + 48) = v20;
    if ( (_DWORD)v18 != -1 )
      goto LABEL_6;
    return IO_new_do_write(
             v16,
             *(_QWORD *)(v16 + 32),
             (__int64)&v20[-*(_QWORD *)(v16 + 32)],
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9,
             a10);
  }
LABEL_5:
  if ( (_DWORD)v18 == -1 )
    return IO_new_do_write(
             v16,
             *(_QWORD *)(v16 + 32),
             (__int64)&v20[-*(_QWORD *)(v16 + 32)],
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9,
             a10);
LABEL_6:
  if ( *(_BYTE **)(v16 + 64) != v20 )
    goto LABEL_7;
  v33 = v18;
  if ( *(int *)(v16 + 192) > 0 )
  {
    v30 = v16;
    if ( (unsigned int)IO_wdo_write(
                         v16,
                         *(_QWORD *)(*(_QWORD *)(v16 + 160) + 24LL),
                         (__int64)(*(_QWORD *)(*(_QWORD *)(v16 + 160) + 32LL)
                                 - *(_QWORD *)(*(_QWORD *)(v16 + 160) + 24LL)) >> 2,
                         a3,
                         a4,
                         a5,
                         a6,
                         a7,
                         a8,
                         a9,
                         a10,
                         v16,
                         v18,
                         a14,
                         a15,
                         a16,
                         v28) == -1 )
      return 0xFFFFFFFFLL;
    goto LABEL_26;
  }
  v30 = v16;
  if ( (unsigned int)IO_new_do_write(
                       v16,
                       *(_QWORD *)(v16 + 32),
                       (__int64)&v20[-*(_QWORD *)(v16 + 32)],
                       a3,
                       a4,
                       a5,
                       a6,
                       a7,
                       a8,
                       a9,
                       a10) != -1 )
  {
LABEL_26:
    v16 = v30;
    LODWORD(v18) = v33;
    v20 = *(_BYTE **)(v30 + 40);
LABEL_7:
    *(_QWORD *)(v16 + 40) = v20 + 1;
    *v20 = v18;
    if ( (*(_DWORD *)v16 & 2) == 0 && ((*(_DWORD *)v16 & 0x200LL) == 0 || (_DWORD)v18 != 10) )
      return (unsigned __int8)v18;
    v29 = v18;
    v25 = IO_new_do_write(
            v16,
            *(_QWORD *)(v16 + 32),
            *(_QWORD *)(v16 + 40) - *(_QWORD *)(v16 + 32),
            a3,
            a4,
            a5,
            a6,
            a7,
            a8,
            a9,
            a10);
    LOBYTE(v18) = v29;
    if ( v25 != -1 )
      return (unsigned __int8)v18;
    return 0xFFFFFFFFLL;
  }
  return 0xFFFFFFFFLL;
}
// 408A0C: variable 'a3' is possibly undefined
// 408A0C: variable 'a4' is possibly undefined
// 408A0C: variable 'a5' is possibly undefined
// 408A0C: variable 'a6' is possibly undefined
// 408A0C: variable 'a7' is possibly undefined
// 408A0C: variable 'a8' is possibly undefined
// 408A0C: variable 'a9' is possibly undefined
// 408A0C: variable 'a10' is possibly undefined
// 408A60: variable 'a15' is possibly undefined
// 408A60: variable 'a16' is possibly undefined
// 408A60: variable 'v28' is possibly undefined

//----- (0000000000408B40) ----------------------------------------------------
__int64 __fastcall IO_new_file_sync(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  unsigned __int64 v17; // x1
  unsigned __int64 v18; // x2
  __int64 v19; // x3
  __int64 v20; // x2
  char v22; // [xsp+0h] [xbp+0h]
  __int64 v23; // [xsp+20h] [xbp+20h]

  v17 = *(_QWORD *)(a1 + 32);
  v18 = *(_QWORD *)(a1 + 40);
  if ( v18 <= v17 )
    goto LABEL_4;
  v19 = *(unsigned int *)(a1 + 192);
  if ( (int)v19 <= 0 )
  {
    if ( !(unsigned int)IO_new_do_write(a1, v17, v18 - v17, a2, a3, a4, a5, a6, a7, a8, a9) )
      goto LABEL_4;
    return 0xFFFFFFFFLL;
  }
  if ( (unsigned int)IO_wdo_write(
                       a1,
                       *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL),
                       (__int64)(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 32LL) - *(_QWORD *)(*(_QWORD *)(a1 + 160) + 24LL)) >> 2,
                       a2,
                       a3,
                       a4,
                       a5,
                       a6,
                       a7,
                       a8,
                       a9,
                       v19,
                       a13,
                       a14,
                       a15,
                       a16,
                       v22) )
    return 0xFFFFFFFFLL;
LABEL_4:
  if ( *(_QWORD *)(a1 + 8) == *(_QWORD *)(a1 + 16) )
  {
LABEL_9:
    *(_QWORD *)(a1 + 144) = -1LL;
    return 0LL;
  }
  v20 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v20 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v23 = *(_QWORD *)(a1 + 216);
    IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
    v20 = v23;
  }
  if ( (*(__int64 (__fastcall **)(__int64))(v20 + 128))(a1) != -1 )
  {
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 8);
    goto LABEL_9;
  }
  if ( *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == 29 )
    goto LABEL_9;
  return 0xFFFFFFFFLL;
}
// 408B78: variable 'v22' is possibly undefined
// 408C14: variable 'a2' is possibly undefined
// 408C14: variable 'a3' is possibly undefined
// 408C14: variable 'a4' is possibly undefined
// 408C14: variable 'a5' is possibly undefined
// 408C14: variable 'a6' is possibly undefined
// 408C14: variable 'a7' is possibly undefined
// 408C14: variable 'a8' is possibly undefined
// 408C14: variable 'a9' is possibly undefined

//----- (0000000000408C20) ----------------------------------------------------
__int64 __fastcall IO_file_sync_mmap(__int64 a1)
{
  __int64 v1; // x1
  __int64 v3; // x0
  __int64 v4; // t2
  __off_t v5; // x1
  unsigned __int64 v6; // x1
  __int64 v7; // x0
  __int64 result; // x0
  __int64 v9; // x0
  __int64 v10; // [xsp+18h] [xbp-8h]

  v1 = *(_QWORD *)(a1 + 56);
  v4 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  v5 = v3 - v1;
  if ( v3 == *(_QWORD *)(v4 + 8) )
  {
    v9 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 8) = v9;
    *(_QWORD *)(a1 + 16) = v9;
    result = 0LL;
    *(_QWORD *)(a1 + 144) = v5;
  }
  else
  {
    v10 = a1;
    v6 = lseek64(*(_DWORD *)(a1 + 112), v5, 0);
    if ( *(_QWORD *)(v10 + 8) - *(_QWORD *)(v10 + 56) == v6 )
    {
      v7 = *(_QWORD *)(v10 + 24);
      *(_QWORD *)(v10 + 8) = v7;
      *(_QWORD *)(v10 + 16) = v7;
      result = 0LL;
      *(_QWORD *)(v10 + 144) = v6;
    }
    else
    {
      *(_DWORD *)v10 |= 0x20u;
      return 0xFFFFFFFFLL;
    }
  }
  return result;
}

//----- (0000000000408CAC) ----------------------------------------------------
__int64 __fastcall IO_new_file_seekoff(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        int a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  __int64 v15; // x2
  __int64 v16; // x3
  unsigned __int64 v17; // x0
  unsigned __int64 v18; // x1
  _BOOL4 v20; // w23
  __int64 v21; // x1
  __int64 v22; // x1
  int v23; // w2
  __int64 v24; // x3
  bool v25; // cc
  __int64 v26; // x0
  __int64 v27; // x2
  __int64 v28; // x21
  __int64 v29; // x0
  __int64 v30; // x3
  double v31; // d0
  double v32; // d1
  double v33; // d2
  double v34; // d3
  double v35; // d4
  double v36; // d5
  double v37; // d6
  double v38; // d7
  __int64 v39; // x0
  __int64 v40; // x1
  __int64 v41; // x2
  __int64 v42; // x0
  __int64 v43; // x1
  int v44; // w0
  __int64 result; // x0
  double v46; // d0
  double v47; // d1
  double v48; // d2
  double v49; // d3
  double v50; // d4
  double v51; // d5
  double v52; // d6
  double v53; // d7
  __int64 v54; // x1
  int v55; // w1
  __int64 v56; // x1
  __int64 v57; // x0
  unsigned __int64 v58; // x0
  __int64 v59; // x0
  unsigned __int64 v60; // x2
  unsigned __int64 v61; // x20
  int v62; // w1
  bool v63; // cc
  __int64 v64; // x20
  __int64 v65; // x0
  __int64 v66; // x1
  __int64 v67; // x20
  unsigned __int64 v68; // x20
  __int64 v69; // x21
  __int64 v70; // x0
  __int64 v71; // x21
  __int64 v72; // [xsp+40h] [xbp+40h]
  __int64 v73; // [xsp+40h] [xbp+40h]
  __int64 v74; // [xsp+40h] [xbp+40h]
  __int64 v75; // [xsp+40h] [xbp+40h]
  __int64 v76; // [xsp+40h] [xbp+40h]
  __int64 v77; // [xsp+48h] [xbp+48h]
  char v78[16]; // [xsp+50h] [xbp+50h] BYREF
  int v79; // [xsp+60h] [xbp+60h]
  __int64 v80; // [xsp+80h] [xbp+80h]

  if ( !a4 )
  {
    if ( *(_QWORD *)(a1 + 56) )
    {
      v60 = *(_QWORD *)(a1 + 32);
      v61 = *(_QWORD *)(a1 + 40);
      v62 = *(_DWORD *)a1 & 0x1000;
      if ( v62 )
        v63 = v61 > v60;
      else
        v63 = 0;
      if ( v63 )
      {
        v64 = *(_QWORD *)(a1 + 216);
        if ( (unsigned __int64)(v64 - (_QWORD)&_io_vtables) > 0x92F )
          IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
        v65 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(v64 + 128))(a1, 0LL, 2LL);
        if ( v65 == -1 )
          return -1LL;
        v66 = *(_QWORD *)(a1 + 32);
        v67 = *(_QWORD *)(a1 + 40);
        *(_QWORD *)(a1 + 144) = v65;
        v68 = v67 - v66;
        goto LABEL_66;
      }
      v65 = *(_QWORD *)(a1 + 144);
      if ( v61 <= v60 )
      {
        v68 = *(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 16);
      }
      else if ( v62 )
      {
        v68 = v61 - v60;
      }
      else
      {
        v68 = v61 - *(_QWORD *)(a1 + 16);
      }
    }
    else
    {
      v65 = *(_QWORD *)(a1 + 144);
      v68 = 0LL;
    }
    if ( v65 == -1 )
    {
      v69 = *(_QWORD *)(a1 + 216);
      if ( (unsigned __int64)(v69 - (_QWORD)&_io_vtables) > 0x92F )
        IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
      v65 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(v69 + 128))(a1, 0LL, 1LL);
      if ( v65 == -1 )
        return -1LL;
    }
LABEL_66:
    result = v65 + v68;
    if ( result >= 0 )
      return result;
    goto LABEL_50;
  }
  v15 = *(_QWORD *)(a1 + 16);
  v16 = *(_QWORD *)(a1 + 24);
  v18 = *(_QWORD *)(a1 + 32);
  v17 = *(_QWORD *)(a1 + 40);
  v20 = v16 == v15 && v18 == v17;
  if ( (v18 < v17 || (*(_DWORD *)a1 & 0x800) != 0)
    && (unsigned int)IO_switch_to_get_mode((int *)a1, a5, a6, a7, a8, a9, a10, a11, a12) )
  {
    return -1LL;
  }
  if ( !*(_QWORD *)(a1 + 56) )
  {
    v58 = *(_QWORD *)(a1 + 24);
    if ( v58 )
    {
      if ( v58 != a1 + 119 )
        free(v58, a5, a6, a7, a8, a9, a10, a11, a12);
      *(_DWORD *)a1 &= ~0x100u;
    }
    IO_doallocbuf((int *)a1, a5, a6, a7, a8, a9, a10, a11, a12);
    v59 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 8) = v59;
    *(_QWORD *)(a1 + 16) = v59;
    *(_QWORD *)(a1 + 24) = v59;
    *(_QWORD *)(a1 + 32) = v59;
    *(_QWORD *)(a1 + 40) = v59;
    *(_QWORD *)(a1 + 48) = v59;
  }
  if ( a3 == 1 )
  {
    a2 -= *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
    v57 = *(_QWORD *)(a1 + 144);
    if ( v57 == -1 )
      goto LABEL_44;
    a2 += v57;
    if ( a2 >= 0 )
      goto LABEL_18;
LABEL_50:
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return -1LL;
  }
  if ( a3 != 2 )
    goto LABEL_19;
  v21 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v21 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v75 = *(_QWORD *)(a1 + 216);
    IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
    v21 = v75;
  }
  if ( !(*(unsigned int (__fastcall **)(__int64, char *))(v21 + 144))(a1, v78) && (v79 & 0xF000) == 0x8000 )
  {
    a2 += v80;
LABEL_18:
    a3 = 0;
LABEL_19:
    IO_free_backup_area((_QWORD *)a1, a5, a6, a7, a8, a9, a10, a11, a12);
    v22 = *(_QWORD *)(a1 + 144);
    v23 = *(_DWORD *)a1;
    if ( v22 != -1 && *(_QWORD *)(a1 + 24) && (v23 & 0x100) == 0 )
    {
      v24 = *(_QWORD *)(a1 + 56);
      v25 = a2 < v22 - (*(_QWORD *)(a1 + 16) - v24) || v22 <= a2;
      if ( !v25 )
      {
        v70 = a2 - (v22 - *(_QWORD *)(a1 + 16));
        *(_DWORD *)a1 = v23 & 0xFFFFFFEF;
        *(_QWORD *)(a1 + 8) = v70;
        *(_QWORD *)(a1 + 24) = v24;
        *(_QWORD *)(a1 + 32) = v24;
        *(_QWORD *)(a1 + 40) = v24;
        *(_QWORD *)(a1 + 48) = v24;
        if ( (v22 & 0x8000000000000000LL) == 0 )
        {
          v71 = *(_QWORD *)(a1 + 216);
          if ( (unsigned __int64)(v71 - (_QWORD)&_io_vtables) > 0x92F )
            IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
          (*(void (__fastcall **)(__int64))(v71 + 128))(a1);
        }
        return a2;
      }
    }
    if ( (v23 & 4) == 0 )
    {
      v27 = *(_QWORD *)(a1 + 56);
      v26 = *(_QWORD *)(a1 + 64);
      v28 = a2 & ~(v27 - v26);
      v25 = v26 - v27 < v28;
      v29 = *(_QWORD *)(a1 + 216);
      if ( v25 )
        v28 = 0LL;
      if ( (unsigned __int64)(v29 - (_QWORD)&_io_vtables) > 0x92F )
      {
        v74 = *(_QWORD *)(a1 + 216);
        IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
        v29 = v74;
      }
      v30 = (*(__int64 (__fastcall **)(__int64))(v29 + 128))(a1);
      if ( v30 < 0 )
        return -1LL;
      if ( !v28 )
      {
        v42 = 0LL;
        goto LABEL_40;
      }
      v39 = *(_QWORD *)(a1 + 216);
      if ( (unsigned __int64)(v39 - (_QWORD)&_io_vtables) > 0x92F )
      {
        v76 = *(_QWORD *)(a1 + 216);
        v77 = v30;
        IO_vtable_check(v31, v32, v33, v34, v35, v36, v37, v38);
        v39 = v76;
        v30 = v77;
      }
      v40 = *(_QWORD *)(a1 + 56);
      v41 = v28;
      if ( !v20 )
        v41 = *(_QWORD *)(a1 + 64) - v40;
      v72 = v30;
      v42 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v39 + 112))(a1, v40, v41);
      if ( v28 <= v42 )
      {
        v30 = v72 + v42;
LABEL_40:
        v43 = *(_QWORD *)(a1 + 56);
        *(_QWORD *)(a1 + 24) = v43;
        *(_QWORD *)(a1 + 32) = v43;
        *(_QWORD *)(a1 + 8) = v43 + v28;
        *(_QWORD *)(a1 + 16) = v43 + v42;
        v44 = *(_DWORD *)a1;
        *(_QWORD *)(a1 + 40) = v43;
        *(_QWORD *)(a1 + 48) = v43;
        *(_DWORD *)a1 = v44 & 0xFFFFFFEF;
        *(_QWORD *)(a1 + 144) = v30;
        return a2;
      }
      if ( v42 == -1 )
        a2 = v28;
      else
        a2 = v28 - v42;
      a3 = 1;
    }
  }
LABEL_44:
  IO_unsave_markers((_QWORD *)a1, a5, a6, a7, a8, a9, a10, a11, a12);
  v54 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v54 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v73 = *(_QWORD *)(a1 + 216);
    IO_vtable_check(v46, v47, v48, v49, v50, v51, v52, v53);
    v54 = v73;
  }
  result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v54 + 128))(a1, a2, a3);
  if ( result != -1 )
  {
    v55 = *(_DWORD *)a1;
    *(_QWORD *)(a1 + 144) = result;
    *(_DWORD *)a1 = v55 & 0xFFFFFFEF;
    v56 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 8) = v56;
    *(_QWORD *)(a1 + 16) = v56;
    *(_QWORD *)(a1 + 24) = v56;
    *(_QWORD *)(a1 + 32) = v56;
    *(_QWORD *)(a1 + 40) = v56;
    *(_QWORD *)(a1 + 48) = v56;
  }
  return result;
}
// 409124: variable 'a5' is possibly undefined
// 409124: variable 'a6' is possibly undefined
// 409124: variable 'a7' is possibly undefined
// 409124: variable 'a8' is possibly undefined
// 409124: variable 'a9' is possibly undefined
// 409124: variable 'a10' is possibly undefined
// 409124: variable 'a11' is possibly undefined
// 409124: variable 'a12' is possibly undefined
// 409134: variable 'v31' is possibly undefined
// 409134: variable 'v32' is possibly undefined
// 409134: variable 'v33' is possibly undefined
// 409134: variable 'v34' is possibly undefined
// 409134: variable 'v35' is possibly undefined
// 409134: variable 'v36' is possibly undefined
// 409134: variable 'v37' is possibly undefined
// 409134: variable 'v38' is possibly undefined
// 409104: variable 'v46' is possibly undefined
// 409104: variable 'v47' is possibly undefined
// 409104: variable 'v48' is possibly undefined
// 409104: variable 'v49' is possibly undefined
// 409104: variable 'v50' is possibly undefined
// 409104: variable 'v51' is possibly undefined
// 409104: variable 'v52' is possibly undefined
// 409104: variable 'v53' is possibly undefined

//----- (0000000000409164) ----------------------------------------------------
__int64 __fastcall IO_file_seekoff_mmap(
        _QWORD *a1,
        __int64 a2,
        int a3,
        int a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  _QWORD *v12; // x4
  __int64 v13; // x2
  __int64 v14; // x0
  __int64 v15; // x1
  __int64 v16; // x2
  __int64 v17; // x3
  int v18; // w0
  _QWORD *v21; // [xsp+18h] [xbp-18h]
  __int64 v22; // [xsp+18h] [xbp-18h]
  __int64 v23; // [xsp+20h] [xbp-10h]
  __int64 v24; // [xsp+20h] [xbp-10h]

  v12 = a1;
  if ( !a4 )
    return a1[18] - (a1[2] - a1[1]);
  if ( a3 == 1 )
  {
    a2 += a1[1] - a1[3];
  }
  else if ( a3 == 2 )
  {
    a2 += a1[8] - a1[7];
  }
  if ( a2 < 0 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return -1LL;
  }
  v13 = a1[27];
  if ( (unsigned __int64)(v13 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v22 = a1[27];
    v24 = a2;
    IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
    v12 = a1;
    v13 = v22;
    a2 = v24;
  }
  v21 = v12;
  v23 = a2;
  v14 = (*(__int64 (__fastcall **)(_QWORD *))(v13 + 128))(v12);
  v15 = v23;
  if ( v14 < 0 )
    return -1LL;
  v17 = v21[7];
  v16 = v21[8];
  v21[18] = v14;
  v18 = *(_DWORD *)v21;
  v21[3] = v17;
  *(_DWORD *)v21 = v18 & 0xFFFFFFEF;
  if ( v16 - v17 >= v23 )
    v16 = v17 + v23;
  v21[1] = v16;
  v21[2] = v16;
  return v15;
}

//----- (0000000000409268) ----------------------------------------------------
__int64 __fastcall IO_file_seekoff_maybe_mmap(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v10; // x0
  __int64 result; // x0
  __int64 v12; // [xsp+28h] [xbp+28h]

  v10 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v10 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v12 = v10;
    IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
    v10 = v12;
  }
  result = (*(__int64 (__fastcall **)(__int64))(v10 + 128))(a1);
  if ( result < 0 )
    return -1LL;
  *(_QWORD *)(a1 + 144) = result;
  return result;
}

//----- (00000000004092D0) ----------------------------------------------------
unsigned __int64 __fastcall IO_file_read(__int64 a1, void *a2, void *a3)
{
  int v3; // w3

  v3 = *(_DWORD *)(a1 + 112);
  if ( (*(_QWORD *)(a1 + 112) & 0x200000000LL) != 0 )
    return _read_nocancel(v3, a2, (size_t)a3);
  else
    return read(v3, a2, a3);
}

//----- (00000000004092EC) ----------------------------------------------------
unsigned __int64 __fastcall IO_file_seek(__int64 a1, __off_t a2, int a3)
{
  return lseek64(*(_DWORD *)(a1 + 112), a2, a3);
}

//----- (0000000000409300) ----------------------------------------------------
unsigned __int64 __fastcall IO_file_stat(__int64 a1, struct stat *a2)
{
  return fstat64(*(_DWORD *)(a1 + 112), a2);
}

//----- (0000000000409308) ----------------------------------------------------
unsigned __int64 __fastcall IO_file_close_mmap(__int64 a1)
{
  int v2; // w0

  munmap(*(void **)(a1 + 56), *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 56));
  v2 = *(_DWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 56) = 0LL;
  *(_QWORD *)(a1 + 64) = 0LL;
  return _close_nocancel(v2);
}

//----- (0000000000409340) ----------------------------------------------------
unsigned __int64 __fastcall IO_file_close(__int64 a1)
{
  return _close_nocancel(*(_DWORD *)(a1 + 112));
}

//----- (0000000000409348) ----------------------------------------------------
__int64 __fastcall IO_new_file_write(__int64 a1, char *a2, __int64 a3)
{
  char *v6; // x19
  int v7; // w0
  unsigned __int64 v8; // x0
  __int64 result; // x0
  __int64 v10; // x1

  if ( a3 > 0 )
  {
    v6 = (char *)a3;
    while ( 1 )
    {
      v7 = *(_DWORD *)(a1 + 112);
      if ( (*(_QWORD *)(a1 + 112) & 0x200000000LL) != 0 )
      {
        v8 = _write_nocancel(v7, a2, (size_t)v6);
        if ( (v8 & 0x8000000000000000LL) != 0 )
        {
LABEL_11:
          *(_DWORD *)a1 |= 0x20u;
          result = a3 - (_QWORD)v6;
          goto LABEL_7;
        }
      }
      else
      {
        v8 = write(v7, a2, v6);
        if ( (v8 & 0x8000000000000000LL) != 0 )
          goto LABEL_11;
      }
      v6 -= v8;
      a2 += v8;
      if ( (__int64)v6 <= 0 )
      {
        result = a3 - (_QWORD)v6;
        goto LABEL_7;
      }
    }
  }
  result = 0LL;
LABEL_7:
  v10 = *(_QWORD *)(a1 + 144);
  if ( (v10 & 0x8000000000000000LL) == 0 )
    *(_QWORD *)(a1 + 144) = result + v10;
  return result;
}

//----- (00000000004093EC) ----------------------------------------------------
__int64 __fastcall IO_new_file_xsputn(
        _QWORD *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  unsigned __int64 v12; // x4
  _QWORD *v13; // x5
  int v14; // w1
  unsigned __int64 v15; // x0
  unsigned __int64 v16; // x3
  unsigned __int64 v17; // x3
  __int64 v18; // x8
  __int64 (__fastcall *v19)(__int64, __int64 *, unsigned __int64); // x0
  __int64 v20; // x8
  unsigned __int64 v21; // x7
  __int64 result; // x0
  __int64 v23; // x1
  int v24; // w0
  double v25; // d0
  double v26; // d1
  double v27; // d2
  double v28; // d3
  double v29; // d4
  double v30; // d5
  double v31; // d6
  double v32; // d7
  _QWORD *v33; // x5
  unsigned __int64 v34; // x7
  unsigned __int64 v35; // x4
  unsigned __int64 v36; // x6
  unsigned __int64 v37; // x0
  __int64 v38; // x3
  unsigned __int64 v39; // x1
  int v40; // t1
  unsigned __int64 v41; // x1
  __int64 v42; // x0
  unsigned __int64 v43; // x0
  unsigned __int64 v44; // x1
  unsigned __int64 v45; // [xsp+18h] [xbp+18h]
  _QWORD *v46; // [xsp+18h] [xbp+18h]
  unsigned __int64 v47; // [xsp+18h] [xbp+18h]
  __int64 v48; // [xsp+18h] [xbp+18h]
  unsigned __int64 v49; // [xsp+20h] [xbp+20h]
  unsigned __int64 v50; // [xsp+20h] [xbp+20h]
  unsigned __int64 v51; // [xsp+20h] [xbp+20h]
  unsigned __int64 v52; // [xsp+28h] [xbp+28h]
  unsigned __int64 v53; // [xsp+28h] [xbp+28h]
  unsigned __int64 v54; // [xsp+28h] [xbp+28h]
  _QWORD *v55; // [xsp+28h] [xbp+28h]
  __int64 v56; // [xsp+30h] [xbp+30h]
  unsigned __int64 v57; // [xsp+30h] [xbp+30h]
  _QWORD *v58; // [xsp+30h] [xbp+30h]
  unsigned __int64 v59; // [xsp+30h] [xbp+30h]
  _QWORD *v60; // [xsp+38h] [xbp+38h]
  unsigned __int64 v61; // [xsp+38h] [xbp+38h]
  unsigned __int64 v62; // [xsp+38h] [xbp+38h]

  if ( !a3 )
    return 0LL;
  v12 = a3;
  v13 = a1;
  v14 = *(_DWORD *)a1 & 0xA00;
  v15 = a1[5];
  if ( v14 == 2560 )
  {
    v39 = a2 + a3;
    v17 = v13[8] - v15;
    if ( a3 <= v17 )
    {
      while ( a2 < v39 )
      {
        v40 = *(unsigned __int8 *)--v39;
        if ( v40 == 10 )
        {
          v44 = v39 - a2;
          v17 = v44 + 1;
          if ( v44 == -1LL )
          {
            v21 = a3;
            v20 = 1LL;
            goto LABEL_9;
          }
          v18 = 1LL;
          goto LABEL_6;
        }
      }
    }
    else
    {
      v21 = a3;
      if ( !v17 )
        goto LABEL_13;
    }
  }
  else
  {
    v16 = v13[6];
    if ( v16 <= v15 )
    {
      v21 = a3;
      goto LABEL_13;
    }
    v17 = v16 - v15;
  }
  v18 = 0LL;
LABEL_6:
  if ( a3 > v17 )
    a3 = v17;
  v45 = a2;
  v49 = a3;
  v52 = v12;
  v56 = v18;
  v60 = v13;
  v19 = j_memcpy();
  v12 = v52;
  v20 = v56;
  v13 = v60;
  a2 = v45 + v49;
  v21 = v52 - v49;
  v60[5] = (char *)v19 + v49;
LABEL_9:
  if ( !(v21 + v20) )
    return v12 - v21;
LABEL_13:
  v23 = v13[27];
  if ( (unsigned __int64)(v23 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v48 = v13[27];
    v51 = v21;
    v55 = v13;
    v59 = a2;
    v62 = v12;
    IO_vtable_check(a4, a5, a6, a7, a8, a9, a10, a11);
    v12 = v62;
    v23 = v48;
    v21 = v51;
    v13 = v55;
    a2 = v59;
  }
  v46 = v13;
  v50 = v21;
  v53 = a2;
  v57 = v12;
  v24 = (*(__int64 (__fastcall **)(_QWORD *, __int64))(v23 + 24))(v13, 0xFFFFFFFFLL);
  v33 = v46;
  v34 = v50;
  v36 = v53;
  v35 = v57;
  if ( v24 == -1 )
  {
    result = v57 - v50;
    if ( !v50 )
      return -1LL;
  }
  else
  {
    v37 = v46[8] - v46[7];
    if ( v37 <= 0x7F )
    {
      if ( !v50 )
        return v35;
      v38 = v50;
    }
    else
    {
      v38 = v50 - v50 % v37;
      if ( v50 == v50 % v37 )
        goto LABEL_18;
    }
    v41 = v53;
    v42 = (__int64)v46;
    v47 = v38;
    v54 = v57;
    v58 = v33;
    v61 = v36;
    v43 = new_do_write(v42, v41, v38, v25, v26, v27, v28, v29, v30, v31, v32);
    v38 = v47;
    v35 = v54;
    if ( v43 >= v47 )
    {
      v33 = v58;
      v36 = v61;
      v34 = v50 - v43;
LABEL_18:
      if ( v34 )
        return IO_default_xsputn(v33, (unsigned __int8 *)(v36 + v38), v34, v25, v26, v27, v28, v29, v30, v31, v32)
             - v34
             + v35;
      return v35;
    }
    return v54 - v50 + v43;
  }
  return result;
}
// 4095C8: variable 'a4' is possibly undefined
// 4095C8: variable 'a5' is possibly undefined
// 4095C8: variable 'a6' is possibly undefined
// 4095C8: variable 'a7' is possibly undefined
// 4095C8: variable 'a8' is possibly undefined
// 4095C8: variable 'a9' is possibly undefined
// 4095C8: variable 'a10' is possibly undefined
// 4095C8: variable 'a11' is possibly undefined
// 4094FC: variable 'v25' is possibly undefined
// 4094FC: variable 'v26' is possibly undefined
// 4094FC: variable 'v27' is possibly undefined
// 4094FC: variable 'v28' is possibly undefined
// 4094FC: variable 'v29' is possibly undefined
// 4094FC: variable 'v30' is possibly undefined
// 4094FC: variable 'v31' is possibly undefined
// 4094FC: variable 'v32' is possibly undefined

//----- (00000000004095F0) ----------------------------------------------------
__int64 __fastcall IO_file_xsgetn(
        __int64 a1,
        char *a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        void *a15)
{
  unsigned __int64 v18; // x21
  unsigned __int64 v19; // x20
  unsigned __int64 v20; // x3
  unsigned __int64 v21; // x1
  __int64 v22; // x20
  unsigned __int64 v23; // x2
  __int64 v24; // x0
  bool v25; // zf
  __int64 v26; // x1
  __int64 result; // x0
  int v28; // w1
  unsigned __int64 v29; // x0
  unsigned __int64 v30; // [xsp+48h] [xbp+48h]

  if ( !*(_QWORD *)(a1 + 56) )
  {
    v29 = *(_QWORD *)(a1 + 72);
    if ( v29 )
    {
      if ( v29 != a1 + 119 )
        free(v29, a4, a5, a6, a7, a8, a9, a10, a11);
      *(_DWORD *)a1 &= ~0x100u;
    }
    IO_doallocbuf((int *)a1, a4, a5, a6, a7, a8, a9, a10, a11);
  }
  v18 = a3;
  if ( !a3 )
    return a3;
LABEL_3:
  while ( 2 )
  {
    v19 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
    if ( v19 >= v18 )
    {
LABEL_15:
      j_memcpy();
      *(_QWORD *)(a1 + 8) += v18;
      return a3;
    }
    while ( 1 )
    {
      if ( v19 )
      {
        a2 = (char *)j_memcpy() + v19;
        v18 -= v19;
        *(_QWORD *)(a1 + 8) += v19;
        if ( (*(_DWORD *)a1 & 0x100) != 0 )
        {
LABEL_24:
          IO_switch_to_main_get_area(a1);
          goto LABEL_3;
        }
      }
      else if ( (*(_DWORD *)a1 & 0x100) != 0 )
      {
        goto LABEL_24;
      }
      v20 = *(_QWORD *)(a1 + 56);
      if ( !v20 )
        goto LABEL_17;
      v21 = *(_QWORD *)(a1 + 64) - v20;
      if ( v21 > v18 )
        break;
      if ( v21 > 0x7F )
      {
        v22 = *(_QWORD *)(a1 + 216);
        *(_QWORD *)(a1 + 8) = v20;
        *(_QWORD *)(a1 + 16) = v20;
        *(_QWORD *)(a1 + 24) = v20;
        *(_QWORD *)(a1 + 32) = v20;
        *(_QWORD *)(a1 + 40) = v20;
        *(_QWORD *)(a1 + 48) = v20;
        v23 = v18 / v21 * v21;
        if ( (unsigned __int64)(v22 - (_QWORD)&_io_vtables) <= 0x92F )
          goto LABEL_10;
        goto LABEL_18;
      }
LABEL_17:
      v22 = *(_QWORD *)(a1 + 216);
      *(_QWORD *)(a1 + 8) = v20;
      *(_QWORD *)(a1 + 16) = v20;
      v23 = v18;
      *(_QWORD *)(a1 + 24) = v20;
      *(_QWORD *)(a1 + 32) = v20;
      *(_QWORD *)(a1 + 40) = v20;
      *(_QWORD *)(a1 + 48) = v20;
      if ( (unsigned __int64)(v22 - (_QWORD)&_io_vtables) <= 0x92F )
      {
LABEL_10:
        v24 = (*(__int64 (__fastcall **)(__int64, char *, unsigned __int64))(v22 + 112))(a1, a2, v23);
        v25 = v24 == 0;
        if ( v24 <= 0 )
          goto LABEL_19;
        goto LABEL_11;
      }
LABEL_18:
      v30 = v23;
      IO_vtable_check(a4, a5, a6, a7, a8, a9, a10, a11);
      v24 = (*(__int64 (__fastcall **)(__int64, char *, unsigned __int64))(v22 + 112))(a1, a2, v30);
      v25 = v24 == 0;
      if ( v24 <= 0 )
      {
LABEL_19:
        result = a3 - v18;
        v28 = *(_DWORD *)a1 | 0x20;
        if ( v25 )
          v28 = *(_DWORD *)a1 | 0x10;
        *(_DWORD *)a1 = v28;
        return result;
      }
LABEL_11:
      v26 = *(_QWORD *)(a1 + 144);
      v18 -= v24;
      if ( v26 != -1 )
        *(_QWORD *)(a1 + 144) = v26 + v24;
      if ( !v18 )
        return a3;
      a2 += v24;
      v19 = *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8);
      if ( v19 >= v18 )
        goto LABEL_15;
    }
    if ( (unsigned int)_underflow(a1, a4, a5, a6, a7, a8, a9, a10, a11, v21, a3, v20, a13, a14, a15) != -1 )
      continue;
    return a3 - v18;
  }
}
// 409724: variable 'a4' is possibly undefined
// 409724: variable 'a5' is possibly undefined
// 409724: variable 'a6' is possibly undefined
// 409724: variable 'a7' is possibly undefined
// 409724: variable 'a8' is possibly undefined
// 409724: variable 'a9' is possibly undefined
// 409724: variable 'a10' is possibly undefined
// 409724: variable 'a11' is possibly undefined
// 4097A8: variable 'a3' is possibly undefined
// 4097A8: variable 'a13' is possibly undefined
// 4097A8: variable 'a14' is possibly undefined
// 4097A8: variable 'a15' is possibly undefined

//----- (0000000000409800) ----------------------------------------------------
char *__fastcall IO_file_xsgetn_mmap(
        __int64 a1,
        char *a2,
        unsigned __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  __int64 v12; // x3
  unsigned __int64 v13; // x5
  __int64 v14; // x1
  unsigned __int64 v15; // x4
  char *v16; // x6
  int v17; // w0
  double v18; // d0
  double v19; // d1
  double v20; // d2
  double v21; // d3
  double v22; // d4
  double v23; // d5
  double v24; // d6
  double v25; // d7
  char *v26; // x6
  unsigned __int64 v28; // x2
  __int64 (__fastcall *v29)(__int64, __int64 *, unsigned __int64); // x0
  __int64 v30; // x1
  char *v31; // x19
  __int64 v32; // [xsp+28h] [xbp+28h]
  __int64 v33; // [xsp+28h] [xbp+28h]
  __int64 v34; // [xsp+28h] [xbp+28h]
  __int64 v35; // [xsp+28h] [xbp+28h]
  char *v36; // [xsp+30h] [xbp+30h]
  unsigned __int64 v38; // [xsp+30h] [xbp+30h]
  __int64 v39; // [xsp+30h] [xbp+30h]
  unsigned __int64 v40; // [xsp+38h] [xbp+38h]
  char *v41; // [xsp+38h] [xbp+38h]
  __int64 v42; // [xsp+38h] [xbp+38h]
  char *v43; // [xsp+40h] [xbp+40h]
  char *v44; // [xsp+40h] [xbp+40h]
  char *v45; // [xsp+40h] [xbp+40h]

  v12 = a1;
  v13 = a3;
  v14 = *(_QWORD *)(a1 + 8);
  v15 = *(_QWORD *)(a1 + 16) - v14;
  if ( v15 >= a3 )
  {
    v26 = a2;
    if ( v15 )
      goto LABEL_10;
    return (char *)(v26 - a2);
  }
  v16 = a2;
  if ( (*(_DWORD *)a1 & 0x100) != 0 )
  {
    v33 = *(_QWORD *)(a1 + 16) - v14;
    v44 = a2;
    v41 = (char *)j_memcpy() + v15;
    IO_switch_to_main_get_area(a1);
    v12 = a1;
    v13 = a3 - v33;
    v16 = v41;
    a2 = v44;
    v14 = *(_QWORD *)(a1 + 8);
    v15 = *(_QWORD *)(a1 + 16) - v14;
    if ( a3 - v33 <= v15 )
    {
LABEL_10:
      if ( v13 > v15 )
        v28 = v15;
      else
        v28 = v13;
      v34 = v14;
      v38 = v28;
      v42 = v12;
      v45 = a2;
      v29 = j_memcpy();
      a2 = v45;
      v26 = (char *)v29 + v38;
      *(_QWORD *)(v42 + 8) = v34 + v38;
      return (char *)(v26 - a2);
    }
  }
  v32 = v12;
  v36 = v16;
  v40 = v13;
  v43 = a2;
  v17 = mmap_remap_check(v12, a4, a5, a6, a7, a8, a9, a10, a11);
  v12 = v32;
  v26 = v36;
  v13 = v40;
  a2 = v43;
  if ( !v17 )
  {
    v14 = *(_QWORD *)(v32 + 8);
    v15 = *(_QWORD *)(v32 + 16) - v14;
    if ( v15 >= v40 )
      goto LABEL_10;
    *(_DWORD *)v32 |= 0x10u;
    if ( v15 )
      goto LABEL_10;
    return (char *)(v26 - a2);
  }
  v30 = *(_QWORD *)(v32 + 216);
  v31 = (char *)(v36 - v43);
  if ( (unsigned __int64)(v30 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v35 = *(_QWORD *)(v32 + 216);
    v39 = v12;
    IO_vtable_check(v18, v19, v20, v21, v22, v23, v24, v25);
    v30 = v35;
    v12 = v39;
    v13 = v40;
    a2 = v43;
  }
  return &v31[(*(__int64 (__fastcall **)(__int64, char *, unsigned __int64))(v30 + 64))(v12, a2, v13)];
}
// 40983C: variable 'a4' is possibly undefined
// 40983C: variable 'a5' is possibly undefined
// 40983C: variable 'a6' is possibly undefined
// 40983C: variable 'a7' is possibly undefined
// 40983C: variable 'a8' is possibly undefined
// 40983C: variable 'a9' is possibly undefined
// 40983C: variable 'a10' is possibly undefined
// 40983C: variable 'a11' is possibly undefined
// 409944: variable 'v18' is possibly undefined
// 409944: variable 'v19' is possibly undefined
// 409944: variable 'v20' is possibly undefined
// 409944: variable 'v21' is possibly undefined
// 409944: variable 'v22' is possibly undefined
// 409944: variable 'v23' is possibly undefined
// 409944: variable 'v24' is possibly undefined
// 409944: variable 'v25' is possibly undefined

//----- (0000000000409960) ----------------------------------------------------
__int64 __fastcall IO_file_xsgetn_maybe_mmap(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7
  __int64 v19; // x1
  __int64 v20; // x2
  __int64 v21; // x4
  __int64 v24; // [xsp+10h] [xbp+10h]
  __int64 v26; // [xsp+18h] [xbp+18h]
  __int64 v28; // [xsp+20h] [xbp+20h]
  __int64 v29; // [xsp+28h] [xbp+28h]

  decide_maybe_mmap(a1, a4, a5, a6, a7, a8, a9, a10, a11);
  v20 = a3;
  v19 = a2;
  v21 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v21 - (_QWORD)&_io_vtables) <= 0x92F )
    return (*(__int64 (**)(void))(v21 + 64))();
  v24 = *(_QWORD *)(a1 + 216);
  v26 = a1;
  v28 = v19;
  v29 = v20;
  IO_vtable_check(v11, v12, v13, v14, v15, v16, v17, v18);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v24 + 64))(v26, v28, v29);
}
// 4099AC: variable 'v11' is possibly undefined
// 4099AC: variable 'v12' is possibly undefined
// 4099AC: variable 'v13' is possibly undefined
// 4099AC: variable 'v14' is possibly undefined
// 4099AC: variable 'v15' is possibly undefined
// 4099AC: variable 'v16' is possibly undefined
// 4099AC: variable 'v17' is possibly undefined
// 4099AC: variable 'v18' is possibly undefined

//----- (00000000004099E0) ----------------------------------------------------
void flush_cleanup()
{
  _DWORD *v0; // x2
  __int64 v1; // x0
  int v2; // w1
  __int64 v3; // x5
  int v4; // w4
  char *v5; // x1
  int v6; // w0
  __int64 v7; // x1
  void *v8; // x4
  void *v9; // x5
  void *v10; // x6
  int v11; // w0
  __int64 v12; // x1
  __int64 v13; // x2
  __int64 v14; // x3
  void *v15; // x4
  void *v16; // x5
  void *v17; // x6
  int v18; // w0
  void *v19; // [xsp+10h] [xbp+10h]
  void *v20; // [xsp+10h] [xbp+10h]

  v0 = &unk_492000;
  v1 = run_fp;
  v2 = (unsigned __int8)_libc_single_threaded;
  if ( !run_fp || (*(_DWORD *)run_fp & 0x8000) != 0 )
  {
LABEL_11:
    if ( v2 )
      goto LABEL_6;
    goto LABEL_12;
  }
  v3 = *(_QWORD *)(run_fp + 136);
  v4 = *(_DWORD *)(v3 + 4);
  if ( _libc_single_threaded )
  {
    if ( v4 )
    {
      *(_DWORD *)(v3 + 4) = v4 - 1;
    }
    else
    {
      *(_QWORD *)(v3 + 8) = 0LL;
      **(_DWORD **)(v1 + 136) = 0;
    }
LABEL_6:
    v5 = (char *)(v0 + 682);
    v6 = v0[685];
    if ( !v6 )
    {
      *((_DWORD *)v5 + 2) = 0;
      *((_QWORD *)v5 + 2) = 0LL;
      return;
    }
    goto LABEL_7;
  }
  if ( v4 )
  {
    *(_DWORD *)(v3 + 4) = v4 - 1;
    goto LABEL_12;
  }
  *(_QWORD *)(v3 + 8) = 0LL;
  v19 = *(void **)(v1 + 136);
  _aarch64_swp4_rel();
  v0 = &unk_492000;
  if ( v11 <= 1 )
  {
    v2 = (unsigned __int8)_libc_single_threaded;
    goto LABEL_11;
  }
  _lll_lock_wake_private(v19, v7, (__int64)&unk_492000, (__int64)&_libc_single_threaded, v8, v9, v10);
  v0 = (_DWORD *)&unk_492000;
  if ( _libc_single_threaded )
    goto LABEL_6;
LABEL_12:
  v6 = v0[685];
  if ( v6 )
  {
LABEL_7:
    v0[685] = v6 - 1;
    return;
  }
  *((_QWORD *)v0 + 343) = 0LL;
  v20 = v0 + 684;
  _aarch64_swp4_rel();
  if ( v18 > 1 )
    _lll_lock_wake_private(v20, v12, v13, v14, v15, v16, v17);
}
// 409A60: variable 'v11' is possibly undefined
// 409A8C: variable 'v18' is possibly undefined
// 409A98: variable 'v12' is possibly undefined
// 409A98: variable 'v13' is possibly undefined
// 409A98: variable 'v14' is possibly undefined
// 409A98: variable 'v15' is possibly undefined
// 409A98: variable 'v16' is possibly undefined
// 409A98: variable 'v17' is possibly undefined
// 409AD4: variable 'v7' is possibly undefined
// 409AD4: variable 'v8' is possibly undefined
// 409AD4: variable 'v9' is possibly undefined
// 409AD4: variable 'v10' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;
// 492AA8: using guessed type __int64 run_fp;

//----- (0000000000409AEC) ----------------------------------------------------
__int64 __fastcall save_for_backup(
        _QWORD *a1,
        __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        void *a15)
{
  _DWORD *v17; // x3
  __int64 v18; // x9
  unsigned __int64 v19; // x5
  __int64 v20; // x4
  __int64 **v21; // x1
  __int64 v22; // x2
  __int64 v23; // x7
  __int64 v24; // x2
  __int64 v25; // x1
  __int64 v26; // x6
  __int64 v28; // x21
  unsigned __int64 v29; // x0
  _QWORD *v30; // x7
  __int64 (__fastcall *v31)(__int64, __int64 *, unsigned __int64); // x6
  double v32; // d0
  double v33; // d1
  double v34; // d2
  double v35; // d3
  double v36; // d4
  double v37; // d5
  double v38; // d6
  double v39; // d7
  unsigned __int64 v40; // x7
  unsigned __int64 v41; // x8
  __int64 (__fastcall *v42)(__int64, __int64 *, unsigned __int64); // x6
  __int64 v43; // x1
  _QWORD *v44; // [xsp+30h] [xbp+30h]
  unsigned __int64 v45; // [xsp+30h] [xbp+30h]
  __int64 v46; // [xsp+30h] [xbp+30h]
  _QWORD *v47; // [xsp+38h] [xbp+38h]
  unsigned __int64 v48; // [xsp+38h] [xbp+38h]
  __int64 (__fastcall *v49)(__int64, __int64 *, unsigned __int64); // [xsp+38h] [xbp+38h]
  __int64 v50; // [xsp+38h] [xbp+38h]
  __int64 (__fastcall *v51)(__int64, __int64 *, unsigned __int64); // [xsp+38h] [xbp+38h]
  _DWORD *v52; // [xsp+40h] [xbp+40h]
  _QWORD *v53; // [xsp+48h] [xbp+48h]
  __int64 v54; // [xsp+50h] [xbp+50h]
  unsigned __int64 v55; // [xsp+50h] [xbp+50h]
  int v56; // [xsp+58h] [xbp+58h]

  v17 = (_DWORD *)a1[12];
  v18 = a1[3];
  v19 = a2 - v18;
  if ( !v17 )
  {
    v43 = a1[11];
    if ( (v19 & 0x8000000000000000LL) == 0 )
    {
      a1[10] = v43;
      return 0LL;
    }
    v26 = v43 - a1[9];
    goto LABEL_19;
  }
  v20 = a2 - v18;
  v21 = (__int64 **)a1[12];
  do
  {
    v22 = *((int *)v21 + 4);
    v21 = (__int64 **)*v21;
    if ( v20 > v22 )
      v20 = v22;
  }
  while ( v21 );
  v23 = a1[9];
  v24 = v19 - v20;
  v25 = a1[11];
  if ( v19 - v20 <= v25 - v23 )
  {
    v26 = v25 - v23 - v24;
    if ( (v20 & 0x8000000000000000LL) == 0 )
    {
      if ( !v24 )
      {
        a1[10] = v25;
        goto LABEL_10;
      }
      v46 = v25 - v23 - v24;
      goto LABEL_20;
    }
LABEL_19:
    v50 = v26;
    j_memmove();
    v46 = v50;
LABEL_20:
    j_memcpy();
    v19 = a2 - a1[3];
    v17 = (_DWORD *)a1[12];
    v42 = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))(a1[9] + v46);
LABEL_16:
    a1[10] = v42;
    if ( !v17 )
      return 0LL;
    do
    {
LABEL_10:
      v17[4] -= v19;
      v17 = *(_DWORD **)v17;
    }
    while ( v17 );
    return 0LL;
  }
  v28 = v24 + 100;
  v47 = (_QWORD *)a1[9];
  v52 = (_DWORD *)a1[12];
  v54 = v20;
  v56 = v19;
  v29 = malloc(v24 + 100, v25, v24, v17, (void *)v20, (void *)v19, a15, v23, a3, a4, a5, a6, a7, a8, a9, a10);
  if ( v29 )
  {
    v30 = v47;
    if ( v54 < 0 )
    {
      v51 = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))(v29 + 100);
      v53 = v30;
      v55 = v29;
      j_memcpy();
      j_memcpy();
      v40 = (unsigned __int64)v53;
      v41 = v55;
      v17 = v52;
      LODWORD(v19) = v56;
      v31 = v51;
      if ( v53 != (_QWORD *)((char *)a1 + 119) )
        goto LABEL_15;
    }
    else
    {
      v44 = v47;
      v48 = v29;
      v31 = j_memcpy();
      v40 = (unsigned __int64)v44;
      v41 = v48;
      v17 = v52;
      LODWORD(v19) = v56;
      if ( v44 != (_QWORD *)((char *)a1 + 119) )
      {
LABEL_15:
        v45 = v41;
        v49 = v31;
        free(v40, v32, v33, v34, v35, v36, v37, v38, v39);
        v42 = v49;
        a1[9] = v45;
        v17 = (_DWORD *)a1[12];
        v19 = a2 - a1[3];
        a1[11] = v45 + v28;
        goto LABEL_16;
      }
    }
    a1[9] = v41;
    a1[10] = v31;
    a1[11] = v41 + v28;
    goto LABEL_10;
  }
  return 0xFFFFFFFFLL;
}
// 409BF8: variable 'v32' is possibly undefined
// 409BF8: variable 'v33' is possibly undefined
// 409BF8: variable 'v34' is possibly undefined
// 409BF8: variable 'v35' is possibly undefined
// 409BF8: variable 'v36' is possibly undefined
// 409BF8: variable 'v37' is possibly undefined
// 409BF8: variable 'v38' is possibly undefined
// 409BF8: variable 'v39' is possibly undefined

//----- (0000000000409D20) ----------------------------------------------------
void __fastcall IO_un_link_part_0(__int64 a1)
{
  unsigned __int64 v1; // x21
  __int64 v3; // x1
  __int64 v4; // x2
  __int64 v5; // x3
  void *v6; // x4
  void *v7; // x5
  void *v8; // x6
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  int v17; // w0
  int v18; // w0
  __int64 v19; // x24
  __int64 v20; // x0
  __int64 v21; // x1
  __int64 v22; // x2
  __int64 v23; // x3
  void *v24; // x4
  void *v25; // x5
  void *v26; // x6
  double v27; // d0
  double v28; // d1
  double v29; // d2
  double v30; // d3
  double v31; // d4
  double v32; // d5
  double v33; // d6
  double v34; // d7
  int v35; // w0
  _QWORD *v36; // x1
  __int64 v37; // x0
  int v38; // w0
  int v39; // w1
  __int64 v40; // x2
  int v41; // w0
  int v42; // w0
  __int64 v43; // x1
  __int64 v44; // x2
  __int64 v45; // x3
  void *v46; // x4
  void *v47; // x5
  void *v48; // x6
  int v49; // w0
  void *v50; // x20
  __int64 v51; // x1
  __int64 v52; // x2
  __int64 v53; // x3
  void *v54; // x4
  void *v55; // x5
  void *v56; // x6
  int v57; // w0
  _QWORD v58[4]; // [xsp+40h] [xbp+40h] BYREF

  v1 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
  v58[0] = flush_cleanup;
  v58[1] = 0LL;
  _libc_cleanup_push_defer((__int64)v58);
  if ( _libc_single_threaded && !qword_492AB8 )
  {
    LODWORD(list_all_lock) = 1;
    qword_492AB8 = v1;
  }
  else if ( v1 == qword_492AB8 )
  {
    ++HIDWORD(list_all_lock);
  }
  else
  {
    _aarch64_cas4_acq();
    if ( v17 )
      _lll_lock_wait_private(&list_all_lock, v9, v10, v11, v12, v13, v14, v15, v16, v3, v4, v5, v6, v7, v8);
    qword_492AB8 = v1;
  }
  v18 = *(_DWORD *)a1;
  run_fp = a1;
  if ( (v18 & 0x8000) != 0 )
  {
    if ( !IO_list_all )
    {
      v39 = (unsigned __int8)_libc_single_threaded;
      *(_DWORD *)a1 = v18 & 0xFFFFFF7F;
LABEL_25:
      run_fp = 0LL;
      v42 = HIDWORD(list_all_lock);
      if ( v39 )
        goto LABEL_20;
      goto LABEL_26;
    }
    goto LABEL_14;
  }
  v19 = *(_QWORD *)(a1 + 136);
  v20 = *(_QWORD *)(v19 + 8);
  if ( !_libc_single_threaded || v20 )
  {
    if ( v1 == v20 )
    {
      ++*(_DWORD *)(v19 + 4);
    }
    else
    {
      _aarch64_cas4_acq();
      if ( v35 )
        _lll_lock_wait_private((_DWORD *)v19, v27, v28, v29, v30, v31, v32, v33, v34, v21, v22, v23, v24, v25, v26);
      *(_QWORD *)(*(_QWORD *)(a1 + 136) + 8LL) = v1;
    }
  }
  else
  {
    *(_DWORD *)v19 = 1;
    *(_QWORD *)(v19 + 8) = v1;
  }
  if ( IO_list_all )
  {
LABEL_14:
    v36 = *(_QWORD **)(a1 + 184);
    v37 = *(_QWORD *)(a1 + 104);
    *v36 = v37;
    if ( v37 )
      *(_QWORD *)(v37 + 184) = v36;
  }
  v38 = *(_DWORD *)a1;
  *(_DWORD *)a1 &= ~0x80u;
  v39 = (unsigned __int8)_libc_single_threaded;
  if ( (v38 & 0x8000) != 0 )
    goto LABEL_25;
  v40 = *(_QWORD *)(a1 + 136);
  v41 = *(_DWORD *)(v40 + 4);
  if ( !_libc_single_threaded )
  {
    if ( v41 )
    {
      *(_DWORD *)(v40 + 4) = v41 - 1;
      run_fp = 0LL;
      v42 = HIDWORD(list_all_lock);
      if ( HIDWORD(list_all_lock) )
        goto LABEL_21;
      goto LABEL_27;
    }
    *(_QWORD *)(v40 + 8) = 0LL;
    v50 = *(void **)(a1 + 136);
    _aarch64_swp4_rel();
    if ( v57 > 1 )
      _lll_lock_wake_private(v50, v51, v52, v53, v54, v55, v56);
    run_fp = 0LL;
    v42 = HIDWORD(list_all_lock);
    if ( _libc_single_threaded )
      goto LABEL_20;
LABEL_26:
    if ( v42 )
      goto LABEL_21;
LABEL_27:
    qword_492AB8 = 0LL;
    _aarch64_swp4_rel();
    if ( v49 > 1 )
      _lll_lock_wake_private(&list_all_lock, v43, v44, v45, v46, v47, v48);
    goto LABEL_22;
  }
  if ( v41 )
  {
    *(_DWORD *)(v40 + 4) = v41 - 1;
    run_fp = 0LL;
    v42 = HIDWORD(list_all_lock);
    if ( HIDWORD(list_all_lock) )
      goto LABEL_21;
    goto LABEL_31;
  }
  *(_QWORD *)(v40 + 8) = 0LL;
  run_fp = 0LL;
  **(_DWORD **)(a1 + 136) = 0;
  v42 = HIDWORD(list_all_lock);
LABEL_20:
  if ( v42 )
  {
LABEL_21:
    HIDWORD(list_all_lock) = v42 - 1;
LABEL_22:
    _libc_cleanup_pop_restore((__int64)v58);
    return;
  }
LABEL_31:
  LODWORD(list_all_lock) = 0;
  qword_492AB8 = 0LL;
  _libc_cleanup_pop_restore((__int64)v58);
}
// 409D90: variable 'v17' is possibly undefined
// 409F94: variable 'v9' is possibly undefined
// 409F94: variable 'v10' is possibly undefined
// 409F94: variable 'v11' is possibly undefined
// 409F94: variable 'v12' is possibly undefined
// 409F94: variable 'v13' is possibly undefined
// 409F94: variable 'v14' is possibly undefined
// 409F94: variable 'v15' is possibly undefined
// 409F94: variable 'v16' is possibly undefined
// 409F94: variable 'v3' is possibly undefined
// 409F94: variable 'v4' is possibly undefined
// 409F94: variable 'v5' is possibly undefined
// 409F94: variable 'v6' is possibly undefined
// 409F94: variable 'v7' is possibly undefined
// 409F94: variable 'v8' is possibly undefined
// 409DD0: variable 'v35' is possibly undefined
// 409FB0: variable 'v27' is possibly undefined
// 409FB0: variable 'v28' is possibly undefined
// 409FB0: variable 'v29' is possibly undefined
// 409FB0: variable 'v30' is possibly undefined
// 409FB0: variable 'v31' is possibly undefined
// 409FB0: variable 'v32' is possibly undefined
// 409FB0: variable 'v33' is possibly undefined
// 409FB0: variable 'v34' is possibly undefined
// 409FB0: variable 'v21' is possibly undefined
// 409FB0: variable 'v22' is possibly undefined
// 409FB0: variable 'v23' is possibly undefined
// 409FB0: variable 'v24' is possibly undefined
// 409FB0: variable 'v25' is possibly undefined
// 409FB0: variable 'v26' is possibly undefined
// 409EA4: variable 'v49' is possibly undefined
// 409EAC: variable 'v43' is possibly undefined
// 409EAC: variable 'v44' is possibly undefined
// 409EAC: variable 'v45' is possibly undefined
// 409EAC: variable 'v46' is possibly undefined
// 409EAC: variable 'v47' is possibly undefined
// 409EAC: variable 'v48' is possibly undefined
// 409F64: variable 'v57' is possibly undefined
// 409FA0: variable 'v51' is possibly undefined
// 409FA0: variable 'v52' is possibly undefined
// 409FA0: variable 'v53' is possibly undefined
// 409FA0: variable 'v54' is possibly undefined
// 409FA0: variable 'v55' is possibly undefined
// 409FA0: variable 'v56' is possibly undefined
// 490058: using guessed type __int64 *IO_list_all;
// 490F08: using guessed type char _libc_single_threaded;
// 492AA8: using guessed type __int64 run_fp;
// 492AB0: using guessed type __int64 list_all_lock;
// 492AB8: using guessed type __int64 qword_492AB8;

//----- (0000000000409FC0) ----------------------------------------------------
void __fastcall IO_un_link(__int64 a1)
{
  if ( (*(_DWORD *)a1 & 0x80) != 0 )
    IO_un_link_part_0(a1);
}

//----- (0000000000409FD0) ----------------------------------------------------
void __fastcall IO_link_in(int *a1)
{
  int v2; // w0
  _QWORD *v3; // x4
  __int64 *v4; // x3
  unsigned __int64 v5; // x5
  int v6; // w0
  __int64 v7; // x1
  __int64 v8; // x2
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  int v17; // w0
  int v18; // w1
  __int64 v19; // x2
  __int64 v20; // x1
  __int64 v21; // x1
  __int64 v22; // x2
  double v23; // d0
  double v24; // d1
  double v25; // d2
  double v26; // d3
  double v27; // d4
  double v28; // d5
  double v29; // d6
  double v30; // d7
  void *v31; // x5
  int v32; // w0
  __int16 v33; // w2
  int v34; // w2
  __int64 *v35; // x5
  __int64 v36; // x2
  int v37; // w1
  int v38; // w1
  char *v39; // x4
  __int64 *v40; // x2
  char *v41; // x4
  __int64 v42; // x1
  __int64 v43; // x2
  __int64 v44; // x3
  void *v45; // x4
  void *v46; // x5
  void *v47; // x6
  int v48; // w0
  int v49; // w1
  __int64 v50; // x1
  __int64 v51; // x2
  __int64 v52; // x3
  void *v53; // x5
  int v54; // w0
  __int64 v55; // [xsp+20h] [xbp-40h]
  _DWORD *v56; // [xsp+20h] [xbp-40h]
  void *v57; // [xsp+20h] [xbp-40h]
  void *v58; // [xsp+20h] [xbp-40h]
  void *v59; // [xsp+28h] [xbp-38h]
  __int64 v60; // [xsp+28h] [xbp-38h]
  void *v61; // [xsp+38h] [xbp-28h]
  _QWORD v62[4]; // [xsp+40h] [xbp-20h] BYREF

  v2 = *a1;
  if ( (v2 & 0x80) == 0 )
  {
    *a1 = v2 | 0x80;
    v62[0] = flush_cleanup;
    v62[1] = 0LL;
    v55 = (__int64)a1;
    _libc_cleanup_push_defer((__int64)v62);
    v3 = &unk_492000;
    v4 = (__int64 *)v55;
    v5 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
    v6 = (unsigned __int8)_libc_single_threaded;
    if ( _libc_single_threaded && !qword_492AB8 )
    {
      LODWORD(list_all_lock) = 1;
      run_fp = v55;
      v49 = *(_DWORD *)v55;
      qword_492AB8 = v5;
      if ( (v49 & 0x8000) == 0 )
      {
        v19 = *(_QWORD *)(v55 + 136);
        v20 = *(_QWORD *)(v19 + 8);
LABEL_37:
        if ( !v20 )
        {
          *(_DWORD *)v19 = 1;
          *(_QWORD *)(v19 + 8) = v5;
          v34 = *(_DWORD *)v4 & 0x8000;
          goto LABEL_14;
        }
LABEL_10:
        if ( v5 == v20 )
        {
          ++*(_DWORD *)(v19 + 4);
          v34 = *(_DWORD *)v4 & 0x8000;
        }
        else
        {
          v56 = (_DWORD *)v19;
          v60 = (__int64)v4;
          v61 = (void *)v5;
          _aarch64_cas4_acq();
          v3 = &unk_492000;
          v31 = v61;
          v4 = (__int64 *)v60;
          if ( v32 )
          {
            _lll_lock_wait_private(
              v56,
              v23,
              v24,
              v25,
              v26,
              v27,
              v28,
              v29,
              v30,
              v21,
              v22,
              v60,
              &unk_492000,
              v61,
              &_libc_single_threaded);
            v3 = (_QWORD *)&unk_492000;
            v31 = v61;
            v4 = (__int64 *)v60;
          }
          v33 = *(_DWORD *)v4;
          *(_QWORD *)(v4[17] + 8) = v31;
          v34 = v33 & 0x8000;
          v6 = (unsigned __int8)_libc_single_threaded;
        }
LABEL_14:
        v4[23] = (__int64)&IO_list_all;
        v35 = IO_list_all;
        v4[13] = (__int64)IO_list_all;
        if ( v35 )
          v35[23] = (__int64)(v4 + 13);
        IO_list_all = v4;
        if ( !v34 )
        {
          v36 = v4[17];
          v37 = *(_DWORD *)(v36 + 4);
          if ( v6 )
          {
            if ( v37 )
            {
              *(_DWORD *)(v36 + 4) = v37 - 1;
              v3[341] = 0LL;
            }
            else
            {
              *(_QWORD *)(v36 + 8) = 0LL;
              v3[341] = 0LL;
              *(_DWORD *)v4[17] = 0;
            }
            v38 = *((_DWORD *)v3 + 685);
LABEL_21:
            if ( !v38 )
            {
              v39 = (char *)(v3 + 341);
              *((_DWORD *)v39 + 2) = 0;
              *((_QWORD *)v39 + 2) = 0LL;
LABEL_31:
              _libc_cleanup_pop_restore((__int64)v62);
              return;
            }
LABEL_32:
            *((_DWORD *)v3 + 685) = v38 - 1;
            _libc_cleanup_pop_restore((__int64)v62);
            return;
          }
          if ( v37 )
          {
            *(_DWORD *)(v36 + 4) = v37 - 1;
            v3[341] = 0LL;
            v38 = *((_DWORD *)v3 + 685);
            goto LABEL_28;
          }
          *(_QWORD *)(v36 + 8) = 0LL;
          v58 = (void *)v4[17];
          _aarch64_swp4_rel();
          v3 = (_QWORD *)&unk_492000;
          if ( v54 > 1 )
          {
            _lll_lock_wake_private(v58, v50, v51, v52, &unk_492000, v53, &_libc_single_threaded);
            v3 = (_QWORD *)&unk_492000;
          }
          v6 = (unsigned __int8)_libc_single_threaded;
        }
LABEL_27:
        v3[341] = 0LL;
        v38 = *((_DWORD *)v3 + 685);
        if ( v6 )
          goto LABEL_21;
LABEL_28:
        if ( !v38 )
        {
          v41 = (char *)(v3 + 341);
          v57 = v41 + 8;
          *((_QWORD *)v41 + 2) = 0LL;
          _aarch64_swp4_rel();
          if ( v48 > 1 )
            _lll_lock_wake_private(v57, v42, v43, v44, v45, v46, v47);
          goto LABEL_31;
        }
        goto LABEL_32;
      }
    }
    else
    {
      if ( v5 == qword_492AB8 )
      {
        ++HIDWORD(list_all_lock);
      }
      else
      {
        v59 = (void *)v5;
        _aarch64_cas4_acq();
        v3 = &unk_492000;
        v5 = (unsigned __int64)v59;
        v4 = (__int64 *)v55;
        if ( v17 )
        {
          _lll_lock_wait_private(
            &list_all_lock,
            v9,
            v10,
            v11,
            v12,
            v13,
            v14,
            v15,
            v16,
            v7,
            v8,
            v55,
            &unk_492000,
            v59,
            &_libc_single_threaded);
          v3 = (_QWORD *)&unk_492000;
          v5 = (unsigned __int64)v59;
          v4 = (__int64 *)v55;
        }
        v3[343] = v5;
        v6 = (unsigned __int8)_libc_single_threaded;
      }
      v18 = *(_DWORD *)v4;
      v3[341] = v4;
      if ( (v18 & 0x8000) == 0 )
      {
        v19 = v4[17];
        v20 = *(_QWORD *)(v19 + 8);
        if ( !v6 )
          goto LABEL_10;
        goto LABEL_37;
      }
    }
    v4[23] = (__int64)&IO_list_all;
    v40 = IO_list_all;
    v4[13] = (__int64)IO_list_all;
    if ( v40 )
      v40[23] = (__int64)(v4 + 13);
    IO_list_all = v4;
    goto LABEL_27;
  }
}
// 40A06C: variable 'v17' is possibly undefined
// 40A298: variable 'v9' is possibly undefined
// 40A298: variable 'v10' is possibly undefined
// 40A298: variable 'v11' is possibly undefined
// 40A298: variable 'v12' is possibly undefined
// 40A298: variable 'v13' is possibly undefined
// 40A298: variable 'v14' is possibly undefined
// 40A298: variable 'v15' is possibly undefined
// 40A298: variable 'v16' is possibly undefined
// 40A298: variable 'v7' is possibly undefined
// 40A298: variable 'v8' is possibly undefined
// 40A0BC: variable 'v32' is possibly undefined
// 40A2B4: variable 'v23' is possibly undefined
// 40A2B4: variable 'v24' is possibly undefined
// 40A2B4: variable 'v25' is possibly undefined
// 40A2B4: variable 'v26' is possibly undefined
// 40A2B4: variable 'v27' is possibly undefined
// 40A2B4: variable 'v28' is possibly undefined
// 40A2B4: variable 'v29' is possibly undefined
// 40A2B4: variable 'v30' is possibly undefined
// 40A2B4: variable 'v21' is possibly undefined
// 40A2B4: variable 'v22' is possibly undefined
// 40A1A0: variable 'v48' is possibly undefined
// 40A2CC: variable 'v42' is possibly undefined
// 40A2CC: variable 'v43' is possibly undefined
// 40A2CC: variable 'v44' is possibly undefined
// 40A2CC: variable 'v45' is possibly undefined
// 40A2CC: variable 'v46' is possibly undefined
// 40A2CC: variable 'v47' is possibly undefined
// 40A268: variable 'v54' is possibly undefined
// 40A2DC: variable 'v50' is possibly undefined
// 40A2DC: variable 'v51' is possibly undefined
// 40A2DC: variable 'v52' is possibly undefined
// 40A2DC: variable 'v53' is possibly undefined
// 490058: using guessed type __int64 *IO_list_all;
// 490F08: using guessed type char _libc_single_threaded;
// 492AA8: using guessed type __int64 run_fp;
// 492AB0: using guessed type __int64 list_all_lock;
// 492AB8: using guessed type __int64 qword_492AB8;

//----- (000000000040A2F0) ----------------------------------------------------
__int64 __fastcall IO_switch_to_main_get_area(__int64 result)
{
  __int64 v1; // x3
  __int64 v2; // x2
  __int64 v3; // x1

  v1 = *(_QWORD *)(result + 88);
  *(_DWORD *)result &= ~0x100u;
  v2 = *(_QWORD *)(result + 24);
  *(_QWORD *)(result + 88) = *(_QWORD *)(result + 16);
  v3 = *(_QWORD *)(result + 72);
  *(_QWORD *)(result + 8) = v3;
  *(_QWORD *)(result + 16) = v1;
  *(_QWORD *)(result + 24) = v3;
  *(_QWORD *)(result + 72) = v2;
  return result;
}

//----- (000000000040A320) ----------------------------------------------------
__int64 __fastcall IO_switch_to_backup_area(__int64 result)
{
  __int64 v1; // x2
  __int64 v2; // x3
  __int64 v3; // x1

  v2 = *(_QWORD *)(result + 16);
  v1 = *(_QWORD *)(result + 24);
  *(_DWORD *)result |= 0x100u;
  v3 = *(_QWORD *)(result + 88);
  *(_QWORD *)(result + 8) = v3;
  *(_QWORD *)(result + 16) = v3;
  *(_QWORD *)(result + 24) = *(_QWORD *)(result + 72);
  *(_QWORD *)(result + 72) = v1;
  *(_QWORD *)(result + 88) = v2;
  return result;
}

//----- (000000000040A34C) ----------------------------------------------------
__int64 __fastcall IO_switch_to_get_mode(
        int *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  unsigned int *v9; // x2
  unsigned __int64 v10; // x0
  unsigned __int64 v11; // x1
  __int64 v12; // x1
  __int64 result; // x0
  unsigned int v14; // w1
  unsigned __int64 v15; // x0
  unsigned int v16; // w1
  unsigned int *v17; // [xsp+10h] [xbp-10h]
  __int64 v18; // [xsp+10h] [xbp-10h]
  unsigned int *v19; // [xsp+18h] [xbp-8h]

  v9 = (unsigned int *)a1;
  v11 = *((_QWORD *)a1 + 4);
  v10 = *((_QWORD *)a1 + 5);
  if ( v10 <= v11 )
  {
    v16 = *v9;
    if ( (*v9 & 0x100) != 0 )
    {
      *((_QWORD *)v9 + 3) = *((_QWORD *)v9 + 10);
    }
    else
    {
      *((_QWORD *)v9 + 3) = *((_QWORD *)v9 + 7);
      if ( *((_QWORD *)v9 + 2) < v10 )
      {
        *v9 = v16 & 0xFFFFF7FF;
        *((_QWORD *)v9 + 1) = v10;
        *((_QWORD *)v9 + 2) = v10;
        *((_QWORD *)v9 + 4) = v10;
        *((_QWORD *)v9 + 6) = v10;
        return 0LL;
      }
    }
    *v9 = v16 & 0xFFFFF7FF;
    *((_QWORD *)v9 + 1) = v10;
    *((_QWORD *)v9 + 4) = v10;
    *((_QWORD *)v9 + 6) = v10;
    return 0LL;
  }
  v12 = *((_QWORD *)v9 + 27);
  if ( (unsigned __int64)(v12 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v18 = *((_QWORD *)v9 + 27);
    v19 = v9;
    IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
    v12 = v18;
    v9 = v19;
  }
  v17 = v9;
  result = (*(__int64 (__fastcall **)(unsigned int *, __int64))(v12 + 24))(v9, 0xFFFFFFFFLL);
  if ( (_DWORD)result != -1 )
  {
    v14 = *v17;
    v15 = *((_QWORD *)v17 + 5);
    if ( (*v17 & 0x100) != 0 )
    {
      *((_QWORD *)v17 + 3) = *((_QWORD *)v17 + 10);
    }
    else
    {
      *((_QWORD *)v17 + 3) = *((_QWORD *)v17 + 7);
      if ( *((_QWORD *)v17 + 2) < v15 )
        *((_QWORD *)v17 + 2) = v15;
    }
    *v17 = v14 & 0xFFFFF7FF;
    *((_QWORD *)v17 + 1) = v15;
    *((_QWORD *)v17 + 4) = v15;
    *((_QWORD *)v17 + 6) = v15;
    return 0LL;
  }
  return result;
}

//----- (000000000040A460) ----------------------------------------------------
void __fastcall IO_free_backup_area(
        _QWORD *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  int v9; // w2
  unsigned __int64 v11; // x0
  __int64 v12; // x2
  unsigned __int64 v13; // x2
  _QWORD *v14; // [xsp+18h] [xbp-8h]

  v9 = *(_DWORD *)a1;
  v11 = a1[9];
  if ( (v9 & 0x100) != 0 )
  {
    *(_DWORD *)a1 = v9 & 0xFFFFFEFF;
    v12 = a1[11];
    a1[1] = v11;
    a1[2] = v12;
    v13 = a1[3];
    a1[3] = v11;
    v11 = v13;
  }
  if ( (_QWORD *)v11 == (_QWORD *)((char *)a1 + 119) )
  {
    a1[9] = 0LL;
    a1[10] = 0LL;
    a1[11] = 0LL;
  }
  else
  {
    v14 = a1;
    free(v11, a2, a3, a4, a5, a6, a7, a8, a9);
    v14[9] = 0LL;
    v14[10] = 0LL;
    v14[11] = 0LL;
  }
}

//----- (000000000040A4C8) ----------------------------------------------------
__int64 __fastcall _overflow(
        __int64 a1,
        unsigned int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  __int64 v10; // x3
  __int64 v12; // [xsp+18h] [xbp-18h]

  if ( !*(_DWORD *)(a1 + 192) )
    *(_DWORD *)(a1 + 192) = -1;
  v10 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v10 - (_QWORD)&_io_vtables) <= 0x92F )
    return (*(__int64 (**)(void))(v10 + 24))();
  v12 = *(_QWORD *)(a1 + 216);
  IO_vtable_check(a3, a4, a5, a6, a7, a8, a9, a10);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(v12 + 24))(a1, a2);
}

//----- (000000000040A528) ----------------------------------------------------
__int64 __fastcall _underflow(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        unsigned __int64 a12,
        __int64 a13,
        __int64 a14,
        void *a15)
{
  __int64 v15; // x2
  int v16; // w0
  unsigned __int8 *v17; // x0
  unsigned __int64 v18; // x1
  __int64 v19; // x1
  int v20; // w0
  __int64 v21; // x1
  unsigned __int64 v23; // x0
  __int64 v24; // x1
  unsigned __int64 v25; // x1
  int mode; // w0
  __int64 v27; // [xsp+10h] [xbp+10h]
  __int64 v28; // [xsp+10h] [xbp+10h]
  __int64 v29; // [xsp+10h] [xbp+10h]
  __int64 v30; // [xsp+10h] [xbp+10h]
  __int64 v31; // [xsp+18h] [xbp+18h]

  v15 = a1;
  v16 = *(_DWORD *)(a1 + 192);
  if ( v16 )
  {
    if ( v16 != -1 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    *(_DWORD *)(v15 + 192) = -1;
  }
  if ( (*(_DWORD *)v15 & 0x800) != 0 )
  {
    v29 = v15;
    mode = IO_switch_to_get_mode((int *)v15, a2, a3, a4, a5, a6, a7, a8, a9);
    v15 = v29;
    if ( mode == -1 )
      return 0xFFFFFFFFLL;
  }
  v17 = *(unsigned __int8 **)(v15 + 8);
  v18 = *(_QWORD *)(v15 + 16);
  if ( (unsigned __int64)v17 < v18 )
    return *v17;
  if ( (*(_DWORD *)v15 & 0x100) != 0 )
  {
    *(_DWORD *)v15 &= ~0x100u;
    v17 = *(unsigned __int8 **)(v15 + 72);
    a12 = *(_QWORD *)(v15 + 88);
    *(_QWORD *)(v15 + 88) = v18;
    v19 = *(_QWORD *)(v15 + 24);
    *(_QWORD *)(v15 + 8) = v17;
    *(_QWORD *)(v15 + 16) = a12;
    *(_QWORD *)(v15 + 24) = v17;
    *(_QWORD *)(v15 + 72) = v19;
    if ( a12 > (unsigned __int64)v17 )
      return *v17;
  }
  if ( *(_QWORD *)(v15 + 96) )
  {
    v27 = v15;
    v20 = save_for_backup((_QWORD *)v15, *(_QWORD *)(v15 + 16), a2, a3, a4, a5, a6, a7, a8, a9, v15, a12, a13, a14, a15);
    v15 = v27;
    if ( v20 )
      return 0xFFFFFFFFLL;
  }
  else if ( *(_QWORD *)(v15 + 80) )
  {
    v23 = *(_QWORD *)(v15 + 72);
    if ( (*(_DWORD *)v15 & 0x100) != 0 )
    {
      *(_DWORD *)v15 &= ~0x100u;
      v24 = *(_QWORD *)(v15 + 88);
      *(_QWORD *)(v15 + 8) = v23;
      *(_QWORD *)(v15 + 16) = v24;
      v25 = *(_QWORD *)(v15 + 24);
      *(_QWORD *)(v15 + 24) = v23;
      v23 = v25;
    }
    if ( v23 != v15 + 119 )
    {
      v28 = v15;
      free(v23, a2, a3, a4, a5, a6, a7, a8, a9);
      v15 = v28;
    }
    *(_QWORD *)(v15 + 72) = 0LL;
    *(_QWORD *)(v15 + 80) = 0LL;
    *(_QWORD *)(v15 + 88) = 0LL;
  }
  v21 = *(_QWORD *)(v15 + 216);
  if ( (unsigned __int64)(v21 - (_QWORD)&_io_vtables) <= 0x92F )
    return (*(__int64 (__fastcall **)(__int64))(v21 + 32))(v15);
  v30 = *(_QWORD *)(v15 + 216);
  v31 = v15;
  IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
  return (*(__int64 (__fastcall **)(__int64))(v30 + 32))(v31);
}
// 40A5A0: variable 'a2' is possibly undefined
// 40A5A0: variable 'a3' is possibly undefined
// 40A5A0: variable 'a4' is possibly undefined
// 40A5A0: variable 'a5' is possibly undefined
// 40A5A0: variable 'a6' is possibly undefined
// 40A5A0: variable 'a7' is possibly undefined
// 40A5A0: variable 'a8' is possibly undefined
// 40A5A0: variable 'a9' is possibly undefined
// 40A5A0: variable 'a12' is possibly undefined
// 40A5A0: variable 'a13' is possibly undefined
// 40A5A0: variable 'a14' is possibly undefined
// 40A5A0: variable 'a15' is possibly undefined

//----- (000000000040A680) ----------------------------------------------------
__int64 __fastcall _uflow(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        unsigned __int64 a12,
        __int64 a13,
        __int64 a14,
        void *a15)
{
  __int64 v15; // x2
  int v16; // w0
  unsigned __int8 *v17; // x0
  unsigned __int64 v18; // x1
  __int64 v19; // x1
  int v20; // w0
  __int64 v21; // x1
  unsigned __int64 v23; // x0
  __int64 v24; // x1
  unsigned __int64 v25; // x1
  int mode; // w0
  __int64 v27; // [xsp+10h] [xbp+10h]
  __int64 v28; // [xsp+10h] [xbp+10h]
  __int64 v29; // [xsp+10h] [xbp+10h]
  __int64 v30; // [xsp+10h] [xbp+10h]
  __int64 v31; // [xsp+18h] [xbp+18h]

  v15 = a1;
  v16 = *(_DWORD *)(a1 + 192);
  if ( v16 )
  {
    if ( v16 != -1 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    *(_DWORD *)(v15 + 192) = -1;
  }
  if ( (*(_DWORD *)v15 & 0x800) != 0 )
  {
    v29 = v15;
    mode = IO_switch_to_get_mode((int *)v15, a2, a3, a4, a5, a6, a7, a8, a9);
    v15 = v29;
    if ( mode == -1 )
      return 0xFFFFFFFFLL;
  }
  v17 = *(unsigned __int8 **)(v15 + 8);
  v18 = *(_QWORD *)(v15 + 16);
  if ( (unsigned __int64)v17 < v18 )
    goto LABEL_20;
  if ( (*(_DWORD *)v15 & 0x100) == 0 )
    goto LABEL_8;
  *(_DWORD *)v15 &= ~0x100u;
  v17 = *(unsigned __int8 **)(v15 + 72);
  a12 = *(_QWORD *)(v15 + 88);
  *(_QWORD *)(v15 + 88) = v18;
  v19 = *(_QWORD *)(v15 + 24);
  *(_QWORD *)(v15 + 16) = a12;
  *(_QWORD *)(v15 + 24) = v17;
  *(_QWORD *)(v15 + 72) = v19;
  if ( a12 > (unsigned __int64)v17 )
  {
LABEL_20:
    *(_QWORD *)(v15 + 8) = v17 + 1;
    return *v17;
  }
  *(_QWORD *)(v15 + 8) = v17;
LABEL_8:
  if ( *(_QWORD *)(v15 + 96) )
  {
    v27 = v15;
    v20 = save_for_backup((_QWORD *)v15, *(_QWORD *)(v15 + 16), a2, a3, a4, a5, a6, a7, a8, a9, v15, a12, a13, a14, a15);
    v15 = v27;
    if ( v20 )
      return 0xFFFFFFFFLL;
  }
  else if ( *(_QWORD *)(v15 + 80) )
  {
    v23 = *(_QWORD *)(v15 + 72);
    if ( (*(_DWORD *)v15 & 0x100) != 0 )
    {
      *(_DWORD *)v15 &= ~0x100u;
      v24 = *(_QWORD *)(v15 + 88);
      *(_QWORD *)(v15 + 8) = v23;
      *(_QWORD *)(v15 + 16) = v24;
      v25 = *(_QWORD *)(v15 + 24);
      *(_QWORD *)(v15 + 24) = v23;
      v23 = v25;
    }
    if ( v23 != v15 + 119 )
    {
      v28 = v15;
      free(v23, a2, a3, a4, a5, a6, a7, a8, a9);
      v15 = v28;
    }
    *(_QWORD *)(v15 + 72) = 0LL;
    *(_QWORD *)(v15 + 80) = 0LL;
    *(_QWORD *)(v15 + 88) = 0LL;
  }
  v21 = *(_QWORD *)(v15 + 216);
  if ( (unsigned __int64)(v21 - (_QWORD)&_io_vtables) <= 0x92F )
    return (*(__int64 (__fastcall **)(__int64))(v21 + 40))(v15);
  v30 = *(_QWORD *)(v15 + 216);
  v31 = v15;
  IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
  return (*(__int64 (__fastcall **)(__int64))(v30 + 40))(v31);
}
// 40A6F8: variable 'a2' is possibly undefined
// 40A6F8: variable 'a3' is possibly undefined
// 40A6F8: variable 'a4' is possibly undefined
// 40A6F8: variable 'a5' is possibly undefined
// 40A6F8: variable 'a6' is possibly undefined
// 40A6F8: variable 'a7' is possibly undefined
// 40A6F8: variable 'a8' is possibly undefined
// 40A6F8: variable 'a9' is possibly undefined
// 40A6F8: variable 'a12' is possibly undefined
// 40A6F8: variable 'a13' is possibly undefined
// 40A6F8: variable 'a14' is possibly undefined
// 40A6F8: variable 'a15' is possibly undefined

//----- (000000000040A7E0) ----------------------------------------------------
__int64 __fastcall IO_setb(
        int *a1,
        __int64 a2,
        __int64 a3,
        int a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  int v12; // w4
  unsigned __int64 v14; // x0
  __int64 result; // x0
  int v16; // w4
  unsigned int v17; // w4
  int *v18; // [xsp+10h] [xbp-20h]

  v12 = *a1;
  v14 = *((_QWORD *)a1 + 7);
  if ( v14 && (v12 & 1) == 0 )
  {
    v18 = a1;
    free(v14, a5, a6, a7, a8, a9, a10, a11, a12);
    *((_QWORD *)v18 + 7) = a2;
    *((_QWORD *)v18 + 8) = a3;
    result = *v18 & 0xFFFFFFFE;
    v17 = *v18 | 1;
    if ( a4 )
      v17 = *v18 & 0xFFFFFFFE;
    *v18 = v17;
  }
  else
  {
    result = v12 & 0xFFFFFFFE;
    v16 = v12 | 1;
    *((_QWORD *)a1 + 7) = a2;
    *((_QWORD *)a1 + 8) = a3;
    if ( a4 )
      v16 = result;
    *a1 = v16;
  }
  return result;
}

//----- (000000000040A860) ----------------------------------------------------
void __fastcall IO_doallocbuf(
        int *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  int *v9; // x1
  __int64 v10; // x2
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7
  int *v19; // x1
  __int64 v20; // x4
  int *v21; // x3
  unsigned __int64 v22; // x0
  int v23; // w2
  int *v24; // [xsp+18h] [xbp-18h]
  __int64 v25; // [xsp+18h] [xbp-18h]

  v9 = a1;
  if ( !*((_QWORD *)a1 + 7) )
  {
    if ( (*a1 & 2) != 0 && a1[48] <= 0 )
    {
      *a1 |= 1u;
      *((_QWORD *)a1 + 7) = (char *)a1 + 131;
      *((_QWORD *)a1 + 8) = a1 + 33;
    }
    else
    {
      v10 = *((_QWORD *)a1 + 27);
      if ( (unsigned __int64)(v10 - (_QWORD)&_io_vtables) > 0x92F )
      {
        v25 = *((_QWORD *)a1 + 27);
        IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
        v10 = v25;
        v9 = a1;
      }
      v24 = v9;
      if ( (*(unsigned int (__fastcall **)(int *))(v10 + 104))(v9) == -1 )
      {
        v19 = v24;
        v20 = (__int64)v24 + 131;
        v21 = v24 + 33;
        v22 = *((_QWORD *)v24 + 7);
        v23 = *v24;
        if ( v22 )
        {
          if ( (v23 & 1) == 0 )
          {
            free(v22, v11, v12, v13, v14, v15, v16, v17, v18);
            v19 = v24;
            v20 = (__int64)v24 + 131;
            v21 = v24 + 33;
            v23 = *v24;
          }
        }
        *v19 = v23 | 1;
        *((_QWORD *)v19 + 7) = v20;
        *((_QWORD *)v19 + 8) = v21;
      }
    }
  }
}
// 40A90C: variable 'v11' is possibly undefined
// 40A90C: variable 'v12' is possibly undefined
// 40A90C: variable 'v13' is possibly undefined
// 40A90C: variable 'v14' is possibly undefined
// 40A90C: variable 'v15' is possibly undefined
// 40A90C: variable 'v16' is possibly undefined
// 40A90C: variable 'v17' is possibly undefined
// 40A90C: variable 'v18' is possibly undefined

//----- (000000000040A930) ----------------------------------------------------
__int64 IO_default_underflow()
{
  return 0xFFFFFFFFLL;
}

//----- (000000000040A940) ----------------------------------------------------
__int64 __fastcall IO_default_uflow(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v9; // x1
  __int64 result; // x0
  unsigned __int8 *v12; // x0
  __int64 v13; // [xsp+28h] [xbp+28h]

  v9 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v9 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v13 = *(_QWORD *)(a1 + 216);
    IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
    v9 = v13;
  }
  result = (*(__int64 (__fastcall **)(__int64))(v9 + 32))(a1);
  if ( (_DWORD)result != -1 )
  {
    v12 = *(unsigned __int8 **)(a1 + 8);
    *(_QWORD *)(a1 + 8) = v12 + 1;
    return *v12;
  }
  return result;
}

//----- (000000000040A9A8) ----------------------------------------------------
unsigned __int64 __fastcall IO_default_xsputn(
        _QWORD *a1,
        unsigned __int8 *a2,
        unsigned __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  unsigned __int64 v11; // x20
  unsigned __int64 v14; // x23
  unsigned __int64 v15; // x0
  unsigned __int64 v16; // x19
  unsigned __int64 v17; // x19
  __int64 v18; // x19
  __int64 i; // x1

  if ( !a3 )
    return 0LL;
  v11 = a3;
  v14 = a3;
  while ( 1 )
  {
    v15 = a1[5];
    v16 = a1[6];
    if ( v15 < v16 )
    {
      v17 = v16 - v15;
      if ( v17 > v11 )
        v17 = v11;
      if ( v17 > 0x14 )
      {
        a2 += v17;
        v11 -= v17;
        a1[5] = (char *)j_memcpy() + v17;
      }
      else if ( v17 )
      {
        for ( i = 0LL; i != v17; ++i )
          *(_BYTE *)(v15 + i) = a2[i];
        a2 += v17;
        v11 -= v17;
        a1[5] = v15 + v17;
      }
    }
    if ( !v11 )
      break;
    v18 = a1[27];
    if ( (unsigned __int64)(v18 - (_QWORD)&_io_vtables) > 0x92F )
      IO_vtable_check(a4, a5, a6, a7, a8, a9, a10, a11);
    if ( (*(unsigned int (__fastcall **)(_QWORD *, _QWORD))(v18 + 24))(a1, *a2) == -1 )
    {
      v14 -= v11;
      return v14;
    }
    ++a2;
    --v11;
  }
  return v14;
}
// 40AAA8: variable 'a4' is possibly undefined
// 40AAA8: variable 'a5' is possibly undefined
// 40AAA8: variable 'a6' is possibly undefined
// 40AAA8: variable 'a7' is possibly undefined
// 40AAA8: variable 'a8' is possibly undefined
// 40AAA8: variable 'a9' is possibly undefined
// 40AAA8: variable 'a10' is possibly undefined
// 40AAA8: variable 'a11' is possibly undefined

//----- (000000000040AAC0) ----------------------------------------------------
__int64 __fastcall IO_sgetn(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  __int64 v11; // x4
  __int64 v13; // [xsp+10h] [xbp-20h]

  v11 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v11 - (_QWORD)&_io_vtables) <= 0x92F )
    return (*(__int64 (**)(void))(v11 + 64))();
  v13 = *(_QWORD *)(a1 + 216);
  IO_vtable_check(a4, a5, a6, a7, a8, a9, a10, a11);
  return (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v13 + 64))(a1, a2, a3);
}

//----- (000000000040AB10) ----------------------------------------------------
unsigned __int64 __fastcall IO_default_xsgetn(
        __int64 a1,
        char *a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        __int64 a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  unsigned __int64 v17; // x22
  unsigned __int64 v18; // x23
  unsigned __int64 v19; // x1
  unsigned __int64 v20; // x19
  unsigned __int64 v21; // x19
  unsigned __int64 v22; // x19
  __int64 v23; // x3

  v17 = a3;
  v18 = a3;
  v19 = *(_QWORD *)(a1 + 8);
  v20 = *(_QWORD *)(a1 + 16);
  if ( v19 >= v20 )
    goto LABEL_6;
  v21 = v20 - v19;
  if ( v21 > a3 )
    v21 = a3;
  if ( v21 > 0x14 )
    goto LABEL_12;
LABEL_5:
  if ( v21 )
  {
    a5 = (unsigned int)(v21 - 1);
    a3 = (unsigned int)v21;
    v23 = 0LL;
    do
    {
      a2[v23] = *(_BYTE *)(v19 + v23);
      ++v23;
    }
    while ( (unsigned int)v21 != v23 );
    a4 = v19 + 1 + a5;
    a2 += a5 + 1;
    v18 -= v21;
    *(_QWORD *)(a1 + 8) = a4;
  }
LABEL_6:
  while ( v18 )
  {
    do
    {
      if ( (unsigned int)_underflow(a1, a8, a9, a10, a11, a12, a13, a14, a15, v19, a3, a4, a5, a6, a7) == -1 )
      {
        v17 -= v18;
        return v17;
      }
      v19 = *(_QWORD *)(a1 + 8);
      v22 = *(_QWORD *)(a1 + 16);
    }
    while ( v19 >= v22 );
    v21 = v22 - v19;
    if ( v21 > v18 )
      v21 = v18;
    if ( v21 <= 0x14 )
      goto LABEL_5;
LABEL_12:
    a2 = (char *)j_memcpy() + v21;
    v18 -= v21;
    *(_QWORD *)(a1 + 8) += v21;
  }
  return v17;
}
// 40AB70: variable 'a8' is possibly undefined
// 40AB70: variable 'a9' is possibly undefined
// 40AB70: variable 'a10' is possibly undefined
// 40AB70: variable 'a11' is possibly undefined
// 40AB70: variable 'a12' is possibly undefined
// 40AB70: variable 'a13' is possibly undefined
// 40AB70: variable 'a14' is possibly undefined
// 40AB70: variable 'a15' is possibly undefined
// 40AB70: variable 'v19' is possibly undefined
// 40AB70: variable 'a3' is possibly undefined
// 40AB70: variable 'a4' is possibly undefined
// 40AB70: variable 'a5' is possibly undefined
// 40AB70: variable 'a6' is possibly undefined
// 40AB70: variable 'a7' is possibly undefined

//----- (000000000040AC20) ----------------------------------------------------
__int64 __fastcall IO_default_setbuf(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  __int64 v13; // x1
  double v14; // d0
  double v15; // d1
  double v16; // d2
  double v17; // d3
  double v18; // d4
  double v19; // d5
  double v20; // d6
  double v21; // d7
  unsigned __int64 v22; // x0
  bool v23; // zf
  unsigned int v24; // w3
  unsigned int v25; // w1
  __int64 v26; // x2
  __int64 result; // x0
  __int64 v28; // [xsp+20h] [xbp+20h]
  __int64 v29; // [xsp+20h] [xbp+20h]
  __int64 v30; // [xsp+20h] [xbp+20h]
  __int64 v31; // [xsp+28h] [xbp+28h]

  v13 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v13 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v30 = *(_QWORD *)(a1 + 216);
    v31 = a3;
    IO_vtable_check(a4, a5, a6, a7, a8, a9, a10, a11);
    v13 = v30;
    a3 = v31;
  }
  v28 = a3;
  if ( (*(unsigned int (__fastcall **)(__int64))(v13 + 96))(a1) != -1 )
  {
    v22 = *(_QWORD *)(a1 + 56);
    if ( a2 )
      v23 = v28 == 0;
    else
      v23 = 1;
    v24 = *(_DWORD *)a1;
    if ( v23 )
    {
      v25 = v24 | 2;
      v26 = a1 + 132;
      *(_DWORD *)a1 = v24 | 2;
      a2 = a1 + 131;
      if ( !v22 || (v24 & 1) != 0 )
        goto LABEL_11;
    }
    else
    {
      v25 = v24 & 0xFFFFFFFD;
      *(_DWORD *)a1 = v24 & 0xFFFFFFFD;
      v26 = a2 + v28;
      if ( !v22 || (v24 & 1) != 0 )
        goto LABEL_11;
    }
    v29 = v26;
    free(v22, v14, v15, v16, v17, v18, v19, v20, v21);
    v26 = v29;
    v25 = *(_DWORD *)a1;
LABEL_11:
    *(_DWORD *)a1 = v25 | 1;
    result = a1;
    *(_QWORD *)(a1 + 56) = a2;
    *(_QWORD *)(a1 + 64) = v26;
    *(_OWORD *)(a1 + 8) = 0u;
    *(_OWORD *)(a1 + 24) = 0u;
    *(_OWORD *)(a1 + 40) = 0u;
    return result;
  }
  return 0LL;
}
// 40ACD8: variable 'v14' is possibly undefined
// 40ACD8: variable 'v15' is possibly undefined
// 40ACD8: variable 'v16' is possibly undefined
// 40ACD8: variable 'v17' is possibly undefined
// 40ACD8: variable 'v18' is possibly undefined
// 40ACD8: variable 'v19' is possibly undefined
// 40ACD8: variable 'v20' is possibly undefined
// 40ACD8: variable 'v21' is possibly undefined

//----- (000000000040AD00) ----------------------------------------------------
__int64 __fastcall IO_default_seekpos(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  __int64 v11; // x5
  __int64 v13; // [xsp+10h] [xbp-20h]

  v11 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v11 - (_QWORD)&_io_vtables) <= 0x92F )
    return (*(__int64 (**)(void))(v11 + 72))();
  v13 = *(_QWORD *)(a1 + 216);
  IO_vtable_check(a4, a5, a6, a7, a8, a9, a10, a11);
  return (*(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD))(v13 + 72))(a1, a2, 0LL, a3);
}

//----- (000000000040AD68) ----------------------------------------------------
__int64 __fastcall IO_default_doallocate(
        unsigned int *a1,
        __int64 a2,
        __int64 a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  unsigned __int64 v17; // x0
  double v18; // d0
  double v19; // d1
  double v20; // d2
  double v21; // d3
  double v22; // d4
  double v23; // d5
  double v24; // d6
  double v25; // d7
  unsigned __int64 v26; // x1
  unsigned __int64 v27; // x3
  unsigned __int64 v28; // x0
  unsigned int v29; // w2
  unsigned __int64 v31; // [xsp+20h] [xbp+20h]
  unsigned __int64 v32; // [xsp+28h] [xbp+28h]

  v17 = malloc(0x2000LL, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
  if ( !v17 )
    return 0xFFFFFFFFLL;
  v26 = v17;
  v27 = v17 + 0x2000;
  v28 = *((_QWORD *)a1 + 7);
  v29 = *a1;
  if ( v28 )
  {
    if ( (v29 & 1) == 0 )
    {
      v31 = v27;
      v32 = v26;
      free(v28, v18, v19, v20, v21, v22, v23, v24, v25);
      v29 = *a1;
      v27 = v31;
      v26 = v32;
    }
  }
  *a1 = v29 & 0xFFFFFFFE;
  *((_QWORD *)a1 + 7) = v26;
  *((_QWORD *)a1 + 8) = v27;
  return 1LL;
}
// 40ADBC: variable 'v18' is possibly undefined
// 40ADBC: variable 'v19' is possibly undefined
// 40ADBC: variable 'v20' is possibly undefined
// 40ADBC: variable 'v21' is possibly undefined
// 40ADBC: variable 'v22' is possibly undefined
// 40ADBC: variable 'v23' is possibly undefined
// 40ADBC: variable 'v24' is possibly undefined
// 40ADBC: variable 'v25' is possibly undefined

//----- (000000000040ADE0) ----------------------------------------------------
__int64 __fastcall IO_init_internal(__int64 result, int a2)
{
  _QWORD *v2; // x1

  *(_DWORD *)result = a2 | 0xFBAD0000;
  *(_WORD *)(result + 116) = (stdio_needs_locking != 0) << 7;
  *(_BYTE *)(result + 118) = 0;
  *(_WORD *)(result + 128) = 0;
  v2 = *(_QWORD **)(result + 136);
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 40) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(_QWORD *)(result + 104) = 0LL;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + 88) = 0u;
  if ( v2 )
  {
    *v2 = 0LL;
    v2[1] = 0LL;
  }
  *(_DWORD *)(result + 192) = -1;
  *(_OWORD *)(result + 160) = xmmword_45B770;
  return result;
}
// 45B770: using guessed type __int128 xmmword_45B770;
// 492AC0: using guessed type int stdio_needs_locking;

//----- (000000000040AE50) ----------------------------------------------------
__int64 __fastcall IO_init(__int64 result, int a2)
{
  _QWORD *v2; // x1

  *(_DWORD *)result = a2 | 0xFBAD0000;
  *(_WORD *)(result + 116) = (stdio_needs_locking != 0) << 7;
  *(_BYTE *)(result + 118) = 0;
  *(_WORD *)(result + 128) = 0;
  v2 = *(_QWORD **)(result + 136);
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 40) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(_QWORD *)(result + 104) = 0LL;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + 88) = 0u;
  if ( v2 )
  {
    *v2 = 0LL;
    v2[1] = 0LL;
  }
  *(_DWORD *)(result + 192) = -1;
  *(_OWORD *)(result + 160) = xmmword_45B770;
  return result;
}
// 45B770: using guessed type __int128 xmmword_45B770;
// 492AC0: using guessed type int stdio_needs_locking;

//----- (000000000040AEC0) ----------------------------------------------------
__int64 *IO_enable_locks()
{
  __int64 *result; // x0
  __int64 *i; // x1
  int v2; // w0

  result = &run_fp;
  if ( !stdio_needs_locking )
  {
    stdio_needs_locking = 1;
    result = (__int64 *)off_490000;
    for ( i = IO_list_all; i; i = (__int64 *)i[13] )
    {
      v2 = ((int)((unsigned __int64)i[14] >> 24) >> 8) | 0x80;
      *((_WORD *)i + 58) = ((int)((unsigned __int64)i[14] >> 24) >> 8) | 0x80;
      result = (__int64 *)BYTE2(v2);
      *((_BYTE *)i + 118) = (_BYTE)result;
    }
  }
  return result;
}
// 490000: using guessed type __int64 (__fastcall *off_490000[5])();
// 490058: using guessed type __int64 *IO_list_all;
// 492AA8: using guessed type __int64 run_fp;
// 492AC0: using guessed type int stdio_needs_locking;

//----- (000000000040AF08) ----------------------------------------------------
_QWORD *__fastcall IO_old_init(__int64 a1, int a2)
{
  _QWORD *result; // x0

  *(_DWORD *)a1 = a2 | 0xFBAD0000;
  *(_WORD *)(a1 + 116) = (stdio_needs_locking != 0) << 7;
  *(_BYTE *)(a1 + 118) = 0;
  *(_WORD *)(a1 + 128) = 0;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_QWORD *)(a1 + 104) = 0LL;
  result = *(_QWORD **)(a1 + 136);
  if ( result )
  {
    *result = 0LL;
    result[1] = 0LL;
  }
  return result;
}
// 492AC0: using guessed type int stdio_needs_locking;

//----- (000000000040AF64) ----------------------------------------------------
__int64 __fastcall IO_no_init(__int64 result, int a2, int a3, __int64 a4, __int64 a5)
{
  _QWORD *v5; // x1

  *(_DWORD *)result = a2 | 0xFBAD0000;
  *(_WORD *)(result + 116) = (stdio_needs_locking != 0) << 7;
  *(_BYTE *)(result + 118) = 0;
  *(_WORD *)(result + 128) = 0;
  v5 = *(_QWORD **)(result + 136);
  *(_OWORD *)(result + 8) = 0u;
  *(_OWORD *)(result + 24) = 0u;
  *(_OWORD *)(result + 40) = 0u;
  *(_OWORD *)(result + 56) = 0u;
  *(_QWORD *)(result + 104) = 0LL;
  *(_OWORD *)(result + 72) = 0u;
  *(_OWORD *)(result + 88) = 0u;
  if ( v5 )
  {
    *v5 = 0LL;
    v5[1] = 0LL;
  }
  *(_DWORD *)(result + 192) = a3;
  if ( a3 < 0 )
  {
    *(_QWORD *)(result + 160) = -1LL;
  }
  else
  {
    *(_QWORD *)(result + 160) = a4;
    *(_QWORD *)(a4 + 80) = 0LL;
    *(_QWORD *)(a4 + 224) = a5;
    *(_OWORD *)a4 = 0u;
    *(_OWORD *)(a4 + 16) = 0u;
    *(_OWORD *)(a4 + 32) = 0u;
    *(_OWORD *)(a4 + 48) = 0u;
    *(_OWORD *)(a4 + 64) = 0u;
  }
  *(_QWORD *)(result + 168) = 0LL;
  return result;
}
// 492AC0: using guessed type int stdio_needs_locking;

//----- (000000000040B000) ----------------------------------------------------
__int64 IO_default_sync()
{
  return 0LL;
}

//----- (000000000040B008) ----------------------------------------------------
void __fastcall IO_default_finish(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v9; // x2
  unsigned __int64 v10; // x0
  _QWORD *i; // x1
  unsigned __int64 v12; // x0
  __int64 v13; // [xsp+18h] [xbp+18h]
  __int64 v14; // [xsp+18h] [xbp+18h]

  v9 = a1;
  v10 = *(_QWORD *)(a1 + 56);
  if ( v10 && (*(_DWORD *)v9 & 1) == 0 )
  {
    v14 = v9;
    free(v10, a2, a3, a4, a5, a6, a7, a8, a9);
    v9 = v14;
    *(_QWORD *)(v14 + 56) = 0LL;
    *(_QWORD *)(v14 + 64) = 0LL;
  }
  for ( i = *(_QWORD **)(v9 + 96); i; i = (_QWORD *)*i )
    i[1] = 0LL;
  v12 = *(_QWORD *)(v9 + 72);
  if ( v12 )
  {
    if ( v12 != v9 + 119 )
    {
      v13 = v9;
      free(v12, a2, a3, a4, a5, a6, a7, a8, a9);
      v9 = v13;
    }
    *(_QWORD *)(v9 + 72) = 0LL;
  }
  if ( (*(_DWORD *)v9 & 0x80) != 0 )
    IO_un_link_part_0(v9);
}
// 40B050: variable 'a2' is possibly undefined
// 40B050: variable 'a3' is possibly undefined
// 40B050: variable 'a4' is possibly undefined
// 40B050: variable 'a5' is possibly undefined
// 40B050: variable 'a6' is possibly undefined
// 40B050: variable 'a7' is possibly undefined
// 40B050: variable 'a8' is possibly undefined
// 40B050: variable 'a9' is possibly undefined

//----- (000000000040B08C) ----------------------------------------------------
__int64 IO_default_seekoff()
{
  return -1LL;
}

//----- (000000000040B0A0) ----------------------------------------------------
__int64 __fastcall IO_sputbackc(
        unsigned int *a1,
        unsigned __int8 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  unsigned __int64 v11; // x0
  unsigned int v12; // w2
  __int64 v13; // x2
  __int64 result; // x0
  __int64 v15; // [xsp+20h] [xbp+20h]

  v11 = *((_QWORD *)a1 + 1);
  if ( v11 > *((_QWORD *)a1 + 3) )
  {
    v12 = *a1;
    if ( (*a1 & 0x100) == 0 && *(unsigned __int8 *)(v11 - 1) == a2 )
    {
      *((_QWORD *)a1 + 1) = v11 - 1;
      result = a2;
      goto LABEL_7;
    }
  }
  v13 = *((_QWORD *)a1 + 27);
  if ( (unsigned __int64)(v13 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v15 = *((_QWORD *)a1 + 27);
    IO_vtable_check(a3, a4, a5, a6, a7, a8, a9, a10);
    v13 = v15;
  }
  result = (*(__int64 (__fastcall **)(unsigned int *))(v13 + 48))(a1);
  if ( (_DWORD)result != -1 )
  {
    v12 = *a1;
LABEL_7:
    *a1 = v12 & 0xFFFFFFEF;
  }
  return result;
}

//----- (000000000040B140) ----------------------------------------------------
__int64 __fastcall IO_sungetc(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v9; // x2
  unsigned __int64 v10; // x0
  __int64 result; // x0
  __int64 v12; // x1
  _DWORD *v13; // [xsp+10h] [xbp-10h]
  __int64 v14; // [xsp+10h] [xbp-10h]
  __int64 v15; // [xsp+18h] [xbp-8h]

  v9 = a1;
  v10 = *(_QWORD *)(a1 + 8);
  if ( v10 <= *(_QWORD *)(v9 + 24) )
  {
    v12 = *(_QWORD *)(v9 + 216);
    if ( (unsigned __int64)(v12 - (_QWORD)&_io_vtables) > 0x92F )
    {
      v14 = *(_QWORD *)(v9 + 216);
      v15 = v9;
      IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
      v12 = v14;
      v9 = v15;
    }
    v13 = (_DWORD *)v9;
    result = (*(__int64 (__fastcall **)(__int64, __int64))(v12 + 48))(v9, 0xFFFFFFFFLL);
    if ( (_DWORD)result != -1 )
      *v13 &= ~0x10u;
  }
  else
  {
    *(_QWORD *)(v9 + 8) = v10 - 1;
    result = *(unsigned __int8 *)(v10 - 1);
    *(_DWORD *)v9 &= ~0x10u;
  }
  return result;
}

//----- (000000000040B1E0) ----------------------------------------------------
__int64 __fastcall IO_adjust_column(int a1, unsigned __int64 a2, int a3)
{
  unsigned __int64 v3; // x3
  int v4; // t1

  v3 = a2 + a3;
  do
  {
    if ( v3 <= a2 )
      return (unsigned int)(a3 + a1);
    v4 = *(unsigned __int8 *)--v3;
  }
  while ( v4 != 10 );
  return (unsigned int)(a2 + a3 - v3 - 1);
}

//----- (000000000040B220) ----------------------------------------------------
__int64 IO_flush_all()
{
  unsigned __int64 v0; // x22
  double v1; // d0
  double v2; // d1
  double v3; // d2
  double v4; // d3
  double v5; // d4
  double v6; // d5
  double v7; // d6
  double v8; // d7
  __int64 v9; // x1
  __int64 v10; // x2
  __int64 v11; // x3
  void *v12; // x4
  void *v13; // x5
  void *v14; // x6
  int v15; // w0
  __int64 *v16; // x19
  unsigned int v17; // w23
  __int64 v18; // x26
  __int64 v19; // x1
  int v20; // w0
  int v21; // w0
  __int64 v22; // x26
  __int64 v23; // x0
  __int64 v24; // x1
  __int64 v25; // x2
  __int64 v26; // x3
  void *v27; // x4
  void *v28; // x5
  void *v29; // x6
  int v30; // w0
  int v31; // w0
  void *v33; // x26
  __int64 v34; // x1
  __int64 v35; // x2
  __int64 v36; // x3
  void *v37; // x4
  void *v38; // x5
  void *v39; // x6
  int v40; // w0
  __int64 v41; // x1
  __int64 v42; // x2
  __int64 v43; // x3
  void *v44; // x4
  void *v45; // x5
  void *v46; // x6
  int v47; // w0
  _QWORD v48[4]; // [xsp+50h] [xbp+50h] BYREF

  v0 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
  v48[0] = flush_cleanup;
  v48[1] = 0LL;
  _libc_cleanup_push_defer((__int64)v48);
  if ( _libc_single_threaded && !qword_492AB8 )
  {
    LODWORD(list_all_lock) = 1;
    qword_492AB8 = v0;
    v17 = 0;
    v16 = IO_list_all;
    if ( IO_list_all )
    {
LABEL_8:
      v17 = 0;
      while ( 1 )
      {
        v21 = *(_DWORD *)v16;
        run_fp = (__int64)v16;
        if ( (v21 & 0x8000) == 0 )
        {
          v22 = v16[17];
          v23 = *(_QWORD *)(v22 + 8);
          if ( _libc_single_threaded && !v23 )
          {
            *(_DWORD *)v22 = 1;
            *(_QWORD *)(v22 + 8) = v0;
          }
          else if ( v0 == v23 )
          {
            ++*(_DWORD *)(v22 + 4);
          }
          else
          {
            _aarch64_cas4_acq();
            if ( v30 )
              _lll_lock_wait_private((_DWORD *)v22, v1, v2, v3, v4, v5, v6, v7, v8, v24, v25, v26, v27, v28, v29);
            *(_QWORD *)(v16[17] + 8) = v0;
          }
        }
        if ( *((int *)v16 + 48) > 0 )
        {
          if ( *(_QWORD *)(v16[20] + 32) > *(_QWORD *)(v16[20] + 24) )
          {
            v18 = v16[27];
            if ( (unsigned __int64)(v18 - (_QWORD)&_io_vtables) > 0x92F )
              goto LABEL_28;
            goto LABEL_11;
          }
        }
        else if ( v16[5] > (unsigned __int64)v16[4] )
        {
          v18 = v16[27];
          if ( (unsigned __int64)(v18 - (_QWORD)&_io_vtables) > 0x92F )
LABEL_28:
            IO_vtable_check(v1, v2, v3, v4, v5, v6, v7, v8);
LABEL_11:
          if ( (*(unsigned int (__fastcall **)(__int64 *, __int64))(v18 + 24))(v16, 0xFFFFFFFFLL) == -1 )
            v17 = -1;
        }
        if ( (*(_DWORD *)v16 & 0x8000) != 0 )
        {
LABEL_17:
          v16 = (__int64 *)v16[13];
          run_fp = 0LL;
          if ( !v16 )
            goto LABEL_30;
        }
        else
        {
          v19 = v16[17];
          v20 = *(_DWORD *)(v19 + 4);
          if ( _libc_single_threaded )
          {
            if ( !v20 )
            {
              *(_QWORD *)(v19 + 8) = 0LL;
              *(_DWORD *)v16[17] = 0;
              goto LABEL_17;
            }
          }
          else if ( !v20 )
          {
            *(_QWORD *)(v19 + 8) = 0LL;
            v33 = (void *)v16[17];
            _aarch64_swp4_rel();
            if ( v40 > 1 )
              _lll_lock_wake_private(v33, v34, v35, v36, v37, v38, v39);
            goto LABEL_17;
          }
          v16 = (__int64 *)v16[13];
          run_fp = 0LL;
          *(_DWORD *)(v19 + 4) = v20 - 1;
          if ( !v16 )
            goto LABEL_30;
        }
      }
    }
  }
  else
  {
    if ( v0 == qword_492AB8 )
    {
      ++HIDWORD(list_all_lock);
    }
    else
    {
      _aarch64_cas4_acq();
      if ( v15 )
        _lll_lock_wait_private(&list_all_lock, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);
      qword_492AB8 = v0;
    }
    v16 = IO_list_all;
    if ( IO_list_all )
      goto LABEL_8;
    v17 = 0;
LABEL_30:
    if ( !_libc_single_threaded )
    {
      v31 = HIDWORD(list_all_lock);
      if ( !HIDWORD(list_all_lock) )
      {
        qword_492AB8 = 0LL;
        _aarch64_swp4_rel();
        if ( v47 > 1 )
          _lll_lock_wake_private(&list_all_lock, v41, v42, v43, v44, v45, v46);
        goto LABEL_33;
      }
LABEL_32:
      HIDWORD(list_all_lock) = v31 - 1;
LABEL_33:
      _libc_cleanup_pop_restore((__int64)v48);
      return v17;
    }
  }
  v31 = HIDWORD(list_all_lock);
  if ( HIDWORD(list_all_lock) )
    goto LABEL_32;
  LODWORD(list_all_lock) = 0;
  qword_492AB8 = 0LL;
  _libc_cleanup_pop_restore((__int64)v48);
  return v17;
}
// 40B28C: variable 'v15' is possibly undefined
// 40B4E4: variable 'v1' is possibly undefined
// 40B4E4: variable 'v2' is possibly undefined
// 40B4E4: variable 'v3' is possibly undefined
// 40B4E4: variable 'v4' is possibly undefined
// 40B4E4: variable 'v5' is possibly undefined
// 40B4E4: variable 'v6' is possibly undefined
// 40B4E4: variable 'v7' is possibly undefined
// 40B4E4: variable 'v8' is possibly undefined
// 40B4E4: variable 'v9' is possibly undefined
// 40B4E4: variable 'v10' is possibly undefined
// 40B4E4: variable 'v11' is possibly undefined
// 40B4E4: variable 'v12' is possibly undefined
// 40B4E4: variable 'v13' is possibly undefined
// 40B4E4: variable 'v14' is possibly undefined
// 40B364: variable 'v30' is possibly undefined
// 40B4D0: variable 'v24' is possibly undefined
// 40B4D0: variable 'v25' is possibly undefined
// 40B4D0: variable 'v26' is possibly undefined
// 40B4D0: variable 'v27' is possibly undefined
// 40B4D0: variable 'v28' is possibly undefined
// 40B4D0: variable 'v29' is possibly undefined
// 40B410: variable 'v40' is possibly undefined
// 40B418: variable 'v34' is possibly undefined
// 40B418: variable 'v35' is possibly undefined
// 40B418: variable 'v36' is possibly undefined
// 40B418: variable 'v37' is possibly undefined
// 40B418: variable 'v38' is possibly undefined
// 40B418: variable 'v39' is possibly undefined
// 40B4A8: variable 'v47' is possibly undefined
// 40B4B0: variable 'v41' is possibly undefined
// 40B4B0: variable 'v42' is possibly undefined
// 40B4B0: variable 'v43' is possibly undefined
// 40B4B0: variable 'v44' is possibly undefined
// 40B4B0: variable 'v45' is possibly undefined
// 40B4B0: variable 'v46' is possibly undefined
// 490058: using guessed type __int64 *IO_list_all;
// 490F08: using guessed type char _libc_single_threaded;
// 492AA8: using guessed type __int64 run_fp;
// 492AB0: using guessed type __int64 list_all_lock;
// 492AB8: using guessed type __int64 qword_492AB8;

//----- (000000000040B4EC) ----------------------------------------------------
void flushlbf()
{
  unsigned __int64 v0; // x21
  double v1; // d0
  double v2; // d1
  double v3; // d2
  double v4; // d3
  double v5; // d4
  double v6; // d5
  double v7; // d6
  double v8; // d7
  __int64 v9; // x1
  __int64 v10; // x2
  __int64 v11; // x3
  void *v12; // x4
  void *v13; // x5
  void *v14; // x6
  int v15; // w0
  __int64 *v16; // x19
  __int64 v17; // x25
  __int64 v18; // x0
  __int64 v19; // x1
  __int64 v20; // x2
  __int64 v21; // x3
  void *v22; // x4
  void *v23; // x5
  void *v24; // x6
  int v25; // w0
  __int64 v26; // x1
  int v27; // w0
  int v28; // w0
  __int64 v29; // x25
  int v30; // w0
  void *v31; // x25
  __int64 v32; // x1
  __int64 v33; // x2
  __int64 v34; // x3
  void *v35; // x4
  void *v36; // x5
  void *v37; // x6
  int v38; // w0
  __int64 v39; // x1
  __int64 v40; // x2
  __int64 v41; // x3
  void *v42; // x4
  void *v43; // x5
  void *v44; // x6
  int v45; // w0
  _QWORD v46[4]; // [xsp+50h] [xbp+50h] BYREF

  v0 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
  v46[0] = flush_cleanup;
  v46[1] = 0LL;
  _libc_cleanup_push_defer((__int64)v46);
  if ( _libc_single_threaded && !qword_492AB8 )
  {
    LODWORD(list_all_lock) = 1;
    qword_492AB8 = v0;
    v16 = IO_list_all;
    if ( IO_list_all )
      goto LABEL_21;
  }
  else
  {
    if ( v0 == qword_492AB8 )
    {
      ++HIDWORD(list_all_lock);
    }
    else
    {
      _aarch64_cas4_acq();
      if ( v15 )
        _lll_lock_wait_private(&list_all_lock, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);
      qword_492AB8 = v0;
    }
    v16 = IO_list_all;
    if ( IO_list_all )
    {
      while ( 1 )
      {
LABEL_21:
        v28 = *(_DWORD *)v16;
        run_fp = (__int64)v16;
        if ( (v28 & 0x8000) != 0 )
        {
          if ( (*v16 & 0x208) != 0x200 )
            goto LABEL_20;
        }
        else
        {
          v17 = v16[17];
          v18 = *(_QWORD *)(v17 + 8);
          if ( _libc_single_threaded && !v18 )
          {
            *(_DWORD *)v17 = 1;
            *(_QWORD *)(v17 + 8) = v0;
          }
          else if ( v0 == v18 )
          {
            ++*(_DWORD *)(v17 + 4);
          }
          else
          {
            _aarch64_cas4_acq();
            if ( v25 )
              _lll_lock_wait_private((_DWORD *)v17, v1, v2, v3, v4, v5, v6, v7, v8, v19, v20, v21, v22, v23, v24);
            *(_QWORD *)(v16[17] + 8) = v0;
          }
          if ( (*v16 & 0x208) != 0x200 )
            goto LABEL_16;
        }
        v29 = v16[27];
        if ( (unsigned __int64)(v29 - (_QWORD)&_io_vtables) > 0x92F )
          IO_vtable_check(v1, v2, v3, v4, v5, v6, v7, v8);
        (*(void (__fastcall **)(__int64 *, __int64))(v29 + 24))(v16, 0xFFFFFFFFLL);
LABEL_16:
        if ( (*(_DWORD *)v16 & 0x8000) != 0 )
        {
LABEL_20:
          v16 = (__int64 *)v16[13];
          run_fp = 0LL;
          if ( !v16 )
            break;
        }
        else
        {
          v26 = v16[17];
          v27 = *(_DWORD *)(v26 + 4);
          if ( _libc_single_threaded )
          {
            if ( !v27 )
            {
              *(_QWORD *)(v26 + 8) = 0LL;
              *(_DWORD *)v16[17] = 0;
              goto LABEL_20;
            }
          }
          else if ( !v27 )
          {
            *(_QWORD *)(v26 + 8) = 0LL;
            v31 = (void *)v16[17];
            _aarch64_swp4_rel();
            if ( v38 > 1 )
              _lll_lock_wake_private(v31, v32, v33, v34, v35, v36, v37);
            goto LABEL_20;
          }
          v16 = (__int64 *)v16[13];
          run_fp = 0LL;
          *(_DWORD *)(v26 + 4) = v27 - 1;
          if ( !v16 )
            break;
        }
      }
    }
    if ( !_libc_single_threaded )
    {
      v30 = HIDWORD(list_all_lock);
      if ( !HIDWORD(list_all_lock) )
      {
        qword_492AB8 = 0LL;
        _aarch64_swp4_rel();
        if ( v45 > 1 )
          _lll_lock_wake_private(&list_all_lock, v39, v40, v41, v42, v43, v44);
        goto LABEL_30;
      }
LABEL_29:
      HIDWORD(list_all_lock) = v30 - 1;
LABEL_30:
      _libc_cleanup_pop_restore((__int64)v46);
      return;
    }
  }
  v30 = HIDWORD(list_all_lock);
  if ( HIDWORD(list_all_lock) )
    goto LABEL_29;
  LODWORD(list_all_lock) = 0;
  qword_492AB8 = 0LL;
  _libc_cleanup_pop_restore((__int64)v46);
}
// 40B558: variable 'v15' is possibly undefined
// 40B780: variable 'v1' is possibly undefined
// 40B780: variable 'v2' is possibly undefined
// 40B780: variable 'v3' is possibly undefined
// 40B780: variable 'v4' is possibly undefined
// 40B780: variable 'v5' is possibly undefined
// 40B780: variable 'v6' is possibly undefined
// 40B780: variable 'v7' is possibly undefined
// 40B780: variable 'v8' is possibly undefined
// 40B780: variable 'v9' is possibly undefined
// 40B780: variable 'v10' is possibly undefined
// 40B780: variable 'v11' is possibly undefined
// 40B780: variable 'v12' is possibly undefined
// 40B780: variable 'v13' is possibly undefined
// 40B780: variable 'v14' is possibly undefined
// 40B5B0: variable 'v25' is possibly undefined
// 40B76C: variable 'v19' is possibly undefined
// 40B76C: variable 'v20' is possibly undefined
// 40B76C: variable 'v21' is possibly undefined
// 40B76C: variable 'v22' is possibly undefined
// 40B76C: variable 'v23' is possibly undefined
// 40B76C: variable 'v24' is possibly undefined
// 40B6B8: variable 'v38' is possibly undefined
// 40B6C0: variable 'v32' is possibly undefined
// 40B6C0: variable 'v33' is possibly undefined
// 40B6C0: variable 'v34' is possibly undefined
// 40B6C0: variable 'v35' is possibly undefined
// 40B6C0: variable 'v36' is possibly undefined
// 40B6C0: variable 'v37' is possibly undefined
// 40B744: variable 'v45' is possibly undefined
// 40B74C: variable 'v39' is possibly undefined
// 40B74C: variable 'v40' is possibly undefined
// 40B74C: variable 'v41' is possibly undefined
// 40B74C: variable 'v42' is possibly undefined
// 40B74C: variable 'v43' is possibly undefined
// 40B74C: variable 'v44' is possibly undefined
// 490058: using guessed type __int64 *IO_list_all;
// 490F08: using guessed type char _libc_single_threaded;
// 492AA8: using guessed type __int64 run_fp;
// 492AB0: using guessed type __int64 list_all_lock;
// 492AB8: using guessed type __int64 qword_492AB8;

//----- (000000000040B788) ----------------------------------------------------
void __fastcall _libio_freemem(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  __int64 v8; // x19

  v8 = freeres_list;
  for ( dealloc_buffers = 1; v8; freeres_list = v8 )
  {
    free(*(_QWORD *)(v8 + 176), a1, a2, a3, a4, a5, a6, a7, a8);
    v8 = *(_QWORD *)(v8 + 168);
  }
}
// 40B7B0: variable 'a1' is possibly undefined
// 40B7B0: variable 'a2' is possibly undefined
// 40B7B0: variable 'a3' is possibly undefined
// 40B7B0: variable 'a4' is possibly undefined
// 40B7B0: variable 'a5' is possibly undefined
// 40B7B0: variable 'a6' is possibly undefined
// 40B7B0: variable 'a7' is possibly undefined
// 40B7B0: variable 'a8' is possibly undefined
// 492AC4: using guessed type char dealloc_buffers;
// 492AC8: using guessed type __int64 freeres_list;

//----- (000000000040B7CC) ----------------------------------------------------
__int64 IO_cleanup()
{
  unsigned __int64 v0; // x22
  unsigned int v1; // w27
  double v2; // d0
  double v3; // d1
  double v4; // d2
  double v5; // d3
  double v6; // d4
  double v7; // d5
  double v8; // d6
  double v9; // d7
  __int64 v10; // x1
  __int64 v11; // x2
  __int64 v12; // x3
  void *v13; // x4
  void *v14; // x5
  void *v15; // x6
  int v16; // w0
  __int64 *v17; // x19
  unsigned int v18; // w0
  __int64 v19; // x1
  int v20; // w0
  unsigned int v21; // w0
  __int64 v22; // x26
  __int64 v23; // x0
  __int64 v24; // x1
  __int64 v25; // x2
  __int64 v26; // x3
  void *v27; // x4
  void *v28; // x5
  void *v29; // x6
  int v30; // w0
  unsigned __int64 v31; // x0
  __int64 v32; // x1
  unsigned __int64 v33; // x1
  __int64 v34; // x0
  __int64 v35; // x1
  __int64 v36; // x26
  int v37; // w0
  void *v39; // x26
  __int64 v40; // x1
  __int64 v41; // x2
  __int64 v42; // x3
  void *v43; // x4
  void *v44; // x5
  void *v45; // x6
  int v46; // w0
  __int64 v47; // x1
  __int64 v48; // x2
  __int64 v49; // x3
  void *v50; // x4
  void *v51; // x5
  void *v52; // x6
  int v53; // w0
  _QWORD v54[4]; // [xsp+60h] [xbp+60h] BYREF

  v0 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
  v1 = IO_flush_all();
  v54[0] = flush_cleanup;
  v54[1] = 0LL;
  _libc_cleanup_push_defer((__int64)v54);
  if ( _libc_single_threaded && !qword_492AB8 )
  {
    LODWORD(list_all_lock) = 1;
    qword_492AB8 = v0;
    v17 = IO_list_all;
    if ( IO_list_all )
      goto LABEL_17;
  }
  else
  {
    if ( v0 == qword_492AB8 )
    {
      ++HIDWORD(list_all_lock);
    }
    else
    {
      _aarch64_cas4_acq();
      if ( v16 )
        _lll_lock_wait_private(&list_all_lock, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
      qword_492AB8 = v0;
    }
    v17 = IO_list_all;
    if ( IO_list_all )
    {
      while ( 1 )
      {
LABEL_17:
        v21 = *(_DWORD *)v17;
        run_fp = (__int64)v17;
        if ( (v21 & 0x8000) == 0 )
        {
          v22 = v17[17];
          v23 = *(_QWORD *)(v22 + 8);
          if ( _libc_single_threaded && !v23 )
          {
            *(_DWORD *)v22 = 1;
            *(_QWORD *)(v22 + 8) = v0;
          }
          else if ( v0 == v23 )
          {
            ++*(_DWORD *)(v22 + 4);
          }
          else
          {
            _aarch64_cas4_acq();
            if ( v30 )
              _lll_lock_wait_private((_DWORD *)v22, v2, v3, v4, v5, v6, v7, v8, v9, v24, v25, v26, v27, v28, v29);
            *(_QWORD *)(v17[17] + 8) = v0;
          }
        }
        if ( v17[10] )
        {
          v31 = v17[9];
          if ( (*(_DWORD *)v17 & 0x100) != 0 )
          {
            *(_DWORD *)v17 &= ~0x100u;
            v32 = v17[11];
            v17[1] = v31;
            v17[2] = v32;
            v33 = v17[3];
            v17[3] = v31;
            v31 = v33;
          }
          if ( (__int64 *)v31 != (__int64 *)((char *)v17 + 119) )
            free(v31, v2, v3, v4, v5, v6, v7, v8, v9);
          v17[9] = 0LL;
          v17[10] = 0LL;
          v17[11] = 0LL;
        }
        if ( *((int *)v17 + 48) > 0 )
        {
          if ( !*(_QWORD *)(v17[20] + 72) )
          {
            v18 = *(_DWORD *)v17;
            if ( (*(_DWORD *)v17 & 2) == 0 )
              goto LABEL_33;
            goto LABEL_12;
          }
          IO_free_wbackup_area((unsigned int *)v17, v2, v3, v4, v5, v6, v7, v8, v9);
        }
        v18 = *(_DWORD *)v17;
        if ( (*(_DWORD *)v17 & 2) == 0 && *((_DWORD *)v17 + 48) )
        {
LABEL_33:
          if ( (dealloc_buffers & 1) == 0 && (v18 & 1) == 0 )
          {
            *(_DWORD *)v17 = v18 | 1;
            v34 = freeres_list;
            freeres_list = (__int64)v17;
            v35 = v17[7];
            v17[21] = v34;
            v17[22] = v35;
          }
          v36 = v17[27];
          if ( (unsigned __int64)(v36 - (_QWORD)&_io_vtables) > 0x92F )
            IO_vtable_check(v2, v3, v4, v5, v6, v7, v8, v9);
          (*(void (__fastcall **)(__int64 *, _QWORD, _QWORD))(v36 + 88))(v17, 0LL, 0LL);
          if ( *((int *)v17 + 48) > 0 )
            IO_wsetb((__int64)v17, 0LL, 0LL, 0, v2, v3, v4, v5, v6, v7, v8, v9);
          v18 = *(_DWORD *)v17;
        }
LABEL_12:
        *((_DWORD *)v17 + 48) = -1;
        if ( (v18 & 0x8000) != 0 )
        {
LABEL_16:
          v17 = (__int64 *)v17[13];
          run_fp = 0LL;
          if ( !v17 )
            break;
        }
        else
        {
          v19 = v17[17];
          v20 = *(_DWORD *)(v19 + 4);
          if ( _libc_single_threaded )
          {
            if ( !v20 )
            {
              *(_QWORD *)(v19 + 8) = 0LL;
              *(_DWORD *)v17[17] = 0;
              goto LABEL_16;
            }
          }
          else if ( !v20 )
          {
            *(_QWORD *)(v19 + 8) = 0LL;
            v39 = (void *)v17[17];
            _aarch64_swp4_rel();
            if ( v46 > 1 )
              _lll_lock_wake_private(v39, v40, v41, v42, v43, v44, v45);
            goto LABEL_16;
          }
          v17 = (__int64 *)v17[13];
          run_fp = 0LL;
          *(_DWORD *)(v19 + 4) = v20 - 1;
          if ( !v17 )
            break;
        }
      }
    }
    if ( !_libc_single_threaded )
    {
      v37 = HIDWORD(list_all_lock);
      if ( !HIDWORD(list_all_lock) )
      {
        qword_492AB8 = 0LL;
        _aarch64_swp4_rel();
        if ( v53 > 1 )
          _lll_lock_wake_private(&list_all_lock, v47, v48, v49, v50, v51, v52);
        goto LABEL_45;
      }
LABEL_44:
      HIDWORD(list_all_lock) = v37 - 1;
LABEL_45:
      _libc_cleanup_pop_restore((__int64)v54);
      return v1;
    }
  }
  v37 = HIDWORD(list_all_lock);
  if ( HIDWORD(list_all_lock) )
    goto LABEL_44;
  LODWORD(list_all_lock) = 0;
  qword_492AB8 = 0LL;
  _libc_cleanup_pop_restore((__int64)v54);
  return v1;
}
// 40B840: variable 'v16' is possibly undefined
// 40BB24: variable 'v2' is possibly undefined
// 40BB24: variable 'v3' is possibly undefined
// 40BB24: variable 'v4' is possibly undefined
// 40BB24: variable 'v5' is possibly undefined
// 40BB24: variable 'v6' is possibly undefined
// 40BB24: variable 'v7' is possibly undefined
// 40BB24: variable 'v8' is possibly undefined
// 40BB24: variable 'v9' is possibly undefined
// 40BB24: variable 'v10' is possibly undefined
// 40BB24: variable 'v11' is possibly undefined
// 40BB24: variable 'v12' is possibly undefined
// 40BB24: variable 'v13' is possibly undefined
// 40BB24: variable 'v14' is possibly undefined
// 40BB24: variable 'v15' is possibly undefined
// 40B8F4: variable 'v30' is possibly undefined
// 40BB10: variable 'v24' is possibly undefined
// 40BB10: variable 'v25' is possibly undefined
// 40BB10: variable 'v26' is possibly undefined
// 40BB10: variable 'v27' is possibly undefined
// 40BB10: variable 'v28' is possibly undefined
// 40BB10: variable 'v29' is possibly undefined
// 40BA58: variable 'v46' is possibly undefined
// 40BA60: variable 'v40' is possibly undefined
// 40BA60: variable 'v41' is possibly undefined
// 40BA60: variable 'v42' is possibly undefined
// 40BA60: variable 'v43' is possibly undefined
// 40BA60: variable 'v44' is possibly undefined
// 40BA60: variable 'v45' is possibly undefined
// 40BAE8: variable 'v53' is possibly undefined
// 40BAF0: variable 'v47' is possibly undefined
// 40BAF0: variable 'v48' is possibly undefined
// 40BAF0: variable 'v49' is possibly undefined
// 40BAF0: variable 'v50' is possibly undefined
// 40BAF0: variable 'v51' is possibly undefined
// 40BAF0: variable 'v52' is possibly undefined
// 490058: using guessed type __int64 *IO_list_all;
// 490F08: using guessed type char _libc_single_threaded;
// 492AA8: using guessed type __int64 run_fp;
// 492AB0: using guessed type __int64 list_all_lock;
// 492AB8: using guessed type __int64 qword_492AB8;
// 492AC4: using guessed type char dealloc_buffers;
// 492AC8: using guessed type __int64 freeres_list;

//----- (000000000040BB2C) ----------------------------------------------------
__int64 __fastcall IO_init_marker(
        __int64 a1,
        __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  int v10; // w3
  __int64 v12; // x3
  __int64 result; // x0
  __int64 v14; // x3

  v10 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 8) = a2;
  if ( (v10 & 0x800) != 0 )
  {
    IO_switch_to_get_mode((int *)a2, a3, a4, a5, a6, a7, a8, a9, a10);
    if ( (*(_DWORD *)a2 & 0x100) != 0 )
      v14 = *(_QWORD *)(a2 + 16);
    else
      v14 = *(_QWORD *)(a2 + 24);
    *(_DWORD *)(a1 + 16) = *(_QWORD *)(a2 + 8) - v14;
    result = *(_QWORD *)(a2 + 96);
    *(_QWORD *)a1 = result;
    *(_QWORD *)(a2 + 96) = a1;
  }
  else
  {
    if ( (v10 & 0x100) != 0 )
      v12 = *(_QWORD *)(a2 + 16);
    else
      v12 = *(_QWORD *)(a2 + 24);
    *(_DWORD *)(a1 + 16) = *(_QWORD *)(a2 + 8) - v12;
    result = *(_QWORD *)(a2 + 96);
    *(_QWORD *)a1 = result;
    *(_QWORD *)(a2 + 96) = a1;
  }
  return result;
}

//----- (000000000040BBE0) ----------------------------------------------------
_QWORD *__fastcall IO_remove_marker(_QWORD *result)
{
  __int64 v1; // x2
  _QWORD *v2; // x1
  _QWORD *v3; // x2

  v1 = result[1];
  v2 = *(_QWORD **)(v1 + 96);
  if ( v2 )
  {
    v3 = (_QWORD *)(v1 + 96);
    while ( v2 != result )
    {
      v3 = v2;
      v2 = (_QWORD *)*v2;
      if ( !v2 )
        return result;
    }
    result = (_QWORD *)*v2;
    *v3 = *v2;
  }
  return result;
}

//----- (000000000040BC20) ----------------------------------------------------
__int64 __fastcall IO_marker_difference(__int64 a1, __int64 a2)
{
  return (unsigned int)(*(_DWORD *)(a1 + 16) - *(_DWORD *)(a2 + 16));
}

//----- (000000000040BC30) ----------------------------------------------------
__int64 __fastcall IO_marker_delta(__int64 a1)
{
  __int64 v1; // x1
  __int64 v2; // x2
  __int64 v3; // x1

  v1 = *(_QWORD *)(a1 + 8);
  if ( !v1 )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(v1 + 8);
  if ( (*(_DWORD *)v1 & 0x100) != 0 )
    v3 = v2 - *(_QWORD *)(v1 + 16);
  else
    v3 = v2 - *(_QWORD *)(v1 + 24);
  return (unsigned int)(*(_DWORD *)(a1 + 16) - v3);
}

//----- (000000000040BC6C) ----------------------------------------------------
__int64 __fastcall IO_seekmark(int *a1, __int64 a2)
{
  int v2; // w2
  int v3; // w3
  int v4; // w4
  __int64 v5; // x5
  __int64 v6; // x2
  __int64 v7; // x3
  __int64 v9; // x4
  __int64 v10; // x3
  __int64 v11; // x2

  if ( *(int **)(a2 + 8) != a1 )
    return 0xFFFFFFFFLL;
  v2 = *(_DWORD *)(a2 + 16);
  v3 = *a1;
  v4 = *a1 & 0x100;
  if ( (v2 & 0x80000000) == 0 )
  {
    v5 = *((_QWORD *)a1 + 3);
    if ( v4 )
    {
      *a1 = v3 & 0xFFFFFEFF;
      v6 = *((_QWORD *)a1 + 11);
      *((_QWORD *)a1 + 11) = *((_QWORD *)a1 + 2);
      v7 = *((_QWORD *)a1 + 9);
      *((_QWORD *)a1 + 2) = v6;
      *((_QWORD *)a1 + 3) = v7;
      v2 = *(_DWORD *)(a2 + 16);
      *((_QWORD *)a1 + 9) = v5;
      v5 = v7;
    }
    goto LABEL_5;
  }
  v5 = *((_QWORD *)a1 + 2);
  if ( v4 )
  {
LABEL_5:
    *((_QWORD *)a1 + 1) = v5 + v2;
    return 0LL;
  }
  *a1 = v3 | 0x100;
  v9 = *((_QWORD *)a1 + 9);
  v10 = *((_QWORD *)a1 + 11);
  v11 = *((_QWORD *)a1 + 3);
  *((_QWORD *)a1 + 2) = v10;
  *((_QWORD *)a1 + 3) = v9;
  *((_QWORD *)a1 + 9) = v11;
  LODWORD(v11) = *(_DWORD *)(a2 + 16);
  *((_QWORD *)a1 + 11) = v5;
  *((_QWORD *)a1 + 1) = v10 + (int)v11;
  return 0LL;
}

//----- (000000000040BD10) ----------------------------------------------------
void __fastcall IO_unsave_markers(
        _QWORD *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  unsigned __int64 v10; // x0
  __int64 v11; // x2
  unsigned __int64 v12; // x2
  _QWORD *v13; // [xsp+18h] [xbp-8h]

  if ( a1[12] )
    a1[12] = 0LL;
  if ( a1[10] )
  {
    v10 = a1[9];
    if ( (*(_DWORD *)a1 & 0x100) != 0 )
    {
      *(_DWORD *)a1 &= ~0x100u;
      v11 = a1[11];
      a1[1] = v10;
      a1[2] = v11;
      v12 = a1[3];
      a1[3] = v10;
      v10 = v12;
    }
    if ( (_QWORD *)v10 == (_QWORD *)((char *)a1 + 119) )
    {
      a1[9] = 0LL;
      a1[10] = 0LL;
      a1[11] = 0LL;
    }
    else
    {
      v13 = a1;
      free(v10, a2, a3, a4, a5, a6, a7, a8, a9);
      v13[9] = 0LL;
      v13[10] = 0LL;
      v13[11] = 0LL;
    }
  }
}

//----- (000000000040BD90) ----------------------------------------------------
__int64 __fastcall IO_default_pbackfail(
        __int64 *a1,
        unsigned int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  __int64 v16; // x4
  __int64 *v17; // x3
  __int64 v18; // x2
  char *v19; // x5
  void *v20; // x6
  unsigned __int64 v21; // x1
  int v22; // w0
  __int64 v23; // x6
  __int64 v24; // x1
  __int64 v25; // x0
  unsigned __int64 v27; // x0
  char *v28; // x6
  unsigned __int64 v29; // x5
  __int64 v30; // x1
  __int64 v31; // x2
  __int64 v32; // x19
  unsigned __int64 v33; // x0
  __int64 (__fastcall *v34)(__int64, __int64 *, unsigned __int64); // x5
  double v35; // d0
  double v36; // d1
  double v37; // d2
  double v38; // d3
  double v39; // d4
  double v40; // d5
  double v41; // d6
  double v42; // d7
  __int64 *v43; // x3
  unsigned __int64 v44; // x6
  __int64 v45; // x1
  __int64 (__fastcall *v47)(__int64, __int64 *, unsigned __int64); // [xsp+28h] [xbp+28h]
  __int64 v48; // [xsp+28h] [xbp+28h]
  char v49; // [xsp+30h] [xbp+30h]
  unsigned __int64 v50; // [xsp+30h] [xbp+30h]
  int v51; // [xsp+30h] [xbp+30h]
  char v54; // [xsp+44h] [xbp+44h]
  char v55; // [xsp+44h] [xbp+44h]
  unsigned __int64 v56; // [xsp+48h] [xbp+48h]

  v16 = a2;
  v17 = a1;
  v18 = *(unsigned int *)a1;
  v19 = (char *)a1[1];
  v20 = (void *)(v18 & 0x100);
  v21 = a1[3];
  if ( (unsigned __int64)v19 <= v21 )
  {
    if ( (v18 & 0x100) != 0 )
    {
      v31 = a1[2];
      v50 = a1[3];
      v32 = 2 * (v31 - v21);
      v54 = v16;
      v33 = malloc(v32, v21, v31 - v21, a1, (void *)v16, v19, v20, a16, a3, a4, a5, a6, a7, a8, a9, a10);
      if ( v33 )
      {
        v56 = v33;
        v34 = j_memcpy();
        v43 = a1;
        v44 = v56;
        LOBYTE(v16) = v54;
        if ( (__int64 *)v50 != (__int64 *)((char *)a1 + 119) )
        {
          v47 = v34;
          free(v50, v35, v36, v37, v38, v39, v40, v41, v42);
          v34 = v47;
          v44 = v56;
          v43 = a1;
          LOBYTE(v16) = v54;
        }
        v43[2] = v44 + v32;
        v43[3] = v44;
        v43[1] = (__int64)v34 - 1;
        v43[10] = (__int64)v34;
        *((_BYTE *)v34 - 1) = v16;
        return (unsigned __int8)v16;
      }
      return 0xFFFFFFFFLL;
    }
    if ( a1[10] )
    {
      v27 = a1[9];
      v28 = v19;
      v29 = v17[11];
LABEL_12:
      v30 = v17[2];
      *(_DWORD *)v17 = v18 | 0x100;
      v17[2] = v29;
      v17[3] = v27;
      v17[1] = v29 - 1;
      v17[9] = (__int64)v28;
      v17[11] = v30;
      *(_BYTE *)(v29 - 1) = v16;
      return (unsigned __int8)v16;
    }
LABEL_17:
    v48 = a1[1];
    v51 = *(_DWORD *)a1;
    v55 = v16;
    v27 = malloc(128LL, v21, v18, a1, (void *)v16, v19, v20, a16, a3, a4, a5, a6, a7, a8, a9, a10);
    v45 = 128LL;
    v17 = a1;
    LODWORD(v18) = v51;
    LOBYTE(v16) = v55;
    if ( !v27 )
    {
      v27 = (unsigned __int64)a1 + 119;
      v45 = 1LL;
    }
    v28 = (char *)v48;
    v29 = v27 + v45;
    a1[10] = v27 + v45;
    goto LABEL_12;
  }
  if ( (v18 & 0x100) != 0 )
  {
LABEL_7:
    v17[1] = (__int64)(v19 - 1);
    *(v19 - 1) = v16;
    return (unsigned __int8)v16;
  }
  if ( (unsigned __int8)*(v19 - 1) == (_DWORD)v16 )
  {
    a1[1] = (__int64)(v19 - 1);
    return (unsigned __int8)v16;
  }
  v21 = a1[10];
  if ( !v21 )
    goto LABEL_17;
  v49 = v16;
  v22 = save_for_backup(a1, a1[1], a3, a4, a5, a6, a7, a8, a9, a10, v18, (__int64)a1, v16, (__int64)v19, v20);
  v17 = a1;
  LOBYTE(v16) = v49;
  if ( !v22 )
  {
    v23 = a1[1];
    v24 = a1[2];
    *(_DWORD *)a1 |= 0x100u;
    v25 = a1[9];
    a1[9] = v23;
    v19 = (char *)a1[11];
    a1[2] = (__int64)v19;
    a1[3] = v25;
    a1[11] = v24;
    goto LABEL_7;
  }
  return 0xFFFFFFFFLL;
}
// 40BEDC: variable 'v35' is possibly undefined
// 40BEDC: variable 'v36' is possibly undefined
// 40BEDC: variable 'v37' is possibly undefined
// 40BEDC: variable 'v38' is possibly undefined
// 40BEDC: variable 'v39' is possibly undefined
// 40BEDC: variable 'v40' is possibly undefined
// 40BEDC: variable 'v41' is possibly undefined
// 40BEDC: variable 'v42' is possibly undefined

//----- (000000000040BF80) ----------------------------------------------------
__int64 IO_default_seek()
{
  return -1LL;
}

//----- (000000000040BF88) ----------------------------------------------------
__int64 IO_default_stat()
{
  return 0xFFFFFFFFLL;
}

//----- (000000000040BF90) ----------------------------------------------------
__int64 IO_default_read()
{
  return -1LL;
}

//----- (000000000040BFA0) ----------------------------------------------------
__int64 IO_default_write()
{
  return 0LL;
}

//----- (000000000040BFA8) ----------------------------------------------------
__int64 IO_default_showmanyc()
{
  return 0xFFFFFFFFLL;
}

//----- (000000000040BFC0) ----------------------------------------------------
__int64 *IO_iter_begin()
{
  return IO_list_all;
}
// 490058: using guessed type __int64 *IO_list_all;

//----- (000000000040BFCC) ----------------------------------------------------
__int64 IO_iter_end()
{
  return 0LL;
}

//----- (000000000040BFE0) ----------------------------------------------------
__int64 __fastcall IO_iter_next(__int64 a1)
{
  return *(_QWORD *)(a1 + 104);
}

//----- (000000000040BFEC) ----------------------------------------------------
void IO_list_lock()
{
  unsigned __int64 v0; // x4
  __int64 v1; // x1
  __int64 v2; // x2
  void *v3; // x5
  void *v4; // x6
  double v5; // d0
  double v6; // d1
  double v7; // d2
  double v8; // d3
  double v9; // d4
  double v10; // d5
  double v11; // d6
  double v12; // d7
  void *v13; // x4
  _QWORD *v14; // x3
  int v15; // w0
  void *v16; // [xsp+18h] [xbp-8h]

  v0 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
  if ( _libc_single_threaded && !qword_492AB8 )
  {
    LODWORD(list_all_lock) = 1;
    qword_492AB8 = v0;
  }
  else if ( v0 == qword_492AB8 )
  {
    ++HIDWORD(list_all_lock);
  }
  else
  {
    v16 = (void *)v0;
    _aarch64_cas4_acq();
    v13 = v16;
    v14 = &unk_492000;
    if ( v15 )
    {
      _lll_lock_wait_private(
        &list_all_lock,
        v5,
        v6,
        v7,
        v8,
        v9,
        v10,
        v11,
        v12,
        v1,
        v2,
        (__int64)&unk_492000,
        v16,
        v3,
        v4);
      v13 = v16;
      v14 = (_QWORD *)&unk_492000;
    }
    v14[343] = v13;
  }
}
// 40C044: variable 'v15' is possibly undefined
// 40C084: variable 'v5' is possibly undefined
// 40C084: variable 'v6' is possibly undefined
// 40C084: variable 'v7' is possibly undefined
// 40C084: variable 'v8' is possibly undefined
// 40C084: variable 'v9' is possibly undefined
// 40C084: variable 'v10' is possibly undefined
// 40C084: variable 'v11' is possibly undefined
// 40C084: variable 'v12' is possibly undefined
// 40C084: variable 'v1' is possibly undefined
// 40C084: variable 'v2' is possibly undefined
// 40C084: variable 'v3' is possibly undefined
// 40C084: variable 'v4' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;
// 492AB0: using guessed type __int64 list_all_lock;
// 492AB8: using guessed type __int64 qword_492AB8;

//----- (000000000040C0A0) ----------------------------------------------------
void IO_list_unlock()
{
  __int64 v0; // x1
  __int64 v1; // x2
  __int64 v2; // x3
  void *v3; // x4
  void *v4; // x5
  void *v5; // x6
  int v6; // w0

  if ( _libc_single_threaded )
  {
    if ( !HIDWORD(list_all_lock) )
    {
      LODWORD(list_all_lock) = 0;
      qword_492AB8 = 0LL;
      return;
    }
    goto LABEL_5;
  }
  if ( HIDWORD(list_all_lock) )
  {
LABEL_5:
    --HIDWORD(list_all_lock);
    return;
  }
  qword_492AB8 = 0LL;
  _aarch64_swp4_rel();
  if ( v6 > 1 )
    _lll_lock_wake_private(&list_all_lock, v0, v1, v2, v3, v4, v5);
}
// 40C100: variable 'v6' is possibly undefined
// 40C114: variable 'v0' is possibly undefined
// 40C114: variable 'v1' is possibly undefined
// 40C114: variable 'v2' is possibly undefined
// 40C114: variable 'v3' is possibly undefined
// 40C114: variable 'v4' is possibly undefined
// 40C114: variable 'v5' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;
// 492AB0: using guessed type __int64 list_all_lock;
// 492AB8: using guessed type __int64 qword_492AB8;

//----- (000000000040C120) ----------------------------------------------------
__int64 *IO_list_resetlock()
{
  __int64 *result; // x0

  result = &run_fp;
  list_all_lock = 0LL;
  qword_492AB8 = 0LL;
  return result;
}
// 492AA8: using guessed type __int64 run_fp;
// 492AB0: using guessed type __int64 list_all_lock;
// 492AB8: using guessed type __int64 qword_492AB8;

//----- (000000000040C140) ----------------------------------------------------
__int64 __fastcall enlarge_userbuf(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        void *a15,
        __int64 a16)
{
  unsigned __int64 v16; // x19
  void *v17; // x3
  __int64 v20; // x22
  int v21; // w23
  unsigned __int64 v22; // x20
  double v23; // d0
  double v24; // d1
  double v25; // d2
  double v26; // d3
  double v27; // d4
  double v28; // d5
  double v29; // d6
  double v30; // d7
  int *v31; // x4
  char *v32; // x5
  double v33; // d0
  double v34; // d1
  double v35; // d2
  double v36; // d3
  double v37; // d4
  double v38; // d5
  double v39; // d6
  double v40; // d7
  __int64 v41; // x6
  unsigned __int64 v42; // x1
  unsigned __int64 v43; // x0
  __int64 v44; // x2
  __int64 v45; // x3
  __int64 v46; // x2
  unsigned __int64 v47; // x2
  __int64 v48; // [xsp+40h] [xbp+40h]
  int *v49; // [xsp+40h] [xbp+40h]
  char *v51; // [xsp+48h] [xbp+48h]
  char *v52; // [xsp+50h] [xbp+50h]

  v16 = a1[7];
  v17 = (void *)(a1[8] - v16);
  if ( (__int64)v17 >= a2 )
    return 0LL;
  if ( (*(_DWORD *)a1 & 1) == 0 )
  {
    v20 = a2 + 100;
    v21 = a3;
    v48 = a1[4];
    v52 = (char *)a1[6];
    v22 = malloc(a2 + 100, v48, a3, v17, a1, v52, a15, a16, a4, a5, a6, a7, a8, a9, a10, a11);
    if ( !v22 )
      return 1LL;
    v31 = (int *)a1;
    v32 = &v52[-v48];
    if ( v16 )
    {
      j_memcpy();
      free(v16, v33, v34, v35, v36, v37, v38, v39, v40);
      v32 = &v52[-v48];
      v31 = (int *)a1;
      a1[7] = 0LL;
    }
    v49 = v31;
    v51 = v32;
    IO_setb(v31, v22, v22 + v20, 1, v23, v24, v25, v26, v27, v28, v29, v30);
    v41 = *((_QWORD *)v49 + 8);
    v42 = v22 + *((_QWORD *)v49 + 1) - v16;
    v43 = v22 + *((_QWORD *)v49 + 5) - v16;
    if ( v21 )
    {
      v46 = *((_QWORD *)v49 + 4);
      *((_QWORD *)v49 + 1) = v42;
      *((_QWORD *)v49 + 2) = v41;
      *((_QWORD *)v49 + 3) = v22;
      *((_QWORD *)v49 + 4) = v22 + v46 - v16;
      v47 = v22 + *((_QWORD *)v49 + 6) - v16;
      *((_QWORD *)v49 + 5) = v43;
      *((_QWORD *)v49 + 6) = v47;
      if ( a2 >= (__int64)v51 )
        goto LABEL_10;
    }
    else
    {
      v44 = *((_QWORD *)v49 + 2);
      v45 = *((_QWORD *)v49 + 3);
      *((_QWORD *)v49 + 5) = v43;
      *((_QWORD *)v49 + 6) = v41;
      *((_QWORD *)v49 + 1) = v42;
      *((_QWORD *)v49 + 2) = v22 + v44 - v16;
      *((_QWORD *)v49 + 3) = v22 + v45 - v16;
      *((_QWORD *)v49 + 4) = v22;
      if ( a2 >= (__int64)v51 )
      {
LABEL_10:
        memset();
        return 0LL;
      }
    }
    _libc_assert_fail((__int64)"offset >= oldend", (__int64)"strops.c", 0xE1u, (__int64)"enlarge_userbuf");
  }
  return 1LL;
}
// 40C1D0: variable 'v33' is possibly undefined
// 40C1D0: variable 'v34' is possibly undefined
// 40C1D0: variable 'v35' is possibly undefined
// 40C1D0: variable 'v36' is possibly undefined
// 40C1D0: variable 'v37' is possibly undefined
// 40C1D0: variable 'v38' is possibly undefined
// 40C1D0: variable 'v39' is possibly undefined
// 40C1D0: variable 'v40' is possibly undefined
// 40C1F0: variable 'v23' is possibly undefined
// 40C1F0: variable 'v24' is possibly undefined
// 40C1F0: variable 'v25' is possibly undefined
// 40C1F0: variable 'v26' is possibly undefined
// 40C1F0: variable 'v27' is possibly undefined
// 40C1F0: variable 'v28' is possibly undefined
// 40C1F0: variable 'v29' is possibly undefined
// 40C1F0: variable 'v30' is possibly undefined

//----- (000000000040C2C4) ----------------------------------------------------
unsigned __int64 __fastcall IO_str_init_static_internal(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        unsigned __int64 a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  unsigned __int64 v15; // x2
  unsigned __int64 v16; // x2
  bool v17; // zf
  unsigned __int64 result; // x0
  unsigned __int64 v19; // [xsp+38h] [xbp+38h]

  if ( a3 )
  {
    v15 = a2 + a3;
    if ( a2 >= v15 )
      v15 = -1LL;
  }
  else
  {
    v15 = (unsigned __int64)strlen() + a2;
  }
  v19 = v15;
  IO_setb((int *)a1, a2, v15, 0, a5, a6, a7, a8, a9, a10, a11, a12);
  v16 = v19;
  v17 = a4 == 0;
  if ( a4 )
    result = a4;
  else
    result = a2;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a2;
  if ( !a4 )
    a4 = v19;
  if ( v17 )
    v16 = a2;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 40) = result;
  *(_QWORD *)(a1 + 48) = v16;
  *(_QWORD *)(a1 + 224) = 0LL;
  return result;
}
// 40C300: variable 'a5' is possibly undefined
// 40C300: variable 'a6' is possibly undefined
// 40C300: variable 'a7' is possibly undefined
// 40C300: variable 'a8' is possibly undefined
// 40C300: variable 'a9' is possibly undefined
// 40C300: variable 'a10' is possibly undefined
// 40C300: variable 'a11' is possibly undefined
// 40C300: variable 'a12' is possibly undefined

//----- (000000000040C348) ----------------------------------------------------
unsigned __int64 __fastcall IO_str_init_static(
        __int64 a1,
        unsigned __int64 a2,
        int a3,
        unsigned __int64 a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  unsigned __int64 v15; // x2
  unsigned __int64 v16; // x2
  bool v17; // zf
  unsigned __int64 result; // x0
  unsigned __int64 v19; // [xsp+38h] [xbp+38h]

  if ( a3 < 0 )
    a3 = -1;
  if ( a3 )
  {
    v15 = a2 + a3;
    if ( a2 >= v15 )
      v15 = -1LL;
  }
  else
  {
    v15 = (unsigned __int64)strlen() + a2;
  }
  v19 = v15;
  IO_setb((int *)a1, a2, v15, 0, a5, a6, a7, a8, a9, a10, a11, a12);
  v16 = v19;
  v17 = a4 == 0;
  if ( a4 )
    result = a4;
  else
    result = a2;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a2;
  if ( !a4 )
    a4 = v19;
  if ( v17 )
    v16 = a2;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a4;
  *(_QWORD *)(a1 + 40) = result;
  *(_QWORD *)(a1 + 48) = v16;
  *(_QWORD *)(a1 + 224) = 0LL;
  return result;
}
// 40C38C: variable 'a5' is possibly undefined
// 40C38C: variable 'a6' is possibly undefined
// 40C38C: variable 'a7' is possibly undefined
// 40C38C: variable 'a8' is possibly undefined
// 40C38C: variable 'a9' is possibly undefined
// 40C38C: variable 'a10' is possibly undefined
// 40C38C: variable 'a11' is possibly undefined
// 40C38C: variable 'a12' is possibly undefined

//----- (000000000040C3E0) ----------------------------------------------------
__int64 __fastcall IO_str_init_readonly(
        __int64 a1,
        unsigned __int64 a2,
        int a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  __int64 v13; // x20
  int v14; // w0
  __int64 result; // x0
  unsigned __int64 v16; // x2

  if ( a3 < 0 )
    a3 = -1;
  if ( a3 )
  {
    v16 = a2 + a3;
    if ( a2 >= v16 )
      v13 = -1LL;
    else
      v13 = v16;
  }
  else
  {
    v13 = (__int64)strlen() + a2;
  }
  IO_setb((int *)a1, a2, v13, 0, a4, a5, a6, a7, a8, a9, a10, a11);
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = v13;
  v14 = *(_DWORD *)a1;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a2;
  result = v14 | 8u;
  *(_DWORD *)a1 = result;
  *(_QWORD *)(a1 + 40) = a2;
  *(_QWORD *)(a1 + 48) = a2;
  *(_QWORD *)(a1 + 224) = 0LL;
  return result;
}
// 40C420: variable 'a4' is possibly undefined
// 40C420: variable 'a5' is possibly undefined
// 40C420: variable 'a6' is possibly undefined
// 40C420: variable 'a7' is possibly undefined
// 40C420: variable 'a8' is possibly undefined
// 40C420: variable 'a9' is possibly undefined
// 40C420: variable 'a10' is possibly undefined
// 40C420: variable 'a11' is possibly undefined

//----- (000000000040C460) ----------------------------------------------------
__int64 __fastcall IO_str_overflow(
        __int64 a1,
        unsigned int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        void *a15,
        __int64 a16)
{
  unsigned __int64 v16; // x4
  int v18; // w0
  unsigned int v19; // w22
  _BOOL4 v20; // w2
  _BYTE *v21; // x0
  unsigned __int64 v22; // x21
  unsigned __int64 v23; // x1
  void *v24; // x3
  unsigned __int64 v25; // x2
  void *v26; // x5
  unsigned __int64 v27; // x20
  __int64 v28; // x5
  int v29; // w4
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  double v38; // d0
  double v39; // d1
  double v40; // d2
  double v41; // d3
  double v42; // d4
  double v43; // d5
  double v44; // d6
  double v45; // d7
  unsigned __int64 v46; // x1
  __int64 v47; // x1
  unsigned __int64 v48; // x0
  __int64 v51; // [xsp+38h] [xbp+38h]
  __int64 v52; // [xsp+38h] [xbp+38h]
  int v53; // [xsp+40h] [xbp+40h]
  int v54; // [xsp+4Ch] [xbp+4Ch]

  v16 = a2;
  v18 = *(_DWORD *)a1;
  if ( (v18 & 8) == 0 )
  {
    v19 = v18 & 8;
    v20 = a2 == -1;
    if ( (*(_QWORD *)a1 & 0xC00LL) == 0x400 )
    {
      *(_DWORD *)a1 = v18 | 0x800;
      v21 = *(_BYTE **)(a1 + 8);
      *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 16);
      *(_QWORD *)(a1 + 40) = v21;
    }
    else
    {
      v21 = *(_BYTE **)(a1 + 40);
    }
    v22 = *(_QWORD *)(a1 + 56);
    v23 = (unsigned __int64)&v21[-*(_QWORD *)(a1 + 32)];
    v24 = (void *)(*(_QWORD *)(a1 + 64) - v22);
    v25 = (unsigned __int64)v24 + v20;
    if ( v25 <= v23 )
    {
      if ( (*(_DWORD *)a1 & 1) != 0 )
        return (unsigned int)-1;
      v26 = (void *)(2LL * ((_QWORD)v24 + 50));
      if ( v24 > v26 )
        return (unsigned int)-1;
      v51 = 2LL * ((_QWORD)v24 + 50);
      v54 = v16;
      v27 = malloc(v51, v23, v25, v24, (void *)v16, v26, a15, a16, a3, a4, a5, a6, a7, a8, a9, a10);
      if ( !v27 )
        return (unsigned int)-1;
      v28 = v51;
      v29 = v54;
      if ( v22 )
      {
        j_memcpy();
        free(v22, v30, v31, v32, v33, v34, v35, v36, v37);
        v29 = v54;
        v28 = v51;
        *(_QWORD *)(a1 + 56) = 0LL;
      }
      v52 = v28;
      v53 = v29;
      memset();
      IO_setb((int *)a1, v27, v27 + v52, 1, v38, v39, v40, v41, v42, v43, v44, v45);
      *(_QWORD *)(a1 + 24) = v27 + *(_QWORD *)(a1 + 24) - v22;
      *(_QWORD *)(a1 + 32) = v27;
      v46 = v27 + *(_QWORD *)(a1 + 16) - v22;
      *(_QWORD *)(a1 + 8) = v27 + *(_QWORD *)(a1 + 8) - v22;
      *(_QWORD *)(a1 + 16) = v46;
      v47 = *(_QWORD *)(a1 + 64);
      v21 = (_BYTE *)(v27 + *(_QWORD *)(a1 + 40) - v22);
      *(_QWORD *)(a1 + 40) = v21;
      *(_QWORD *)(a1 + 48) = v47;
      LODWORD(v16) = v53;
    }
    if ( (_DWORD)v16 != -1 )
    {
      *(_QWORD *)(a1 + 40) = v21 + 1;
      *v21 = v16;
      v48 = *(_QWORD *)(a1 + 40);
      if ( v48 > *(_QWORD *)(a1 + 16) )
        *(_QWORD *)(a1 + 16) = v48;
      return (unsigned int)v16;
    }
    if ( *(_QWORD *)(a1 + 16) < (unsigned __int64)v21 )
    {
      *(_QWORD *)(a1 + 16) = v21;
      return v19;
    }
    return v19;
  }
  if ( a2 == -1 )
    return 0;
  else
    return (unsigned int)-1;
}
// 40C510: variable 'v30' is possibly undefined
// 40C510: variable 'v31' is possibly undefined
// 40C510: variable 'v32' is possibly undefined
// 40C510: variable 'v33' is possibly undefined
// 40C510: variable 'v34' is possibly undefined
// 40C510: variable 'v35' is possibly undefined
// 40C510: variable 'v36' is possibly undefined
// 40C510: variable 'v37' is possibly undefined
// 40C54C: variable 'v38' is possibly undefined
// 40C54C: variable 'v39' is possibly undefined
// 40C54C: variable 'v40' is possibly undefined
// 40C54C: variable 'v41' is possibly undefined
// 40C54C: variable 'v42' is possibly undefined
// 40C54C: variable 'v43' is possibly undefined
// 40C54C: variable 'v44' is possibly undefined
// 40C54C: variable 'v45' is possibly undefined

//----- (000000000040C640) ----------------------------------------------------
__int64 __fastcall IO_str_underflow(__int64 a1)
{
  unsigned __int64 v1; // x2
  unsigned __int8 *v2; // x1
  __int64 v4; // x3

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(unsigned __int8 **)(a1 + 40);
  if ( (unsigned __int64)v2 > v1 )
  {
    v1 = *(_QWORD *)(a1 + 40);
    *(_QWORD *)(a1 + 16) = v2;
  }
  if ( (*(_DWORD *)a1 & 0xC00) == 0xC00 )
  {
    *(_DWORD *)a1 &= ~0x800u;
    v4 = *(_QWORD *)(a1 + 48);
    *(_QWORD *)(a1 + 8) = v2;
    *(_QWORD *)(a1 + 40) = v4;
  }
  else
  {
    v2 = *(unsigned __int8 **)(a1 + 8);
  }
  if ( v1 <= (unsigned __int64)v2 )
    return 0xFFFFFFFFLL;
  else
    return *v2;
}

//----- (000000000040C6A0) ----------------------------------------------------
__int64 __fastcall IO_str_count(_QWORD *a1)
{
  unsigned __int64 v1; // x2
  __int64 v2; // x0
  unsigned __int64 v3; // x1

  v1 = a1[5];
  v3 = a1[2];
  v2 = a1[3];
  if ( v3 < v1 )
    v3 = v1;
  return v3 - v2;
}

//----- (000000000040C6C0) ----------------------------------------------------
__int64 __fastcall IO_str_seekoff(
        _QWORD *a1,
        __int64 a2,
        unsigned int a3,
        __int64 a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  _QWORD *v12; // x4
  __int64 v14; // x7
  unsigned __int64 v15; // x1
  unsigned __int64 v16; // x2
  int v17; // w0
  __int64 v18; // x2
  unsigned __int64 v19; // x5
  __int64 v20; // x5
  __int64 v21; // x1
  __int64 v23; // x1
  __int64 v24; // x1
  __int64 v26; // x1
  unsigned __int64 v28; // x5
  unsigned __int64 v29; // x5
  int v30; // w0
  int v31; // w0
  _QWORD *v32; // [xsp+18h] [xbp+18h]
  _QWORD *v33; // [xsp+18h] [xbp+18h]
  __int64 v34; // [xsp+20h] [xbp+20h]
  __int64 v35; // [xsp+20h] [xbp+20h]
  __int64 v36; // [xsp+28h] [xbp+28h]
  __int64 v37; // [xsp+30h] [xbp+30h]
  unsigned int v38; // [xsp+38h] [xbp+38h]
  unsigned int v39; // [xsp+3Ch] [xbp+3Ch]

  v12 = a1;
  v14 = a3;
  v16 = a1[4];
  v15 = a1[5];
  v17 = *(_DWORD *)a1;
  if ( !(_DWORD)a4 )
  {
    a4 = v17 & 0x400;
    if ( (v17 & 0x400) != 0 )
    {
      if ( (v17 & 0x800) != 0 )
      {
        a4 = 2LL;
        if ( (v17 & 0x100) != 0 )
          goto LABEL_35;
      }
      else
      {
        if ( v15 <= v16 )
        {
          v19 = v12[2];
          v18 = v12[3];
          a4 = 1LL;
          if ( v19 < v15 )
            v19 = v15;
          v20 = v19 - v18;
          if ( (_DWORD)v14 )
            goto LABEL_8;
LABEL_50:
          if ( a2 < 0 )
            goto LABEL_60;
          v23 = a2;
          goto LABEL_15;
        }
        a4 = 1LL;
        if ( (v17 & 0x100) != 0 )
        {
LABEL_35:
          v18 = v12[10];
          *(_DWORD *)v12 = v17 & 0xFFFFF7FF;
          v12[1] = v15;
          v12[2] = v15;
          v12[3] = v18;
          if ( (_DWORD)a4 )
          {
LABEL_36:
            v28 = v12[2];
            if ( v28 < v15 )
              v28 = v15;
            v23 = -1LL;
            v20 = v28 - v18;
            if ( (a4 & 1) == 0 )
              goto LABEL_17;
            goto LABEL_39;
          }
          return v12[1] - v18;
        }
      }
LABEL_32:
      v18 = v12[7];
      *(_DWORD *)v12 = v17 & 0xFFFFF7FF;
      v12[1] = v15;
      v12[2] = v15;
      v12[3] = v18;
      if ( (_DWORD)a4 )
        goto LABEL_36;
      return v12[1] - v18;
    }
    if ( v15 <= v16 && (v17 & 0x800) == 0 )
    {
      v18 = v12[3];
      return v12[1] - v18;
    }
LABEL_31:
    if ( (v17 & 0x100) != 0 )
      goto LABEL_35;
    goto LABEL_32;
  }
  if ( v15 > v16 || (v17 & 0x800) != 0 )
    goto LABEL_31;
  v29 = v12[2];
  v18 = v12[3];
  if ( v29 < v15 )
    v29 = v15;
  v23 = -1LL;
  v20 = v29 - v18;
  if ( (a4 & 1) == 0 )
    goto LABEL_17;
LABEL_39:
  if ( !(_DWORD)v14 )
    goto LABEL_50;
LABEL_8:
  v21 = v20;
  if ( (_DWORD)v14 == 1 )
    v21 = v12[1] - v18;
  if ( -v21 > a2 || 0x7FFFFFFFFFFFFFFFLL - v21 < a2 )
    goto LABEL_60;
  v23 = v21 + a2;
LABEL_15:
  if ( v20 < v23 )
  {
    v32 = v12;
    v34 = v23;
    v36 = v20;
    v37 = a2;
    v38 = a4;
    v39 = v14;
    v30 = enlarge_userbuf(v12, v23, 1LL, a5, a6, a7, a8, a9, a10, a11, a12, a4, (__int64)v12, v20, (void *)a2, v14);
    v12 = v32;
    v23 = v34;
    v20 = v36;
    a2 = v37;
    a4 = v38;
    v14 = v39;
    if ( v30 )
      return -1LL;
    v18 = v32[3];
  }
  v12[1] = v18 + v23;
  v12[2] = v18 + v20;
LABEL_17:
  if ( (a4 & 2) != 0 )
  {
    if ( (_DWORD)v14 )
    {
      v24 = v20;
      if ( (_DWORD)v14 == 1 )
        v24 = v12[5] - v12[4];
      if ( a2 > 0x7FFFFFFFFFFFFFFFLL - v24 || -v24 > a2 )
        goto LABEL_60;
      v26 = v24 + a2;
      goto LABEL_27;
    }
    if ( (a2 & 0x8000000000000000LL) == 0 )
    {
      v26 = a2;
LABEL_27:
      if ( v20 >= v26
        || (v33 = v12,
            v35 = v26,
            v31 = enlarge_userbuf(
                    v12,
                    v26,
                    0LL,
                    a5,
                    a6,
                    a7,
                    a8,
                    a9,
                    a10,
                    a11,
                    a12,
                    a4,
                    (__int64)v12,
                    v20,
                    (void *)a2,
                    v14),
            v12 = v33,
            v26 = v35,
            !v31) )
      {
        v12[5] = v12[4] + v26;
        return v26;
      }
      return -1LL;
    }
LABEL_60:
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return -1LL;
  }
  return v23;
}
// 40C8B0: variable 'a5' is possibly undefined
// 40C8B0: variable 'a6' is possibly undefined
// 40C8B0: variable 'a7' is possibly undefined
// 40C8B0: variable 'a8' is possibly undefined
// 40C8B0: variable 'a9' is possibly undefined
// 40C8B0: variable 'a10' is possibly undefined
// 40C8B0: variable 'a11' is possibly undefined
// 40C8B0: variable 'a12' is possibly undefined

//----- (000000000040C8EC) ----------------------------------------------------
__int64 __fastcall IO_str_pbackfail(
        __int64 *a1,
        unsigned int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  __int64 v16; // x2

  v16 = *(unsigned int *)a1;
  if ( (v16 & 8) == 0 || a2 == -1 )
    return IO_default_pbackfail(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, v16, a12, a13, a14, a15, a16);
  else
    return 0xFFFFFFFFLL;
}

//----- (000000000040C908) ----------------------------------------------------
void __fastcall IO_str_finish(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  unsigned __int64 v10; // x0
  __int64 v11; // x0
  __int64 v12; // [xsp+18h] [xbp-8h]

  v10 = *(_QWORD *)(a1 + 56);
  if ( v10 && (*(_DWORD *)a1 & 1) == 0 )
  {
    v12 = a1;
    free(v10, a2, a3, a4, a5, a6, a7, a8, a9);
    v11 = v12;
    *(_QWORD *)(v12 + 56) = 0LL;
  }
  else
  {
    *(_QWORD *)(a1 + 56) = 0LL;
    v11 = a1;
  }
  IO_default_finish(v11, a2, a3, a4, a5, a6, a7, a8, a9);
}
// 40C950: variable 'a2' is possibly undefined
// 40C950: variable 'a3' is possibly undefined
// 40C950: variable 'a4' is possibly undefined
// 40C950: variable 'a5' is possibly undefined
// 40C950: variable 'a6' is possibly undefined
// 40C950: variable 'a7' is possibly undefined
// 40C950: variable 'a8' is possibly undefined
// 40C950: variable 'a9' is possibly undefined

//----- (000000000040C960) ----------------------------------------------------
void __fastcall _libc_cleanup_push_defer(__int64 a1)
{
  unsigned __int64 StatusReg; // x2
  __int64 v2; // x3
  unsigned __int64 v3; // x5
  _DWORD *v4; // x2
  int v5; // w4
  unsigned int v6; // w0
  int v7; // [xsp+14h] [xbp-1Ch]
  _DWORD *v8; // [xsp+18h] [xbp-18h]
  __int64 v9; // [xsp+20h] [xbp-10h]
  unsigned __int64 v10; // [xsp+28h] [xbp-8h]

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v2 = a1;
  v3 = StatusReg - 1824;
  v4 = (_DWORD *)(StatusReg - 1560);
  *(_QWORD *)(a1 + 24) = *(_QWORD *)(v3 + 0xF8);
  v5 = *v4;
  if ( (*v4 & 2) != 0 )
  {
    do
    {
      v7 = v5;
      v8 = v4;
      v9 = v2;
      v10 = v3;
      _aarch64_cas4_acq();
      v3 = v10;
      v4 = v8;
      v2 = v9;
      v5 = v6;
    }
    while ( v6 != v7 );
    *(_DWORD *)(v9 + 16) = (v6 >> 1) & 1;
    *(_QWORD *)(v10 + 248) = v9;
  }
  else
  {
    *(_DWORD *)(a1 + 16) = (*v4 >> 1) & 1;
    *(_QWORD *)(v3 + 0xF8) = a1;
  }
}
// 40C9C0: variable 'v6' is possibly undefined

//----- (000000000040C9E0) ----------------------------------------------------
void __fastcall _libc_cleanup_pop_restore(__int64 a1)
{
  __int64 v1; // x1
  unsigned __int64 StatusReg; // x2
  unsigned __int64 v3; // x4
  _DWORD *v4; // x2
  int v5; // w3
  int v6; // w0
  __int64 v7; // x1
  __int64 v8; // x2
  __int64 v9; // x3
  void *v10; // x5
  void *v11; // x6
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  int v20; // [xsp+18h] [xbp+18h]
  _DWORD *v21; // [xsp+20h] [xbp+20h]
  unsigned __int64 v22; // [xsp+28h] [xbp+28h]

  v1 = *(_QWORD *)(a1 + 24);
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v3 = StatusReg - 1824;
  v4 = (_DWORD *)(StatusReg - 1560);
  *(_QWORD *)(v3 + 0xF8) = v1;
  if ( *(_DWORD *)(a1 + 16) && (*v4 & 2) == 0 )
  {
    v5 = *v4;
    do
    {
      v20 = v5;
      v21 = v4;
      v22 = v3;
      _aarch64_cas4_acq();
      v4 = v21;
      v3 = v22;
      v5 = v6;
    }
    while ( v6 != v20 );
    if ( (v6 & 0x39) == 8 )
    {
      *(_QWORD *)(v22 + 1064) = -1LL;
      _aarch64_ldset4_relax();
      _lll_lock_wait_private(
        *(_DWORD **)(v22 + 256),
        v12,
        v13,
        v14,
        v15,
        v16,
        v17,
        v18,
        v19,
        v7,
        v8,
        v9,
        (void *)v22,
        v10,
        v11);
    }
  }
}
// 40CA30: variable 'v6' is possibly undefined
// 40CA7D: variable 'v12' is possibly undefined
// 40CA7D: variable 'v13' is possibly undefined
// 40CA7D: variable 'v14' is possibly undefined
// 40CA7D: variable 'v15' is possibly undefined
// 40CA7D: variable 'v16' is possibly undefined
// 40CA7D: variable 'v17' is possibly undefined
// 40CA7D: variable 'v18' is possibly undefined
// 40CA7D: variable 'v19' is possibly undefined
// 40CA7D: variable 'v7' is possibly undefined
// 40CA7D: variable 'v8' is possibly undefined
// 40CA7D: variable 'v9' is possibly undefined
// 40CA7D: variable 'v10' is possibly undefined
// 40CA7D: variable 'v11' is possibly undefined

//----- (000000000040CA80) ----------------------------------------------------
void __fastcall _lll_lock_wait_private(
        _DWORD *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        void *a13,
        void *a14,
        void *a15)
{
  int v16; // w0
  unsigned __int64 v17; // x0

  if ( *a1 == 2 )
    goto LABEL_3;
  while ( 1 )
  {
    _aarch64_swp4_acq();
    if ( !v16 )
      break;
LABEL_3:
    v17 = linux_eabi_syscall(__NR_futex, a1, (void *)0x80, (void *)2, 0LL, a13, a14, a15);
    if ( v17 > 0xFFFFFFFFFFFFF000LL && (_DWORD)v17 != -11 && (_DWORD)v17 != -4 )
      _libc_fatal((__int64)"The futex facility returned an unexpected error code.\n", a2, a3, a4, a5, a6, a7, a8, a9);
  }
}
// 40CAA8: variable 'v16' is possibly undefined
// 40CAC0: variable 'a13' is possibly undefined
// 40CAC0: variable 'a14' is possibly undefined
// 40CAC0: variable 'a15' is possibly undefined
// 40CAE4: variable 'a2' is possibly undefined
// 40CAE4: variable 'a3' is possibly undefined
// 40CAE4: variable 'a4' is possibly undefined
// 40CAE4: variable 'a5' is possibly undefined
// 40CAE4: variable 'a6' is possibly undefined
// 40CAE4: variable 'a7' is possibly undefined
// 40CAE4: variable 'a8' is possibly undefined
// 40CAE4: variable 'a9' is possibly undefined

//----- (000000000040CB00) ----------------------------------------------------
void __fastcall _lll_lock_wait(
        _DWORD *a1,
        int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        __int64 a12,
        void *a13,
        void *a14,
        void *a15)
{
  int v17; // w0
  unsigned __int64 v18; // x0

  if ( *a1 == 2 )
    goto LABEL_3;
  while ( 1 )
  {
    _aarch64_swp4_acq();
    if ( !v17 )
      break;
LABEL_3:
    v18 = linux_eabi_syscall(__NR_futex, a1, (void *)(a2 ^ 0x80), (void *)2, 0LL, a13, a14, a15);
    if ( v18 > 0xFFFFFFFFFFFFF000LL && (_DWORD)v18 != -11 && (_DWORD)v18 != -4 )
      _libc_fatal((__int64)"The futex facility returned an unexpected error code.\n", a3, a4, a5, a6, a7, a8, a9, a10);
  }
}
// 40CB2C: variable 'v17' is possibly undefined
// 40CB48: variable 'a13' is possibly undefined
// 40CB48: variable 'a14' is possibly undefined
// 40CB48: variable 'a15' is possibly undefined
// 40CB6C: variable 'a3' is possibly undefined
// 40CB6C: variable 'a4' is possibly undefined
// 40CB6C: variable 'a5' is possibly undefined
// 40CB6C: variable 'a6' is possibly undefined
// 40CB6C: variable 'a7' is possibly undefined
// 40CB6C: variable 'a8' is possibly undefined
// 40CB6C: variable 'a9' is possibly undefined
// 40CB6C: variable 'a10' is possibly undefined

//----- (000000000040CB80) ----------------------------------------------------
signed __int64 __fastcall _lll_lock_wake_private(
        void *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        void *a5,
        void *a6,
        void *a7)
{
  return linux_eabi_syscall(__NR_futex, a1, (void *)0x81, (void *)1, 0LL, a5, a6, a7);
}

//----- (000000000040CBA0) ----------------------------------------------------
signed __int64 __fastcall _lll_lock_wake(void *a1, int a2, __int64 a3, __int64 a4, void *a5, void *a6, void *a7)
{
  return linux_eabi_syscall(__NR_futex, a1, (void *)(a2 ^ 0x81), (void *)1, 0LL, a5, a6, a7);
}

//----- (000000000040CBC0) ----------------------------------------------------
void __fastcall _nptl_deallocate_tsd(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  unsigned __int64 StatusReg; // x24
  unsigned __int64 v9; // x25
  int v10; // w28
  __int64 *v11; // x22
  __int64 *v12; // x23
  __int64 v13; // x21
  __int64 v14; // x27
  _QWORD *v15; // x19
  __int64 *v16; // x20
  _QWORD *v17; // x27
  __int64 v18; // x2
  __int64 v19; // x1
  void (*v20)(void); // x1
  unsigned __int64 *v21; // x19
  unsigned __int64 *v22; // x24

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v9 = StatusReg - 1824;
  if ( (*(_BYTE *)(StatusReg - 1824 + 0x410) & 1) != 0 )
  {
    v10 = 4;
    while ( 1 )
    {
      v11 = (__int64 *)(StatusReg - 1040);
      v12 = &_pthread_keys;
      v13 = 32LL;
      *(_BYTE *)(v9 + 0x410) = 0;
      do
      {
        v14 = *v11;
        if ( *v11 )
        {
          v15 = (_QWORD *)(v14 + 8);
          v16 = v12;
          v17 = (_QWORD *)(v14 + 520);
          do
          {
            if ( *v15 )
            {
              v18 = *(v15 - 1);
              v19 = *v16;
              *v15 = 0LL;
              if ( v18 == v19 )
              {
                v20 = (void (*)(void))v16[1];
                if ( v20 )
                  v20();
              }
            }
            v15 += 2;
            v16 += 2;
          }
          while ( v15 != v17 );
        }
        v13 += 32LL;
        ++v11;
        v12 += 64;
      }
      while ( v13 != 1056 );
      if ( (*(_BYTE *)(v9 + 0x410) & 1) == 0 )
        break;
      if ( !--v10 )
      {
        memset();
        break;
      }
    }
    v21 = (unsigned __int64 *)(StatusReg - 1032);
    v22 = (unsigned __int64 *)(StatusReg - 784);
    do
    {
      if ( *v21 )
      {
        free(*v21, a1, a2, a3, a4, a5, a6, a7, a8);
        *v21 = 0LL;
      }
      ++v21;
    }
    while ( v21 != v22 );
    *(_BYTE *)(v9 + 0x410) = 0;
  }
}
// 40CCA8: variable 'a1' is possibly undefined
// 40CCA8: variable 'a2' is possibly undefined
// 40CCA8: variable 'a3' is possibly undefined
// 40CCA8: variable 'a4' is possibly undefined
// 40CCA8: variable 'a5' is possibly undefined
// 40CCA8: variable 'a6' is possibly undefined
// 40CCA8: variable 'a7' is possibly undefined
// 40CCA8: variable 'a8' is possibly undefined
// 492B00: using guessed type __int64 _pthread_keys;

//----- (000000000040CCE0) ----------------------------------------------------
__int64 __fastcall _pthread_kill_implementation_constprop_0(
        __int64 a1,
        void *a2,
        void *a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7)
{
  void *v8; // x0
  int v9; // w22
  int v10; // w0
  void *v11; // x20
  __int64 v12; // x1
  __int64 v13; // x2
  __int64 v14; // x3
  void *v15; // x4
  void *v16; // x5
  void *v17; // x6
  double v18; // d0
  double v19; // d1
  double v20; // d2
  double v21; // d3
  double v22; // d4
  double v23; // d5
  double v24; // d6
  double v25; // d7
  int v26; // w0
  unsigned int v27; // w19
  __int64 v28; // x1
  __int64 v29; // x2
  __int64 v30; // x3
  void *v31; // x4
  void *v32; // x5
  void *v33; // x6
  int v34; // w0
  int v35; // w0
  void *v37; // x19
  __pid_t v38; // w0
  void *v39; // x3
  void *v40; // x4
  void *v41; // x5
  void *v42; // x6
  signed __int64 v43; // x0
  signed __int64 v44; // x0
  void *v45; // x19
  __pid_t v46; // w0
  void *v47; // x3
  void *v48; // x4
  void *v49; // x5
  void *v50; // x6
  signed __int64 v51; // x0
  char v52; // [xsp+38h] [xbp+38h] BYREF

  v8 = (void *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824);
  v9 = (int)a2;
  if ( (void *)a1 == v8 )
  {
    v44 = linux_eabi_syscall(__NR_gettid, v8, a2, a3, a4, a5, a6, a7);
    v45 = (void *)(int)v44;
    v46 = getpid();
    v51 = linux_eabi_syscall(__NR_tgkill, (void *)v46, v45, (void *)v9, v47, v48, v49, v50);
    if ( (unsigned int)v51 > 0xFFFFF000 )
      return (unsigned int)-(int)v51;
    else
      return 0;
  }
  else
  {
    v10 = linux_eabi_syscall(__NR_rt_sigprocmask, 0, (const sigset_t *)&sigall_set, (sigset_t *)&v52);
    v11 = (void *)(a1 + 1796);
    _aarch64_cas4_acq();
    if ( v26 )
      _lll_lock_wait_private(
        (_DWORD *)(a1 + 1796),
        v18,
        v19,
        v20,
        v21,
        v22,
        v23,
        v24,
        v25,
        v12,
        v13,
        v14,
        v15,
        v16,
        v17);
    if ( (*(_BYTE *)(a1 + 1793) & 1) != 0
      || (v37 = (void *)*(int *)(a1 + 208),
          v38 = getpid(),
          v43 = linux_eabi_syscall(__NR_tgkill, (void *)v38, v37, (void *)v9, v39, v40, v41, v42),
          (unsigned int)v43 <= 0xFFFFF000) )
    {
      v27 = 0;
    }
    else
    {
      v27 = -(int)v43;
    }
    _aarch64_swp4_rel();
    if ( v34 > 1 )
      _lll_lock_wake_private(v11, v28, v29, v30, v31, v32, v33);
    v35 = linux_eabi_syscall(__NR_rt_sigprocmask, 2, (const sigset_t *)&v52, 0LL);
  }
  return v27;
}
// 40CD38: variable 'v26' is possibly undefined
// 40CDF4: variable 'v18' is possibly undefined
// 40CDF4: variable 'v19' is possibly undefined
// 40CDF4: variable 'v20' is possibly undefined
// 40CDF4: variable 'v21' is possibly undefined
// 40CDF4: variable 'v22' is possibly undefined
// 40CDF4: variable 'v23' is possibly undefined
// 40CDF4: variable 'v24' is possibly undefined
// 40CDF4: variable 'v25' is possibly undefined
// 40CDF4: variable 'v12' is possibly undefined
// 40CDF4: variable 'v13' is possibly undefined
// 40CDF4: variable 'v14' is possibly undefined
// 40CDF4: variable 'v15' is possibly undefined
// 40CDF4: variable 'v16' is possibly undefined
// 40CDF4: variable 'v17' is possibly undefined
// 40CD58: variable 'v34' is possibly undefined
// 40CDE8: variable 'v28' is possibly undefined
// 40CDE8: variable 'v29' is possibly undefined
// 40CDE8: variable 'v30' is possibly undefined
// 40CDE8: variable 'v31' is possibly undefined
// 40CDE8: variable 'v32' is possibly undefined
// 40CDE8: variable 'v33' is possibly undefined
// 40CDA0: variable 'v39' is possibly undefined
// 40CDA0: variable 'v40' is possibly undefined
// 40CDA0: variable 'v41' is possibly undefined
// 40CDA0: variable 'v42' is possibly undefined
// 40CDD4: variable 'v47' is possibly undefined
// 40CDD4: variable 'v48' is possibly undefined
// 40CDD4: variable 'v49' is possibly undefined
// 40CDD4: variable 'v50' is possibly undefined

//----- (000000000040CE00) ----------------------------------------------------
__int64 __fastcall _pthread_raise_internal(void *a1, void *a2, __int64 a3, void *a4, void *a5, void *a6, void *a7)
{
  __pid_t v7; // w0
  void *v8; // x3
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  signed __int64 v12; // x0
  void *v14; // [xsp+10h] [xbp+10h]
  void *v15; // [xsp+18h] [xbp+18h]

  v15 = (void *)(int)a1;
  v14 = (void *)(int)gettid(a1, a2, (void *)(int)a1, a4, a5, a6, a7);
  v7 = getpid();
  v12 = linux_eabi_syscall(__NR_tgkill, (void *)v7, v14, v15, v8, v9, v10, v11);
  if ( (unsigned int)v12 > 0xFFFFF000 )
    return (unsigned int)-(int)v12;
  else
    return 0LL;
}
// 40CE2C: variable 'v8' is possibly undefined
// 40CE2C: variable 'v9' is possibly undefined
// 40CE2C: variable 'v10' is possibly undefined
// 40CE2C: variable 'v11' is possibly undefined

//----- (000000000040CE44) ----------------------------------------------------
__int64 __fastcall pthread_kill(__int64 a1, void *a2, __int64 a3, void *a4, void *a5, void *a6, void *a7)
{
  unsigned __int64 v7; // x2

  v7 = (unsigned int)((_DWORD)a2 - 32);
  if ( (unsigned int)v7 <= 1 )
    return 22LL;
  else
    return _pthread_kill_implementation_constprop_0(a1, a2, (void *)v7, a4, a5, a6, a7);
}

//----- (000000000040CE60) ----------------------------------------------------
__int64 __fastcall pthread_rwlock_init(__int64 a1, _DWORD *a2)
{
  if ( !a2 )
    a2 = &default_rwlockattr;
  *(_QWORD *)(a1 + 48) = 0LL;
  *(_OWORD *)a1 = 0uLL;
  *(_OWORD *)(a1 + 16) = 0uLL;
  *(_OWORD *)(a1 + 32) = 0uLL;
  *(_DWORD *)(a1 + 48) = *a2;
  *(_DWORD *)(a1 + 28) = a2[1] != 0;
  return 0LL;
}

//----- (000000000040CEA0) ----------------------------------------------------
__int64 __fastcall pthread_rwlock_rdlock(unsigned int *a1)
{
  unsigned int v2; // w1
  void *v3; // x6
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double v7; // d3
  double v8; // d4
  double v9; // d5
  double v10; // d6
  double v11; // d7
  int v12; // w0
  int v13; // w20
  unsigned int v14; // w3
  unsigned int v15; // w20
  __int64 v16; // x5
  void *v17; // x6
  double v18; // d0
  double v19; // d1
  double v20; // d2
  double v21; // d3
  double v22; // d4
  double v23; // d5
  double v24; // d6
  double v25; // d7
  unsigned int v26; // w0
  unsigned int v27; // w0
  bool v28; // zf
  int v30; // w0
  void *v31; // x4
  void *v32; // x5
  void *v33; // x6
  double v34; // d0
  double v35; // d1
  double v36; // d2
  double v37; // d3
  double v38; // d4
  double v39; // d5
  double v40; // d6
  double v41; // d7
  char v42; // w0
  unsigned __int64 v43; // x0
  int v44; // w0
  _DWORD *v45; // x5
  _BOOL4 v46; // w20
  int v47; // w21
  char v48; // w20
  unsigned int v49; // w3
  int v50; // w0
  unsigned int v52; // w20
  unsigned int v53; // w0
  _DWORD *v54; // [xsp+30h] [xbp+30h]
  _DWORD *v55; // [xsp+30h] [xbp+30h]
  unsigned int v56; // [xsp+30h] [xbp+30h]
  unsigned int v57; // [xsp+38h] [xbp+38h]
  _DWORD *v58; // [xsp+38h] [xbp+38h]

  v2 = a1[6];
  if ( v2 == *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824 + 0xD0) )
    return 35LL;
  if ( a1[12] == 2 )
  {
    v15 = *a1;
    while ( (v15 & 3) == 2 && v15 >> 3 )
    {
      _aarch64_cas4_relax();
      v28 = v26 == v15;
      v15 = v26;
      if ( v28 )
      {
        while ( 1 )
        {
          v15 = *a1;
          if ( (*a1 & 4) == 0 )
            break;
          v27 = _futex_abstimed_wait64(
                  a1,
                  v15,
                  0,
                  0LL,
                  (unsigned __int8)(a1[7] != 0) << 7,
                  v18,
                  v19,
                  v20,
                  v21,
                  v22,
                  v23,
                  v24,
                  v25,
                  v16,
                  v17);
          v14 = v27;
          v28 = v27 == 110 || v27 == 75;
          if ( v28 )
            return v14;
        }
      }
    }
  }
  _aarch64_ldadd4_acq();
  v13 = v12 + 8;
  while ( v13 < 0 )
  {
    _aarch64_cas4_relax();
    v28 = v44 == v13;
    v13 = v44;
    if ( v28 )
      return 11;
  }
  if ( (v13 & 1) != 0 )
  {
    while ( (v13 & 3) == 1 )
    {
      _aarch64_cas4_acq();
      v28 = v30 == v13;
      v13 = v30;
      if ( v28 )
      {
        _aarch64_swp4_relax();
        if ( (v42 & 2) != 0 )
        {
          v43 = linux_eabi_syscall(
                  __NR_futex,
                  a1 + 2,
                  (void *)(((a1[7] != 0) << 7) ^ 0x81u),
                  (void *)0x7FFFFFFF,
                  0LL,
                  v31,
                  v32,
                  v33);
          if ( v43 > 0xFFFFFFFFFFFFF000LL && (((_DWORD)v43 + 22) & 0xFFFFFFF7) != 0 )
            _libc_fatal(
              (__int64)"The futex facility returned an unexpected error code.\n",
              v34,
              v35,
              v36,
              v37,
              v38,
              v39,
              v40,
              v41);
        }
        return 0;
      }
    }
    v45 = a1 + 2;
    v46 = 0;
    while ( 1 )
    {
      v47 = *v45;
      if ( (*v45 | 2) != 3 )
        break;
LABEL_35:
      v49 = a1[7];
      if ( (v47 & 2) == 0 )
      {
        v54 = v45;
        v57 = a1[7];
        _aarch64_cas4_relax();
        v45 = v54;
        v49 = v57;
        if ( v50 != v47 )
          continue;
      }
      v55 = v45;
      v14 = _futex_abstimed_wait64(
              v45,
              3u,
              0,
              0LL,
              (unsigned __int8)(v49 != 0) << 7,
              v4,
              v5,
              v6,
              v7,
              v8,
              v9,
              v10,
              v11,
              (__int64)v45,
              v3);
      v45 = v55;
      if ( v14 == 110 || v14 == 75 )
      {
        v52 = *a1;
        while ( (v52 & 1) != 0 )
        {
          v56 = v14;
          v58 = v45;
          _aarch64_cas4_relax();
          v45 = v58;
          v28 = v53 == v52;
          v14 = v56;
          v52 = v53;
          if ( v28 )
            return v14;
        }
        __dmb(9u);
        while ( (*v45 | 2) == 3 )
          ;
        return 0;
      }
    }
    while ( !v46 )
    {
      v48 = atomic_load(a1);
      v46 = (v48 & 1) == 0;
      v47 = *v45;
      if ( (*v45 | 2) == 3 )
        goto LABEL_35;
    }
    return 0;
  }
  else
  {
    return 0;
  }
}
// 40CEA0: could not find valid save-restore pair for x21
// 40CEE4: variable 'v12' is possibly undefined
// 40CF28: variable 'v26' is possibly undefined
// 40CF68: variable 'v18' is possibly undefined
// 40CF68: variable 'v19' is possibly undefined
// 40CF68: variable 'v20' is possibly undefined
// 40CF68: variable 'v21' is possibly undefined
// 40CF68: variable 'v22' is possibly undefined
// 40CF68: variable 'v23' is possibly undefined
// 40CF68: variable 'v24' is possibly undefined
// 40CF68: variable 'v25' is possibly undefined
// 40CF68: variable 'v16' is possibly undefined
// 40CF68: variable 'v17' is possibly undefined
// 40CFAC: variable 'v30' is possibly undefined
// 40CFC4: variable 'v42' is possibly undefined
// 40CFEC: variable 'v31' is possibly undefined
// 40CFEC: variable 'v32' is possibly undefined
// 40CFEC: variable 'v33' is possibly undefined
// 40D010: variable 'v34' is possibly undefined
// 40D010: variable 'v35' is possibly undefined
// 40D010: variable 'v36' is possibly undefined
// 40D010: variable 'v37' is possibly undefined
// 40D010: variable 'v38' is possibly undefined
// 40D010: variable 'v39' is possibly undefined
// 40D010: variable 'v40' is possibly undefined
// 40D010: variable 'v41' is possibly undefined
// 40D038: variable 'v44' is possibly undefined
// 40D0B8: variable 'v50' is possibly undefined
// 40D0DC: variable 'v4' is possibly undefined
// 40D0DC: variable 'v5' is possibly undefined
// 40D0DC: variable 'v6' is possibly undefined
// 40D0DC: variable 'v7' is possibly undefined
// 40D0DC: variable 'v8' is possibly undefined
// 40D0DC: variable 'v9' is possibly undefined
// 40D0DC: variable 'v10' is possibly undefined
// 40D0DC: variable 'v11' is possibly undefined
// 40D0DC: variable 'v3' is possibly undefined
// 40D11C: variable 'v53' is possibly undefined

//----- (000000000040D160) ----------------------------------------------------
__int64 __fastcall pthread_rwlock_unlock(int *a1)
{
  _DWORD *v1; // x1
  int v3; // w2
  bool v4; // zf
  unsigned __int64 v5; // x0
  int v6; // w21
  unsigned int v7; // w3
  unsigned int v8; // w20
  unsigned int v9; // w0
  void *v10; // x5
  void *v11; // x6
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  unsigned __int64 v20; // x4
  unsigned __int64 v21; // x0
  char v23; // w0
  unsigned __int64 v24; // x0
  char v25; // w0
  char v26; // w22
  unsigned int v27; // w20
  unsigned int v28; // w0
  void *v29; // x4
  void *v30; // x5
  void *v31; // x6
  unsigned __int64 v32; // x0
  _DWORD *v33; // x2
  int v34; // w20
  int v35; // w0
  char v36; // w0
  unsigned __int64 v37; // x0
  unsigned int v38; // [xsp+40h] [xbp+40h]
  unsigned int v39; // [xsp+40h] [xbp+40h]
  _DWORD *v40; // [xsp+40h] [xbp+40h]

  v1 = a1 + 6;
  v3 = a1[6];
  v4 = a1[7] == 0;
  v5 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
  v6 = !v4;
  if ( *(_DWORD *)(v5 + 0xD0) == v3 )
  {
    *v1 = 0;
    _aarch64_swp4_relax();
    v26 = v25;
    if ( a1[12] )
    {
      v33 = a1 + 1;
      v34 = a1[1];
      while ( v34 )
      {
        v40 = v33;
        _aarch64_cas4_rel();
        v33 = v40;
        v4 = v35 == v34;
        v34 = v35;
        if ( v4 )
          goto LABEL_24;
      }
    }
    v27 = *a1;
    do
    {
      _aarch64_cas4_rel();
      v4 = v28 == v27;
      v27 = v28;
    }
    while ( !v4 );
    if ( v28 >> 3 )
    {
      _aarch64_swp4_relax();
      if ( (v36 & 2) != 0 )
      {
        v37 = linux_eabi_syscall(
                __NR_futex,
                a1 + 2,
                (void *)((v6 << 7) ^ 0x81u),
                (void *)0x7FFFFFFF,
                0LL,
                v29,
                v30,
                v31);
        if ( v37 > 0xFFFFFFFFFFFFF000LL && (((_DWORD)v37 + 22) & 0xFFFFFFF7) != 0 )
LABEL_34:
          _libc_fatal(
            (__int64)"The futex facility returned an unexpected error code.\n",
            v12,
            v13,
            v14,
            v15,
            v16,
            v17,
            v18,
            v19);
      }
    }
LABEL_24:
    if ( (v26 & 2) != 0 )
    {
      v32 = linux_eabi_syscall(__NR_futex, a1 + 3, (void *)((v6 << 7) ^ 0x81u), (void *)1, 0LL, v29, v30, v31);
      if ( v32 > 0xFFFFFFFFFFFFF000LL && (((_DWORD)v32 + 22) & 0xFFFFFFF7) != 0 )
        goto LABEL_34;
    }
    return 0LL;
  }
  else
  {
    v7 = *a1;
    do
    {
      v8 = v7 - 8;
      if ( !((v7 - 8) >> 3) )
      {
        if ( (v8 & 2) != 0 )
          v8 |= 1u;
        v8 &= ~4u;
      }
      v38 = v7;
      _aarch64_cas4_rel();
      v20 = v9;
      v7 = v9;
    }
    while ( v9 != v38 );
    if ( (v8 & 1) != 0 )
    {
      v39 = v9;
      __dmb(9u);
      _aarch64_swp4_relax();
      v20 = v39;
      if ( (v23 & 2) != 0 )
      {
        v24 = linux_eabi_syscall(
                __NR_futex,
                a1 + 2,
                (void *)((v6 << 7) ^ 0x81u),
                (void *)0x7FFFFFFF,
                0LL,
                (void *)v39,
                v10,
                v11);
        if ( v24 > 0xFFFFFFFFFFFFF000LL && (((_DWORD)v24 + 22) & 0xFFFFFFF7) != 0 )
          goto LABEL_34;
      }
    }
    if ( ((v8 ^ (unsigned int)v20) & 4) != 0 )
    {
      v21 = linux_eabi_syscall(
              __NR_futex,
              a1,
              (void *)((v6 << 7) ^ 0x81u),
              (void *)0x7FFFFFFF,
              0LL,
              (void *)v20,
              v10,
              v11);
      if ( v21 > 0xFFFFFFFFFFFFF000LL && (((_DWORD)v21 + 22) & 0xFFFFFFF7) != 0 )
        goto LABEL_34;
    }
    return 0LL;
  }
}
// 40D1C0: variable 'v9' is possibly undefined
// 40D1F8: variable 'v10' is possibly undefined
// 40D1F8: variable 'v11' is possibly undefined
// 40D248: variable 'v23' is possibly undefined
// 40D29C: variable 'v25' is possibly undefined
// 40D2C8: variable 'v28' is possibly undefined
// 40D2F8: variable 'v29' is possibly undefined
// 40D2F8: variable 'v30' is possibly undefined
// 40D2F8: variable 'v31' is possibly undefined
// 40D33C: variable 'v35' is possibly undefined
// 40D358: variable 'v36' is possibly undefined
// 40D394: variable 'v12' is possibly undefined
// 40D394: variable 'v13' is possibly undefined
// 40D394: variable 'v14' is possibly undefined
// 40D394: variable 'v15' is possibly undefined
// 40D394: variable 'v16' is possibly undefined
// 40D394: variable 'v17' is possibly undefined
// 40D394: variable 'v18' is possibly undefined
// 40D394: variable 'v19' is possibly undefined

//----- (000000000040D3C0) ----------------------------------------------------
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock)
{
  __int64 *v2; // x21
  int writer; // w1
  unsigned __int64 v4; // x20
  __int64 v5; // x5
  void *v6; // x6
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  int v15; // w0
  int lock; // w3
  _DWORD *p_writer_wakeup; // x22
  int v18; // w2
  int v19; // w0
  int v20; // w0
  int v21; // w4
  unsigned int flags; // w24
  unsigned int *v24; // x23
  int v25; // w25
  int v26; // w0
  int shared; // w4
  int v28; // w0
  __int64 *v30; // x6
  int v31; // w23
  int v32; // w3
  int v33; // w0
  int v34; // w24
  int v35; // w4
  int v37; // w0
  int v38; // w4
  int v39; // w3
  unsigned int v40; // w0
  double v41; // d0
  double v42; // d1
  double v43; // d2
  double v44; // d3
  double v45; // d4
  double v46; // d5
  double v47; // d6
  double v48; // d7
  unsigned __int64 v49; // x5
  unsigned __int64 v50; // x0
  unsigned __int64 v51; // x0
  char v52; // w0
  unsigned int nr_readers; // w22
  int v54; // w0
  char *v55; // x2
  int v56; // w0
  int v57; // w5
  unsigned int v58; // w3
  unsigned int v59; // w0
  unsigned __int64 v60; // x0
  char *v61; // x2
  unsigned int v62; // w3
  unsigned int v63; // w0
  int v64; // [xsp+58h] [xbp+58h]
  int v65; // [xsp+58h] [xbp+58h]
  unsigned int v66; // [xsp+58h] [xbp+58h]
  __int64 *v67; // [xsp+58h] [xbp+58h]
  __int64 *v68; // [xsp+58h] [xbp+58h]
  __int64 *v69; // [xsp+58h] [xbp+58h]
  int v70; // [xsp+58h] [xbp+58h]
  int v71; // [xsp+58h] [xbp+58h]
  int v72; // [xsp+58h] [xbp+58h]
  unsigned int v73; // [xsp+58h] [xbp+58h]
  unsigned int v74; // [xsp+58h] [xbp+58h]
  unsigned int v75; // [xsp+58h] [xbp+58h]
  int v76; // [xsp+60h] [xbp+60h]
  int v77; // [xsp+60h] [xbp+60h]
  int v78; // [xsp+60h] [xbp+60h]
  unsigned int v79; // [xsp+60h] [xbp+60h]
  int v80; // [xsp+60h] [xbp+60h]
  char *v81; // [xsp+60h] [xbp+60h]
  char *v82; // [xsp+60h] [xbp+60h]
  __int64 *v83; // [xsp+68h] [xbp+68h]
  int v84; // [xsp+68h] [xbp+68h]
  unsigned int v85; // [xsp+68h] [xbp+68h]
  int v86; // [xsp+68h] [xbp+68h]
  __int64 *v87; // [xsp+70h] [xbp+70h]
  unsigned int v88; // [xsp+70h] [xbp+70h]
  __int64 *v89; // [xsp+78h] [xbp+78h]

  v2 = &rwlock->__align + 3;
  writer = rwlock->__writer;
  v4 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
  if ( writer == *(_DWORD *)(v4 + 0xD0) )
    return 35;
  _aarch64_ldset4_acq();
  lock = v15;
  p_writer_wakeup = &rwlock->__writer_wakeup;
  v18 = v15 & 2;
  v19 = 1;
  if ( (lock & 2) == 0 )
    goto LABEL_3;
  flags = rwlock->__flags;
  if ( flags )
  {
    v71 = lock;
    v80 = v18;
    _aarch64_ldadd4_relax();
    lock = v71;
    v18 = v80;
  }
  v24 = &rwlock->__writer_wakeup;
  v25 = 0;
  while ( 1 )
  {
    while ( !v18 )
    {
      v65 = lock;
      _aarch64_cas4_acq();
      lock = v26;
      if ( v26 == v65 )
      {
        if ( flags )
        {
          v72 = v26;
          _aarch64_ldadd4_relax();
          lock = v72;
        }
LABEL_17:
        p_writer_wakeup = &rwlock->__writer_wakeup;
        lock |= 2u;
        if ( v25 )
          v19 = 3;
        else
          v19 = 1;
        goto LABEL_3;
      }
LABEL_29:
      v18 = lock & 2;
    }
    while ( flags )
    {
      nr_readers = rwlock->__nr_readers;
      if ( (nr_readers & 0x80000000) == 0 )
        break;
      _aarch64_cas4_acq();
      if ( v54 == nr_readers )
      {
        lock = rwlock->__lock;
        goto LABEL_17;
      }
    }
    shared = rwlock->__shared;
    p_writer_wakeup = &rwlock->__writer_wakeup;
    if ( (*v24 & 0xFFFFFFFD) == 1 )
    {
      if ( *v24 == 3 )
        break;
      v66 = *v24;
      v76 = rwlock->__shared;
      _aarch64_cas4_relax();
      shared = v76;
      if ( v28 == v66 )
        break;
    }
    lock = rwlock->__lock;
    v18 = rwlock->__lock & 2;
  }
  v21 = _futex_abstimed_wait64(
          (char *)&rwlock->__align + 12,
          3u,
          0,
          0LL,
          (unsigned __int8)(shared != 0) << 7,
          v7,
          v8,
          v9,
          v10,
          v11,
          v12,
          v13,
          v14,
          v5,
          v6);
  if ( v21 != 110 && v21 != 75 )
  {
    lock = rwlock->__lock;
    v25 = 1;
    goto LABEL_29;
  }
  if ( !flags )
    return v21;
  v61 = &rwlock->__size[4];
  v62 = rwlock->__nr_readers;
  do
  {
    v75 = v62;
    v82 = v61;
    v86 = v21;
    _aarch64_cas4_acq();
    v5 = 2147483649LL;
    v61 = v82;
    v21 = v86;
    v62 = v63;
  }
  while ( v63 != v75 );
  if ( v63 != -2147483647 )
    return v21;
  lock = rwlock->__lock | 2;
  v19 = 3;
LABEL_3:
  *p_writer_wakeup = v19;
  if ( (lock & 1) != 0 )
    goto LABEL_7;
  while ( (lock & 0xFFFFFFF9) == 0 )
  {
    v64 = lock;
    _aarch64_cas4_acq();
    lock = v20;
    if ( v20 == v64 )
    {
      rwlock->__readers_wakeup = 1;
      goto LABEL_7;
    }
  }
  v30 = &rwlock->__align + 1;
  v31 = 0;
  while ( 1 )
  {
    while ( (*(_DWORD *)v30 & 0xFFFFFFFD) != 0 )
    {
      if ( v31 )
        goto LABEL_7;
      v52 = atomic_load((unsigned int *)rwlock);
      v31 = v52 & 1;
    }
    v32 = rwlock->__shared;
    if ( !*(_DWORD *)v30 )
    {
      v67 = v30;
      v77 = rwlock->__shared;
      _aarch64_cas4_relax();
      v30 = v67;
      v32 = v77;
      if ( v33 )
        continue;
    }
    v68 = v30;
    v34 = (v32 != 0) << 7;
    v35 = _futex_abstimed_wait64(v30, 2u, 0, 0LL, v34, v7, v8, v9, v10, v11, v12, v13, v14, v5, v30);
    v30 = v68;
    if ( v35 == 110 || v35 == 75 )
      break;
  }
  if ( rwlock->__flags && rwlock->__nr_readers )
  {
    v73 = rwlock->__nr_readers;
    v84 = v35;
    v87 = v30;
    _aarch64_swp4_relax();
    v55 = &rwlock->__size[4];
    v57 = v56;
    v30 = v87;
    v58 = v73;
    v21 = v84;
    while ( 1 )
    {
      v74 = v58;
      v81 = v55;
      v85 = v57;
      v88 = v21;
      v89 = v30;
      _aarch64_cas4_rel();
      v55 = v81;
      v30 = v89;
      v57 = v85;
      v21 = v88;
      if ( v59 == v74 )
        break;
      v58 = v59;
      if ( !v59 )
      {
        *p_writer_wakeup = v85;
        goto LABEL_42;
      }
    }
    if ( (v85 & 2) != 0 )
    {
      v60 = linux_eabi_syscall(
              __NR_futex,
              p_writer_wakeup,
              (void *)(v34 ^ 0x81u),
              (void *)1,
              0LL,
              (void *)v88,
              (void *)v85,
              v89);
      if ( v60 > 0xFFFFFFFFFFFFF000LL && (((_DWORD)v60 + 22) & 0xFFFFFFF7) != 0 )
        goto LABEL_51;
    }
  }
  else
  {
LABEL_42:
    if ( (rwlock->__lock & 1) == 0 )
    {
      v69 = v30;
      v78 = rwlock->__lock;
      _aarch64_swp4_relax();
      v30 = v69;
      v38 = v37;
      v39 = v78;
      while ( 1 )
      {
        v70 = v39;
        v79 = v38;
        v83 = v30;
        _aarch64_cas4_rel();
        v49 = v40;
        v30 = v83;
        v38 = v79;
        v39 = v40;
        if ( v40 == v70 )
          break;
        if ( (v40 & 1) != 0 )
        {
          *p_writer_wakeup = v79;
          goto LABEL_56;
        }
      }
      if ( (v79 & 2) == 0
        || (v50 = linux_eabi_syscall(
                    __NR_futex,
                    p_writer_wakeup,
                    (void *)(v34 ^ 0x81u),
                    (void *)1,
                    0LL,
                    (void *)v79,
                    (void *)v40,
                    v83),
            v50 <= 0xFFFFFFFFFFFFF000LL)
        || (((_DWORD)v50 + 22) & 0xFFFFFFF7) == 0 )
      {
        if ( (v49 & 4) == 0 )
          return 110;
        v51 = linux_eabi_syscall(
                __NR_futex,
                rwlock,
                (void *)(v34 ^ 0x81u),
                (void *)0x7FFFFFFF,
                0LL,
                (void *)v79,
                (void *)v49,
                v83);
        if ( v51 <= 0xFFFFFFFFFFFFF000LL || (((_DWORD)v51 + 22) & 0xFFFFFFF7) == 0 )
          return 110;
      }
LABEL_51:
      _libc_fatal(
        (__int64)"The futex facility returned an unexpected error code.\n",
        v41,
        v42,
        v43,
        v44,
        v45,
        v46,
        v47,
        v48);
    }
LABEL_56:
    __dmb(9u);
    while ( (*(_DWORD *)v30 & 0xFFFFFFFD) == 0 )
      ;
LABEL_7:
    *(_DWORD *)v2 = *(_DWORD *)(v4 + 0xD0);
    return 0;
  }
  return v21;
}
// 40D3C0: could not find valid save-restore pair for x23
// 40D3C0: could not find valid save-restore pair for x24
// 40D3C0: could not find valid save-restore pair for x25
// 40D3FC: variable 'v15' is possibly undefined
// 40D43C: variable 'v20' is possibly undefined
// 40D4C4: variable 'v26' is possibly undefined
// 40D538: variable 'v28' is possibly undefined
// 40D558: variable 'v7' is possibly undefined
// 40D558: variable 'v8' is possibly undefined
// 40D558: variable 'v9' is possibly undefined
// 40D558: variable 'v10' is possibly undefined
// 40D558: variable 'v11' is possibly undefined
// 40D558: variable 'v12' is possibly undefined
// 40D558: variable 'v13' is possibly undefined
// 40D558: variable 'v14' is possibly undefined
// 40D558: variable 'v5' is possibly undefined
// 40D558: variable 'v6' is possibly undefined
// 40D5D0: variable 'v33' is possibly undefined
// 40D648: variable 'v37' is possibly undefined
// 40D674: variable 'v40' is possibly undefined
// 40D700: variable 'v41' is possibly undefined
// 40D700: variable 'v42' is possibly undefined
// 40D700: variable 'v43' is possibly undefined
// 40D700: variable 'v44' is possibly undefined
// 40D700: variable 'v45' is possibly undefined
// 40D700: variable 'v46' is possibly undefined
// 40D700: variable 'v47' is possibly undefined
// 40D700: variable 'v48' is possibly undefined
// 40D774: variable 'v54' is possibly undefined
// 40D7B8: variable 'v56' is possibly undefined
// 40D800: variable 'v59' is possibly undefined
// 40D89C: variable 'v63' is possibly undefined

//----- (000000000040D8E0) ----------------------------------------------------
__int64 __fastcall pthread_sigmask(int a1, const sigset_t *a2, sigset_t *a3)
{
  const sigset_t *v3; // x3
  unsigned __int64 v4; // x3
  unsigned int v5; // w0
  __int128 v7; // q25
  __int128 v8; // q26
  __int128 v9; // q27
  __int128 v10; // q28
  __int128 v11; // q29
  __int128 v12; // q30
  __int128 v13; // q31
  unsigned int v14; // w0
  sigset_t v15; // [xsp+0h] [xbp-80h] BYREF

  v3 = 0LL;
  if ( !a2 )
    goto LABEL_4;
  v4 = a2->__val[0];
  if ( (a2->__val[0] & 0x180000000LL) == 0 )
  {
    v3 = a2;
LABEL_4:
    v5 = linux_eabi_syscall(__NR_rt_sigprocmask, a1, v3, a3);
    if ( v5 > 0xFFFFF000 )
      return -v5;
    else
      return 0LL;
  }
  v7 = *(_OWORD *)&a2->__val[2];
  v8 = *(_OWORD *)&a2->__val[4];
  v9 = *(_OWORD *)&a2->__val[6];
  v10 = *(_OWORD *)&a2->__val[8];
  v11 = *(_OWORD *)&a2->__val[10];
  v12 = *(_OWORD *)&a2->__val[12];
  v13 = *(_OWORD *)&a2->__val[14];
  v15.__val[1] = a2->__val[1];
  *(_OWORD *)&v15.__val[2] = v7;
  v15.__val[0] = v4 & 0xFFFFFFFE7FFFFFFFLL;
  *(_OWORD *)&v15.__val[4] = v8;
  *(_OWORD *)&v15.__val[6] = v9;
  *(_OWORD *)&v15.__val[8] = v10;
  *(_OWORD *)&v15.__val[10] = v11;
  *(_OWORD *)&v15.__val[12] = v12;
  *(_OWORD *)&v15.__val[14] = v13;
  v14 = linux_eabi_syscall(__NR_rt_sigprocmask, a1, &v15, a3);
  if ( v14 > 0xFFFFF000 )
    return -v14;
  else
    return 0LL;
}

//----- (000000000040D980) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_mmap_threshold(__int64 *a1)
{
  __int64 result; // x0

  qword_4905E8 = *a1;
  result = 1LL;
  dword_490620 = 1;
  return result;
}
// 4905E8: using guessed type __int64 qword_4905E8;
// 490620: using guessed type int dword_490620;

//----- (000000000040D9A0) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_mmaps_max(_QWORD *a1)
{
  __int64 result; // x0

  dword_490618 = *a1;
  result = 1LL;
  dword_490620 = 1;
  return result;
}
// 490618: using guessed type int dword_490618;
// 490620: using guessed type int dword_490620;

//----- (000000000040D9C0) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_top_pad(__int64 *a1)
{
  __int64 result; // x0

  qword_4905E0 = *a1;
  result = 1LL;
  dword_490620 = 1;
  return result;
}
// 4905E0: using guessed type __int64 qword_4905E0;
// 490620: using guessed type int dword_490620;

//----- (000000000040D9E0) ----------------------------------------------------
void *__fastcall dl_tunable_set_perturb_byte(__int64 *a1)
{
  __int64 v1; // x1
  void *result; // x0

  v1 = *a1;
  result = &unk_496000;
  perturb_byte = v1;
  return result;
}
// 496B00: using guessed type int perturb_byte;

//----- (000000000040D9F0) ----------------------------------------------------
__int64 __fastcall dl_tunable_set_trim_threshold(__int64 *a1)
{
  __int64 result; // x0

  mp_ = *a1;
  result = 1LL;
  dword_490620 = 1;
  return result;
}
// 4905D8: using guessed type __int64 mp_;
// 490620: using guessed type int dword_490620;

//----- (000000000040DA0C) ----------------------------------------------------
__int64 (__fastcall **__fastcall dl_tunable_set_arena_max(__int64 *a1))()
{
  __int64 v1; // x1
  __int64 (__fastcall **result)(); // x0

  v1 = *a1;
  result = off_490000;
  qword_4905F8 = v1;
  return result;
}
// 490000: using guessed type __int64 (__fastcall *off_490000[5])();
// 4905F8: using guessed type __int64 qword_4905F8;

//----- (000000000040DA20) ----------------------------------------------------
__int64 (__fastcall **__fastcall dl_tunable_set_arena_test(__int64 *a1))()
{
  __int64 v1; // x1
  __int64 (__fastcall **result)(); // x0

  v1 = *a1;
  result = off_490000;
  qword_4905F0 = v1;
  return result;
}
// 490000: using guessed type __int64 (__fastcall *off_490000[5])();
// 4905F0: using guessed type __int64 qword_4905F0;

//----- (000000000040DA30) ----------------------------------------------------
unsigned __int64 __fastcall dl_tunable_set_tcache_max(unsigned __int64 result)
{
  __int64 v1; // x1

  v1 = *(_QWORD *)result;
  if ( *(_QWORD *)result <= 0x408uLL )
  {
    result = ((((v1 + 23) & 0xFFFFFFFFFFFFFFF0LL) - 17) >> 4) + 1;
    if ( (unsigned __int64)(v1 + 23) <= 0x1F )
      result = 1LL;
    qword_490640 = result;
    unk_490648 = v1;
  }
  return result;
}
// 490640: using guessed type __int64 qword_490640;

//----- (000000000040DA6C) ----------------------------------------------------
unsigned __int64 __fastcall dl_tunable_set_tcache_count(unsigned __int64 *a1)
{
  unsigned __int64 result; // x0

  result = *a1;
  if ( result <= 0xFFFF )
    qword_490650 = result;
  return result;
}
// 490650: using guessed type __int64 qword_490650;

//----- (000000000040DA8C) ----------------------------------------------------
__int64 (__fastcall **__fastcall dl_tunable_set_tcache_unsorted_limit(__int64 *a1))()
{
  __int64 v1; // x1
  __int64 (__fastcall **result)(); // x0

  v1 = *a1;
  result = off_490000;
  qword_490658 = v1;
  return result;
}
// 490000: using guessed type __int64 (__fastcall *off_490000[5])();
// 490658: using guessed type __int64 qword_490658;

//----- (000000000040DAA0) ----------------------------------------------------
unsigned __int64 __fastcall dl_tunable_set_mxfast(unsigned __int64 *a1)
{
  unsigned __int64 result; // x0

  result = *a1;
  if ( result <= 0xA0 )
  {
    if ( result <= 7 )
      result = 16LL;
    else
      result = (unsigned __int8)(result + 8) & 0xF0;
    global_max_fast = result;
  }
  return result;
}
// 496B04: using guessed type char global_max_fast;

//----- (000000000040DAD0) ----------------------------------------------------
void __fastcall __noreturn malloc_printerr(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  _libc_message_impl((unsigned __int8 *)"%s\n", a2, a3, a4, a5, a6, a7, a8, a9, a1);
}
// 40DAE8: using guessed type __int64 tcache_double_free_verify(void);

//----- (000000000040DAE8) ----------------------------------------------------
_QWORD *__fastcall tcache_double_free_verify(
        _QWORD *result,
        __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  unsigned __int64 v10; // x1
  __int64 v11; // x2
  __int64 v12; // x3
  unsigned __int64 v13; // x4

  v10 = *(_QWORD *)(*(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 48) + 8 * (a2 + 16));
  if ( v10 )
  {
    v11 = 0LL;
    do
    {
      if ( qword_490650 == v11 )
        malloc_printerr((__int64)"free(): too many chunks detected in tcache", a3, a4, a5, a6, a7, a8, a9, a10);
      if ( (v10 & 0xF) != 0 )
        malloc_printerr((__int64)"free(): unaligned chunk detected in tcache 2", a3, a4, a5, a6, a7, a8, a9, a10);
      if ( (_QWORD *)v10 == result )
        malloc_printerr((__int64)"free(): double free detected in tcache 2", a3, a4, a5, a6, a7, a8, a9, a10);
      v12 = *(_QWORD *)v10;
      v13 = v10 >> 12;
      ++v11;
      v10 = (v10 >> 12) ^ *(_QWORD *)v10;
    }
    while ( v13 != v12 );
  }
  return result;
}
// 40DB80: using guessed type __int64 int_mallinfo(void);
// 490650: using guessed type __int64 qword_490650;

//----- (000000000040DB80) ----------------------------------------------------
__int64 __fastcall int_mallinfo(
        __int64 result,
        __int64 *a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  unsigned __int64 *v10; // x5
  unsigned __int64 *v11; // x6
  int v12; // w7
  __int64 v13; // x8
  unsigned __int64 v14; // x2
  __int64 v15; // x4
  unsigned __int64 v16; // x3
  int v17; // w4
  unsigned __int64 v18; // x10
  __int64 v19; // x5
  unsigned __int64 *i; // x2
  unsigned __int64 v21; // x3
  __int64 v22; // x7
  __int64 v23; // x6
  __int64 v24; // x3

  v10 = (unsigned __int64 *)(result + 16);
  v11 = (unsigned __int64 *)(result + 96);
  v12 = 0;
  v13 = 0LL;
  do
  {
    v14 = *v10;
    if ( *v10 )
    {
      do
      {
        if ( (v14 & 0xF) != 0 )
          malloc_printerr((__int64)"int_mallinfo(): unaligned fastbin chunk detected", a3, a4, a5, a6, a7, a8, a9, a10);
        v15 = *(_QWORD *)(v14 + 16);
        ++v12;
        v13 += *(_QWORD *)(v14 + 8) & 0xFFFFFFFFFFFFFFF8LL;
        v16 = v14 + 16;
        v14 = v15 ^ ((v14 + 16) >> 12);
      }
      while ( v15 != v16 >> 12 );
    }
    ++v10;
  }
  while ( v10 != v11 );
  v17 = 1;
  v18 = *(_QWORD *)(*(_QWORD *)(result + 96) + 8LL) & 0xFFFFFFFFFFFFFFF8LL;
  v19 = v18 + v13;
  do
  {
    for ( i = (unsigned __int64 *)v11[3]; i != v11; v19 += v21 & 0xFFFFFFFFFFFFFFF8LL )
    {
      v21 = i[1];
      ++v17;
      i = (unsigned __int64 *)i[3];
    }
    v11 += 2;
  }
  while ( (unsigned __int64 *)(result + 2128) != v11 );
  v22 = a2[2] + v12;
  v23 = *a2;
  a2[1] += v17;
  a2[2] = v22;
  a2[8] += v19;
  v24 = a2[6];
  a2[7] = a2[7] + *(_QWORD *)(result + 2184) - v19;
  *a2 = v23 + *(_QWORD *)(result + 2184);
  a2[6] = v24 + v13;
  if ( (int *)result == &main_arena )
  {
    result = qword_490628;
    a2[3] = dword_490614;
    a2[4] = result;
    a2[5] = 0LL;
    a2[9] = v18;
  }
  return result;
}
// 490614: using guessed type int dword_490614;
// 490628: using guessed type __int64 qword_490628;
// 490670: using guessed type int main_arena;

//----- (000000000040DCB0) ----------------------------------------------------
int8x16_t *(__fastcall *alloc_perturb())(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3)
{
  int8x16_t *(__fastcall *result)(int8x16_t *, unsigned __int8, unsigned __int64); // x0

  if ( perturb_byte )
    return memset();
  return result;
}
// 496B00: using guessed type int perturb_byte;

//----- (000000000040DCCC) ----------------------------------------------------
unsigned __int64 __fastcall munmap_chunk(
        _QWORD *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v9; // x19
  unsigned __int64 v10; // x21
  size_t v11; // x19

  v9 = a1[1];
  if ( (v9 & 2) == 0 )
    _libc_assert_fail((__int64)"chunk_is_mmapped (p)", (__int64)"malloc.c", 0xBD6u, (__int64)"munmap_chunk");
  v10 = (unsigned __int64)a1 - *a1;
  v11 = (v9 & 0xFFFFFFFFFFFFFFF8LL) + *a1;
  if ( (v10 | v11) & (dl_pagesize - 1) | (((unsigned __int64)(a1 + 2) & (dl_pagesize - 1)) - 1) & (unsigned __int64)(a1 + 2) & (dl_pagesize - 1) )
    malloc_printerr((__int64)"munmap_chunk(): invalid pointer", a2, a3, a4, a5, a6, a7, a8, a9);
  _aarch64_ldadd4_relax();
  _aarch64_ldadd8_relax();
  return munmap((void *)v10, v11);
}
// 490F10: using guessed type __int64 dl_pagesize;

//----- (000000000040DD88) ----------------------------------------------------
void __noreturn detach_arena_part_0()
{
  _libc_assert_fail(
    (__int64)"replaced_arena->attached_threads > 0",
    (__int64)"arena.c",
    0x26Du,
    (__int64)"detach_arena");
}

//----- (000000000040DDB0) ----------------------------------------------------
unsigned __int64 __fastcall dl_tunable_set_hugetlb(unsigned __int64 *a1)
{
  unsigned __int64 result; // x0

  result = *a1;
  if ( result == 1 )
  {
    result = _malloc_thp_mode();
    if ( (_DWORD)result == 1 )
    {
      result = _malloc_default_thp_pagesize();
      qword_490600 = result;
    }
  }
  else if ( result > 1 )
  {
    if ( result == 2 )
      result = 0LL;
    return _malloc_hugepage_config(result, (unsigned __int64 *)&qword_490608, (unsigned int *)&dword_490610);
  }
  return result;
}
// 490600: using guessed type __int64 qword_490600;
// 490608: using guessed type __int64 qword_490608;
// 490610: using guessed type int dword_490610;

//----- (000000000040DE0C) ----------------------------------------------------
__int64 __fastcall _malloc_info_part_0(__int64 a1)
{
  char *v1; // x21
  int *v2; // x22
  __int64 v4; // x1
  __int64 v5; // x2
  __int64 v6; // x3
  void *v7; // x4
  void *v8; // x5
  void *v9; // x6
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7
  int v18; // w0
  __int64 v19; // x1
  unsigned __int64 *v20; // x5
  int *v21; // x13
  char *v22; // x4
  __int64 v23; // x10
  __int64 v24; // x8
  __int64 v25; // x11
  __int64 v26; // x6
  __int64 v27; // x0
  unsigned __int64 v28; // x8
  char *v29; // x7
  __int64 v30; // x9
  __int64 v31; // x2
  __int64 v32; // x0
  __int64 v33; // x26
  __int64 v34; // x24
  __int64 v35; // x25
  __int64 v36; // x1
  __int64 v37; // x2
  __int64 v38; // x3
  void *v39; // x4
  void *v40; // x5
  void *v41; // x6
  unsigned __int64 v42; // x8
  __int64 v43; // x10
  __int64 v44; // x9
  __int64 v45; // x11
  int v46; // w0
  __int64 v47; // x27
  __int64 *v48; // x22
  __int64 v49; // x28
  __int64 v50; // x21
  __int64 v51; // x5
  __int64 v53; // x2
  __int64 v54; // x3
  __int64 v55; // x4
  __int64 v56; // x11
  __int64 v57; // x8
  __int64 v58; // x9
  __int64 v59; // x10
  __int64 v60; // x6
  __int64 v61; // x7
  unsigned __int64 v63; // x0
  __int64 v64; // x2
  unsigned __int64 v65; // x3
  __int64 v66; // x0
  __int64 v67; // x5
  unsigned __int64 v68; // x4
  unsigned __int64 v69; // x3
  __int64 v70; // x6
  unsigned __int64 v71; // x0
  __int64 v72; // x0
  __int64 v73; // x0
  _QWORD *v74; // x1
  __int64 v75; // x0
  __int64 v76; // x2
  __int64 v77; // x0
  unsigned int v78; // [xsp+84h] [xbp-118Ch]
  __int64 v79; // [xsp+90h] [xbp-1180h]
  __int64 v80; // [xsp+98h] [xbp-1178h]
  __int64 v81; // [xsp+A0h] [xbp-1170h]
  __int64 v82; // [xsp+A8h] [xbp-1168h]
  __int64 v83; // [xsp+B0h] [xbp-1160h]
  __int64 v84; // [xsp+B8h] [xbp-1158h]
  __int64 v85; // [xsp+C0h] [xbp-1150h]
  __int64 v86; // [xsp+C8h] [xbp-1148h]
  unsigned __int64 v87; // [xsp+D0h] [xbp-1140h]
  int *v88; // [xsp+D0h] [xbp-1140h]
  __int64 v89; // [xsp+D8h] [xbp-1138h]
  unsigned __int64 v90; // [xsp+D8h] [xbp-1138h]
  __int64 v91; // [xsp+E0h] [xbp-1130h]
  __int64 v92; // [xsp+E0h] [xbp-1130h]
  __int64 v93; // [xsp+E8h] [xbp-1128h]
  char *v94; // [xsp+E8h] [xbp-1128h]
  char v95; // [xsp+F0h] [xbp-1120h] BYREF
  size_t v96; // [xsp+230h] [xbp-FE0h]
  size_t v97; // [xsp+238h] [xbp-FD8h]
  size_t v98; // [xsp+240h] [xbp-FD0h]
  size_t v99; // [xsp+248h] [xbp-FC8h]

  v1 = &v95;
  v2 = &main_arena;
  v78 = 0;
  v79 = 0LL;
  v80 = 0LL;
  v81 = 0LL;
  v82 = 0LL;
  v83 = 0LL;
  v84 = 0LL;
  v85 = 0LL;
  v86 = 0LL;
  do
  {
    fprintf(a1, (__int64)"<heap nr=\"%d\">\n<sizes>\n", v78);
    _aarch64_cas4_acq();
    if ( v18 )
      _lll_lock_wait_private(v2, v10, v11, v12, v13, v14, v15, v16, v17, v4, v5, v6, v7, v8, v9);
    v19 = *((_QWORD *)v2 + 12);
    v20 = (unsigned __int64 *)(v2 + 4);
    v21 = v2 + 24;
    v22 = v1;
    v23 = 0LL;
    v24 = *(_QWORD *)(v19 + 8);
    v25 = 0LL;
    do
    {
      if ( *v20 )
      {
        v63 = *v20;
        v26 = 0LL;
        do
        {
          if ( (v63 & 0xF) != 0 )
            malloc_printerr(
              (__int64)"__malloc_info(): unaligned fastbin chunk detected",
              v10,
              v11,
              v12,
              v13,
              v14,
              v15,
              v16,
              v17);
          v64 = *(_QWORD *)(v63 + 16);
          v65 = v63 + 16;
          ++v26;
          v63 = v64 ^ ((v63 + 16) >> 12);
        }
        while ( v64 != v65 >> 12 );
        v66 = *(_QWORD *)(*v20 + 8);
        v23 += v26;
        *((_QWORD *)v22 + 3) = v26;
        v66 &= 0xFFFFFFFFFFFFFFF8LL;
        *(_QWORD *)v22 = v66 - 15;
        *((_QWORD *)v22 + 1) = v66;
        v25 += v66 * v26;
      }
      else
      {
        v26 = 0LL;
        *(_QWORD *)v22 = 0LL;
        *((_QWORD *)v22 + 1) = 0LL;
        *((_QWORD *)v22 + 3) = 0LL;
      }
      v27 = *((_QWORD *)v22 + 1);
      ++v20;
      v22 += 32;
      *((_QWORD *)v22 - 2) = v27 * v26;
    }
    while ( v21 != (int *)v20 );
    v28 = v24 & 0xFFFFFFFFFFFFFFF8LL;
    v29 = v1 + 320;
    v30 = 1LL;
    ++v78;
    do
    {
      v31 = *((_QWORD *)v21 + 2);
      *((_QWORD *)v29 + 3) = 0LL;
      *(_OWORD *)(v29 + 8) = 0uLL;
      if ( !v31 || (int *)v31 == v21 )
        goto LABEL_10;
      v67 = 1LL;
      v68 = 0LL;
      v69 = -1LL;
      v70 = 0LL;
      do
      {
        v71 = *(_QWORD *)(v31 + 8);
        v31 = *(_QWORD *)(v31 + 16);
        v70 += v71;
        if ( v69 > v71 )
          v69 = v71;
        if ( v68 < v71 )
          v68 = v71;
        v72 = v67++;
      }
      while ( (int *)v31 != v21 );
      *(_QWORD *)v29 = v69;
      *((_QWORD *)v29 + 1) = v68;
      v30 += v72;
      *((_QWORD *)v29 + 2) = v70;
      *((_QWORD *)v29 + 3) = v72;
      if ( !v72 )
LABEL_10:
        *(_QWORD *)v29 = 0LL;
      v32 = *((_QWORD *)v29 + 2);
      v29 += 32;
      v21 += 4;
      v28 += v32;
    }
    while ( v1 + 4384 != v29 );
    if ( v2 == &main_arena )
    {
      v33 = 0LL;
      v34 = 0LL;
      v35 = 0LL;
    }
    else
    {
      v33 = 0LL;
      v34 = 0LL;
      v35 = 0LL;
      v73 = -4 * qword_490608;
      if ( !qword_490608 )
        v73 = -67108864LL;
      v74 = (_QWORD *)(v19 & v73);
      do
      {
        v76 = v74[2];
        v75 = v74[3];
        ++v33;
        v74 = (_QWORD *)v74[1];
        v35 += v76;
        v34 += v75;
      }
      while ( v74 );
    }
    v87 = v28;
    v89 = v23;
    v91 = v25;
    v93 = v30;
    _aarch64_swp4_rel();
    v42 = v87;
    v43 = v89;
    v45 = v91;
    v44 = v93;
    if ( v46 > 1 )
    {
      _lll_lock_wake_private(v2, v36, v37, v38, v39, v40, v41);
      v42 = v87;
      v43 = v89;
      v45 = v91;
      v44 = v93;
    }
    v47 = v45;
    v79 += v43;
    v88 = v2;
    v90 = v42;
    v48 = (__int64 *)v1;
    v81 += v45;
    v49 = v44;
    v92 = v43;
    v94 = v1;
    v50 = 0LL;
    v82 += v44;
    v80 += v42;
    do
    {
      while ( 1 )
      {
        v51 = v48[3];
        if ( v51 && v50 != 10 )
          break;
        ++v50;
        v48 += 4;
        if ( v50 == 137 )
          goto LABEL_23;
      }
      v53 = *v48;
      v54 = v48[1];
      v55 = v48[2];
      ++v50;
      v48 += 4;
      fprintf(a1, (__int64)"  <size from=\"%zu\" to=\"%zu\" total=\"%zu\" count=\"%zu\"/>\n", v53, v54, v55, v51);
    }
    while ( v50 != 137 );
LABEL_23:
    v56 = v47;
    v57 = v90;
    v58 = v49;
    v59 = v92;
    v1 = v94;
    if ( v99 )
    {
      fprintf(a1, (__int64)"  <unsorted from=\"%zu\" to=\"%zu\" total=\"%zu\" count=\"%zu\"/>\n", v96, v97, v98, v99);
      v57 = v90;
      v59 = v92;
      v56 = v47;
      v58 = v49;
    }
    v60 = *((_QWORD *)v88 + 273);
    v61 = *((_QWORD *)v88 + 274);
    v83 += v60;
    v84 += v61;
    fprintf(
      a1,
      (__int64)"</sizes>\n"
               "<total type=\"fast\" count=\"%zu\" size=\"%zu\"/>\n"
               "<total type=\"rest\" count=\"%zu\" size=\"%zu\"/>\n"
               "<system type=\"current\" size=\"%zu\"/>\n"
               "<system type=\"max\" size=\"%zu\"/>\n",
      v59,
      v56,
      v58,
      v57,
      v60,
      v61);
    if ( v88 == &main_arena )
    {
      fprintf(
        a1,
        (__int64)"<aspace type=\"total\" size=\"%zu\"/>\n<aspace type=\"mprotect\" size=\"%zu\"/>\n",
        *((_QWORD *)v88 + 273),
        *((_QWORD *)v88 + 273));
      v77 = *((_QWORD *)v88 + 273);
      v85 += v77;
      v86 += v77;
    }
    else
    {
      fprintf(
        a1,
        (__int64)"<aspace type=\"total\" size=\"%zu\"/>\n"
                 "<aspace type=\"mprotect\" size=\"%zu\"/>\n"
                 "<aspace type=\"subheaps\" size=\"%zu\"/>\n",
        v35,
        v34,
        v33);
      v85 += v35;
      v86 += v34;
    }
    fputs((__int64)"</heap>\n", a1);
    v2 = (int *)*((_QWORD *)v88 + 270);
  }
  while ( v2 != &main_arena );
  fprintf(
    a1,
    (__int64)"<total type=\"fast\" count=\"%zu\" size=\"%zu\"/>\n"
             "<total type=\"rest\" count=\"%zu\" size=\"%zu\"/>\n"
             "<total type=\"mmap\" count=\"%d\" size=\"%zu\"/>\n"
             "<system type=\"current\" size=\"%zu\"/>\n"
             "<system type=\"max\" size=\"%zu\"/>\n"
             "<aspace type=\"total\" size=\"%zu\"/>\n"
             "<aspace type=\"mprotect\" size=\"%zu\"/>\n"
             "</malloc>\n",
    v79,
    v81,
    v82,
    v80,
    dword_490614,
    qword_490628,
    v83,
    v84,
    v85,
    v86);
  return 0LL;
}
// 40DE98: variable 'v18' is possibly undefined
// 40E224: variable 'v10' is possibly undefined
// 40E224: variable 'v11' is possibly undefined
// 40E224: variable 'v12' is possibly undefined
// 40E224: variable 'v13' is possibly undefined
// 40E224: variable 'v14' is possibly undefined
// 40E224: variable 'v15' is possibly undefined
// 40E224: variable 'v16' is possibly undefined
// 40E224: variable 'v17' is possibly undefined
// 40E224: variable 'v4' is possibly undefined
// 40E224: variable 'v5' is possibly undefined
// 40E224: variable 'v6' is possibly undefined
// 40E224: variable 'v7' is possibly undefined
// 40E224: variable 'v8' is possibly undefined
// 40E224: variable 'v9' is possibly undefined
// 40DF74: variable 'v46' is possibly undefined
// 40E298: variable 'v36' is possibly undefined
// 40E298: variable 'v37' is possibly undefined
// 40E298: variable 'v38' is possibly undefined
// 40E298: variable 'v39' is possibly undefined
// 40E298: variable 'v40' is possibly undefined
// 40E298: variable 'v41' is possibly undefined
// 490608: using guessed type __int64 qword_490608;
// 490614: using guessed type int dword_490614;
// 490628: using guessed type __int64 qword_490628;
// 490670: using guessed type int main_arena;

//----- (000000000040E2A8) ----------------------------------------------------
_QWORD *__fastcall unlink_chunk_isra_0(
        _QWORD *result,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  unsigned __int64 v9; // x3
  _QWORD *v10; // x1
  __int64 v11; // x2
  __int64 v12; // x2
  __int64 v13; // x3

  v9 = result[1];
  if ( (v9 & 0xFFFFFFFFFFFFFFF8LL) != *(_QWORD *)((char *)result + (v9 & 0xFFFFFFFFFFFFFFF8LL)) )
    malloc_printerr((__int64)"corrupted size vs. prev_size", a2, a3, a4, a5, a6, a7, a8, a9);
  v10 = (_QWORD *)result[2];
  if ( result != (_QWORD *)v10[3] || (v11 = result[3], result != *(_QWORD **)(v11 + 16)) )
    malloc_printerr((__int64)"corrupted double-linked list", a2, a3, a4, a5, a6, a7, a8, a9);
  v10[3] = v11;
  *(_QWORD *)(v11 + 16) = v10;
  if ( v9 > 0x3FF )
  {
    v12 = result[4];
    if ( v12 )
    {
      if ( result != *(_QWORD **)(v12 + 40) || (v13 = result[5], result != *(_QWORD **)(v13 + 32)) )
        malloc_printerr((__int64)"corrupted double-linked list (not small)", a2, a3, a4, a5, a6, a7, a8, a9);
      if ( v10[4] )
      {
        *(_QWORD *)(v12 + 40) = v13;
        *(_QWORD *)(v13 + 32) = v12;
      }
      else if ( result == (_QWORD *)v12 )
      {
        v10[4] = v10;
        v10[5] = v10;
      }
      else
      {
        v10[4] = v12;
        v10[5] = v13;
        *(_QWORD *)(v12 + 40) = v10;
        result = (_QWORD *)result[5];
        result[4] = v10;
      }
    }
  }
  return result;
}
// 40E380: using guessed type __int64 malloc_consolidate(void);

//----- (000000000040E380) ----------------------------------------------------
void __fastcall malloc_consolidate(__int64 a1)
{
  __int64 v1; // x20
  __int64 v2; // x21
  __int64 v3; // x22
  __int64 v4; // x23
  __int64 v5; // x24
  __int64 v7; // x28
  __int64 v8; // x27
  _QWORD *v9; // x0
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7
  _QWORD *v18; // x19
  _QWORD *v19; // x21
  unsigned __int64 v20; // x2
  unsigned __int64 v21; // x20
  unsigned __int64 v22; // x25
  unsigned __int64 v23; // x2
  __int64 v24; // x2
  __int64 v25; // x3
  _QWORD *v26; // x22
  __int64 v27; // x24
  __int64 v28; // x23
  __int64 v29; // [xsp+18h] [xbp+18h]
  __int64 v30; // [xsp+20h] [xbp+20h]
  __int64 v31; // [xsp+28h] [xbp+28h]
  __int64 v32; // [xsp+30h] [xbp+30h]
  __int64 v33; // [xsp+38h] [xbp+38h]

  *(_DWORD *)(a1 + 8) = 0;
  v7 = a1 + 96;
  v8 = a1 + 16;
  do
  {
    _aarch64_swp8_acq();
    if ( !v9 )
      goto LABEL_3;
    v29 = v1;
    v18 = v9;
    v30 = v2;
    v31 = v3;
    v32 = v4;
    v33 = v5;
    do
    {
      while ( 1 )
      {
        if ( ((unsigned __int8)v18 & 0xF) != 0 )
          malloc_printerr(
            (__int64)"malloc_consolidate(): unaligned fastbin chunk detected",
            v10,
            v11,
            v12,
            v13,
            v14,
            v15,
            v16,
            v17);
        v25 = v18[1];
        if ( v8 != a1 + 8 * (((unsigned int)v25 >> 4) - 2 + 2LL) )
          malloc_printerr((__int64)"malloc_consolidate(): invalid chunk size", v10, v11, v12, v13, v14, v15, v16, v17);
        v21 = v25 & 0xFFFFFFFFFFFFFFF8LL;
        v26 = (_QWORD *)((char *)v18 + (v25 & 0xFFFFFFFFFFFFFFF8LL));
        v27 = v18[2];
        v28 = v26[1];
        if ( (v25 & 1) == 0 )
          break;
        v19 = v18;
        v23 = v28 & 0xFFFFFFFFFFFFFFF8LL;
        v22 = (unsigned __int64)(v18 + 2) >> 12;
        v18 = (_QWORD *)(v27 ^ v22);
        if ( *(_QWORD **)(a1 + 96) != v26 )
          goto LABEL_8;
LABEL_17:
        v19[1] = (v21 + v23) | 1;
        *(_QWORD *)(a1 + 96) = v19;
        if ( v22 == v27 )
          goto LABEL_18;
      }
      v19 = (_QWORD *)((char *)v18 - *v18);
      v20 = v19[1] & 0xFFFFFFFFFFFFFFF8LL;
      if ( v20 != *v18 )
        malloc_printerr((__int64)"corrupted size vs. prev_size in fastbins", v10, v11, v12, v13, v14, v15, v16, v17);
      v21 += v20;
      unlink_chunk_isra_0((_QWORD *)((char *)v18 - *v18), v10, v11, v12, v13, v14, v15, v16, v17);
      v22 = (unsigned __int64)(v18 + 2) >> 12;
      v23 = v28 & 0xFFFFFFFFFFFFFFF8LL;
      v18 = (_QWORD *)(v27 ^ v22);
      if ( *(_QWORD **)(a1 + 96) == v26 )
        goto LABEL_17;
LABEL_8:
      if ( (*(_QWORD *)((char *)v26 + v23 + 8) & 1) != 0 )
      {
        v26[1] = v28 & 0xFFFFFFFFFFFFFFFELL;
      }
      else
      {
        v21 += v23;
        unlink_chunk_isra_0(v26, v10, v11, v12, v13, v14, v15, v16, v17);
      }
      v24 = *(_QWORD *)(v7 + 16);
      *(_QWORD *)(v7 + 16) = v19;
      *(_QWORD *)(v24 + 24) = v19;
      if ( v21 > 0x3FF )
      {
        v19[4] = 0LL;
        v19[5] = 0LL;
      }
      v19[1] = v21 | 1;
      v19[2] = v24;
      v19[3] = v7;
      *(_QWORD *)((char *)v19 + v21) = v21;
    }
    while ( v22 != v27 );
LABEL_18:
    v1 = v29;
    v2 = v30;
    v3 = v31;
    v4 = v32;
    v5 = v33;
LABEL_3:
    v8 += 8LL;
  }
  while ( v7 != v8 );
}
// 40E380: could not find valid save-restore pair for x20
// 40E380: could not find valid save-restore pair for x21
// 40E380: could not find valid save-restore pair for x22
// 40E380: could not find valid save-restore pair for x23
// 40E380: could not find valid save-restore pair for x24
// 40E3B0: variable 'v9' is possibly undefined
// 40E3D0: variable 'v1' is possibly undefined
// 40E3D8: variable 'v2' is possibly undefined
// 40E3D8: variable 'v3' is possibly undefined
// 40E3DC: variable 'v4' is possibly undefined
// 40E3DC: variable 'v5' is possibly undefined
// 40E404: variable 'v10' is possibly undefined
// 40E404: variable 'v11' is possibly undefined
// 40E404: variable 'v12' is possibly undefined
// 40E404: variable 'v13' is possibly undefined
// 40E404: variable 'v14' is possibly undefined
// 40E404: variable 'v15' is possibly undefined
// 40E404: variable 'v16' is possibly undefined
// 40E404: variable 'v17' is possibly undefined
// 40E520: using guessed type __int64 int_free_create_chunk(void);

//----- (000000000040E520) ----------------------------------------------------
unsigned __int64 __fastcall int_free_create_chunk(
        __int64 a1,
        _QWORD *a2,
        unsigned __int64 a3,
        _QWORD *a4,
        __int64 a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13)
{
  __int64 v13; // x5
  unsigned __int64 result; // x0
  __int64 v15; // x3
  unsigned __int64 v16; // x6
  __int64 *v17; // x2
  __int64 *v18; // x2
  __int64 v19; // x3
  __int64 v20; // t1
  _QWORD *v22; // [xsp+18h] [xbp-18h]

  v13 = a1;
  if ( *(_QWORD **)(a1 + 96) == a4 )
  {
    result = a3 + a5;
    a2[1] = (a3 + a5) | 1;
    *(_QWORD *)(v13 + 96) = a2;
    return result;
  }
  if ( (*(_QWORD *)((char *)a4 + a5 + 8) & 1) != 0 )
  {
    a4[1] &= ~1uLL;
    result = a3;
    if ( a3 > 0x3FF )
    {
LABEL_4:
      v15 = *(_QWORD *)(v13 + 112);
      if ( *(_QWORD *)(v15 + 24) != v13 + 96 )
        malloc_printerr((__int64)"free(): corrupted unsorted chunks", a6, a7, a8, a9, a10, a11, a12, a13);
      a2[2] = v15;
      a2[3] = v13 + 96;
      a2[4] = 0LL;
      a2[5] = 0LL;
      *(_QWORD *)(v13 + 112) = a2;
      *(_QWORD *)(v15 + 24) = a2;
      a2[1] = result | 1;
      *(_QWORD *)((char *)a2 + result) = result;
      return result;
    }
  }
  else
  {
    v22 = a2;
    unlink_chunk_isra_0(a4, a6, a7, a8, a9, a10, a11, a12, a13);
    v13 = a1;
    a2 = v22;
    result = a3 + a5;
    if ( a3 + a5 > 0x3FF )
      goto LABEL_4;
  }
  v16 = (unsigned int)result >> 4;
  v17 = (__int64 *)(v13 + 8LL * (unsigned int)(2 * v16 + 12));
  v20 = *v17;
  v18 = v17 - 2;
  v19 = v20;
  if ( *(__int64 **)(v20 + 24) != v18 )
    malloc_printerr((__int64)"free(): chunks in smallbin corrupted", a6, a7, a8, a9, a10, a11, a12, a13);
  *(_DWORD *)(v13 + 4 * ((v16 >> 5) & 0x7FFFFF) + 2144) |= 1 << v16;
  a2[2] = v19;
  a2[3] = v18;
  v18[2] = (__int64)a2;
  *(_QWORD *)(v19 + 24) = a2;
  a2[1] = result | 1;
  *(_QWORD *)((char *)a2 + result) = result;
  return result;
}
// 40E630: variable 'a6' is possibly undefined
// 40E630: variable 'a7' is possibly undefined
// 40E630: variable 'a8' is possibly undefined
// 40E630: variable 'a9' is possibly undefined
// 40E630: variable 'a10' is possibly undefined
// 40E630: variable 'a11' is possibly undefined
// 40E630: variable 'a12' is possibly undefined
// 40E630: variable 'a13' is possibly undefined

//----- (000000000040E640) ----------------------------------------------------
__int64 __fastcall ptmalloc_init_part_0(__int64 a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7)
{
  __int64 v7; // x20
  _UNKNOWN **v8; // x0
  __int64 result; // x0
  struct timespec v10; // [xsp+30h] [xbp+30h] BYREF

  _malloc_initialized = 1;
  if ( linux_eabi_syscall(__NR_getrandom, &tcache_key, (void *)8, (void *)1, a4, a5, a6, a7) != 8 )
  {
    clock_gettime(1, &v10);
    v7 = (unsigned int)(LODWORD(v10.tv_nsec) ^ LODWORD(v10.tv_sec)) ^ __ROR4__(
                                                                        LODWORD(v10.tv_nsec) ^ LODWORD(v10.tv_sec),
                                                                        8);
    tcache_key = v7;
    clock_gettime(1, &v10);
    tcache_key = (unsigned int)(LODWORD(v10.tv_nsec) ^ LODWORD(v10.tv_sec)) ^ __ROR4__(
                                                                                LODWORD(v10.tv_nsec) ^ LODWORD(v10.tv_sec),
                                                                                8) | (unsigned __int64)(v7 << 32);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 56) = &main_arena;
  v8 = &off_4906D0;
  do
  {
    v8[2] = v8;
    v8[3] = v8;
    v8 += 2;
  }
  while ( &unk_490EC0 != (_UNKNOWN *)v8 );
  global_max_fast = 0x80;
  dword_490678 = 0;
  off_4906D0 = &off_4906D0;
  _tunable_get_val(21LL, (char **)&v10, (__int64 (__fastcall *)(char *))dl_tunable_set_top_pad);
  _tunable_get_val(17LL, (char **)&v10, (__int64 (__fastcall *)(char *))dl_tunable_set_perturb_byte);
  _tunable_get_val(15LL, (char **)&v10, (__int64 (__fastcall *)(char *))dl_tunable_set_mmap_threshold);
  _tunable_get_val(22LL, (char **)&v10, (__int64 (__fastcall *)(char *))dl_tunable_set_trim_threshold);
  _tunable_get_val(14LL, (char **)&v10, (__int64 (__fastcall *)(char *))dl_tunable_set_mmaps_max);
  _tunable_get_val(10LL, (char **)&v10, (__int64 (__fastcall *)(char *))dl_tunable_set_arena_max);
  _tunable_get_val(11LL, (char **)&v10, (__int64 (__fastcall *)(char *))dl_tunable_set_arena_test);
  _tunable_get_val(19LL, (char **)&v10, (__int64 (__fastcall *)(char *))dl_tunable_set_tcache_max);
  _tunable_get_val(18LL, (char **)&v10, (__int64 (__fastcall *)(char *))dl_tunable_set_tcache_count);
  _tunable_get_val(20LL, (char **)&v10, (__int64 (__fastcall *)(char *))dl_tunable_set_tcache_unsorted_limit);
  _tunable_get_val(16LL, (char **)&v10, (__int64 (__fastcall *)(char *))dl_tunable_set_mxfast);
  _tunable_get_val(13LL, (char **)&v10, (__int64 (__fastcall *)(char *))dl_tunable_set_hugetlb);
  result = qword_490608;
  if ( qword_490608 )
  {
    if ( (_tunable_is_initialized(0xFu) & 1) == 0 )
    {
      qword_4905E8 = qword_490608;
      dword_490620 = 1;
    }
    result = 1LL;
    _always_fail_morecore = 1;
  }
  return result;
}
// 4905E8: using guessed type __int64 qword_4905E8;
// 490608: using guessed type __int64 qword_490608;
// 490620: using guessed type int dword_490620;
// 490670: using guessed type int main_arena;
// 490678: using guessed type int dword_490678;
// 4906D0: using guessed type _UNKNOWN *off_4906D0;
// 496B04: using guessed type char global_max_fast;
// 496B05: using guessed type char _malloc_initialized;
// 496B08: using guessed type __int64 tcache_key;
// 496B10: using guessed type char _always_fail_morecore;

//----- (000000000040E860) ----------------------------------------------------
__int64 __fastcall alloc_new_heap(size_t a1, __int64 a2, __int64 a3, int a4)
{
  unsigned __int64 v5; // x26
  size_t v6; // x24
  size_t v7; // x1
  int v8; // w25
  unsigned __int64 v9; // x0
  __int64 v10; // x19
  size_t v11; // x20
  void *v12; // x0
  size_t v13; // x1
  __int64 result; // x0
  void *v15; // x0
  __int64 v16; // x20
  unsigned __int64 v17; // x0

  v5 = qword_490608;
  v6 = 4 * qword_490608;
  if ( !qword_490608 )
  {
    v5 = 0x8000LL;
    v6 = 0x4000000LL;
  }
  v7 = a1 + a2;
  if ( v7 >= v5 )
  {
    if ( v7 > v6 )
    {
      v5 = v6;
      if ( a1 > v6 )
        return 0LL;
    }
    else
    {
      v5 = v7;
    }
  }
  v8 = a4 | 0x22;
  if ( aligned_heap_area )
  {
    v9 = mmap64((void *)aligned_heap_area, v6, 0, v8, -1, 0LL);
    aligned_heap_area = 0LL;
    v10 = v9;
    if ( v9 != -1LL )
    {
      if ( (v9 & (v6 - 1)) == 0 )
        goto LABEL_9;
      munmap((void *)v9, v6);
    }
  }
  v15 = (void *)mmap64(0LL, 2 * v6, 0, v8, -1, 0LL);
  if ( v15 == (void *)-1LL )
  {
    v17 = mmap64(0LL, v6, 0, v8, -1, 0LL);
    v10 = v17;
    if ( v17 == -1LL )
      return 0LL;
    if ( (v17 & (v6 - 1)) != 0 )
    {
      munmap((void *)v17, v6);
      return 0LL;
    }
  }
  else
  {
    v10 = ((unsigned __int64)v15 + v6 - 1) & -(__int64)v6;
    v16 = v10 - (_QWORD)v15;
    if ( (void *)v10 == v15 )
      aligned_heap_area = v10 + v6;
    else
      munmap(v15, v10 - (_QWORD)v15);
    munmap((void *)(v10 + v6), v6 - v16);
  }
LABEL_9:
  v11 = -a3 & (a3 - 1 + v5);
  if ( (unsigned int)mprotect((void *)v10, v11, 3) )
  {
    munmap((void *)v10, v6);
    return 0LL;
  }
  _set_vma_name((void *)v10);
  if ( qword_490600 - 1 < v11 )
  {
    v12 = (void *)(v10 & -dl_pagesize);
    v13 = v11 + ((dl_pagesize - 1) & v10);
    if ( ((dl_pagesize - 1) & v10) == 0 )
    {
      v12 = (void *)v10;
      v13 = -a3 & (a3 - 1 + v5);
    }
    madvise(v12, v13, 14);
  }
  *(_QWORD *)(v10 + 16) = v11;
  *(_QWORD *)(v10 + 24) = v11;
  result = v10;
  *(_QWORD *)(v10 + 32) = a3;
  return result;
}
// 490600: using guessed type __int64 qword_490600;
// 490608: using guessed type __int64 qword_490608;
// 490F10: using guessed type __int64 dl_pagesize;
// 496B18: using guessed type __int64 aligned_heap_area;

//----- (000000000040EA8C) ----------------------------------------------------
__int64 __fastcall new_heap(size_t a1, __int64 a2)
{
  __int64 result; // x0

  if ( !qword_490608 )
    return alloc_new_heap(a1, a2, dl_pagesize, 0);
  result = alloc_new_heap(a1, a2, qword_490608, dword_490610);
  if ( !result )
    return alloc_new_heap(a1, a2, dl_pagesize, 0);
  return result;
}
// 490608: using guessed type __int64 qword_490608;
// 490610: using guessed type int dword_490610;
// 490F10: using guessed type __int64 dl_pagesize;

//----- (000000000040EB00) ----------------------------------------------------
int *__fastcall arena_get2(__int64 a1, int *a2, __int64 a3, __int64 a4, void *a5, void *a6, void *a7, __int64 a8)
{
  int *v8; // x2
  unsigned __int64 StatusReg; // x22
  __int64 v12; // x23
  __int64 v13; // x1
  __int64 v14; // x2
  __int64 v15; // x3
  void *v16; // x4
  void *v17; // x5
  void *v18; // x6
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7
  int v27; // w0
  __int64 v28; // x19
  __int64 v29; // x0
  __int64 v30; // x1
  __int64 v31; // x2
  __int64 v32; // x3
  void *v33; // x4
  void *v34; // x5
  void *v35; // x6
  int v36; // w0
  __int64 v37; // x1
  __int64 v38; // x2
  __int64 v39; // x3
  void *v40; // x4
  void *v41; // x5
  void *v42; // x6
  double v43; // d0
  double v44; // d1
  double v45; // d2
  double v46; // d3
  double v47; // d4
  double v48; // d5
  double v49; // d6
  double v50; // d7
  int v51; // w0
  __int64 v53; // x1
  int v54; // w0
  __int64 v55; // x0
  unsigned __int64 v56; // x19
  int *v57; // x19
  int v58; // w0
  unsigned __int64 v59; // x22
  __int64 v60; // x1
  __int64 v61; // x2
  void *v62; // x4
  void *v63; // x5
  void *v64; // x6
  double v65; // d0
  double v66; // d1
  double v67; // d2
  double v68; // d3
  double v69; // d4
  double v70; // d5
  double v71; // d6
  double v72; // d7
  __int64 v73; // x3
  int v74; // w0
  __int64 v75; // x0
  __int64 v76; // x0
  __int64 *v77; // x2
  __int64 v78; // x1
  __int64 v79; // x1
  __int64 v80; // x2
  __int64 v81; // x3
  void *v82; // x4
  void *v83; // x5
  void *v84; // x6
  int v85; // w0
  __int64 v86; // x0
  int nprocs; // w0
  __int64 v88; // x1
  __int64 v89; // x2
  __int64 v90; // x3
  void *v91; // x4
  void *v92; // x5
  void *v93; // x6
  double v94; // d0
  double v95; // d1
  double v96; // d2
  double v97; // d3
  double v98; // d4
  double v99; // d5
  double v100; // d6
  double v101; // d7
  int v102; // w0
  __int64 v103; // x0
  __int64 v104; // x2
  __int64 v105; // x21
  __int64 v106; // x0
  __int64 v107; // x3
  __int64 v108; // x0
  unsigned __int64 v109; // x0
  __int64 v110; // x23
  __int64 v111; // x1
  __int64 v112; // x2
  __int64 v113; // x3
  void *v114; // x4
  void *v115; // x5
  void *v116; // x6
  double v117; // d0
  double v118; // d1
  double v119; // d2
  double v120; // d3
  double v121; // d4
  double v122; // d5
  double v123; // d6
  double v124; // d7
  int v125; // w0
  __int64 v126; // x1
  __int64 v127; // x2
  __int64 v128; // x3
  void *v129; // x4
  void *v130; // x5
  void *v131; // x6
  int v132; // w0
  __int64 v133; // x1
  __int64 v134; // x2
  __int64 v135; // x3
  void *v136; // x4
  void *v137; // x5
  void *v138; // x6
  double v139; // d0
  double v140; // d1
  double v141; // d2
  double v142; // d3
  double v143; // d4
  double v144; // d5
  double v145; // d6
  double v146; // d7
  int v147; // w0
  __int64 v148; // x0
  __int64 v149; // x1
  __int64 v150; // x2
  __int64 v151; // x3
  void *v152; // x4
  void *v153; // x5
  void *v154; // x6
  int v155; // w0
  __int64 v156; // x1
  __int64 v157; // x2
  __int64 v158; // x3
  void *v159; // x4
  void *v160; // x5
  void *v161; // x6
  double v162; // d0
  double v163; // d1
  double v164; // d2
  double v165; // d3
  double v166; // d4
  double v167; // d5
  double v168; // d6
  double v169; // d7
  int v170; // w0
  __int64 v171; // x0
  __int64 v172; // x20
  __int64 v173; // x0
  __int64 v174; // [xsp+58h] [xbp+58h]

  v8 = &perturb_byte;
  if ( free_list )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v12 = *(_QWORD *)(StatusReg + 56);
    _aarch64_cas4_acq();
    if ( v27 )
      _lll_lock_wait_private(&free_list_lock, v19, v20, v21, v22, v23, v24, v25, v26, v13, v14, v15, v16, v17, v18);
    v28 = free_list;
    if ( free_list )
    {
      free_list = *(_QWORD *)(free_list + 2168);
      if ( *(_QWORD *)(v28 + 2176) )
        _libc_assert_fail(
          (__int64)"result->attached_threads == 0",
          (__int64)"arena.c",
          0x2CBu,
          (__int64)"get_free_list");
      *(_QWORD *)(v28 + 2176) = 1LL;
      if ( v12 )
      {
        v29 = *(_QWORD *)(v12 + 2176);
        if ( !v29 )
          goto LABEL_75;
        *(_QWORD *)(v12 + 2176) = v29 - 1;
      }
      _aarch64_swp4_rel();
      if ( v36 > 1 )
        _lll_lock_wake_private(&free_list_lock, v30, v31, v32, v33, v34, v35);
      _aarch64_cas4_acq();
      if ( v51 )
        _lll_lock_wait_private((_DWORD *)v28, v43, v44, v45, v46, v47, v48, v49, v50, v37, v38, v39, v40, v41, v42);
      *(_QWORD *)(StatusReg + 56) = v28;
      return (int *)v28;
    }
    _aarch64_swp4_rel();
    if ( v54 > 1 )
      _lll_lock_wake_private(&free_list_lock, v53, (__int64)v8, a4, a5, a6, a7);
  }
  v55 = narenas_limit_2;
  v56 = narenas;
  if ( !narenas_limit_2 )
  {
    v55 = qword_4905F8;
    if ( qword_4905F8 )
    {
      narenas_limit_2 = qword_4905F8;
    }
    else if ( narenas > (unsigned __int64)qword_4905F0 )
    {
      nprocs = get_nprocs(0LL, qword_4905F0, (__int64)v8, a4, (__int64)a5, (__int64)a6, (__int64)a7, a8);
      v56 = narenas;
      if ( nprocs <= 0 )
      {
        v55 = 16LL;
        narenas_limit_2 = 16LL;
      }
      else
      {
        v55 = 8 * nprocs;
        narenas_limit_2 = v55;
      }
    }
  }
  while ( 1 )
  {
    if ( v55 - 1 < v56 )
    {
      v57 = (int *)next_to_use_5;
      if ( !next_to_use_5 )
      {
        v57 = &main_arena;
        next_to_use_5 = (__int64)&main_arena;
      }
      while ( 1 )
      {
        _aarch64_cas4_acq();
        if ( !v58 )
          break;
        v57 = (int *)*((_QWORD *)v57 + 270);
        if ( v57 == (int *)next_to_use_5 )
        {
          if ( a2 == v57 )
            v57 = (int *)*((_QWORD *)v57 + 270);
          _aarch64_cas4_acq();
          if ( v102 )
            _lll_lock_wait_private(v57, v94, v95, v96, v97, v98, v99, v100, v101, v88, v89, v90, v91, v92, v93);
          break;
        }
      }
      v59 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
      v174 = *(_QWORD *)(v59 + 56);
      _aarch64_cas4_acq();
      v73 = v174;
      if ( v74 )
      {
        _lll_lock_wait_private(&free_list_lock, v65, v66, v67, v68, v69, v70, v71, v72, v60, v61, v174, v62, v63, v64);
        v73 = v174;
      }
      if ( v73 )
      {
        v75 = *(_QWORD *)(v73 + 2176);
        if ( !v75 )
          goto LABEL_75;
        *(_QWORD *)(v73 + 2176) = v75 - 1;
      }
      v76 = free_list;
      if ( free_list )
      {
        v77 = &free_list;
        while ( 1 )
        {
          if ( *(_QWORD *)(v76 + 2176) )
            _libc_assert_fail(
              (__int64)"p->attached_threads == 0",
              (__int64)"arena.c",
              0x2E5u,
              (__int64)"remove_from_free_list");
          v78 = *(_QWORD *)(v76 + 2168);
          if ( v57 == (int *)v76 )
            break;
          v77 = (__int64 *)(v76 + 2168);
          if ( !v78 )
            goto LABEL_34;
          v76 = *(_QWORD *)(v76 + 2168);
        }
        *v77 = v78;
      }
LABEL_34:
      ++*((_QWORD *)v57 + 272);
      _aarch64_swp4_rel();
      if ( v85 > 1 )
        _lll_lock_wake_private(&free_list_lock, v79, v80, v81, v82, v83, v84);
      v86 = *((_QWORD *)v57 + 270);
      *(_QWORD *)(v59 + 56) = v57;
      next_to_use_5 = v86;
      return v57;
    }
    _aarch64_cas8_acq();
    if ( v103 == v56 )
      break;
    v56 = narenas;
    v55 = narenas_limit_2;
  }
  v104 = new_heap(a1 + 2264, qword_4905E0);
  if ( v104 )
  {
LABEL_52:
    v105 = v104 + 48;
    v28 = v104 + 48;
    *(_QWORD *)v104 = v104 + 48;
    v106 = v104 + 144;
    do
    {
      *(_QWORD *)(v106 + 16) = v106;
      *(_QWORD *)(v106 + 24) = v106;
      v106 += 16LL;
    }
    while ( v106 != v104 + 2176 );
    if ( (int *)v105 == &main_arena )
      global_max_fast = 0x80;
    else
      *(_DWORD *)(v104 + 52) |= 2u;
    *(_DWORD *)(v104 + 56) = 0;
    *(_QWORD *)(v104 + 2224) = 1LL;
    v107 = v104 + 2248;
    v108 = *(_QWORD *)(v104 + 16);
    *(_QWORD *)(v104 + 2232) = v108;
    if ( (((_BYTE)v104 - 40) & 0xF) != 0 )
      v107 = v104 + 2248 - (((_BYTE)v104 - 40) & 0xF) + 16;
    *(_QWORD *)(v104 + 2240) = v108;
    *(_QWORD *)(v104 + 144) = v107;
    *(_QWORD *)(v107 + 8) = (v104 + v108 - v107) | 1;
    v109 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    *(_DWORD *)(v104 + 48) = 0;
    v109 += 48LL;
    v110 = *(_QWORD *)(v109 + 8);
    *(_QWORD *)(v109 + 8) = v105;
    _aarch64_cas4_acq();
    if ( v125 )
      _lll_lock_wait_private(
        &list_lock,
        v117,
        v118,
        v119,
        v120,
        v121,
        v122,
        v123,
        v124,
        v111,
        v112,
        v113,
        v114,
        v115,
        v116);
    *(_QWORD *)(v105 + 2160) = off_490EE0;
    __dmb(0xBu);
    off_490EE0 = (int *)v105;
    _aarch64_swp4_rel();
    if ( v132 > 1 )
      _lll_lock_wake_private(&list_lock, v126, v127, v128, v129, v130, v131);
    _aarch64_cas4_acq();
    if ( v147 )
      _lll_lock_wait_private(
        &free_list_lock,
        v139,
        v140,
        v141,
        v142,
        v143,
        v144,
        v145,
        v146,
        v133,
        v134,
        v135,
        v136,
        v137,
        v138);
    if ( v110 )
    {
      v148 = *(_QWORD *)(v110 + 2176);
      if ( v148 )
      {
        *(_QWORD *)(v110 + 2176) = v148 - 1;
        goto LABEL_67;
      }
LABEL_75:
      detach_arena_part_0();
    }
LABEL_67:
    _aarch64_swp4_rel();
    if ( v155 > 1 )
      _lll_lock_wake_private(&free_list_lock, v149, v150, v151, v152, v153, v154);
    _aarch64_cas4_acq();
    if ( v170 )
      _lll_lock_wait_private(
        (_DWORD *)v105,
        v162,
        v163,
        v164,
        v165,
        v166,
        v167,
        v168,
        v169,
        v156,
        v157,
        v158,
        v159,
        v160,
        v161);
  }
  else
  {
    v171 = new_heap(0x8D8uLL, qword_4905E0);
    v28 = v171;
    if ( v171 )
    {
      v104 = v171;
      goto LABEL_52;
    }
    do
    {
      v172 = narenas;
      _aarch64_cas8_acq();
    }
    while ( v172 != v173 );
  }
  return (int *)v28;
}
// 40EB58: variable 'v27' is possibly undefined
// 40ED34: variable 'v19' is possibly undefined
// 40ED34: variable 'v20' is possibly undefined
// 40ED34: variable 'v21' is possibly undefined
// 40ED34: variable 'v22' is possibly undefined
// 40ED34: variable 'v23' is possibly undefined
// 40ED34: variable 'v24' is possibly undefined
// 40ED34: variable 'v25' is possibly undefined
// 40ED34: variable 'v26' is possibly undefined
// 40ED34: variable 'v13' is possibly undefined
// 40ED34: variable 'v14' is possibly undefined
// 40ED34: variable 'v15' is possibly undefined
// 40ED34: variable 'v16' is possibly undefined
// 40ED34: variable 'v17' is possibly undefined
// 40ED34: variable 'v18' is possibly undefined
// 40EBA4: variable 'v36' is possibly undefined
// 40ED7C: variable 'v30' is possibly undefined
// 40ED7C: variable 'v31' is possibly undefined
// 40ED7C: variable 'v32' is possibly undefined
// 40ED7C: variable 'v33' is possibly undefined
// 40ED7C: variable 'v34' is possibly undefined
// 40ED7C: variable 'v35' is possibly undefined
// 40EBB8: variable 'v51' is possibly undefined
// 40ED6C: variable 'v43' is possibly undefined
// 40ED6C: variable 'v44' is possibly undefined
// 40ED6C: variable 'v45' is possibly undefined
// 40ED6C: variable 'v46' is possibly undefined
// 40ED6C: variable 'v47' is possibly undefined
// 40ED6C: variable 'v48' is possibly undefined
// 40ED6C: variable 'v49' is possibly undefined
// 40ED6C: variable 'v50' is possibly undefined
// 40ED6C: variable 'v37' is possibly undefined
// 40ED6C: variable 'v38' is possibly undefined
// 40ED6C: variable 'v39' is possibly undefined
// 40ED6C: variable 'v40' is possibly undefined
// 40ED6C: variable 'v41' is possibly undefined
// 40ED6C: variable 'v42' is possibly undefined
// 40EBF4: variable 'v54' is possibly undefined
// 40ED98: variable 'v53' is possibly undefined
// 40ED98: variable 'v8' is possibly undefined
// 40ED98: variable 'a4' is possibly undefined
// 40ED98: variable 'a5' is possibly undefined
// 40ED98: variable 'a6' is possibly undefined
// 40ED98: variable 'a7' is possibly undefined
// 40EC38: variable 'v58' is possibly undefined
// 40EC6C: variable 'v74' is possibly undefined
// 40ED88: variable 'v65' is possibly undefined
// 40ED88: variable 'v66' is possibly undefined
// 40ED88: variable 'v67' is possibly undefined
// 40ED88: variable 'v68' is possibly undefined
// 40ED88: variable 'v69' is possibly undefined
// 40ED88: variable 'v70' is possibly undefined
// 40ED88: variable 'v71' is possibly undefined
// 40ED88: variable 'v72' is possibly undefined
// 40ED88: variable 'v60' is possibly undefined
// 40ED88: variable 'v61' is possibly undefined
// 40ED88: variable 'v62' is possibly undefined
// 40ED88: variable 'v63' is possibly undefined
// 40ED88: variable 'v64' is possibly undefined
// 40ECDC: variable 'v85' is possibly undefined
// 40EE10: variable 'v79' is possibly undefined
// 40EE10: variable 'v80' is possibly undefined
// 40EE10: variable 'v81' is possibly undefined
// 40EE10: variable 'v82' is possibly undefined
// 40EE10: variable 'v83' is possibly undefined
// 40EE10: variable 'v84' is possibly undefined
// 40ED48: variable 'a8' is possibly undefined
// 40EDCC: variable 'v102' is possibly undefined
// 40EDD4: variable 'v94' is possibly undefined
// 40EDD4: variable 'v95' is possibly undefined
// 40EDD4: variable 'v96' is possibly undefined
// 40EDD4: variable 'v97' is possibly undefined
// 40EDD4: variable 'v98' is possibly undefined
// 40EDD4: variable 'v99' is possibly undefined
// 40EDD4: variable 'v100' is possibly undefined
// 40EDD4: variable 'v101' is possibly undefined
// 40EDD4: variable 'v88' is possibly undefined
// 40EDD4: variable 'v89' is possibly undefined
// 40EDD4: variable 'v90' is possibly undefined
// 40EDD4: variable 'v91' is possibly undefined
// 40EDD4: variable 'v92' is possibly undefined
// 40EDD4: variable 'v93' is possibly undefined
// 40EDF8: variable 'v103' is possibly undefined
// 40EF14: variable 'v125' is possibly undefined
// 40F048: variable 'v117' is possibly undefined
// 40F048: variable 'v118' is possibly undefined
// 40F048: variable 'v119' is possibly undefined
// 40F048: variable 'v120' is possibly undefined
// 40F048: variable 'v121' is possibly undefined
// 40F048: variable 'v122' is possibly undefined
// 40F048: variable 'v123' is possibly undefined
// 40F048: variable 'v124' is possibly undefined
// 40F048: variable 'v111' is possibly undefined
// 40F048: variable 'v112' is possibly undefined
// 40F048: variable 'v113' is possibly undefined
// 40F048: variable 'v114' is possibly undefined
// 40F048: variable 'v115' is possibly undefined
// 40F048: variable 'v116' is possibly undefined
// 40EF44: variable 'v132' is possibly undefined
// 40F03C: variable 'v126' is possibly undefined
// 40F03C: variable 'v127' is possibly undefined
// 40F03C: variable 'v128' is possibly undefined
// 40F03C: variable 'v129' is possibly undefined
// 40F03C: variable 'v130' is possibly undefined
// 40F03C: variable 'v131' is possibly undefined
// 40EF60: variable 'v147' is possibly undefined
// 40F030: variable 'v139' is possibly undefined
// 40F030: variable 'v140' is possibly undefined
// 40F030: variable 'v141' is possibly undefined
// 40F030: variable 'v142' is possibly undefined
// 40F030: variable 'v143' is possibly undefined
// 40F030: variable 'v144' is possibly undefined
// 40F030: variable 'v145' is possibly undefined
// 40F030: variable 'v146' is possibly undefined
// 40F030: variable 'v133' is possibly undefined
// 40F030: variable 'v134' is possibly undefined
// 40F030: variable 'v135' is possibly undefined
// 40F030: variable 'v136' is possibly undefined
// 40F030: variable 'v137' is possibly undefined
// 40F030: variable 'v138' is possibly undefined
// 40EF90: variable 'v155' is possibly undefined
// 40F054: variable 'v149' is possibly undefined
// 40F054: variable 'v150' is possibly undefined
// 40F054: variable 'v151' is possibly undefined
// 40F054: variable 'v152' is possibly undefined
// 40F054: variable 'v153' is possibly undefined
// 40F054: variable 'v154' is possibly undefined
// 40EFA4: variable 'v170' is possibly undefined
// 40EFAC: variable 'v162' is possibly undefined
// 40EFAC: variable 'v163' is possibly undefined
// 40EFAC: variable 'v164' is possibly undefined
// 40EFAC: variable 'v165' is possibly undefined
// 40EFAC: variable 'v166' is possibly undefined
// 40EFAC: variable 'v167' is possibly undefined
// 40EFAC: variable 'v168' is possibly undefined
// 40EFAC: variable 'v169' is possibly undefined
// 40EFAC: variable 'v156' is possibly undefined
// 40EFAC: variable 'v157' is possibly undefined
// 40EFAC: variable 'v158' is possibly undefined
// 40EFAC: variable 'v159' is possibly undefined
// 40EFAC: variable 'v160' is possibly undefined
// 40EFAC: variable 'v161' is possibly undefined
// 40F024: variable 'v173' is possibly undefined
// 4905E0: using guessed type __int64 qword_4905E0;
// 4905F0: using guessed type __int64 qword_4905F0;
// 4905F8: using guessed type __int64 qword_4905F8;
// 490660: using guessed type __int64 narenas;
// 490670: using guessed type int main_arena;
// 490EE0: using guessed type int *off_490EE0;
// 496B00: using guessed type int perturb_byte;
// 496B04: using guessed type char global_max_fast;
// 496B20: using guessed type __int64 free_list;
// 496B28: using guessed type int free_list_lock;
// 496B30: using guessed type __int64 narenas_limit_2;
// 496B38: using guessed type int list_lock;
// 496B40: using guessed type __int64 next_to_use_5;

//----- (000000000040F060) ----------------------------------------------------
int *__fastcall arena_get_retry(int *a1, __int64 a2)
{
  __int64 v3; // x1
  __int64 v4; // x2
  __int64 v5; // x3
  void *v6; // x4
  void *v7; // x5
  void *v8; // x6
  int v9; // w0
  __int64 v10; // x1
  __int64 v11; // x2
  __int64 v12; // x3
  void *v13; // x4
  void *v14; // x5
  void *v15; // x6
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  int v24; // w0
  __int64 v27; // x1
  __int64 v28; // x2
  __int64 v29; // x3
  void *v30; // x4
  void *v31; // x5
  void *v32; // x6
  __int64 v33; // x7
  int v34; // w0

  if ( a1 == &main_arena )
  {
    _aarch64_swp4_rel();
    if ( v34 > 1 )
      _lll_lock_wake_private(a1, v27, v28, v29, v30, v31, v32);
    return arena_get2(a2, &main_arena, v28, v29, v30, v31, v32, v33);
  }
  else
  {
    _aarch64_swp4_rel();
    if ( v9 > 1 )
      _lll_lock_wake_private(a1, v3, v4, v5, v6, v7, v8);
    _aarch64_cas4_acq();
    if ( v24 )
      _lll_lock_wait_private(&main_arena, v16, v17, v18, v19, v20, v21, v22, v23, v10, v11, v12, v13, v14, v15);
    return &main_arena;
  }
}
// 40F090: variable 'v9' is possibly undefined
// 40F0FC: variable 'v3' is possibly undefined
// 40F0FC: variable 'v4' is possibly undefined
// 40F0FC: variable 'v5' is possibly undefined
// 40F0FC: variable 'v6' is possibly undefined
// 40F0FC: variable 'v7' is possibly undefined
// 40F0FC: variable 'v8' is possibly undefined
// 40F0A4: variable 'v24' is possibly undefined
// 40F0F0: variable 'v16' is possibly undefined
// 40F0F0: variable 'v17' is possibly undefined
// 40F0F0: variable 'v18' is possibly undefined
// 40F0F0: variable 'v19' is possibly undefined
// 40F0F0: variable 'v20' is possibly undefined
// 40F0F0: variable 'v21' is possibly undefined
// 40F0F0: variable 'v22' is possibly undefined
// 40F0F0: variable 'v23' is possibly undefined
// 40F0F0: variable 'v10' is possibly undefined
// 40F0F0: variable 'v11' is possibly undefined
// 40F0F0: variable 'v12' is possibly undefined
// 40F0F0: variable 'v13' is possibly undefined
// 40F0F0: variable 'v14' is possibly undefined
// 40F0F0: variable 'v15' is possibly undefined
// 40F0D0: variable 'v34' is possibly undefined
// 40F108: variable 'v27' is possibly undefined
// 40F108: variable 'v28' is possibly undefined
// 40F108: variable 'v29' is possibly undefined
// 40F108: variable 'v30' is possibly undefined
// 40F108: variable 'v31' is possibly undefined
// 40F108: variable 'v32' is possibly undefined
// 40F0E8: variable 'v33' is possibly undefined
// 490670: using guessed type int main_arena;

//----- (000000000040F110) ----------------------------------------------------
unsigned __int64 __fastcall sysmalloc_mmap_fallback_constprop_0(
        size_t *a1,
        size_t a2,
        __int64 a3,
        size_t a4,
        __int64 a5,
        int a6)
{
  unsigned __int64 v6; // x20
  size_t v8; // x19
  __int64 v9; // x2
  size_t v10; // x6
  void *v12; // x0
  size_t v13; // x1
  unsigned __int64 v14; // [xsp+30h] [xbp+30h]

  v6 = 0LL;
  v8 = *a1;
  v9 = (a3 + *a1 + a5 - 1) & -a5;
  if ( (dword_490674 & 2) != 0 )
    v10 = *a1;
  else
    v10 = v9;
  if ( (dword_490674 & 2) == 0 )
    v8 = v9;
  if ( a4 > v10 )
  {
    v10 = a4;
    v8 = a4;
  }
  if ( a2 < v10 )
  {
    v14 = v10;
    v6 = mmap64(0LL, v10, 3, a6 | 0x22u, -1, 0LL);
    if ( v6 != -1LL )
    {
      if ( (a6 & 0x40000) == 0 && qword_490600 - 1 < v14 )
      {
        v12 = (void *)(v6 & -dl_pagesize);
        v13 = ((dl_pagesize - 1) & v6) + v14;
        if ( ((dl_pagesize - 1) & v6) == 0 )
        {
          v12 = (void *)v6;
          v13 = v14;
        }
        madvise(v12, v13, 14);
      }
      _set_vma_name((void *)v6);
      dword_490674 |= 2u;
      *a1 = v8;
    }
  }
  return v6;
}
// 490600: using guessed type __int64 qword_490600;
// 490674: using guessed type int dword_490674;
// 490F10: using guessed type __int64 dl_pagesize;

//----- (000000000040F240) ----------------------------------------------------
__int64 __fastcall sysmalloc_mmap_isra_0(unsigned __int64 a1, __int64 a2, int a3)
{
  unsigned __int64 v3; // x19
  unsigned __int64 v4; // x21
  unsigned __int64 v6; // x20
  int v7; // w0
  int v8; // w1
  int v9; // w0
  __int64 v10; // x0
  unsigned __int64 v11; // x19
  __int64 v12; // x0
  void *v13; // x0
  size_t v14; // x1
  int v16; // [xsp+30h] [xbp+30h]
  __int64 v17; // [xsp+30h] [xbp+30h]
  int v18; // [xsp+3Ch] [xbp+3Ch]

  v3 = (a2 + 7 + a1) & -a2;
  if ( a1 >= v3 )
    return -1LL;
  v6 = mmap64(0LL, (a2 + 7 + a1) & -a2, 3, a3 | 0x22u, -1, 0LL);
  if ( v6 == -1LL )
    return -1LL;
  if ( (a3 & 0x40000) == 0 && qword_490600 - 1 < v3 )
  {
    v13 = (void *)(v6 & -dl_pagesize);
    v14 = v3 + ((dl_pagesize - 1) & v6);
    if ( ((dl_pagesize - 1) & v6) == 0 )
    {
      v13 = (void *)v6;
      v14 = v3;
    }
    madvise(v13, v14, 14);
  }
  _set_vma_name((void *)v6);
  v4 = v6 + 16;
  if ( (v6 & 0xF) != 0 )
    _libc_assert_fail(
      (__int64)"((INTERNAL_SIZE_T) chunk2mem (mm) & MALLOC_ALIGN_MASK) == 0",
      (__int64)"malloc.c",
      0x992u,
      (__int64)"sysmalloc_mmap");
  *(_QWORD *)v6 = 0LL;
  *(_QWORD *)(v6 + 8) = v3 | 2;
  _aarch64_ldadd4_relax();
  v8 = v7 + 1;
  do
  {
    if ( v8 <= dword_49061C )
      break;
    v16 = dword_49061C;
    v18 = v8;
    _aarch64_cas4_acq();
    v8 = v18;
  }
  while ( v9 != v16 );
  _aarch64_ldadd8_relax();
  v11 = v10 + v3;
  while ( v11 > qword_490630 )
  {
    v17 = qword_490630;
    _aarch64_cas8_acq();
    if ( v12 == v17 )
      return v6 + 16;
  }
  return v4;
}
// 40F2FC: variable 'v7' is possibly undefined
// 40F32C: variable 'v9' is possibly undefined
// 40F348: variable 'v10' is possibly undefined
// 40F374: variable 'v12' is possibly undefined
// 40F400: using guessed type __int64 systrim_constprop_0(void);
// 490600: using guessed type __int64 qword_490600;
// 49061C: using guessed type int dword_49061C;
// 490630: using guessed type __int64 qword_490630;
// 490F10: using guessed type __int64 dl_pagesize;

//----- (000000000040F400) ----------------------------------------------------
__int64 __fastcall systrim_constprop_0(unsigned __int64 a1)
{
  unsigned __int64 v1; // x2
  unsigned __int64 v2; // x1
  __int64 v3; // x1
  __int64 v5; // x0
  char *v6; // x5
  __int64 v7; // x0
  __int64 v8; // x0
  char *v9; // x0
  __int64 v10; // [xsp+18h] [xbp-18h]
  unsigned __int64 v11; // [xsp+18h] [xbp-18h]
  unsigned __int64 v12; // [xsp+20h] [xbp-10h]
  char *v13; // [xsp+20h] [xbp-10h]

  v1 = *((_QWORD *)off_4906D0 + 1) & 0xFFFFFFFFFFFFFFF8LL;
  if ( v1 - 33 <= a1 )
    return 0LL;
  v2 = v1 - 33 - a1;
  if ( qword_490600 )
  {
    v3 = -qword_490600 & v2;
    if ( !v3 )
      return 0LL;
  }
  else
  {
    v3 = -dl_pagesize & v2;
    if ( !v3 )
      return 0LL;
  }
  if ( (_always_fail_morecore & 1) != 0 )
    return 0LL;
  v10 = v3;
  v12 = *((_QWORD *)off_4906D0 + 1) & 0xFFFFFFFFFFFFFFF8LL;
  v5 = sbrk(0LL);
  if ( v5 == -1 )
    v6 = 0LL;
  else
    v6 = (char *)v5;
  if ( v6 != (char *)off_4906D0 + v12 )
    return 0LL;
  if ( (_always_fail_morecore & 1) != 0 )
    return 0LL;
  v7 = -v10;
  v11 = v12;
  v13 = v6;
  sbrk(v7);
  if ( (_always_fail_morecore & 1) != 0 )
    return 0LL;
  v8 = sbrk(0LL);
  if ( (unsigned __int64)(v8 - 1) > 0xFFFFFFFFFFFFFFFDLL )
    return 0LL;
  v9 = &v13[-v8];
  if ( !v9 )
    return 0LL;
  qword_490EF8 -= (__int64)v9;
  *((_QWORD *)off_4906D0 + 1) = (v11 - (_QWORD)v9) | 1;
  return 1LL;
}
// 490600: using guessed type __int64 qword_490600;
// 4906D0: using guessed type _UNKNOWN *off_4906D0;
// 490EF8: using guessed type __int64 qword_490EF8;
// 490F10: using guessed type __int64 dl_pagesize;
// 496B10: using guessed type char _always_fail_morecore;

//----- (000000000040F528) ----------------------------------------------------
unsigned __int64 __fastcall int_free_maybe_consolidate_part_0(__int64 a1)
{
  unsigned __int64 v2; // x1
  size_t v3; // x26
  _QWORD *v4; // x24
  __int64 v5; // x27
  char *v6; // x25
  __int64 v7; // x19
  _QWORD *v8; // x0
  __int64 v9; // x2
  __int64 v10; // x4
  __int64 v11; // x3
  char *v12; // x21
  __int64 v13; // x20
  __int64 v14; // x22
  char *v15; // x20
  __int64 v16; // x1
  __int64 v17; // x19
  __int64 v18; // x19
  double v20; // d0
  double v21; // d1
  double v22; // d2
  double v23; // d3
  double v24; // d4
  double v25; // d5
  double v26; // d6
  double v27; // d7
  unsigned __int64 v28; // x19
  unsigned __int64 result; // x0
  unsigned __int64 v30; // x1
  size_t v32; // x20
  __int64 v33; // x22
  int v34; // w26
  int v35; // w0
  int v36; // w28
  int v37; // w0
  unsigned __int64 v38; // [xsp+68h] [xbp+68h]
  char v39; // [xsp+7Fh] [xbp+7Fh] BYREF

  if ( !*(_DWORD *)(a1 + 8) )
  {
    if ( (int *)a1 != &main_arena )
      goto LABEL_3;
LABEL_37:
    result = *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8LL) & 0xFFFFFFFFFFFFFFF8LL;
    if ( result >= mp_ )
      return systrim_constprop_0(qword_4905E0);
    return result;
  }
  malloc_consolidate(a1);
  if ( (int *)a1 == &main_arena )
    goto LABEL_37;
LABEL_3:
  v2 = *(_QWORD *)(a1 + 96);
  if ( qword_490608 )
  {
    v3 = 4 * qword_490608;
    v4 = (_QWORD *)((-4 * qword_490608) & v2);
    v5 = *v4;
    if ( a1 == *v4 )
    {
      v6 = *(char **)(a1 + 96);
      v38 = qword_4905E0;
      goto LABEL_6;
    }
LABEL_58:
    _libc_assert_fail(
      (__int64)"heap->ar_ptr == av",
      (__int64)"malloc.c",
      0x12F3u,
      (__int64)"_int_free_maybe_consolidate");
  }
  v4 = (_QWORD *)(v2 & 0xFFFFFFFFFC000000LL);
  v5 = *(_QWORD *)(v2 & 0xFFFFFFFFFC000000LL);
  if ( a1 != v5 )
    goto LABEL_58;
  v6 = *(char **)(a1 + 96);
  v3 = 0x4000000LL;
  v38 = qword_4905E0;
LABEL_6:
  if ( (_QWORD *)v2 == v4 + 6 )
  {
    while ( 1 )
    {
      v8 = v4;
      v4 = (_QWORD *)v4[1];
      v9 = v4[2];
      v10 = ((_BYTE)v4 + (_BYTE)v9 - 16) & 0xF;
      v11 = v9 - 16 - v10;
      v12 = (char *)v4 + v11;
      if ( *(_QWORD *)((char *)v4 + v11 + 8) != 1LL )
        _libc_assert_fail(
          (__int64)"chunksize_nomask (p) == (0 | PREV_INUSE)",
          (__int64)"arena.c",
          0x229u,
          (__int64)"heap_trim");
      v13 = *(_QWORD *)((char *)v4 + v11);
      v14 = -v13;
      v15 = &v12[-v13];
      v16 = *((_QWORD *)v15 + 1);
      v17 = (v16 & 0xFFFFFFFFFFFFFFF8LL) + v10;
      if ( (unsigned __int64)(v17 + 15) > 0x3E )
        _libc_assert_fail(
          (__int64)"new_size > 0 && new_size < (long) (2 * MINSIZE)",
          (__int64)"arena.c",
          0x22Cu,
          (__int64)"heap_trim");
      v18 = v17 + 16;
      if ( (v16 & 1) == 0 )
        v18 += *(_QWORD *)&v12[v14];
      if ( v18 <= 0 || v3 <= v18 )
        _libc_assert_fail(
          (__int64)"new_size > 0 && new_size < max_size",
          (__int64)"arena.c",
          0x22Fu,
          (__int64)"heap_trim");
      if ( v3 - v9 + v18 < v38 + 32 + v8[4] )
        break;
      *(_QWORD *)(v5 + 2184) -= v8[2];
      if ( (_QWORD *)aligned_heap_area == (_QWORD *)((char *)v8 + v3) )
        aligned_heap_area = 0LL;
      munmap(v8, v3);
      v6 = v15;
      if ( (*((_QWORD *)v15 + 1) & 1) == 0 )
      {
        v6 = &v15[-*(_QWORD *)&v12[v14]];
        unlink_chunk_isra_0(v6, v20, v21, v22, v23, v24, v25, v26, v27);
      }
      if ( ((unsigned __int64)&v6[v18] & (v4[4] - 1LL)) != 0 )
        _libc_assert_fail(
          (__int64)"((unsigned long) ((char *) p + new_size) & (heap->pagesize - 1)) == 0",
          (__int64)"arena.c",
          0x23Eu,
          (__int64)"heap_trim");
      if ( &v6[v18] != (char *)v4 + v4[2] )
        _libc_assert_fail(
          (__int64)"((char *) p + new_size) == ((char *) heap + heap->size)",
          (__int64)"arena.c",
          0x240u,
          (__int64)"heap_trim");
      *(_QWORD *)(v5 + 96) = v6;
      v7 = v18 | 1;
      *((_QWORD *)v6 + 1) = v7;
      if ( v6 != (char *)(v4 + 6) )
        goto LABEL_28;
    }
    v7 = *((_QWORD *)v6 + 1);
    v4 = v8;
  }
  else
  {
    v7 = *(_QWORD *)(v2 + 8);
  }
LABEL_28:
  v28 = v7 & 0xFFFFFFFFFFFFFFF8LL;
  result = mp_;
  if ( v28 >= mp_ )
  {
    v30 = v28 - 33;
    if ( (__int64)(v28 - 33) >= 0 && v30 > v38 )
    {
      result = -v4[4];
      v32 = result & (v30 - v38);
      if ( v32 )
      {
        v33 = v4[2] - v32;
        if ( v33 > 47 )
        {
          if ( may_shrink_heap_12 < 0 )
          {
            v34 = _libc_enable_secure;
            may_shrink_heap_12 = _libc_enable_secure;
            if ( !_libc_enable_secure )
            {
              v35 = _open_nocancel("/proc/sys/vm/overcommit_memory", 0x80000);
              v36 = v35;
              if ( v35 < 0 )
              {
                v37 = may_shrink_heap_12;
              }
              else
              {
                if ( (__int64)_read_nocancel(v35, &v39, 1uLL) > 0 )
                  v34 = v39 == 50;
                may_shrink_heap_12 = v34;
                _close_nocancel(v36);
                v37 = may_shrink_heap_12;
              }
              if ( !v37 )
                goto LABEL_42;
            }
          }
          else if ( !may_shrink_heap_12 )
          {
LABEL_42:
            madvise((char *)v4 + v33, v32, 4);
LABEL_43:
            v4[2] = v33;
            *(_QWORD *)(v5 + 2184) -= v32;
            result = (v28 - v32) | 1;
            *((_QWORD *)v6 + 1) = result;
            return result;
          }
          result = mmap64((char *)v4 + v33, v32, 0, 50, -1, 0LL);
          if ( result != -1LL )
          {
            v4[3] = v33;
            goto LABEL_43;
          }
        }
      }
    }
  }
  return result;
}
// 40F6BC: variable 'v20' is possibly undefined
// 40F6BC: variable 'v21' is possibly undefined
// 40F6BC: variable 'v22' is possibly undefined
// 40F6BC: variable 'v23' is possibly undefined
// 40F6BC: variable 'v24' is possibly undefined
// 40F6BC: variable 'v25' is possibly undefined
// 40F6BC: variable 'v26' is possibly undefined
// 40F6BC: variable 'v27' is possibly undefined
// 40F960: using guessed type __int64 int_free_merge_chunk(void);
// 4905D8: using guessed type __int64 mp_;
// 4905E0: using guessed type __int64 qword_4905E0;
// 490608: using guessed type __int64 qword_490608;
// 490668: using guessed type int may_shrink_heap_12;
// 490670: using guessed type int main_arena;
// 491570: using guessed type int _libc_enable_secure;
// 496B18: using guessed type __int64 aligned_heap_area;

//----- (000000000040F960) ----------------------------------------------------
unsigned __int64 __fastcall int_free_merge_chunk(
        __int64 a1,
        __int64 *a2,
        unsigned __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  __int64 *v12; // x0
  __int64 *v13; // x5
  _QWORD *v14; // x3
  unsigned __int64 v15; // x6
  unsigned __int64 v16; // x4
  unsigned __int64 v17; // x4
  __int64 v18; // x1
  __int64 *v19; // x5
  unsigned __int64 v20; // x0
  unsigned __int64 result; // x0
  __int64 *v22; // [xsp+20h] [xbp+20h]
  unsigned __int64 v24; // [xsp+28h] [xbp+28h]
  _QWORD *v26; // [xsp+30h] [xbp+30h]
  _QWORD *v27; // [xsp+30h] [xbp+30h]
  unsigned __int64 v28; // [xsp+38h] [xbp+38h]
  unsigned __int64 v29; // [xsp+38h] [xbp+38h]

  v12 = *(__int64 **)(a1 + 96);
  if ( v12 == a2 )
    malloc_printerr((__int64)"double free or corruption (top)", a4, a5, a6, a7, a8, a9, a10, a11);
  v13 = a2;
  v14 = (__int64 *)((char *)a2 + a3);
  v15 = a3;
  if ( (*(_DWORD *)(a1 + 4) & 2) == 0 && v14 >= (__int64 *)((char *)v12 + (v12[1] & 0xFFFFFFFFFFFFFFF8LL)) )
    malloc_printerr((__int64)"double free or corruption (out)", a4, a5, a6, a7, a8, a9, a10, a11);
  v16 = v14[1];
  if ( (v16 & 1) == 0 )
    malloc_printerr((__int64)"double free or corruption (!prev)", a4, a5, a6, a7, a8, a9, a10, a11);
  if ( v16 <= 0x10 || (v17 = v16 & 0xFFFFFFFFFFFFFFF8LL, *(_QWORD *)(a1 + 2184) <= v17) )
    malloc_printerr((__int64)"free(): invalid next size (normal)", a4, a5, a6, a7, a8, a9, a10, a11);
  if ( perturb_byte )
  {
    v27 = (__int64 *)((char *)a2 + a3);
    v29 = v17;
    memset();
    v13 = a2;
    v15 = a3;
    v14 = v27;
    v17 = v29;
  }
  if ( (v13[1] & 1) == 0 )
  {
    v18 = *v13;
    v19 = (__int64 *)((char *)v13 - *v13);
    v20 = v19[1] & 0xFFFFFFFFFFFFFFF8LL;
    if ( v20 != v18 )
      malloc_printerr((__int64)"corrupted size vs. prev_size while consolidating", a4, a5, a6, a7, a8, a9, a10, a11);
    v22 = v19;
    v24 = v15 + v20;
    v26 = v14;
    v28 = v17;
    unlink_chunk_isra_0(v19, a4, a5, a6, a7, a8, a9, a10, a11);
    v13 = v22;
    v15 = v24;
    v14 = v26;
    v17 = v28;
  }
  result = int_free_create_chunk(a1, v13, v15, v14, v17, a4, a5, a6, a7, a8, a9, a10, a11);
  if ( result > 0xFFFF )
    return int_free_maybe_consolidate_part_0(a1);
  return result;
}
// 40F9EC: variable 'a4' is possibly undefined
// 40F9EC: variable 'a5' is possibly undefined
// 40F9EC: variable 'a6' is possibly undefined
// 40F9EC: variable 'a7' is possibly undefined
// 40F9EC: variable 'a8' is possibly undefined
// 40F9EC: variable 'a9' is possibly undefined
// 40F9EC: variable 'a10' is possibly undefined
// 40F9EC: variable 'a11' is possibly undefined
// 40FAA0: using guessed type __int64 int_free_chunk(void);
// 496B00: using guessed type int perturb_byte;

//----- (000000000040FAA0) ----------------------------------------------------
void __fastcall int_free_chunk(
        _DWORD *a1,
        __int64 *a2,
        unsigned __int64 a3,
        int a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  _DWORD *v12; // x4
  unsigned __int8 v15; // w23
  char *v16; // x22
  unsigned __int64 v17; // x0
  unsigned __int64 v18; // x22
  unsigned int v19; // w24
  _DWORD *v20; // x0
  __int64 *v21; // x20
  __int64 v22; // x1
  __int64 v23; // x2
  __int64 v24; // x3
  void *v25; // x4
  void *v26; // x5
  void *v27; // x6
  double v28; // d0
  double v29; // d1
  double v30; // d2
  double v31; // d3
  double v32; // d4
  double v33; // d5
  double v34; // d6
  double v35; // d7
  int v36; // w0
  __int64 v37; // x1
  __int64 v38; // x2
  __int64 v39; // x3
  void *v40; // x4
  void *v41; // x5
  void *v42; // x6
  int v43; // w0
  __int64 *v44; // x0
  __int64 v45; // x1
  __int64 v46; // x2
  __int64 v47; // x3
  void *v48; // x5
  void *v49; // x6
  double v50; // d0
  double v51; // d1
  double v52; // d2
  double v53; // d3
  double v54; // d4
  double v55; // d5
  double v56; // d6
  double v57; // d7
  _QWORD *v58; // x4
  int v59; // w0
  unsigned __int64 v60; // x0
  __int64 v61; // x1
  __int64 v62; // x2
  __int64 v63; // x3
  void *v64; // x5
  void *v65; // x6
  int v66; // w0
  __int64 v67; // x1
  __int64 v68; // x2
  __int64 v69; // x3
  void *v70; // x4
  void *v71; // x5
  void *v72; // x6
  int v73; // w0
  _DWORD *v75; // [xsp+48h] [xbp+48h]
  _DWORD *v76; // [xsp+48h] [xbp+48h]
  void *v77; // [xsp+48h] [xbp+48h]
  _DWORD *v78; // [xsp+48h] [xbp+48h]

  v12 = a1;
  v15 = a4;
  if ( a3 > (unsigned __int8)global_max_fast )
  {
    if ( (a2[1] & 2) != 0 )
    {
      munmap_chunk(a2, a5, a6, a7, a8, a9, a10, a11, a12);
    }
    else if ( _libc_single_threaded || a4 )
    {
      int_free_merge_chunk((__int64)a1, a2, a3, a5, a6, a7, a8, a9, a10, a11, a12);
    }
    else
    {
      _aarch64_cas4_acq();
      if ( v36 )
        _lll_lock_wait_private(a1, v28, v29, v30, v31, v32, v33, v34, v35, v22, v23, v24, v25, v26, v27);
      int_free_merge_chunk((__int64)a1, a2, a3, v28, v29, v30, v31, v32, v33, v34, v35);
      _aarch64_swp4_rel();
      if ( v43 > 1 )
        _lll_lock_wake_private(a1, v37, v38, v39, v40, v41, v42);
    }
    return;
  }
  v16 = (char *)a2 + a3;
  v17 = *(__int64 *)((char *)a2 + a3 + 8);
  if ( v17 <= 0x10 || (v17 & 0xFFFFFFFFFFFFFFF8LL) >= *((_QWORD *)v12 + 273) )
  {
    if ( !a4 )
    {
      v75 = v12;
      _aarch64_cas4_acq();
      v58 = v75;
      if ( v59 )
      {
        _lll_lock_wait_private(v75, v50, v51, v52, v53, v54, v55, v56, v57, v45, v46, v47, v75, v48, v49);
        v58 = v75;
      }
      v60 = *((_QWORD *)v16 + 1);
      if ( v60 > 0x10 && (v60 & 0xFFFFFFFFFFFFFFF8LL) < v58[273] )
      {
        v76 = v58;
        _aarch64_swp4_rel();
        v12 = v76;
        if ( v66 > 1 )
        {
          _lll_lock_wake_private(v76, v61, v62, v63, v76, v64, v65);
          v12 = v76;
        }
        goto LABEL_4;
      }
      v77 = v58;
      _aarch64_swp4_rel();
      if ( v73 > 1 )
        _lll_lock_wake_private(v77, v67, v68, v69, v70, v71, v72);
    }
    malloc_printerr((__int64)"free(): invalid next size (fast)", a5, a6, a7, a8, a9, a10, a11, a12);
  }
LABEL_4:
  v18 = (unsigned __int64)(a2 + 2);
  if ( perturb_byte )
  {
    v78 = v12;
    memset();
    v12 = v78;
  }
  v12[2] = 1;
  v19 = (unsigned int)a3 >> 4;
  v20 = &v12[2 * ((unsigned int)a3 >> 4) - 4];
  v21 = (__int64 *)*((_QWORD *)v20 + 2);
  if ( !_libc_single_threaded )
  {
    while ( v21 != a2 )
    {
      a2[2] = (unsigned __int64)v21 ^ (v18 >> 12);
      _aarch64_cas8_rel();
      if ( v21 == v44 )
        goto LABEL_9;
      v21 = v44;
    }
LABEL_24:
    malloc_printerr((__int64)"double free or corruption (fasttop)", a5, a6, a7, a8, a9, a10, a11, a12);
  }
  if ( a2 == v21 )
    goto LABEL_24;
  a2[2] = (unsigned __int64)v21 ^ (v18 >> 12);
  *((_QWORD *)v20 + 2) = a2;
LABEL_9:
  if ( (v15 & (v21 != 0LL)) != 0 && v19 != (unsigned int)v21[1] >> 4 )
    malloc_printerr((__int64)"invalid fastbin entry (free)", a5, a6, a7, a8, a9, a10, a11, a12);
}
// 40FBA8: variable 'v36' is possibly undefined
// 40FD30: variable 'v28' is possibly undefined
// 40FD30: variable 'v29' is possibly undefined
// 40FD30: variable 'v30' is possibly undefined
// 40FD30: variable 'v31' is possibly undefined
// 40FD30: variable 'v32' is possibly undefined
// 40FD30: variable 'v33' is possibly undefined
// 40FD30: variable 'v34' is possibly undefined
// 40FD30: variable 'v35' is possibly undefined
// 40FD30: variable 'v22' is possibly undefined
// 40FD30: variable 'v23' is possibly undefined
// 40FD30: variable 'v24' is possibly undefined
// 40FD30: variable 'v25' is possibly undefined
// 40FD30: variable 'v26' is possibly undefined
// 40FD30: variable 'v27' is possibly undefined
// 40FBD4: variable 'v43' is possibly undefined
// 40FBEC: variable 'v37' is possibly undefined
// 40FBEC: variable 'v38' is possibly undefined
// 40FBEC: variable 'v39' is possibly undefined
// 40FBEC: variable 'v40' is possibly undefined
// 40FBEC: variable 'v41' is possibly undefined
// 40FBEC: variable 'v42' is possibly undefined
// 40FC38: variable 'v44' is possibly undefined
// 40FC50: variable 'a5' is possibly undefined
// 40FC50: variable 'a6' is possibly undefined
// 40FC50: variable 'a7' is possibly undefined
// 40FC50: variable 'a8' is possibly undefined
// 40FC50: variable 'a9' is possibly undefined
// 40FC50: variable 'a10' is possibly undefined
// 40FC50: variable 'a11' is possibly undefined
// 40FC50: variable 'a12' is possibly undefined
// 40FC88: variable 'v59' is possibly undefined
// 40FD20: variable 'v50' is possibly undefined
// 40FD20: variable 'v51' is possibly undefined
// 40FD20: variable 'v52' is possibly undefined
// 40FD20: variable 'v53' is possibly undefined
// 40FD20: variable 'v54' is possibly undefined
// 40FD20: variable 'v55' is possibly undefined
// 40FD20: variable 'v56' is possibly undefined
// 40FD20: variable 'v57' is possibly undefined
// 40FD20: variable 'v45' is possibly undefined
// 40FD20: variable 'v46' is possibly undefined
// 40FD20: variable 'v47' is possibly undefined
// 40FD20: variable 'v48' is possibly undefined
// 40FD20: variable 'v49' is possibly undefined
// 40FCC0: variable 'v66' is possibly undefined
// 40FCC8: variable 'v61' is possibly undefined
// 40FCC8: variable 'v62' is possibly undefined
// 40FCC8: variable 'v63' is possibly undefined
// 40FCC8: variable 'v64' is possibly undefined
// 40FCC8: variable 'v65' is possibly undefined
// 40FCE8: variable 'v73' is possibly undefined
// 40FD3C: variable 'v67' is possibly undefined
// 40FD3C: variable 'v68' is possibly undefined
// 40FD3C: variable 'v69' is possibly undefined
// 40FD3C: variable 'v70' is possibly undefined
// 40FD3C: variable 'v71' is possibly undefined
// 40FD3C: variable 'v72' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;
// 496B00: using guessed type int perturb_byte;
// 496B04: using guessed type char global_max_fast;

//----- (000000000040FD44) ----------------------------------------------------
__int64 __fastcall sysmalloc(unsigned __int64 a1, __int64 (__fastcall **a2)())
{
  __int64 v4; // x23
  int v5; // w25
  unsigned __int64 v6; // x7
  __int64 *v7; // x22
  __int64 v8; // x1
  unsigned __int64 v9; // x20
  unsigned __int64 v10; // x9
  __int64 (__fastcall **v12)(); // x6
  unsigned __int64 v13; // x2
  __int64 v14; // x4
  _QWORD *v15; // x4
  __int64 v16; // x8
  unsigned __int64 v17; // x5
  unsigned __int64 v18; // x0
  unsigned __int64 v19; // x3
  __int64 (__fastcall *v20)(); // x0
  unsigned __int64 v21; // x0
  __int64 result; // x0
  _QWORD *v23; // x0
  double v24; // d0
  double v25; // d1
  double v26; // d2
  double v27; // d3
  double v28; // d4
  double v29; // d5
  double v30; // d6
  double v31; // d7
  __int64 v32; // x2
  __int64 (__fastcall *v33)(); // x1
  unsigned __int64 v34; // x2
  unsigned __int64 v35; // x0
  unsigned __int64 v36; // x0
  __int64 v37; // x4
  unsigned __int64 v38; // x0
  size_t v39; // x4
  __int64 v40; // x5
  int v41; // w10
  __int64 (__fastcall *v42)(); // x1
  __int64 (__fastcall **v43)(); // x2
  unsigned __int64 v44; // x23
  unsigned __int64 v45; // x4
  unsigned __int64 v46; // x0
  char *v47; // x1
  __int64 v48; // x0
  unsigned __int64 v49; // x2
  __int64 v50; // x23
  unsigned __int64 v51; // x20
  unsigned __int64 v52; // x0
  __int64 v53; // x5
  __int64 v54; // x4
  unsigned __int16 v55; // w1
  __int64 (__fastcall **v56)(); // x20
  int v57; // w0
  __int64 v58; // x20
  void *v59; // x0
  size_t v60; // x1
  unsigned __int64 v61; // x0
  bool v62; // cc
  unsigned __int64 v63; // x1
  unsigned __int64 v64; // x25
  unsigned __int64 v65; // x0
  void *v66; // x0
  size_t v67; // x1
  __int64 v68; // x0
  unsigned __int64 v69; // [xsp+58h] [xbp+58h]
  unsigned __int64 v70; // [xsp+58h] [xbp+58h]
  unsigned __int64 v71; // [xsp+58h] [xbp+58h]
  _QWORD *v72; // [xsp+58h] [xbp+58h]
  char *v73; // [xsp+58h] [xbp+58h]
  unsigned __int64 v74; // [xsp+58h] [xbp+58h]
  unsigned __int64 v75; // [xsp+58h] [xbp+58h]
  __int64 v76; // [xsp+58h] [xbp+58h]
  unsigned __int64 v77; // [xsp+58h] [xbp+58h]
  unsigned __int64 v78; // [xsp+60h] [xbp+60h]
  size_t v79; // [xsp+60h] [xbp+60h]
  unsigned __int64 v80; // [xsp+60h] [xbp+60h]
  __int64 (__fastcall **v81)(); // [xsp+60h] [xbp+60h]
  unsigned __int64 v82; // [xsp+60h] [xbp+60h]
  unsigned __int64 v83; // [xsp+60h] [xbp+60h]
  _QWORD *v84; // [xsp+68h] [xbp+68h]
  unsigned __int64 v85; // [xsp+68h] [xbp+68h]
  unsigned __int64 v86; // [xsp+68h] [xbp+68h]
  unsigned __int64 v87; // [xsp+68h] [xbp+68h]
  unsigned __int64 v88; // [xsp+68h] [xbp+68h]
  __int64 v89; // [xsp+68h] [xbp+68h]
  __int64 v90; // [xsp+68h] [xbp+68h]
  __int64 v91; // [xsp+70h] [xbp+70h]
  unsigned __int64 v92; // [xsp+70h] [xbp+70h]
  unsigned __int64 v93; // [xsp+70h] [xbp+70h]
  unsigned __int64 v94; // [xsp+70h] [xbp+70h]
  unsigned __int64 v95; // [xsp+70h] [xbp+70h]
  unsigned __int64 v96; // [xsp+70h] [xbp+70h]
  unsigned __int64 v97; // [xsp+70h] [xbp+70h]
  unsigned __int64 v98; // [xsp+78h] [xbp+78h]
  size_t v99; // [xsp+88h] [xbp+88h] BYREF

  v4 = dl_pagesize;
  if ( a2 && (qword_4905E8 > a1 || dword_490614 >= dword_490618) )
  {
    v5 = 0;
  }
  else
  {
    if ( a1 > qword_490608 - 1 )
    {
      result = sysmalloc_mmap_isra_0(a1, qword_490608, dword_490610);
      if ( result != -1 )
        return result;
    }
    result = sysmalloc_mmap_isra_0(a1, v4, 0);
    if ( result != -1 )
      return result;
    v5 = 1;
    if ( !a2 )
      return 0LL;
  }
  v6 = a1 + 32;
  v7 = (__int64 *)a2[12];
  v8 = v7[1];
  v9 = v8 & 0xFFFFFFFFFFFFFFF8LL;
  v10 = (unsigned __int64)v7 + (v8 & 0xFFFFFFFFFFFFFFF8LL);
  if ( (v8 & 0xFFFFFFFFFFFFFFF8LL) != 0 || a2 + 12 != (__int64 (__fastcall **)())v7 )
  {
    if ( v9 <= 0x1F || (v8 & 1) == 0 || (v10 & (v4 - 1)) != 0 )
      _libc_assert_fail(
        (__int64)"(old_top == initial_top (av) && old_size == 0) || ((unsigned long) (old_size) >= MINSIZE && prev_inuse "
                 "(old_top) && ((unsigned long) old_end & (pagesize - 1)) == 0)",
        (__int64)"malloc.c",
        0xA29u,
        (__int64)"sysmalloc");
    v6 = a1 + 32;
    if ( a1 + 32 <= v9 )
      _libc_assert_fail(
        (__int64)"(unsigned long) (old_size) < (unsigned long) (nb + MINSIZE)",
        (__int64)"malloc.c",
        0xA2Fu,
        (__int64)"sysmalloc");
  }
  v12 = off_490000;
  if ( a2 == (__int64 (__fastcall **)())&main_arena )
  {
    v36 = qword_4905E0 + 32 + a1;
    if ( (*((_DWORD *)a2 + 1) & 2LL) == 0 )
      v36 -= v9;
    if ( qword_490600 )
      v37 = ((_curbrk + v36 + qword_490600 - 1) & -qword_490600) - _curbrk;
    else
      v37 = (dl_pagesize - 1 + v36) & -dl_pagesize;
    v99 = v37;
    if ( v37 <= 0
      || (_always_fail_morecore & 1) != 0
      || (v73 = (char *)v7 + (v8 & 0xFFFFFFFFFFFFFFF8LL),
          v87 = v6,
          v92 = v37,
          v19 = sbrk(v37),
          v12 = off_490000,
          v6 = v87,
          v10 = (unsigned __int64)v73,
          v19 - 1 > 0xFFFFFFFFFFFFFFFDLL) )
    {
      if ( !qword_490608
        || (v80 = v10,
            v94 = v6,
            v61 = sysmalloc_mmap_fallback_constprop_0(&v99, a1, v9, qword_490608, qword_490608, dword_490610),
            v12 = off_490000,
            v10 = v80,
            v19 = v61,
            v6 = v94,
            v61 == -1LL) )
      {
        v70 = v10;
        v85 = v6;
        v38 = sysmalloc_mmap_fallback_constprop_0(&v99, a1, v9, 0x100000uLL, v4, 0);
        v6 = v85;
        v19 = v38;
        v10 = v70;
        v12 = off_490000;
        if ( v38 == -1LL )
          goto LABEL_71;
      }
      if ( !v19 )
        goto LABEL_71;
      v39 = v99;
      v40 = v19 + v99;
      if ( !qword_490638 )
        qword_490638 = v19;
      v41 = 0;
      v42 = (__int64 (__fastcall *)())((char *)v12[479] + v99);
      v12[479] = v42;
    }
    else
    {
      v39 = v92;
      if ( qword_490600 - 1 < v92 )
      {
        v74 = v19;
        v79 = v92;
        v59 = (void *)(v19 & -dl_pagesize);
        v60 = ((dl_pagesize - 1) & v19) + v92;
        if ( ((dl_pagesize - 1) & v19) == 0 )
        {
          v60 = v92;
          v59 = (void *)v19;
        }
        v93 = v10;
        madvise(v59, v60, 14);
        v19 = v74;
        v39 = v79;
        v12 = off_490000;
        v10 = v93;
        v6 = v87;
      }
      if ( !qword_490638 )
        qword_490638 = v19;
      v42 = (__int64 (__fastcall *)())((char *)v12[479] + v39);
      v12[479] = v42;
      if ( v10 == v19 )
      {
        v19 = (unsigned __int64)v12[218];
        v7[1] = (v9 + v39) | 1;
        goto LABEL_19;
      }
      v40 = 0LL;
      v41 = 1;
    }
    v43 = v12 + 206;
    if ( (*((_DWORD *)v12 + 413) & 2) != 0 )
    {
      v44 = v19 & 0xF;
      if ( (v19 & 0xF) != 0 )
        _libc_assert_fail(
          (__int64)"((unsigned long) chunk2mem (brk) & MALLOC_ALIGN_MASK) == 0",
          (__int64)"malloc.c",
          0xB21u,
          (__int64)"sysmalloc");
      v45 = 0LL;
      if ( !v41 )
        goto LABEL_47;
      if ( (_always_fail_morecore & 1) != 0 )
        goto LABEL_115;
      v77 = v19;
      v81 = v12 + 206;
      v88 = v6;
      v68 = sbrk(0LL);
      v6 = v88;
      v40 = v68;
      v64 = v77;
      v43 = v81;
      v12 = off_490000;
      if ( v68 == -1 )
      {
LABEL_115:
        v19 = (unsigned __int64)v43[12];
        goto LABEL_19;
      }
    }
    else
    {
      if ( v9 )
        v62 = v10 > v19;
      else
        v62 = 0;
      if ( v62 )
        malloc_printerr((__int64)"break adjusted to free malloc space", v24, v25, v26, v27, v28, v29, v30, v31);
      if ( v9 )
        v12[479] = (__int64 (__fastcall *)())((char *)v42 + v19 - v10);
      v63 = v19 & 0xF;
      if ( (v19 & 0xF) != 0 )
      {
        v64 = v19 + 16 - v63;
        v65 = 16 - v63 + v9;
      }
      else
      {
        v65 = v9;
        v64 = v19;
      }
      v44 = ((v4 - 1 + v19 + v39 + v65) & -v4) - (v19 + v39);
      if ( (v44 & 0x8000000000000000LL) != 0 )
        _libc_assert_fail((__int64)"correction >= 0", (__int64)"malloc.c", 0xB06u, (__int64)"sysmalloc");
      if ( (_always_fail_morecore & 1) != 0 )
        goto LABEL_71;
      v95 = v6;
      v40 = sbrk(v44);
      v12 = off_490000;
      v45 = v44;
      v6 = v95;
      if ( (unsigned __int64)(v40 - 1) <= 0xFFFFFFFFFFFFFFFDLL )
      {
        if ( v44 > qword_490600 - 1 )
        {
          v76 = v40;
          v66 = (void *)(v40 & -dl_pagesize);
          v67 = v44 + ((dl_pagesize - 1) & v40);
          if ( ((dl_pagesize - 1) & v40) == 0 )
          {
            v66 = (void *)v40;
            v67 = v44;
          }
          madvise(v66, v67, 14);
          v6 = v95;
          v19 = v64;
          v40 = v76;
          v45 = v44;
          v12 = off_490000;
        }
        else
        {
          v19 = v64;
        }
LABEL_47:
        v12[218] = (__int64 (__fastcall *)())v19;
        *(_QWORD *)(v19 + 8) = (v40 - v19 + v45) | 1;
        v12[479] = (__int64 (__fastcall *)())((char *)v12[479] + v44);
        if ( !v9 )
          goto LABEL_19;
        v46 = (v9 - 32) & 0xFFFFFFFFFFFFFFF0LL;
        v7[1] = v46 | 1;
        v47 = (char *)v7 + v46;
        *((_QWORD *)v47 + 1) = 17LL;
        *((_QWORD *)v47 + 3) = 17LL;
        if ( v46 <= 0x1F )
          goto LABEL_19;
        v48 = v7[1];
        v49 = v48 & 0xFFFFFFFFFFFFFFF8LL;
        if ( (unsigned __int64)v7 <= -(__int64)(v48 & 0xFFFFFFFFFFFFFFF8LL) && ((unsigned __int8)v7 & 0xF) == 0 )
        {
          if ( v49 <= 0x1F || (v48 & 8) != 0 )
            malloc_printerr((__int64)"free(): invalid size", v24, v25, v26, v27, v28, v29, v30, v31);
          v50 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 48);
          if ( !v50 )
            goto LABEL_58;
          v51 = (v49 - 17) >> 4;
          if ( v51 >= qword_490640 )
            goto LABEL_58;
          v52 = (unsigned __int64)(v7 + 2);
          v53 = tcache_key;
          if ( v7[3] == tcache_key )
          {
            v83 = v49;
            v90 = tcache_key;
            v97 = v19;
            v98 = v6;
            tcache_double_free_verify((_QWORD *)v52, v51, v24, v25, v26, v27, v28, v29, v30, v31);
            v6 = v98;
            v12 = off_490000;
            v52 = (unsigned __int64)(v7 + 2);
            v49 = v83;
            v53 = v90;
            v19 = v97;
          }
          v54 = 2 * v51;
          v55 = *(_WORD *)(v50 + 2 * v51);
          if ( qword_490650 <= (unsigned __int64)v55 )
          {
LABEL_58:
            v56 = v12 + 206;
            v71 = v6;
            int_free_chunk((_DWORD *)v12 + 412, v7, v49, 1, v24, v25, v26, v27, v28, v29, v30, v31);
            v6 = v71;
            v12 = off_490000;
            v19 = (unsigned __int64)v56[12];
            goto LABEL_19;
          }
LABEL_68:
          v58 = v50 + 8 * v51;
          v7[2] = *(_QWORD *)(v58 + 128) ^ (v52 >> 12);
          v7[3] = v53;
          *(_QWORD *)(v58 + 128) = v52;
          *(_WORD *)(v50 + v54) = v55 + 1;
          goto LABEL_19;
        }
LABEL_110:
        malloc_printerr((__int64)"free(): invalid pointer", v24, v25, v26, v27, v28, v29, v30, v31);
      }
      if ( (_always_fail_morecore & 1) != 0 || (v40 = sbrk(0LL), v6 = v95, v12 = off_490000, v40 == -1) )
      {
LABEL_71:
        v19 = (unsigned __int64)v12[218];
        goto LABEL_19;
      }
    }
    if ( v40 )
    {
      v19 = v64;
      v44 = 0LL;
      v45 = 0LL;
      goto LABEL_47;
    }
    goto LABEL_71;
  }
  if ( qword_490608 )
  {
    v13 = 4 * qword_490608;
    v14 = -4 * qword_490608;
  }
  else
  {
    v14 = -67108864LL;
    v13 = 0x4000000LL;
  }
  v15 = (_QWORD *)((unsigned __int64)v7 & v14);
  if ( (__int64)(v6 - v9) <= 0 )
    goto LABEL_29;
  v16 = v15[2];
  v17 = ((v6 - v9 - 1 + v15[4]) & -v15[4]) + v16;
  if ( v13 < v17 )
    goto LABEL_29;
  v18 = v15[3];
  v19 = (unsigned __int64)a2[12];
  if ( v17 > v18 )
  {
    v72 = v15;
    v78 = v6;
    v86 = ((v6 - v9 - 1 + v15[4]) & -v15[4]) + v16;
    v91 = v15[2];
    v57 = mprotect((char *)v15 + v18, v17 - v18, 3);
    v12 = off_490000;
    v15 = v72;
    v6 = v78;
    if ( !v57 )
    {
      v17 = v86;
      v16 = v91;
      v19 = (unsigned __int64)a2[12];
      v72[3] = v86;
      goto LABEL_18;
    }
LABEL_29:
    v84 = v15;
    v69 = v6;
    v23 = (_QWORD *)new_heap(a1 + 80, qword_4905E0);
    v6 = v69;
    v12 = off_490000;
    if ( !v23 )
    {
      if ( v5 )
      {
        v19 = (unsigned __int64)a2[12];
      }
      else
      {
        result = sysmalloc_mmap_isra_0(a1, v4, 0);
        if ( result != -1 )
          return result;
        v6 = v69;
        v12 = off_490000;
        v19 = (unsigned __int64)a2[12];
      }
      goto LABEL_19;
    }
    *v23 = a2;
    v23[1] = v84;
    v19 = (unsigned __int64)(v23 + 6);
    v32 = v23[2];
    v33 = a2[273];
    a2[12] = (__int64 (__fastcall *)())(v23 + 6);
    a2[273] = (__int64 (__fastcall *)())((char *)v33 + v32);
    v34 = (v9 - 32) & 0xFFFFFFFFFFFFFFF0LL;
    v23[7] = (v23[2] - 48LL) | 1;
    v35 = v34 + 16;
    *(__int64 *)((char *)v7 + v34 + 24) = 1LL;
    if ( v34 <= 0x1F )
    {
      v7[1] = v35 | 1;
      *(__int64 *)((char *)v7 + v35) = v35;
      goto LABEL_19;
    }
    *(_OWORD *)((char *)v7 + v34 + 8) = xmmword_45B780;
    v7[1] = v34 | 5;
    if ( (unsigned __int64)v7 <= -(__int64)v34 && ((unsigned __int8)v7 & 0xF) == 0 )
    {
      v50 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 48);
      if ( !v50 )
        goto LABEL_102;
      v51 = (v34 - 17) >> 4;
      if ( v51 >= qword_490640 )
        goto LABEL_102;
      v52 = (unsigned __int64)(v7 + 2);
      v53 = tcache_key;
      if ( v7[3] == tcache_key )
      {
        v82 = v34;
        v89 = tcache_key;
        v96 = v19;
        tcache_double_free_verify((_QWORD *)v52, (v34 - 17) >> 4, v24, v25, v26, v27, v28, v29, v30, v31);
        v6 = v69;
        v12 = off_490000;
        v52 = (unsigned __int64)(v7 + 2);
        v34 = v82;
        v53 = v89;
        v19 = v96;
      }
      v54 = 2 * v51;
      v55 = *(_WORD *)(v50 + 2 * v51);
      if ( qword_490650 <= (unsigned __int64)v55 )
      {
LABEL_102:
        v75 = v6;
        int_free_chunk(a2, v7, v34, 1, v24, v25, v26, v27, v28, v29, v30, v31);
        v6 = v75;
        v12 = off_490000;
        v19 = (unsigned __int64)a2[12];
        goto LABEL_19;
      }
      goto LABEL_68;
    }
    goto LABEL_110;
  }
LABEL_18:
  v15[2] = v17;
  a2[273] = (__int64 (__fastcall *)())((char *)a2[273] + v17 - v16);
  v7[1] = ((char *)v15 + v15[2] - (char *)v7) | 1;
LABEL_19:
  v20 = a2[273];
  if ( (unsigned __int64)v20 > (unsigned __int64)a2[274] )
    a2[274] = v20;
  v21 = *(_QWORD *)(v19 + 8) & 0xFFFFFFFFFFFFFFF8LL;
  if ( v21 < v6 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 12;
    return 0LL;
  }
  else
  {
    a2[12] = (__int64 (__fastcall *)())(v19 + a1);
    *(_QWORD *)(v19 + 8) = a1 | (4LL * (a2 != v12 + 206)) | 1;
    *(_QWORD *)(v19 + a1 + 8) = (v21 - a1) | 1;
    return v19 + 16;
  }
}
// 410658: variable 'v24' is possibly undefined
// 410658: variable 'v25' is possibly undefined
// 410658: variable 'v26' is possibly undefined
// 410658: variable 'v27' is possibly undefined
// 410658: variable 'v28' is possibly undefined
// 410658: variable 'v29' is possibly undefined
// 410658: variable 'v30' is possibly undefined
// 410658: variable 'v31' is possibly undefined
// 4106C8: using guessed type __int64 int_malloc(void);
// 45B780: using guessed type __int128 xmmword_45B780;
// 490000: using guessed type __int64 (__fastcall *off_490000[5])();
// 4905E0: using guessed type __int64 qword_4905E0;
// 4905E8: using guessed type __int64 qword_4905E8;
// 490600: using guessed type __int64 qword_490600;
// 490608: using guessed type __int64 qword_490608;
// 490610: using guessed type int dword_490610;
// 490614: using guessed type int dword_490614;
// 490618: using guessed type int dword_490618;
// 490638: using guessed type __int64 qword_490638;
// 490640: using guessed type __int64 qword_490640;
// 490650: using guessed type __int64 qword_490650;
// 490670: using guessed type int main_arena;
// 490F10: using guessed type __int64 dl_pagesize;
// 496B08: using guessed type __int64 tcache_key;
// 496B10: using guessed type char _always_fail_morecore;
// 496B60: using guessed type __int64 _curbrk;

//----- (00000000004106C8) ----------------------------------------------------
unsigned __int64 __fastcall int_malloc(
        int *a1,
        __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  unsigned __int64 v11; // x27
  unsigned int v12; // w28
  int *v13; // x23
  __int64 v14; // x19
  unsigned __int64 v15; // x20
  __int64 *v16; // x25
  unsigned __int64 v17; // x19
  unsigned __int64 v18; // x0
  __int64 v19; // x19
  unsigned __int64 v20; // x4
  unsigned __int64 v21; // x5
  __int64 v22; // x1
  __int64 v23; // x2
  unsigned int v24; // w0
  __int64 v25; // x27
  __int64 v26; // x0
  unsigned __int64 v27; // x26
  unsigned __int64 v28; // x1
  __int64 v29; // x0
  __int64 v30; // x0
  unsigned __int64 StatusReg; // x4
  unsigned __int64 v32; // x26
  unsigned __int64 v33; // x22
  int *v34; // x1
  int *v35; // x19
  unsigned __int64 v36; // x23
  int v37; // w5
  int v38; // w6
  unsigned __int64 v39; // x0
  unsigned __int64 v40; // x3
  unsigned __int64 *v41; // x7
  unsigned __int64 v42; // x2
  int *v44; // x3
  bool v45; // zf
  signed int v46; // w7
  __int64 v47; // x3
  int *v48; // x3
  int *v49; // x2
  int *v50; // x3
  int *v51; // t1
  int *v52; // x8
  unsigned __int64 v53; // x9
  unsigned __int64 v54; // x0
  __int64 v55; // x0
  int v57; // w2
  int *v58; // x1
  int *v59; // x0
  int *v60; // x1
  int *v61; // t1
  unsigned int v62; // w5
  int *v63; // x2
  int v64; // w1
  unsigned int v65; // w3
  __int64 v66; // x28
  __int64 v67; // x0
  __int64 v68; // x2
  __int64 v69; // x1
  __int64 v70; // x1
  __int64 v71; // x0
  __int64 v72; // x2
  __int64 v73; // x7
  unsigned __int64 v74; // x5
  unsigned __int64 v75; // x4
  _WORD *v76; // x9
  unsigned int v77; // w6
  _QWORD *v78; // x2
  __int64 v79; // x2
  unsigned __int16 v80; // w0
  __int64 v82; // x7
  int *v83; // x8
  int *v84; // t1
  _QWORD *i; // x20
  __int64 v86; // x2
  unsigned __int64 v87; // x22
  unsigned __int64 v88; // x23
  double v89; // d0
  double v90; // d1
  double v91; // d2
  double v92; // d3
  double v93; // d4
  double v94; // d5
  double v95; // d6
  double v96; // d7
  __int64 v97; // x1
  _QWORD *v98; // x0
  __int64 v99; // x10
  __int64 v100; // x10
  unsigned __int64 v101; // x3
  __int64 v102; // x0
  unsigned int v103; // w0
  int *v104; // x1
  __int64 v105; // x0
  unsigned __int64 v106; // x1
  unsigned __int64 v107; // x28
  unsigned __int64 v108; // x7
  unsigned __int64 v109; // x20
  unsigned __int64 v110; // x22
  double v111; // d0
  double v112; // d1
  double v113; // d2
  double v114; // d3
  double v115; // d4
  double v116; // d5
  double v117; // d6
  double v118; // d7
  __int64 v119; // x1
  _QWORD *v120; // x0
  __int64 v121; // x0
  __int64 v122; // x2
  unsigned __int64 v123; // x28
  _QWORD *v124; // x2
  unsigned __int64 v125; // x0
  unsigned int v126; // w2
  unsigned __int64 v127; // [xsp+60h] [xbp+60h]
  __int64 v128; // [xsp+68h] [xbp+68h]

  if ( a2 < 0 )
  {
    v15 = 0LL;
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 12;
    return v15;
  }
  if ( (unsigned __int64)(a2 + 23) <= 0x1F )
  {
    if ( a1 )
    {
      if ( (unsigned __int8)global_max_fast <= 0x1Fu )
      {
        v69 = 32LL;
        v12 = 2;
        v11 = 32LL;
        goto LABEL_88;
      }
      v13 = a1;
      v12 = 2;
      v11 = 32LL;
      v14 = *((_QWORD *)a1 + 2);
      if ( v14 )
        goto LABEL_6;
      goto LABEL_107;
    }
    v11 = 32LL;
  }
  else
  {
    v11 = (a2 + 23) & 0xFFFFFFFFFFFFFFF0LL;
    if ( a1 )
    {
      if ( v11 > (unsigned __int8)global_max_fast )
      {
        if ( v11 > 0x3FF )
        {
          v12 = (v11 >> 6) + 48;
          if ( v11 > 0xC3F )
          {
            if ( v11 >> 9 > 0x14 )
            {
              if ( v11 >> 12 <= 0xA )
              {
                v12 = (v11 >> 12) + 110;
              }
              else if ( v11 >> 15 > 4 )
              {
                v107 = v11 >> 18;
                if ( v11 >> 18 > 2 )
                  LODWORD(v107) = 2;
                v12 = v107 + 124;
              }
              else
              {
                v12 = (v11 >> 15) + 119;
              }
            }
            else
            {
              v12 = (v11 >> 9) + 91;
            }
          }
          if ( a1[2] )
            malloc_consolidate((__int64)a1);
          goto LABEL_31;
        }
        v12 = (unsigned int)v11 >> 4;
        v69 = 2LL * (((unsigned int)v11 >> 3) + 12);
LABEL_88:
        v70 = (__int64)&a1[v69 - 4];
        v71 = *(_QWORD *)(v70 + 24);
        if ( v70 != v71 )
        {
          v72 = *(_QWORD *)(v71 + 24);
          if ( *(_QWORD *)(v72 + 16) != v71 )
            malloc_printerr((__int64)"malloc(): smallbin double linked list corrupted", a3, a4, a5, a6, a7, a8, a9, a10);
          *(_QWORD *)(v71 + v11 + 8) |= 1uLL;
          *(_QWORD *)(v70 + 24) = v72;
          *(_QWORD *)(v72 + 16) = v70;
          if ( a1 != &main_arena )
            *(_QWORD *)(v71 + 8) |= 4uLL;
          v73 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 48);
          if ( v73 )
          {
            v74 = (v11 - 17) >> 4;
            if ( qword_490640 > v74 )
            {
              v75 = qword_490650;
              v76 = (_WORD *)(v73 + 2LL * (unsigned int)((v11 - 17) >> 4));
              v77 = (unsigned __int16)*v76;
              while ( v77 < v75 )
              {
                v78 = *(_QWORD **)(v70 + 24);
                if ( (_QWORD *)v70 == v78 )
                  break;
                if ( v78 )
                {
                  v99 = v78[3];
                  *(_QWORD *)((char *)v78 + v11 + 8) |= 1uLL;
                  if ( a1 != &main_arena )
                    v78[1] |= 4uLL;
                  *(_QWORD *)(v70 + 24) = v99;
                  *(_QWORD *)(v99 + 16) = v70;
                  v100 = v73 + 8LL * (unsigned int)v74;
                  v78[3] = tcache_key;
                  v77 = (unsigned __int16)(v77 + 1);
                  v78[2] = *(_QWORD *)(v100 + 128) ^ ((unsigned __int64)(v78 + 2) >> 12);
                  *(_QWORD *)(v100 + 128) = v78 + 2;
                  *v76 = v77;
                }
              }
            }
          }
          v15 = v71 + 16;
          if ( !perturb_byte )
            return v15;
          goto LABEL_114;
        }
LABEL_31:
        StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
        v32 = 0LL;
        v33 = (v11 - 17) >> 4;
        if ( *(_QWORD *)(StatusReg + 48) )
        {
          if ( qword_490640 <= v33 )
            v32 = 0LL;
          else
            v32 = v11;
        }
        v34 = (int *)*((_QWORD *)a1 + 15);
        v35 = a1 + 24;
        v36 = 0LL;
        if ( v34 != a1 + 24 )
          goto LABEL_36;
        while ( 1 )
        {
          v57 = 2 * v12;
          if ( v11 <= 0x3FF )
            goto LABEL_72;
          while ( 1 )
          {
            v57 = 2 * v12;
            v58 = &a1[4 * v12 + 24];
            v61 = *(int **)v58;
            v60 = v58 - 4;
            v59 = v61;
            if ( v61 != v60 && *((_QWORD *)v59 + 1) >= v11 )
            {
              for ( i = (_QWORD *)*((_QWORD *)v59 + 5); ; i = (_QWORD *)i[5] )
              {
                v86 = i[1];
                v87 = v86 & 0xFFFFFFFFFFFFFFF8LL;
                if ( (v86 & 0xFFFFFFFFFFFFFFF8LL) >= v11 )
                  break;
              }
              if ( *((_QWORD **)v60 + 3) != i && v86 == *(_QWORD *)(i[2] + 8LL) )
                i = (_QWORD *)i[2];
              v88 = v87 - v11;
              unlink_chunk_isra_0(i, a3, a4, a5, a6, a7, a8, a9, a10);
              if ( v87 - v11 <= 0x1F )
              {
                *(_QWORD *)((char *)i + v87 + 8) |= 1uLL;
                if ( a1 != &main_arena )
                  i[1] |= 4uLL;
              }
              else
              {
                v97 = *((_QWORD *)a1 + 14);
                if ( *(int **)(v97 + 24) != v35 )
                  malloc_printerr(
                    (__int64)"malloc(): corrupted unsorted chunks",
                    v89,
                    v90,
                    v91,
                    v92,
                    v93,
                    v94,
                    v95,
                    v96);
                v98 = (_QWORD *)((char *)i + v11);
                v98[2] = v97;
                v98[3] = v35;
                *((_QWORD *)a1 + 14) = (char *)i + v11;
                *(_QWORD *)(v97 + 24) = (char *)i + v11;
                if ( v88 > 0x3FF )
                {
                  v98[4] = 0LL;
                  v98[5] = 0LL;
                }
                i[1] = v11 | (4LL * (a1 != &main_arena)) | 1;
                v98[1] = v88 | 1;
                *(_QWORD *)((char *)i + v87) = v88;
              }
              v15 = (unsigned __int64)(i + 2);
              goto LABEL_144;
            }
LABEL_72:
            v62 = (v12 + 1) >> 5;
            v63 = &a1[2 * (v57 + 14) - 4];
            v64 = 1 << (v12 + 1);
            v65 = a1[v62 + 536];
LABEL_73:
            if ( v65 > v64 - 1 )
              goto LABEL_76;
            v103 = v62 + 1;
            v104 = &a1[v62 + 1];
            while ( 1 )
            {
              v62 = v103;
              if ( v103 > 3 )
                break;
              v65 = v104[536];
              ++v104;
              if ( v65 )
              {
                v64 = 1;
                v63 = &a1[128 * v103 + 20];
LABEL_76:
                while ( (v64 & v65) == 0 )
                {
                  v63 += 4;
                  v64 *= 2;
                  if ( !v64 )
                    _libc_assert_fail((__int64)"bit != 0", (__int64)"malloc.c", 0x113Fu, (__int64)"_int_malloc");
                }
                v66 = *((_QWORD *)v63 + 3);
                if ( v63 != (int *)v66 )
                {
                  v109 = *(_QWORD *)(v66 + 8) & 0xFFFFFFFFFFFFFFF8LL;
                  if ( v109 < v11 )
                    _libc_assert_fail(
                      (__int64)"(unsigned long) (size) >= (unsigned long) (nb)",
                      (__int64)"malloc.c",
                      0x1152u,
                      (__int64)"_int_malloc");
                  v110 = v109 - v11;
                  unlink_chunk_isra_0(*((_QWORD **)v63 + 3), a3, a4, a5, a6, a7, a8, a9, a10);
                  if ( v109 - v11 <= 0x1F )
                  {
                    *(_QWORD *)(v66 + v109 + 8) |= 1uLL;
                    if ( a1 == &main_arena )
                      goto LABEL_194;
                    v15 = v66 + 16;
                    *(_QWORD *)(v66 + 8) |= 4uLL;
                  }
                  else
                  {
                    v119 = *((_QWORD *)a1 + 14);
                    if ( *(int **)(v119 + 24) != v35 )
                      malloc_printerr(
                        (__int64)"malloc(): corrupted unsorted chunks 2",
                        v111,
                        v112,
                        v113,
                        v114,
                        v115,
                        v116,
                        v117,
                        v118);
                    v120 = (_QWORD *)(v66 + v11);
                    v120[2] = v119;
                    v120[3] = v35;
                    *((_QWORD *)a1 + 14) = v66 + v11;
                    *(_QWORD *)(v119 + 24) = v66 + v11;
                    if ( v11 <= 0x3FF )
                      *((_QWORD *)a1 + 13) = v120;
                    if ( v110 > 0x3FF )
                    {
                      v120[4] = 0LL;
                      v120[5] = 0LL;
                    }
                    *(_QWORD *)(v66 + 8) = v11 | (4LL * (a1 != &main_arena)) | 1;
                    v120[1] = v110 | 1;
                    *(_QWORD *)(v66 + v109) = v110;
LABEL_194:
                    v15 = v66 + 16;
                  }
LABEL_104:
                  if ( !perturb_byte )
                    return v15;
LABEL_114:
                  memset();
                  return v15;
                }
                v65 &= ~v64;
                v63 += 4;
                v64 *= 2;
                a1[v62 + 536] = v65;
                goto LABEL_73;
              }
              ++v103;
            }
            v105 = *((_QWORD *)a1 + 12);
            v106 = *(_QWORD *)(v105 + 8) & 0xFFFFFFFFFFFFFFF8LL;
            if ( *((_QWORD *)a1 + 273) < v106 )
              malloc_printerr((__int64)"malloc(): corrupted top size", a3, a4, a5, a6, a7, a8, a9, a10);
            if ( v11 + 32 <= v106 )
            {
              *((_QWORD *)a1 + 12) = v105 + v11;
              v15 = v105 + 16;
              *(_QWORD *)(v105 + 8) = v11 | (4LL * (a1 != &main_arena)) | 1;
              *(_QWORD *)(v105 + v11 + 8) = (v106 - v11) | 1;
LABEL_144:
              alloc_perturb();
              return v15;
            }
            if ( !a1[2] )
            {
              v15 = sysmalloc(v11, (__int64 (__fastcall **)())a1);
              if ( !v15 )
                return v15;
              goto LABEL_144;
            }
            v127 = StatusReg;
            malloc_consolidate((__int64)a1);
            StatusReg = v127;
            if ( v11 <= 0x3FF )
              break;
            if ( v11 > 0xC3F )
            {
              if ( v11 >> 9 > 0x14 )
              {
                if ( v11 >> 12 > 0xA )
                {
                  if ( v11 >> 15 > 4 )
                  {
                    v34 = (int *)*((_QWORD *)a1 + 15);
                    v123 = v11 >> 18;
                    if ( v11 >> 18 > 2 )
                      LODWORD(v123) = 2;
                    v12 = v123 + 124;
                    if ( v34 != v35 )
                      goto LABEL_36;
                  }
                  else
                  {
                    v34 = (int *)*((_QWORD *)a1 + 15);
                    v12 = (v11 >> 15) + 119;
                    if ( v34 != v35 )
                      goto LABEL_36;
                  }
                }
                else
                {
                  v34 = (int *)*((_QWORD *)a1 + 15);
                  v12 = (v11 >> 12) + 110;
                  if ( v34 != v35 )
                    goto LABEL_36;
                }
              }
              else
              {
                v34 = (int *)*((_QWORD *)a1 + 15);
                v12 = (v11 >> 9) + 91;
                if ( v35 != v34 )
                  goto LABEL_36;
              }
            }
            else
            {
              v34 = (int *)*((_QWORD *)a1 + 15);
              v12 = (v11 >> 6) + 48;
              if ( v34 != v35 )
                goto LABEL_36;
            }
          }
          v34 = (int *)*((_QWORD *)a1 + 15);
          v12 = (unsigned int)v11 >> 4;
          if ( v34 == v35 )
          {
            v57 = 2 * v12;
            goto LABEL_72;
          }
LABEL_36:
          v37 = 0;
          v38 = 0;
          while ( 2 )
          {
            v39 = *((_QWORD *)v34 + 1) & 0xFFFFFFFFFFFFFFF8LL;
            if ( v39 <= 0x10 || (v40 = *((_QWORD *)a1 + 273), v40 < v39) )
              malloc_printerr((__int64)"malloc(): invalid size (unsorted)", a3, a4, a5, a6, a7, a8, a9, a10);
            v41 = (unsigned __int64 *)((char *)v34 + v39);
            v42 = *(_QWORD *)((char *)v34 + v39 + 8);
            if ( v42 <= 0xF || v40 < v42 )
              malloc_printerr((__int64)"malloc(): invalid next size (unsorted)", a3, a4, a5, a6, a7, a8, a9, a10);
            if ( (*(_QWORD *)((_BYTE *)v34 + v39) & 0xFFFFFFFFFFFFFFF8LL) != v39 )
              malloc_printerr(
                (__int64)"malloc(): mismatching next->prev_size (unsorted)",
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10);
            v44 = (int *)*((_QWORD *)v34 + 3);
            if ( v34 != *((int **)v44 + 2) || *((int **)v34 + 2) != v35 )
              malloc_printerr(
                (__int64)"malloc(): unsorted double linked list corrupted",
                a3,
                a4,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10);
            if ( (v42 & 1) != 0 )
              malloc_printerr((__int64)"malloc(): invalid next->prev_inuse (unsorted)", a3, a4, a5, a6, a7, a8, a9, a10);
            v45 = v11 <= 0x3FF && v44 == v35;
            if ( !v45 || v34 != *((int **)a1 + 13) )
            {
              *((_QWORD *)a1 + 15) = v44;
              *((_QWORD *)v44 + 2) = v35;
              if ( v39 != v11 )
              {
                if ( v39 <= 0x3FF )
                  goto LABEL_129;
                if ( v39 > 0xC3F )
                {
                  if ( v39 >> 9 <= 0x14 )
                  {
                    v46 = (v39 >> 9) + 91;
                    v47 = 2LL * (unsigned int)(2 * v46 + 12);
                  }
                  else if ( v39 >> 12 > 0xA )
                  {
                    if ( v39 >> 15 > 4 )
                    {
                      v108 = v39 >> 18;
                      if ( v39 >> 18 > 2 )
                        LODWORD(v108) = 2;
                      v46 = v108 + 124;
                      v47 = 2LL * (unsigned int)(2 * v46 + 12);
                    }
                    else
                    {
                      v46 = (v39 >> 15) + 119;
                      v47 = 2LL * (unsigned int)(2 * v46 + 12);
                    }
                  }
                  else
                  {
                    v46 = (v39 >> 12) + 110;
                    v47 = 2LL * (unsigned int)(2 * v46 + 12);
                  }
                }
                else
                {
                  v46 = (v39 >> 6) + 48;
                  v47 = 2LL * (unsigned int)(2 * v46 + 12);
                }
                goto LABEL_56;
              }
LABEL_100:
              v41[1] = v42 | 1;
              if ( a1 != &main_arena )
                *((_QWORD *)v34 + 1) |= 4uLL;
              v15 = (unsigned __int64)(v34 + 4);
              if ( !v32 )
                goto LABEL_104;
              v79 = *(_QWORD *)(StatusReg + 48);
              v80 = *(_WORD *)(v79 + 2 * v33);
              if ( qword_490650 <= (unsigned __int64)v80 )
                goto LABEL_104;
              v82 = v79 + 8 * v33;
              *((_QWORD *)v34 + 3) = tcache_key;
              *((_QWORD *)v34 + 2) = *(_QWORD *)(v82 + 128) ^ (v15 >> 12);
              *(_QWORD *)(v82 + 128) = v15;
              v38 = 1;
              *(_WORD *)(v79 + 2 * v33) = v80 + 1;
              goto LABEL_67;
            }
            if ( v11 + 32 < v39 )
            {
              v124 = (_QWORD *)((char *)v34 + v11);
              *((_QWORD *)a1 + 14) = (char *)v34 + v11;
              *((_QWORD *)a1 + 15) = (char *)v34 + v11;
              v125 = v39 - v11;
              *((_QWORD *)a1 + 13) = (char *)v34 + v11;
              v124[2] = v35;
              v124[3] = v35;
              if ( v125 > 0x3FF )
              {
                v124[4] = 0LL;
                v124[5] = 0LL;
              }
              v15 = (unsigned __int64)(v34 + 4);
              *((_QWORD *)v34 + 1) = v11 | (4LL * (a1 != &main_arena)) | 1;
              v124[1] = v125 | 1;
              *v41 = v125;
              goto LABEL_144;
            }
            *((_QWORD *)a1 + 15) = v44;
            *((_QWORD *)v44 + 2) = v35;
            if ( v39 == v11 )
              goto LABEL_100;
            v47 = 280LL;
            v46 = 64;
            if ( v39 <= 0x3FF )
            {
LABEL_129:
              v46 = (unsigned int)v39 >> 4;
              v83 = &a1[4 * ((unsigned int)v39 >> 4) + 24];
              v84 = *(int **)v83;
              v52 = v83 - 4;
              v50 = v84;
              goto LABEL_60;
            }
LABEL_56:
            v48 = &a1[v47];
            v51 = *(int **)v48;
            v50 = v48 - 4;
            v49 = v51;
            if ( v50 == v51 )
            {
              v52 = v50;
              *((_QWORD *)v34 + 4) = v34;
              *((_QWORD *)v34 + 5) = v34;
            }
            else
            {
              v52 = (int *)*((_QWORD *)v50 + 3);
              v53 = *((_QWORD *)v52 + 1);
              if ( (v53 & 4) != 0 )
                _libc_assert_fail(
                  (__int64)"chunk_main_arena (bck->bk)",
                  (__int64)"malloc.c",
                  0x108Du,
                  (__int64)"_int_malloc");
              v54 = v39 | 1;
              if ( v53 <= v54 )
              {
                v101 = *((_QWORD *)v49 + 1);
                if ( (v101 & 4) != 0 )
                {
                  v126 = 4250;
                  goto LABEL_220;
                }
                while ( v54 < v101 )
                {
                  v49 = (int *)*((_QWORD *)v49 + 4);
                  v101 = *((_QWORD *)v49 + 1);
                  if ( (v101 & 4) != 0 )
                  {
                    v126 = 4254;
LABEL_220:
                    _libc_assert_fail(
                      (__int64)"chunk_main_arena (fwd)",
                      (__int64)"malloc.c",
                      v126,
                      (__int64)"_int_malloc");
                  }
                }
                if ( v54 == v101 )
                {
                  v50 = (int *)*((_QWORD *)v49 + 2);
                }
                else
                {
                  v102 = *((_QWORD *)v49 + 5);
                  *((_QWORD *)v34 + 4) = v49;
                  *((_QWORD *)v34 + 5) = v102;
                  if ( *(int **)(v102 + 32) != v49 )
                    malloc_printerr(
                      (__int64)"malloc(): largebin double linked list corrupted (nextsize)",
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      a9,
                      a10);
                  *((_QWORD *)v49 + 5) = v34;
                  v50 = v49;
                  *(_QWORD *)(*((_QWORD *)v34 + 5) + 32LL) = v34;
                }
                v52 = (int *)*((_QWORD *)v50 + 3);
                if ( *((int **)v52 + 2) != v50 )
                  malloc_printerr(
                    (__int64)"malloc(): largebin double linked list corrupted (bk)",
                    a3,
                    a4,
                    a5,
                    a6,
                    a7,
                    a8,
                    a9,
                    a10);
              }
              else
              {
                v55 = *((_QWORD *)v49 + 5);
                *((_QWORD *)v34 + 4) = v49;
                *((_QWORD *)v34 + 5) = v55;
                *(_QWORD *)(v55 + 32) = v34;
                *((_QWORD *)v49 + 5) = v34;
              }
            }
LABEL_60:
            ++v36;
            a1[(v46 >> 5) + 536] |= 1 << v46;
            *((_QWORD *)v34 + 2) = v50;
            *((_QWORD *)v34 + 3) = v52;
            *((_QWORD *)v50 + 3) = v34;
            *((_QWORD *)v52 + 2) = v34;
            if ( v38 )
            {
              if ( qword_490658 && qword_490658 < v36 )
                goto LABEL_203;
            }
            if ( ++v37 > 9999 )
              break;
LABEL_67:
            v34 = (int *)*((_QWORD *)a1 + 15);
            if ( v34 != v35 )
              continue;
            break;
          }
          if ( v38 )
          {
LABEL_203:
            v121 = *(_QWORD *)(StatusReg + 48);
            v122 = v121 + 8 * v33;
            v15 = *(_QWORD *)(v122 + 128);
            if ( (v15 & 0xF) != 0 )
              malloc_printerr((__int64)"malloc(): unaligned tcache chunk detected", a3, a4, a5, a6, a7, a8, a9, a10);
            *(_QWORD *)(v122 + 128) = *(_QWORD *)v15 ^ (v15 >> 12);
            --*(_WORD *)(v121 + 2 * v33);
            *(_QWORD *)(v15 + 8) = 0LL;
            return v15;
          }
        }
      }
      v12 = (unsigned int)v11 >> 4;
      v13 = &a1[2 * ((unsigned int)v11 >> 4) - 4];
      v14 = *((_QWORD *)v13 + 2);
      if ( v14 )
      {
LABEL_6:
        if ( (v14 & 0xF) != 0 )
          malloc_printerr((__int64)"malloc(): unaligned fastbin chunk detected 2", a3, a4, a5, a6, a7, a8, a9, a10);
        if ( _libc_single_threaded )
        {
          v15 = v14 + 16;
          *((_QWORD *)v13 + 2) = *(_QWORD *)(v14 + 16) ^ ((unsigned __int64)(v14 + 16) >> 12);
        }
        else
        {
          while ( 1 )
          {
            v68 = *(_QWORD *)(v14 + 16);
            v15 = v14 + 16;
            if ( v68 != (unsigned __int64)(v14 + 16) >> 12 && ((v68 ^ ((unsigned __int64)(v14 + 16) >> 12)) & 0xF) != 0 )
LABEL_24:
              malloc_printerr((__int64)"malloc(): unaligned fastbin chunk detected", a3, a4, a5, a6, a7, a8, a9, a10);
            _aarch64_cas8_acq();
            if ( v14 == v67 )
              break;
            if ( !v67 )
              goto LABEL_107;
            v14 = v67;
          }
        }
        if ( v12 != (unsigned int)*(_QWORD *)(v14 + 8) >> 4 )
          malloc_printerr((__int64)"malloc(): memory corruption (fast)", a3, a4, a5, a6, a7, a8, a9, a10);
        v16 = (__int64 *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 48);
        if ( !*v16 )
          goto LABEL_104;
        v17 = (v11 - 17) >> 4;
        if ( qword_490640 <= v17 )
          goto LABEL_104;
        v18 = *(unsigned __int16 *)(*v16 + 2 * v17);
        v128 = 8LL * (unsigned int)((v11 - 17) >> 4);
        v19 = 2LL * (unsigned int)((v11 - 17) >> 4);
        if ( qword_490650 <= v18 )
          goto LABEL_104;
        while ( 1 )
        {
          v25 = *((_QWORD *)v13 + 2);
          if ( !v25 )
            goto LABEL_104;
          if ( (v25 & 0xF) != 0 )
            malloc_printerr((__int64)"malloc(): unaligned fastbin chunk detected 3", a3, a4, a5, a6, a7, a8, a9, a10);
          if ( _libc_single_threaded )
          {
            v20 = v25 + 16;
            v21 = (unsigned __int64)(v25 + 16) >> 12;
            *((_QWORD *)v13 + 2) = *(_QWORD *)(v25 + 16) ^ v21;
          }
          else
          {
            v26 = *(_QWORD *)(v25 + 16);
            v27 = v25 + 16;
            v28 = v26 ^ ((unsigned __int64)(v25 + 16) >> 12);
            if ( v26 != (unsigned __int64)(v25 + 16) >> 12 )
            {
LABEL_23:
              if ( (v28 & 0xF) != 0 )
                goto LABEL_24;
            }
            while ( 1 )
            {
              _aarch64_cas8_acq();
              if ( v25 == v29 )
                break;
              if ( !v29 )
                goto LABEL_104;
              v25 = v29;
              v27 = v29 + 16;
              v30 = *(_QWORD *)(v29 + 16);
              v28 = v30 ^ (v27 >> 12);
              if ( v30 != v27 >> 12 )
                goto LABEL_23;
            }
            v20 = v27;
            v21 = v27 >> 12;
          }
          *(_QWORD *)(v25 + 24) = tcache_key;
          v22 = *v16;
          v23 = *v16 + v128;
          *(_QWORD *)(v25 + 16) = *(_QWORD *)(v23 + 128) ^ v21;
          *(_QWORD *)(v23 + 128) = v20;
          v24 = (unsigned __int16)(*(_WORD *)(v22 + v19) + 1);
          *(_WORD *)(v22 + v19) = v24;
          if ( qword_490650 <= (unsigned __int64)v24 )
            goto LABEL_104;
        }
      }
LABEL_107:
      v69 = 2LL * (2 * v12 + 12);
      goto LABEL_88;
    }
  }
  v15 = sysmalloc(v11, 0LL);
  if ( !v15 )
    return 0LL;
  if ( perturb_byte )
    goto LABEL_114;
  return v15;
}
// 41085C: variable 'v29' is possibly undefined
// 41088C: variable 'a3' is possibly undefined
// 41088C: variable 'a4' is possibly undefined
// 41088C: variable 'a5' is possibly undefined
// 41088C: variable 'a6' is possibly undefined
// 41088C: variable 'a7' is possibly undefined
// 41088C: variable 'a8' is possibly undefined
// 41088C: variable 'a9' is possibly undefined
// 41088C: variable 'a10' is possibly undefined
// 410B10: variable 'v67' is possibly undefined
// 411438: variable 'v111' is possibly undefined
// 411438: variable 'v112' is possibly undefined
// 411438: variable 'v113' is possibly undefined
// 411438: variable 'v114' is possibly undefined
// 411438: variable 'v115' is possibly undefined
// 411438: variable 'v116' is possibly undefined
// 411438: variable 'v117' is possibly undefined
// 411438: variable 'v118' is possibly undefined
// 411470: variable 'v89' is possibly undefined
// 411470: variable 'v90' is possibly undefined
// 411470: variable 'v91' is possibly undefined
// 411470: variable 'v92' is possibly undefined
// 411470: variable 'v93' is possibly undefined
// 411470: variable 'v94' is possibly undefined
// 411470: variable 'v95' is possibly undefined
// 411470: variable 'v96' is possibly undefined
// 490640: using guessed type __int64 qword_490640;
// 490650: using guessed type __int64 qword_490650;
// 490658: using guessed type __int64 qword_490658;
// 490670: using guessed type int main_arena;
// 490F08: using guessed type char _libc_single_threaded;
// 496B00: using guessed type int perturb_byte;
// 496B04: using guessed type char global_max_fast;
// 496B08: using guessed type __int64 tcache_key;

//----- (00000000004114E0) ----------------------------------------------------
void __fastcall tcache_init_part_0(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8)
{
  unsigned __int64 StatusReg; // x21
  int *retry; // x19
  __int64 v10; // x1
  __int64 v11; // x2
  __int64 v12; // x3
  void *v13; // x4
  void *v14; // x5
  void *v15; // x6
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  int v24; // w0
  unsigned __int64 v25; // x20
  __int64 v26; // x1
  __int64 v27; // x2
  __int64 v28; // x3
  void *v29; // x4
  void *v30; // x5
  void *v31; // x6
  int v32; // w0
  double v33; // d0
  double v34; // d1
  double v35; // d2
  double v36; // d3
  double v37; // d4
  double v38; // d5
  double v39; // d6
  double v40; // d7
  bool v41; // zf
  double v42; // d0
  double v43; // d1
  double v44; // d2
  double v45; // d3
  double v46; // d4
  double v47; // d5
  double v48; // d6
  double v49; // d7
  __int64 v50; // x1
  __int64 v51; // x2
  __int64 v52; // x3
  void *v53; // x4
  void *v54; // x5
  void *v55; // x6
  int v56; // w0

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  retry = *(int **)(StatusReg + 56);
  if ( retry )
  {
    _aarch64_cas4_acq();
    if ( v24 )
      _lll_lock_wait_private(retry, v16, v17, v18, v19, v20, v21, v22, v23, v10, v11, v12, v13, v14, v15);
    v25 = int_malloc(retry, 640LL, v16, v17, v18, v19, v20, v21, v22, v23);
    if ( v25 )
    {
      _aarch64_swp4_rel();
      if ( v32 > 1 )
        _lll_lock_wake_private(retry, v26, v27, v28, v29, v30, v31);
LABEL_7:
      *(_QWORD *)(StatusReg + 48) = v25;
      memset();
      return;
    }
  }
  else
  {
    retry = arena_get2(640LL, 0LL, a3, a4, a5, a6, a7, a8);
    v25 = int_malloc(retry, 640LL, v33, v34, v35, v36, v37, v38, v39, v40);
    if ( v25 )
      v41 = 1;
    else
      v41 = retry == 0LL;
    if ( v41 )
      goto LABEL_13;
  }
  retry = arena_get_retry(retry, 640LL);
  v25 = int_malloc(retry, 640LL, v42, v43, v44, v45, v46, v47, v48, v49);
LABEL_13:
  if ( retry )
  {
    _aarch64_swp4_rel();
    if ( v56 > 1 )
      _lll_lock_wake_private(retry, v50, v51, v52, v53, v54, v55);
  }
  if ( v25 )
    goto LABEL_7;
}
// 411518: variable 'v24' is possibly undefined
// 4115E4: variable 'v16' is possibly undefined
// 4115E4: variable 'v17' is possibly undefined
// 4115E4: variable 'v18' is possibly undefined
// 4115E4: variable 'v19' is possibly undefined
// 4115E4: variable 'v20' is possibly undefined
// 4115E4: variable 'v21' is possibly undefined
// 4115E4: variable 'v22' is possibly undefined
// 4115E4: variable 'v23' is possibly undefined
// 4115E4: variable 'v10' is possibly undefined
// 4115E4: variable 'v11' is possibly undefined
// 4115E4: variable 'v12' is possibly undefined
// 4115E4: variable 'v13' is possibly undefined
// 4115E4: variable 'v14' is possibly undefined
// 4115E4: variable 'v15' is possibly undefined
// 411540: variable 'v32' is possibly undefined
// 4115D8: variable 'v26' is possibly undefined
// 4115D8: variable 'v27' is possibly undefined
// 4115D8: variable 'v28' is possibly undefined
// 4115D8: variable 'v29' is possibly undefined
// 4115D8: variable 'v30' is possibly undefined
// 4115D8: variable 'v31' is possibly undefined
// 411580: variable 'v33' is possibly undefined
// 411580: variable 'v34' is possibly undefined
// 411580: variable 'v35' is possibly undefined
// 411580: variable 'v36' is possibly undefined
// 411580: variable 'v37' is possibly undefined
// 411580: variable 'v38' is possibly undefined
// 411580: variable 'v39' is possibly undefined
// 411580: variable 'v40' is possibly undefined
// 4115B4: variable 'v42' is possibly undefined
// 4115B4: variable 'v43' is possibly undefined
// 4115B4: variable 'v44' is possibly undefined
// 4115B4: variable 'v45' is possibly undefined
// 4115B4: variable 'v46' is possibly undefined
// 4115B4: variable 'v47' is possibly undefined
// 4115B4: variable 'v48' is possibly undefined
// 4115B4: variable 'v49' is possibly undefined
// 4115FC: variable 'v56' is possibly undefined
// 411604: variable 'v50' is possibly undefined
// 411604: variable 'v51' is possibly undefined
// 411604: variable 'v52' is possibly undefined
// 411604: variable 'v53' is possibly undefined
// 411604: variable 'v54' is possibly undefined
// 411604: variable 'v55' is possibly undefined

//----- (000000000041160C) ----------------------------------------------------
unsigned __int64 __fastcall int_realloc(
        int *a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  unsigned __int64 v12; // x4
  unsigned __int64 v13; // x6
  int *v14; // x9
  unsigned __int64 v15; // x5
  unsigned __int64 v16; // x1
  unsigned __int64 v17; // x10
  unsigned __int64 v18; // x7
  unsigned __int64 v19; // x8
  _BOOL8 v21; // x0
  __int64 v22; // x4
  unsigned __int64 v23; // x4
  unsigned __int64 v25; // x0
  unsigned __int64 v26; // x19
  __int64 *v27; // x5
  int *v28; // x9
  __int64 v29; // x0
  unsigned __int64 v30; // x2
  __int64 v31; // x6
  unsigned __int64 v32; // x1
  __int64 v33; // x8
  __int64 v34; // x7
  unsigned __int16 v35; // w0
  __int64 v36; // x1
  __int64 *v37; // x6
  __int64 v38; // x0
  unsigned __int64 v39; // x2
  __int64 v40; // x4
  unsigned __int64 v41; // x1
  unsigned __int64 v42; // x0
  __int64 v43; // x10
  __int64 v44; // x8
  unsigned __int16 v45; // w7
  __int64 v46; // x1
  unsigned __int64 v47; // x8
  unsigned __int64 v48; // x1
  __int64 v49; // x0
  unsigned __int64 v51; // [xsp+28h] [xbp+28h]
  char v52; // [xsp+28h] [xbp+28h]
  unsigned __int64 v53; // [xsp+28h] [xbp+28h]
  unsigned __int64 v54; // [xsp+28h] [xbp+28h]
  __int64 *v55; // [xsp+28h] [xbp+28h]
  unsigned __int64 v56; // [xsp+28h] [xbp+28h]
  unsigned __int64 v57; // [xsp+30h] [xbp+30h]
  unsigned __int64 v58; // [xsp+30h] [xbp+30h]
  unsigned __int64 v59; // [xsp+30h] [xbp+30h]
  unsigned __int64 v60; // [xsp+30h] [xbp+30h]
  unsigned __int64 v61; // [xsp+30h] [xbp+30h]
  unsigned __int64 v62; // [xsp+38h] [xbp+38h]
  int *v63; // [xsp+38h] [xbp+38h]
  __int64 *v65; // [xsp+38h] [xbp+38h]
  __int64 v66; // [xsp+38h] [xbp+38h]
  unsigned __int64 v67; // [xsp+40h] [xbp+40h]
  unsigned __int64 v68; // [xsp+40h] [xbp+40h]
  unsigned __int64 v69; // [xsp+40h] [xbp+40h]
  __int64 v70; // [xsp+40h] [xbp+40h]
  unsigned __int64 v71; // [xsp+48h] [xbp+48h]
  unsigned __int64 v72; // [xsp+48h] [xbp+48h]
  __int64 v73; // [xsp+48h] [xbp+48h]
  unsigned __int64 v74; // [xsp+48h] [xbp+48h]
  __int64 v75; // [xsp+50h] [xbp+50h]
  int *v76; // [xsp+50h] [xbp+50h]
  int *v77; // [xsp+58h] [xbp+58h]
  __int64 *v78; // [xsp+58h] [xbp+58h]
  unsigned __int64 v79; // [xsp+60h] [xbp+60h]

  v12 = *(_QWORD *)(a2 + 8);
  if ( v12 <= 0x10
    || (v13 = *((_QWORD *)a1 + 273), v14 = a1, v13 <= a3)
    || (v15 = a2, v16 = v12 & 0xFFFFFFFFFFFFFFF8LL, (v12 & 0xFFFFFFFFFFFFFFF8LL) != a3) )
  {
    malloc_printerr((__int64)"realloc(): invalid old size", a5, a6, a7, a8, a9, a10, a11, a12);
  }
  if ( (v12 & 2) != 0 )
    _libc_assert_fail((__int64)"!chunk_is_mmapped (oldp)", (__int64)"malloc.c", 0x137Eu, (__int64)"_int_realloc");
  v17 = v15 + v16;
  v18 = *(_QWORD *)(v15 + v16 + 8);
  v19 = v18 & 0xFFFFFFFFFFFFFFF8LL;
  if ( v13 <= (v18 & 0xFFFFFFFFFFFFFFF8LL) || v18 <= 0x10 )
    malloc_printerr((__int64)"realloc(): invalid next size", a5, a6, a7, a8, a9, a10, a11, a12);
  if ( v16 >= a4 )
  {
LABEL_11:
    v21 = v14 != &main_arena;
    v22 = v12 & 7 | (4 * v21);
    if ( a3 - a4 <= 0x1F )
    {
      *(_QWORD *)(v15 + 8) = v22 | a3;
      *(_QWORD *)(v17 + 8) |= 1uLL;
      return v15 + 16;
    }
    v37 = (__int64 *)(v15 + a4);
    *(_QWORD *)(v15 + 8) = v22 | a4;
    *(_QWORD *)(v15 + a4 + 8) = (a3 - a4) | (4 * v21) | 1;
    *(_QWORD *)(v17 + 8) |= 1uLL;
    v38 = *(_QWORD *)(v15 + a4 + 8);
    v39 = v38 & 0xFFFFFFFFFFFFFFF8LL;
    if ( v15 + a4 <= -(__int64)(v38 & 0xFFFFFFFFFFFFFFF8LL) )
    {
      if ( v39 > 0x1F && (v38 & 8) == 0 )
      {
        v40 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 48);
        if ( !v40 )
          goto LABEL_42;
        v41 = (v39 - 17) >> 4;
        if ( v41 >= qword_490640 )
          goto LABEL_42;
        v42 = (unsigned __int64)(v37 + 2);
        v43 = tcache_key;
        if ( v37[3] == tcache_key )
        {
          v55 = v37 + 2;
          v60 = (v39 - 17) >> 4;
          v65 = (__int64 *)(v15 + a4);
          v69 = v39;
          v73 = v40;
          v75 = tcache_key;
          v77 = v14;
          v79 = v15;
          tcache_double_free_verify((_QWORD *)v42, v41, a5, a6, a7, a8, a9, a10, a11, a12);
          v42 = (unsigned __int64)v55;
          v41 = v60;
          v37 = v65;
          v39 = v69;
          v40 = v73;
          v43 = v75;
          v14 = v77;
          v15 = v79;
        }
        v44 = 2 * v41;
        v45 = *(_WORD *)(v40 + 2 * v41);
        if ( qword_490650 > (unsigned __int64)v45 )
        {
          v46 = v40 + 8 * v41;
          v37[2] = *(_QWORD *)(v46 + 128) ^ (v42 >> 12);
          v37[3] = v43;
          *(_QWORD *)(v46 + 128) = v42;
          *(_WORD *)(v40 + v44) = v45 + 1;
        }
        else
        {
LABEL_42:
          v53 = v15;
          int_free_chunk(v14, v37, v39, 1, a5, a6, a7, a8, a9, a10, a11, a12);
          v15 = v53;
        }
        return v15 + 16;
      }
LABEL_45:
      malloc_printerr((__int64)"free(): invalid size", a5, a6, a7, a8, a9, a10, a11, a12);
    }
LABEL_47:
    malloc_printerr((__int64)"free(): invalid pointer", a5, a6, a7, a8, a9, a10, a11, a12);
  }
  if ( *((_QWORD *)a1 + 12) == v17 )
  {
    v48 = v16 + v19;
    if ( v48 >= a4 + 32 )
    {
      v49 = v12 & 7 | (4LL * (a1 != &main_arena));
      v23 = v15 + 16;
      *(_QWORD *)(v15 + 8) = v49 | a4;
      *((_QWORD *)v14 + 12) = v15 + a4;
      *(_QWORD *)(v15 + a4 + 8) = (v48 - a4) | 1;
      return v23;
    }
  }
  else if ( (*(_QWORD *)(v17 + v19 + 8) & 1) == 0 )
  {
    v47 = a3 + v19;
    if ( a4 <= v47 )
    {
      v52 = v12;
      v59 = v47;
      v68 = v15;
      v72 = a4;
      unlink_chunk_isra_0((_QWORD *)(v15 + v16), a5, a6, a7, a8, a9, a10, a11, a12);
      LOBYTE(v12) = v52;
      v14 = a1;
      v15 = v68;
      a4 = v72;
      a3 = v59;
      v17 = v68 + v59;
      goto LABEL_11;
    }
  }
  v57 = v17;
  v62 = v15;
  v67 = a4;
  v71 = a3;
  v25 = int_malloc(a1, a4 - 15, a5, a6, a7, a8, a9, a10, a11, a12);
  v23 = v25;
  if ( !v25 )
    return v23;
  v14 = a1;
  v15 = v62;
  if ( v57 == v25 - 16 )
  {
    a4 = v67;
    a3 = v71 + (*(_QWORD *)(v57 + 8) & 0xFFFFFFFFFFFFFFF8LL);
    if ( v67 > a3 )
      _libc_assert_fail(
        (__int64)"(unsigned long) (newsize) >= (unsigned long) (nb)",
        (__int64)"malloc.c",
        0x13C7u,
        (__int64)"_int_realloc");
    v12 = *(_QWORD *)(v62 + 8);
    v17 = v62 + a3;
    goto LABEL_11;
  }
  v26 = v62 + 16;
  v51 = v62;
  v58 = v25;
  v63 = v14;
  j_memcpy();
  v27 = (__int64 *)v51;
  v23 = v58;
  v28 = v63;
  v29 = *(_QWORD *)(v51 + 8);
  v30 = v29 & 0xFFFFFFFFFFFFFFF8LL;
  if ( v51 > -(__int64)(v29 & 0xFFFFFFFFFFFFFFF8LL) )
    goto LABEL_47;
  if ( v30 <= 0x1F || (v29 & 8) != 0 )
    goto LABEL_45;
  v31 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 48);
  if ( !v31 )
    goto LABEL_46;
  v32 = (v30 - 17) >> 4;
  if ( v32 >= qword_490640 )
    goto LABEL_46;
  v33 = tcache_key;
  if ( *(_QWORD *)(v51 + 24) == tcache_key )
  {
    v56 = (v30 - 17) >> 4;
    v61 = v29 & 0xFFFFFFFFFFFFFFF8LL;
    v66 = v31;
    v70 = tcache_key;
    v74 = v23;
    v76 = v28;
    v78 = v27;
    tcache_double_free_verify((_QWORD *)v26, v32, a5, a6, a7, a8, a9, a10, a11, a12);
    v32 = v56;
    v30 = v61;
    v31 = v66;
    v33 = v70;
    v23 = v74;
    v28 = v76;
    v27 = v78;
  }
  v34 = 2 * v32;
  v35 = *(_WORD *)(v31 + 2 * v32);
  if ( qword_490650 > (unsigned __int64)v35 )
  {
    v36 = v31 + 8 * v32;
    v27[2] = *(_QWORD *)(v36 + 128) ^ (v26 >> 12);
    v27[3] = v33;
    *(_QWORD *)(v36 + 128) = v26;
    *(_WORD *)(v31 + v34) = v35 + 1;
  }
  else
  {
LABEL_46:
    v54 = v23;
    int_free_chunk(v28, v27, v30, 1, a5, a6, a7, a8, a9, a10, a11, a12);
    return v54;
  }
  return v23;
}
// 411A00: variable 'a5' is possibly undefined
// 411A00: variable 'a6' is possibly undefined
// 411A00: variable 'a7' is possibly undefined
// 411A00: variable 'a8' is possibly undefined
// 411A00: variable 'a9' is possibly undefined
// 411A00: variable 'a10' is possibly undefined
// 411A00: variable 'a11' is possibly undefined
// 411A00: variable 'a12' is possibly undefined
// 411A60: using guessed type __int64 int_memalign(void);
// 490640: using guessed type __int64 qword_490640;
// 490650: using guessed type __int64 qword_490650;
// 490670: using guessed type int main_arena;
// 496B08: using guessed type __int64 tcache_key;

//----- (0000000000411A60) ----------------------------------------------------
char *__fastcall int_memalign(
        int *a1,
        unsigned __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  unsigned __int64 v11; // x2
  unsigned __int64 v13; // x20
  unsigned __int64 v15; // x0
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  unsigned __int64 v24; // x5
  __int64 *v25; // x1
  char *v26; // x4
  signed __int64 v27; // x2
  __int64 v28; // x0
  unsigned __int64 v29; // x3
  _BOOL8 v30; // x0
  __int64 v31; // x0
  unsigned __int64 v32; // x2
  _QWORD *v33; // x3
  unsigned __int64 v34; // x2
  unsigned __int64 v35; // x4
  unsigned __int64 chunk; // x0
  __int64 *v38; // [xsp+30h] [xbp+30h]
  unsigned __int64 v39; // [xsp+30h] [xbp+30h]
  unsigned __int64 v40; // [xsp+38h] [xbp+38h]

  v11 = a3 + 23;
  v13 = v11 & 0xFFFFFFFFFFFFFFF0LL;
  if ( v11 <= 0x1F )
    v13 = 32LL;
  v15 = int_malloc(a1, a2 + 32 + v13, a4, a5, a6, a7, a8, a9, a10, a11);
  v24 = v15;
  if ( !v15 )
    return (char *)v24;
  v25 = (__int64 *)(v15 - 16);
  if ( !(v15 % a2) )
  {
LABEL_10:
    v31 = v25[1];
    if ( (v31 & 2) == 0 )
    {
      v32 = v31 & 0xFFFFFFFFFFFFFFF8LL;
      if ( (v31 & 0xFFFFFFFFFFFFFFF8LL) > v13 )
      {
        v33 = (__int64 *)((char *)v25 + v32);
        v34 = v32 - v13;
        v35 = v33[1] & 0xFFFFFFFFFFFFFFF8LL;
        if ( v34 > 0x1F || *((_QWORD **)a1 + 12) == v33 || (*(_QWORD *)((char *)v33 + v35 + 8) & 1) == 0 )
        {
          v39 = v24;
          v25[1] = v25[1] & 7 | v13;
          chunk = int_free_create_chunk(
                    (__int64)a1,
                    (__int64 *)((char *)v25 + v13),
                    v34,
                    v33,
                    v35,
                    v16,
                    v17,
                    v18,
                    v19,
                    v20,
                    v21,
                    v22,
                    v23);
          v24 = v39;
          if ( chunk > 0xFFFF )
          {
            int_free_maybe_consolidate_part_0((__int64)a1);
            return (char *)v39;
          }
        }
      }
    }
    return (char *)v24;
  }
  v26 = (char *)(((v15 + a2 - 1) & -(__int64)a2) - 16);
  v27 = v26 - (char *)v25;
  if ( (unsigned __int64)(v26 - (char *)v25) <= 0x1F )
  {
    v26 += a2;
    v27 = v26 - (char *)v25;
  }
  v28 = *(_QWORD *)(v15 - 8);
  v29 = (v28 & 0xFFFFFFFFFFFFFFF8LL) - v27;
  if ( (v28 & 2) == 0 )
  {
    v30 = a1 != &main_arena;
    *((_QWORD *)v26 + 1) = v29 | (4 * v30) | 1;
    *(_QWORD *)&v26[v29 + 8] |= 1uLL;
    v25[1] = v25[1] & 7 | (4 * v30) | v27;
    v38 = (__int64 *)v26;
    v40 = v29;
    int_free_merge_chunk((__int64)a1, v25, v27, v16, v17, v18, v19, v20, v21, v22, v23);
    if ( v40 < v13 || (v24 = (unsigned __int64)(v38 + 2), v25 = v38, (unsigned __int64)(v38 + 2) % a2) )
      _libc_assert_fail(
        (__int64)"newsize >= nb && (((unsigned long) (chunk2mem (p))) % alignment) == 0",
        (__int64)"malloc.c",
        0x142Du,
        (__int64)"_int_memalign");
    goto LABEL_10;
  }
  *(_QWORD *)v26 = *(_QWORD *)(v24 - 16) + v27;
  *((_QWORD *)v26 + 1) = v29 | 2;
  return v26 + 16;
}
// 411B34: variable 'v16' is possibly undefined
// 411B34: variable 'v17' is possibly undefined
// 411B34: variable 'v18' is possibly undefined
// 411B34: variable 'v19' is possibly undefined
// 411B34: variable 'v20' is possibly undefined
// 411B34: variable 'v21' is possibly undefined
// 411B34: variable 'v22' is possibly undefined
// 411B34: variable 'v23' is possibly undefined
// 490670: using guessed type int main_arena;

//----- (0000000000411C40) ----------------------------------------------------
__int64 __fastcall _glibc_morecore(__int64 a1)
{
  __int64 result; // x0

  if ( (_always_fail_morecore & 1) != 0 )
    return 0LL;
  result = sbrk(a1);
  if ( result == -1 )
    return 0LL;
  return result;
}
// 496B10: using guessed type char _always_fail_morecore;

//----- (0000000000411C80) ----------------------------------------------------
void _malloc_fork_lock_parent()
{
  __int64 v0; // x1
  __int64 v1; // x2
  __int64 v2; // x3
  void *v3; // x4
  void *v4; // x5
  void *v5; // x6
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7
  int v14; // w0
  int *v15; // x19
  __int64 v16; // x1
  __int64 v17; // x2
  __int64 v18; // x3
  void *v19; // x4
  void *v20; // x5
  void *v21; // x6
  double v22; // d0
  double v23; // d1
  double v24; // d2
  double v25; // d3
  double v26; // d4
  double v27; // d5
  double v28; // d6
  double v29; // d7
  int v30; // w0

  if ( (_malloc_initialized & 1) != 0 )
  {
    _aarch64_cas4_acq();
    if ( v14 )
      _lll_lock_wait_private(&list_lock, v6, v7, v8, v9, v10, v11, v12, v13, v0, v1, v2, v3, v4, v5);
    v15 = &main_arena;
    do
    {
      _aarch64_cas4_acq();
      if ( v30 )
        _lll_lock_wait_private(v15, v22, v23, v24, v25, v26, v27, v28, v29, v16, v17, v18, v19, v20, v21);
      v15 = (int *)*((_QWORD *)v15 + 270);
    }
    while ( v15 != &main_arena );
  }
}
// 411CB0: variable 'v14' is possibly undefined
// 411D00: variable 'v6' is possibly undefined
// 411D00: variable 'v7' is possibly undefined
// 411D00: variable 'v8' is possibly undefined
// 411D00: variable 'v9' is possibly undefined
// 411D00: variable 'v10' is possibly undefined
// 411D00: variable 'v11' is possibly undefined
// 411D00: variable 'v12' is possibly undefined
// 411D00: variable 'v13' is possibly undefined
// 411D00: variable 'v0' is possibly undefined
// 411D00: variable 'v1' is possibly undefined
// 411D00: variable 'v2' is possibly undefined
// 411D00: variable 'v3' is possibly undefined
// 411D00: variable 'v4' is possibly undefined
// 411D00: variable 'v5' is possibly undefined
// 411CD0: variable 'v30' is possibly undefined
// 411CF0: variable 'v22' is possibly undefined
// 411CF0: variable 'v23' is possibly undefined
// 411CF0: variable 'v24' is possibly undefined
// 411CF0: variable 'v25' is possibly undefined
// 411CF0: variable 'v26' is possibly undefined
// 411CF0: variable 'v27' is possibly undefined
// 411CF0: variable 'v28' is possibly undefined
// 411CF0: variable 'v29' is possibly undefined
// 411CF0: variable 'v16' is possibly undefined
// 411CF0: variable 'v17' is possibly undefined
// 411CF0: variable 'v18' is possibly undefined
// 411CF0: variable 'v19' is possibly undefined
// 411CF0: variable 'v20' is possibly undefined
// 411CF0: variable 'v21' is possibly undefined
// 490670: using guessed type int main_arena;
// 496B05: using guessed type char _malloc_initialized;
// 496B38: using guessed type int list_lock;

//----- (0000000000411D08) ----------------------------------------------------
void _malloc_fork_unlock_parent()
{
  int *v0; // x19
  __int64 v1; // x1
  __int64 v2; // x2
  __int64 v3; // x3
  void *v4; // x4
  void *v5; // x5
  void *v6; // x6
  int v7; // w0
  __int64 v8; // x1
  __int64 v9; // x2
  __int64 v10; // x3
  void *v11; // x4
  void *v12; // x5
  void *v13; // x6
  int v14; // w0

  if ( (_malloc_initialized & 1) != 0 )
  {
    v0 = &main_arena;
    do
    {
      _aarch64_swp4_rel();
      if ( v7 > 1 )
        _lll_lock_wake_private(v0, v1, v2, v3, v4, v5, v6);
      v0 = (int *)*((_QWORD *)v0 + 270);
    }
    while ( v0 != &main_arena );
    _aarch64_swp4_rel();
    if ( v14 > 1 )
      _lll_lock_wake_private(&list_lock, v8, v9, v10, v11, v12, v13);
  }
}
// 411D50: variable 'v7' is possibly undefined
// 411D8C: variable 'v1' is possibly undefined
// 411D8C: variable 'v2' is possibly undefined
// 411D8C: variable 'v3' is possibly undefined
// 411D8C: variable 'v4' is possibly undefined
// 411D8C: variable 'v5' is possibly undefined
// 411D8C: variable 'v6' is possibly undefined
// 411D74: variable 'v14' is possibly undefined
// 411DA4: variable 'v8' is possibly undefined
// 411DA4: variable 'v9' is possibly undefined
// 411DA4: variable 'v10' is possibly undefined
// 411DA4: variable 'v11' is possibly undefined
// 411DA4: variable 'v12' is possibly undefined
// 411DA4: variable 'v13' is possibly undefined
// 490670: using guessed type int main_arena;
// 496B05: using guessed type char _malloc_initialized;
// 496B38: using guessed type int list_lock;

//----- (0000000000411DA8) ----------------------------------------------------
int *_malloc_fork_unlock_child()
{
  int *result; // x0
  __int64 v1; // x3
  __int64 v2; // x2

  result = &perturb_byte;
  if ( (_malloc_initialized & 1) != 0 )
  {
    free_list_lock = 0;
    v1 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 56);
    if ( v1 )
      *(_QWORD *)(v1 + 2176) = 1LL;
    result = &main_arena;
    free_list = 0LL;
    do
    {
      *result = 0;
      if ( (int *)v1 != result )
      {
        v2 = free_list;
        free_list = (__int64)result;
        *((_QWORD *)result + 271) = v2;
        *((_QWORD *)result + 272) = 0LL;
      }
      result = (int *)*((_QWORD *)result + 270);
    }
    while ( result != &main_arena );
    list_lock = 0;
  }
  return result;
}
// 490670: using guessed type int main_arena;
// 496B00: using guessed type int perturb_byte;
// 496B05: using guessed type char _malloc_initialized;
// 496B20: using guessed type __int64 free_list;
// 496B28: using guessed type int free_list_lock;
// 496B38: using guessed type int list_lock;

//----- (0000000000411E24) ----------------------------------------------------
unsigned __int64 __fastcall malloc(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  unsigned __int64 StatusReg; // x20
  __int64 v18; // x3
  __int64 v19; // x2
  unsigned __int64 v20; // x0
  unsigned __int64 v21; // x1
  unsigned __int64 v22; // x3
  int *retry; // x20
  __int64 v25; // x1
  __int64 v26; // x2
  __int64 v27; // x3
  void *v28; // x4
  void *v29; // x5
  void *v30; // x6
  double v31; // d0
  double v32; // d1
  double v33; // d2
  double v34; // d3
  double v35; // d4
  double v36; // d5
  double v37; // d6
  double v38; // d7
  int v39; // w0
  __int64 v40; // x1
  __int64 v41; // x2
  void *v42; // x4
  void *v43; // x5
  void *v44; // x6
  int v45; // w0
  __int64 v46; // x1
  unsigned __int64 v47; // x0
  int *v48; // x0
  unsigned __int64 v49; // x0
  __int64 v50; // x1
  unsigned __int64 v51; // x0
  __int64 v52; // x1
  double v53; // d0
  double v54; // d1
  double v55; // d2
  double v56; // d3
  double v57; // d4
  double v58; // d5
  double v59; // d6
  double v60; // d7
  __int64 v61; // x1
  __int64 v62; // x2
  void *v63; // x4
  void *v64; // x5
  void *v65; // x6
  int v66; // w0
  double v67; // d0
  double v68; // d1
  double v69; // d2
  double v70; // d3
  double v71; // d4
  double v72; // d5
  double v73; // d6
  double v74; // d7
  unsigned __int64 v75; // x0
  __int64 v76; // x1
  __int64 v77; // x1
  __int64 *v78; // [xsp+20h] [xbp+20h]
  __int64 v79; // [xsp+20h] [xbp+20h]
  __int64 v80; // [xsp+20h] [xbp+20h]
  unsigned __int64 v81; // [xsp+28h] [xbp+28h]

  if ( (_malloc_initialized & 1) != 0 )
  {
    if ( (a1 & 0x8000000000000000LL) == 0 )
      goto LABEL_3;
LABEL_12:
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 12;
    return 0LL;
  }
  ptmalloc_init_part_0((unsigned __int8)_malloc_initialized, a2, a3, a4, a5, a6, a7);
  if ( a1 < 0 )
    goto LABEL_12;
LABEL_3:
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v18 = StatusReg + 48;
  v19 = *(_QWORD *)(StatusReg + 48);
  v20 = (((a1 + 23) & 0xFFFFFFFFFFFFFFF0LL) - 17) >> 4;
  if ( (unsigned __int64)(a1 + 23) <= 0x1F )
    v20 = 0LL;
  if ( v19 )
  {
    v18 = qword_490640;
    if ( qword_490640 <= v20 )
      goto LABEL_17;
  }
  else
  {
    v19 = *(unsigned __int8 *)(v18 + 0x10);
    if ( (v19 & 1) != 0 )
      goto LABEL_17;
    v78 = (__int64 *)(StatusReg + 48);
    v81 = v20;
    tcache_init_part_0(v20, a1 + 23, v19, v18, a5, a6, a7, a8);
    v20 = v81;
    v19 = qword_490640;
    if ( qword_490640 <= v81 )
      goto LABEL_17;
    v18 = StatusReg + 48;
    v19 = *v78;
    if ( !*v78 )
      goto LABEL_17;
  }
  a6 = (void *)(2 * v20);
  a5 = (void *)*(unsigned __int16 *)(v19 + 2 * v20);
  if ( *(_WORD *)(v19 + 2 * v20) )
  {
    v21 = v19 + 8 * v20;
    v22 = *(_QWORD *)(v21 + 128);
    if ( (v22 & 0xF) != 0 )
      malloc_printerr((__int64)"malloc(): unaligned tcache chunk detected", a9, a10, a11, a12, a13, a14, a15, a16);
    *(_QWORD *)(v21 + 128) = *(_QWORD *)v22 ^ (v22 >> 12);
    *(_WORD *)(v19 + 2 * v20) = (_WORD)a5 - 1;
    *(_QWORD *)(v22 + 8) = 0LL;
    return v22;
  }
LABEL_17:
  if ( !_libc_single_threaded )
  {
    retry = *(int **)(StatusReg + 56);
    if ( retry )
    {
      _aarch64_cas4_acq();
      if ( v39 )
        _lll_lock_wait_private(retry, v31, v32, v33, v34, v35, v36, v37, v38, v25, v26, v27, v28, v29, v30);
      v22 = int_malloc(retry, a1, v31, v32, v33, v34, v35, v36, v37, v38);
      if ( v22 )
      {
LABEL_22:
        v79 = v22;
        _aarch64_swp4_rel();
        v22 = v79;
        if ( v45 > 1 )
        {
          _lll_lock_wake_private(retry, v40, v41, v79, v42, v43, v44);
          v22 = v79;
        }
LABEL_24:
        v46 = *(_QWORD *)(v22 - 8);
        v47 = v22 - 16;
        if ( (v46 & 2) != 0 )
          return v22;
        if ( (v46 & 4) == 0 )
        {
          v48 = &main_arena;
          goto LABEL_27;
        }
LABEL_47:
        v77 = -4 * qword_490608;
        if ( !qword_490608 )
          v77 = -67108864LL;
        v48 = *(int **)(v47 & v77);
LABEL_27:
        if ( retry == v48 )
          return v22;
LABEL_28:
        _libc_assert_fail(
          (__int64)"!victim || chunk_is_mmapped (mem2chunk (victim)) || ar_ptr == arena_for_chunk (mem2chunk (victim))",
          (__int64)"malloc.c",
          0xD65u,
          (__int64)"__libc_malloc");
      }
      goto LABEL_37;
    }
    retry = arena_get2(a1, 0LL, v19, v18, a5, a6, a7, a8);
    v75 = int_malloc(retry, a1, v67, v68, v69, v70, v71, v72, v73, v74);
    v22 = v75;
    if ( v75 )
    {
      if ( !retry )
      {
        v76 = *(_QWORD *)(v75 - 8);
        v47 = v75 - 16;
        if ( (v76 & 2) != 0 )
          return v22;
        if ( (v76 & 4) == 0 )
          goto LABEL_28;
        goto LABEL_47;
      }
      goto LABEL_22;
    }
    if ( retry )
    {
LABEL_37:
      retry = arena_get_retry(retry, a1);
      v22 = int_malloc(retry, a1, v53, v54, v55, v56, v57, v58, v59, v60);
      if ( retry && (v80 = v22, _aarch64_swp4_rel(), v22 = v80, v66 > 1) )
      {
        _lll_lock_wake_private(retry, v61, v62, v80, v63, v64, v65);
        v22 = v80;
        if ( v80 )
          goto LABEL_24;
      }
      else if ( v22 )
      {
        goto LABEL_24;
      }
      return 0LL;
    }
    return 0LL;
  }
  v49 = int_malloc(&main_arena, a1, a9, a10, a11, a12, a13, a14, a15, a16);
  v22 = v49;
  if ( !v49 )
    return 0LL;
  v50 = *(_QWORD *)(v49 - 8);
  v51 = v49 - 16;
  if ( (v50 & 2) == 0 && (v50 & 4) != 0 )
  {
    v52 = -4 * qword_490608;
    if ( !qword_490608 )
      v52 = -67108864LL;
    if ( *(int **)(v51 & v52) != &main_arena )
      _libc_assert_fail(
        (__int64)"!victim || chunk_is_mmapped (mem2chunk (victim)) || &main_arena == arena_for_chunk (mem2chunk (victim))",
        (__int64)"malloc.c",
        0xD4Fu,
        (__int64)"__libc_malloc");
  }
  return v22;
}
// 411EF4: variable 'a5' is possibly undefined
// 411EF4: variable 'a6' is possibly undefined
// 411EF4: variable 'a7' is possibly undefined
// 411EF4: variable 'a8' is possibly undefined
// 411F54: variable 'v39' is possibly undefined
// 41208C: variable 'v31' is possibly undefined
// 41208C: variable 'v32' is possibly undefined
// 41208C: variable 'v33' is possibly undefined
// 41208C: variable 'v34' is possibly undefined
// 41208C: variable 'v35' is possibly undefined
// 41208C: variable 'v36' is possibly undefined
// 41208C: variable 'v37' is possibly undefined
// 41208C: variable 'v38' is possibly undefined
// 41208C: variable 'v25' is possibly undefined
// 41208C: variable 'v26' is possibly undefined
// 41208C: variable 'v27' is possibly undefined
// 41208C: variable 'v28' is possibly undefined
// 41208C: variable 'v29' is possibly undefined
// 41208C: variable 'v30' is possibly undefined
// 411F84: variable 'v45' is possibly undefined
// 412110: variable 'v40' is possibly undefined
// 412110: variable 'v41' is possibly undefined
// 412110: variable 'v42' is possibly undefined
// 412110: variable 'v43' is possibly undefined
// 412110: variable 'v44' is possibly undefined
// 411FD8: variable 'a9' is possibly undefined
// 411FD8: variable 'a10' is possibly undefined
// 411FD8: variable 'a11' is possibly undefined
// 411FD8: variable 'a12' is possibly undefined
// 411FD8: variable 'a13' is possibly undefined
// 411FD8: variable 'a14' is possibly undefined
// 411FD8: variable 'a15' is possibly undefined
// 411FD8: variable 'a16' is possibly undefined
// 412054: variable 'v53' is possibly undefined
// 412054: variable 'v54' is possibly undefined
// 412054: variable 'v55' is possibly undefined
// 412054: variable 'v56' is possibly undefined
// 412054: variable 'v57' is possibly undefined
// 412054: variable 'v58' is possibly undefined
// 412054: variable 'v59' is possibly undefined
// 412054: variable 'v60' is possibly undefined
// 412078: variable 'v66' is possibly undefined
// 412098: variable 'v61' is possibly undefined
// 412098: variable 'v62' is possibly undefined
// 412098: variable 'v63' is possibly undefined
// 412098: variable 'v64' is possibly undefined
// 412098: variable 'v65' is possibly undefined
// 4120B0: variable 'v18' is possibly undefined
// 4120BC: variable 'v67' is possibly undefined
// 4120BC: variable 'v68' is possibly undefined
// 4120BC: variable 'v69' is possibly undefined
// 4120BC: variable 'v70' is possibly undefined
// 4120BC: variable 'v71' is possibly undefined
// 4120BC: variable 'v72' is possibly undefined
// 4120BC: variable 'v73' is possibly undefined
// 4120BC: variable 'v74' is possibly undefined
// 490608: using guessed type __int64 qword_490608;
// 490640: using guessed type __int64 qword_490640;
// 490670: using guessed type int main_arena;
// 490F08: using guessed type char _libc_single_threaded;
// 496B05: using guessed type char _malloc_initialized;

//----- (0000000000412120) ----------------------------------------------------
unsigned __int64 __fastcall mid_memalign_isra_0(
        unsigned __int64 a1,
        __int64 a2,
        __int64 a3,
        void *a4,
        unsigned __int64 a5,
        unsigned __int64 a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  unsigned __int64 i; // x19
  unsigned __int64 v18; // x3
  __int64 v19; // x1
  __int64 v20; // x8
  unsigned __int64 v21; // x5
  unsigned __int64 v22; // x0
  unsigned __int64 result; // x0
  int *retry; // x22
  __int64 v25; // x1
  __int64 v26; // x2
  __int64 v27; // x3
  void *v28; // x4
  void *v29; // x5
  void *v30; // x6
  double v31; // d0
  double v32; // d1
  double v33; // d2
  double v34; // d3
  double v35; // d4
  double v36; // d5
  double v37; // d6
  double v38; // d7
  int v39; // w0
  char *v40; // x5
  __int64 v41; // x1
  __int64 v42; // x2
  __int64 v43; // x3
  void *v44; // x4
  void *v45; // x6
  char *v46; // x5
  int v47; // w0
  __int64 v48; // x1
  __int64 v49; // x1
  int *v50; // x0
  double v51; // d0
  double v52; // d1
  double v53; // d2
  double v54; // d3
  double v55; // d4
  double v56; // d5
  double v57; // d6
  double v58; // d7
  bool v59; // zf
  double v60; // d0
  double v61; // d1
  double v62; // d2
  double v63; // d3
  double v64; // d4
  double v65; // d5
  double v66; // d6
  double v67; // d7
  char *v68; // x0
  __int64 v69; // x1
  char *v70; // x0
  __int64 v71; // x1
  __int64 v72; // x1
  __int64 v73; // x2
  __int64 v74; // x3
  void *v75; // x4
  void *v76; // x6
  int v77; // w0
  char *v78; // [xsp+38h] [xbp-8h]
  char *v79; // [xsp+38h] [xbp-8h]

  if ( a1 <= 0x10 )
    return malloc(a2, a2, a3, a4, (void *)a5, (void *)a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
  if ( a1 <= 0x1F )
  {
    i = 32LL;
  }
  else
  {
    if ( a1 > 0x8000000000000000LL )
    {
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
      return 0LL;
    }
    a3 = a1 - 1;
    if ( ((a1 - 1) & a1) == 0 || a1 == 32 )
    {
      i = a1;
    }
    else
    {
      for ( i = 32LL; i < a1; i *= 2LL )
        ;
    }
  }
  if ( a2 < 0 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 12;
    return 0LL;
  }
  v18 = (((a2 + 23) & 0xFFFFFFFFFFFFFFF0LL) - 17) >> 4;
  if ( (unsigned __int64)(a2 + 23) <= 0x1F )
    v18 = 0LL;
  if ( qword_490640 > v18 )
  {
    v19 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 48);
    if ( v19 )
    {
      v20 = 2 * v18;
      a3 = *(unsigned __int16 *)(v19 + 2 * v18);
      if ( *(_WORD *)(v19 + 2 * v18) )
      {
        v18 += 16LL;
        a6 = *(_QWORD *)(v19 + 8 * v18);
        if ( a6 )
        {
          v18 = v19 + 8 * v18;
          a5 = v18;
          while ( (a6 & (i - 1)) != 0 )
          {
            a7 = *(void **)a6;
            a8 = a6 >> 12;
            a5 = a6;
            a6 = (a6 >> 12) ^ *(_QWORD *)a6;
            if ( (void *)a8 == a7 )
              goto LABEL_23;
          }
          v21 = *(_QWORD *)a5;
          if ( v18 == a5 )
          {
            if ( (v21 & 0xF) == 0 )
            {
              v22 = *(_QWORD *)v21 ^ (v21 >> 12);
              goto LABEL_21;
            }
          }
          else
          {
            v21 ^= a5 >> 12;
            if ( (v21 & 0xF) == 0 )
            {
              v22 = *(_QWORD *)v21 ^ (a5 >> 12) ^ (v21 >> 12);
LABEL_21:
              *(_QWORD *)a5 = v22;
              *(_WORD *)(v19 + v20) = a3 - 1;
              result = v21;
              *(_QWORD *)(v21 + 8) = 0LL;
              return result;
            }
          }
          malloc_printerr((__int64)"malloc(): unaligned tcache chunk detected", a9, a10, a11, a12, a13, a14, a15, a16);
        }
      }
    }
  }
LABEL_23:
  if ( _libc_single_threaded )
  {
    v68 = int_memalign(&main_arena, i, a2, a9, a10, a11, a12, a13, a14, a15, a16);
    v46 = v68;
    if ( v68 )
    {
      v69 = *((_QWORD *)v68 - 1);
      v70 = v68 - 16;
      if ( (v69 & 2) == 0 && (v69 & 4) != 0 )
      {
        v71 = -4 * qword_490608;
        if ( !qword_490608 )
          v71 = -67108864LL;
        if ( *(int **)((unsigned __int64)v70 & v71) != &main_arena )
          _libc_assert_fail(
            (__int64)"!p || chunk_is_mmapped (mem2chunk (p)) || &main_arena == arena_for_chunk (mem2chunk (p))",
            (__int64)"malloc.c",
            0xE85u,
            (__int64)"_mid_memalign");
      }
      return (unsigned __int64)v46;
    }
    return 0LL;
  }
  retry = *(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 56);
  if ( retry )
  {
    _aarch64_cas4_acq();
    if ( v39 )
      _lll_lock_wait_private(retry, v31, v32, v33, v34, v35, v36, v37, v38, v25, v26, v27, v28, v29, v30);
    v40 = int_memalign(retry, i, a2, v31, v32, v33, v34, v35, v36, v37, v38);
    if ( v40 )
    {
      v78 = v40;
      _aarch64_swp4_rel();
      v46 = v78;
      if ( v47 > 1 )
      {
        _lll_lock_wake_private(retry, v41, v42, v43, v44, v78, v45);
        v46 = v78;
      }
      goto LABEL_30;
    }
  }
  else
  {
    retry = arena_get2(a2 + 32 + i, 0LL, a3, v18, (void *)a5, (void *)a6, a7, a8);
    v46 = int_memalign(retry, i, a2, v51, v52, v53, v54, v55, v56, v57, v58);
    if ( v46 )
      v59 = 1;
    else
      v59 = retry == 0LL;
    if ( v59 )
      goto LABEL_43;
  }
  retry = arena_get_retry(retry, a2);
  v46 = int_memalign(retry, i, a2, v60, v61, v62, v63, v64, v65, v66, v67);
LABEL_43:
  if ( retry )
  {
    v79 = v46;
    _aarch64_swp4_rel();
    v46 = v79;
    if ( v77 > 1 )
    {
      _lll_lock_wake_private(retry, v72, v73, v74, v75, v79, v76);
      v46 = v79;
      if ( !v79 )
        return 0LL;
LABEL_30:
      v48 = *((_QWORD *)v46 - 1);
      if ( (v48 & 2) == 0 )
      {
        if ( (v48 & 4) != 0 )
        {
          v49 = -4 * qword_490608;
          if ( !qword_490608 )
            v49 = -67108864LL;
          v50 = *(int **)((unsigned __int64)(v46 - 16) & v49);
        }
        else
        {
          v50 = &main_arena;
        }
        if ( retry != v50 )
          _libc_assert_fail(
            (__int64)"!p || chunk_is_mmapped (mem2chunk (p)) || ar_ptr == arena_for_chunk (mem2chunk (p))",
            (__int64)"malloc.c",
            0xE97u,
            (__int64)"_mid_memalign");
      }
      return (unsigned __int64)v46;
    }
  }
  if ( v46 )
    goto LABEL_30;
  return 0LL;
}
// 412288: variable 'v39' is possibly undefined
// 412460: variable 'v31' is possibly undefined
// 412460: variable 'v32' is possibly undefined
// 412460: variable 'v33' is possibly undefined
// 412460: variable 'v34' is possibly undefined
// 412460: variable 'v35' is possibly undefined
// 412460: variable 'v36' is possibly undefined
// 412460: variable 'v37' is possibly undefined
// 412460: variable 'v38' is possibly undefined
// 412460: variable 'v25' is possibly undefined
// 412460: variable 'v26' is possibly undefined
// 412460: variable 'v27' is possibly undefined
// 412460: variable 'v28' is possibly undefined
// 412460: variable 'v29' is possibly undefined
// 412460: variable 'v30' is possibly undefined
// 4122BC: variable 'v47' is possibly undefined
// 412470: variable 'v41' is possibly undefined
// 412470: variable 'v42' is possibly undefined
// 412470: variable 'v43' is possibly undefined
// 412470: variable 'v44' is possibly undefined
// 412470: variable 'v45' is possibly undefined
// 412330: variable 'v51' is possibly undefined
// 412330: variable 'v52' is possibly undefined
// 412330: variable 'v53' is possibly undefined
// 412330: variable 'v54' is possibly undefined
// 412330: variable 'v55' is possibly undefined
// 412330: variable 'v56' is possibly undefined
// 412330: variable 'v57' is possibly undefined
// 412330: variable 'v58' is possibly undefined
// 41235C: variable 'v60' is possibly undefined
// 41235C: variable 'v61' is possibly undefined
// 41235C: variable 'v62' is possibly undefined
// 41235C: variable 'v63' is possibly undefined
// 41235C: variable 'v64' is possibly undefined
// 41235C: variable 'v65' is possibly undefined
// 41235C: variable 'v66' is possibly undefined
// 41235C: variable 'v67' is possibly undefined
// 4124A0: variable 'v77' is possibly undefined
// 4124AC: variable 'v72' is possibly undefined
// 4124AC: variable 'v73' is possibly undefined
// 4124AC: variable 'v74' is possibly undefined
// 4124AC: variable 'v75' is possibly undefined
// 4124AC: variable 'v76' is possibly undefined
// 490608: using guessed type __int64 qword_490608;
// 490640: using guessed type __int64 qword_490640;
// 490670: using guessed type int main_arena;
// 490F08: using guessed type char _libc_single_threaded;

//----- (00000000004124E0) ----------------------------------------------------
void __fastcall free(
        unsigned __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  unsigned __int64 v9; // x4
  unsigned __int64 StatusReg; // x5
  unsigned __int64 v11; // x1
  __int64 v12; // x7
  __int64 v14; // x2
  int *v15; // x8
  unsigned __int64 v16; // x2
  __int64 v17; // x3
  __int64 (__fastcall **v18)(); // x9
  unsigned __int64 v19; // x1
  __int64 v20; // x12
  __int64 v21; // x11
  unsigned __int16 v22; // w10
  __int64 v23; // x1
  __int64 v24; // x2
  int v25; // [xsp+10h] [xbp+10h]
  int v26; // [xsp+10h] [xbp+10h]
  unsigned __int64 v27; // [xsp+10h] [xbp+10h]
  unsigned __int64 v28; // [xsp+10h] [xbp+10h]
  unsigned __int64 v29; // [xsp+18h] [xbp+18h]
  unsigned __int64 v30; // [xsp+18h] [xbp+18h]
  int v31; // [xsp+18h] [xbp+18h]
  unsigned __int64 v32; // [xsp+18h] [xbp+18h]
  unsigned __int64 v33; // [xsp+20h] [xbp+20h]
  unsigned __int64 v34; // [xsp+20h] [xbp+20h]
  unsigned __int64 v35; // [xsp+28h] [xbp+28h]
  int v36; // [xsp+28h] [xbp+28h]
  unsigned __int64 v37; // [xsp+30h] [xbp+30h]
  int *v38; // [xsp+38h] [xbp+38h]
  __int64 v39; // [xsp+40h] [xbp+40h]
  __int64 v40; // [xsp+48h] [xbp+48h]
  unsigned __int64 v41; // [xsp+50h] [xbp+50h]

  if ( a1 )
  {
    v9 = a1 - 16;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v11 = *(_QWORD *)(a1 - 8);
    v12 = *(unsigned int *)(StatusReg + 40);
    if ( (v11 & 2) != 0 )
    {
      if ( !dword_490620 && v11 > qword_4905E8 && v11 <= 0x2000000 )
      {
        qword_4905E8 = v11 & 0xFFFFFFFFFFFFFFF8LL;
        mp_ = 2LL * ((unsigned int)v11 & 0xFFFFFFF8);
      }
      v25 = v12;
      v29 = StatusReg;
      munmap_chunk((_QWORD *)v9, a2, a3, a4, a5, a6, a7, a8, a9);
      LODWORD(v12) = v25;
      StatusReg = v29;
      goto LABEL_10;
    }
    if ( !*(_QWORD *)(StatusReg + 48) )
    {
      v24 = *(unsigned __int8 *)(StatusReg + 64);
      if ( (v24 & 1) == 0 )
      {
        v27 = a1 - 16;
        v31 = *(_DWORD *)(StatusReg + 40);
        v33 = a1;
        v35 = StatusReg;
        tcache_init_part_0(a1, v11, v24, 0LL, (void *)v9, (void *)StatusReg, (void *)0x28, v12);
        v9 = v27;
        v11 = *(_QWORD *)(v27 + 8);
        a1 = v33;
        StatusReg = v35;
        LODWORD(v12) = v31;
      }
    }
    if ( (v11 & 4) != 0 )
    {
      v14 = -4 * qword_490608;
      if ( !qword_490608 )
        v14 = -67108864LL;
      v15 = *(int **)(v9 & v14);
    }
    else
    {
      v15 = &main_arena;
    }
    v16 = v11 & 0xFFFFFFFFFFFFFFF8LL;
    if ( -(__int64)(v11 & 0xFFFFFFFFFFFFFFF8LL) < v9 || (v9 & 0xF) != 0 )
      malloc_printerr((__int64)"free(): invalid pointer", a2, a3, a4, a5, a6, a7, a8, a9);
    if ( v16 <= 0x1F || (v11 & 8) != 0 )
      malloc_printerr((__int64)"free(): invalid size", a2, a3, a4, a5, a6, a7, a8, a9);
    v17 = *(_QWORD *)(StatusReg + 48);
    if ( v17 )
    {
      v18 = off_490000;
      v19 = (v16 - 17) >> 4;
      if ( v19 < qword_490640 )
      {
        v20 = tcache_key;
        if ( *(_QWORD *)(a1 + 8) == tcache_key )
        {
          v28 = a1;
          v32 = (v16 - 17) >> 4;
          v34 = v9;
          v36 = v12;
          v37 = v16;
          v38 = v15;
          v39 = *(_QWORD *)(StatusReg + 48);
          v40 = tcache_key;
          v41 = StatusReg;
          tcache_double_free_verify((_QWORD *)a1, v19, a2, a3, a4, a5, a6, a7, a8, a9);
          LODWORD(v12) = v36;
          v9 = v34;
          v18 = off_490000;
          a1 = v28;
          v19 = v32;
          v16 = v37;
          v15 = v38;
          v17 = v39;
          v20 = v40;
          StatusReg = v41;
        }
        v21 = 2 * v19;
        v22 = *(_WORD *)(v17 + 2 * v19);
        if ( (unsigned __int64)v18[202] > v22 )
        {
          v23 = v17 + 8 * v19;
          *(_QWORD *)a1 = *(_QWORD *)(v23 + 128) ^ (a1 >> 12);
          *(_QWORD *)(a1 + 8) = v20;
          *(_QWORD *)(v23 + 128) = a1;
          *(_WORD *)(v17 + v21) = v22 + 1;
LABEL_10:
          *(_DWORD *)(StatusReg + 40) = v12;
          return;
        }
      }
    }
    v26 = v12;
    v30 = StatusReg;
    int_free_chunk(v15, (__int64 *)v9, v16, 0, a2, a3, a4, a5, a6, a7, a8, a9);
    *(_DWORD *)(v30 + 40) = v26;
  }
}
// 4126D4: variable 'a2' is possibly undefined
// 4126D4: variable 'a3' is possibly undefined
// 4126D4: variable 'a4' is possibly undefined
// 4126D4: variable 'a5' is possibly undefined
// 4126D4: variable 'a6' is possibly undefined
// 4126D4: variable 'a7' is possibly undefined
// 4126D4: variable 'a8' is possibly undefined
// 4126D4: variable 'a9' is possibly undefined
// 490000: using guessed type __int64 (__fastcall *off_490000[5])();
// 4905D8: using guessed type __int64 mp_;
// 4905E8: using guessed type __int64 qword_4905E8;
// 490608: using guessed type __int64 qword_490608;
// 490620: using guessed type int dword_490620;
// 490640: using guessed type __int64 qword_490640;
// 490670: using guessed type int main_arena;
// 496B08: using guessed type __int64 tcache_key;

//----- (0000000000412700) ----------------------------------------------------
void __fastcall _malloc_arena_thread_freeres(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  unsigned __int64 StatusReg; // x21
  unsigned __int64 v9; // x20
  unsigned __int64 *v10; // x19
  unsigned __int64 v11; // x0
  unsigned __int64 v12; // x21
  __int64 v13; // x20
  __int64 v14; // x1
  __int64 v15; // x2
  __int64 v16; // x3
  void *v17; // x4
  void *v18; // x5
  void *v19; // x6
  double v20; // d0
  double v21; // d1
  double v22; // d2
  double v23; // d3
  double v24; // d4
  double v25; // d5
  double v26; // d6
  double v27; // d7
  int v28; // w0
  __int64 v29; // x0
  __int64 v30; // x0
  __int64 v31; // x1
  __int64 v32; // x1
  __int64 v33; // x2
  __int64 v34; // x3
  void *v35; // x4
  void *v36; // x5
  void *v37; // x6
  int v38; // w0

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v9 = *(_QWORD *)(StatusReg + 48);
  *(_BYTE *)(StatusReg + 48 + 0x10) = 1;
  if ( v9 )
  {
    v10 = (unsigned __int64 *)(v9 + 128);
    *(_QWORD *)(StatusReg + 48) = 0LL;
    do
    {
      while ( 1 )
      {
        v11 = *v10;
        if ( !*v10 )
          break;
        if ( (v11 & 0xF) != 0 )
          malloc_printerr(
            (__int64)"tcache_thread_shutdown(): unaligned tcache chunk detected",
            a1,
            a2,
            a3,
            a4,
            a5,
            a6,
            a7,
            a8);
        *v10 = *(_QWORD *)v11 ^ (v11 >> 12);
        free(v11, a1, a2, a3, a4, a5, a6, a7, a8);
      }
      ++v10;
    }
    while ( v10 != (unsigned __int64 *)(v9 + 640) );
    free(v9, a1, a2, a3, a4, a5, a6, a7, a8);
  }
  v12 = StatusReg + 48;
  v13 = *(_QWORD *)(v12 + 8);
  *(_QWORD *)(v12 + 8) = 0LL;
  if ( v13 )
  {
    _aarch64_cas4_acq();
    if ( v28 )
      _lll_lock_wait_private(&free_list_lock, v20, v21, v22, v23, v24, v25, v26, v27, v14, v15, v16, v17, v18, v19);
    v29 = *(_QWORD *)(v13 + 2176);
    if ( !v29 )
      _libc_assert_fail(
        (__int64)"a->attached_threads > 0",
        (__int64)"arena.c",
        0x38Bu,
        (__int64)"__malloc_arena_thread_freeres");
    v30 = v29 - 1;
    *(_QWORD *)(v13 + 2176) = v30;
    if ( !v30 )
    {
      v31 = free_list;
      free_list = v13;
      *(_QWORD *)(v13 + 2168) = v31;
    }
    _aarch64_swp4_rel();
    if ( v38 > 1 )
      _lll_lock_wake_private(&free_list_lock, v32, v33, v34, v35, v36, v37);
  }
}
// 412748: variable 'a1' is possibly undefined
// 412748: variable 'a2' is possibly undefined
// 412748: variable 'a3' is possibly undefined
// 412748: variable 'a4' is possibly undefined
// 412748: variable 'a5' is possibly undefined
// 412748: variable 'a6' is possibly undefined
// 412748: variable 'a7' is possibly undefined
// 412748: variable 'a8' is possibly undefined
// 4127B0: variable 'v28' is possibly undefined
// 412818: variable 'v20' is possibly undefined
// 412818: variable 'v21' is possibly undefined
// 412818: variable 'v22' is possibly undefined
// 412818: variable 'v23' is possibly undefined
// 412818: variable 'v24' is possibly undefined
// 412818: variable 'v25' is possibly undefined
// 412818: variable 'v26' is possibly undefined
// 412818: variable 'v27' is possibly undefined
// 412818: variable 'v14' is possibly undefined
// 412818: variable 'v15' is possibly undefined
// 412818: variable 'v16' is possibly undefined
// 412818: variable 'v17' is possibly undefined
// 412818: variable 'v18' is possibly undefined
// 412818: variable 'v19' is possibly undefined
// 4127EC: variable 'v38' is possibly undefined
// 412810: variable 'v32' is possibly undefined
// 412810: variable 'v33' is possibly undefined
// 412810: variable 'v34' is possibly undefined
// 412810: variable 'v35' is possibly undefined
// 412810: variable 'v36' is possibly undefined
// 412810: variable 'v37' is possibly undefined
// 496B20: using guessed type __int64 free_list;
// 496B28: using guessed type int free_list_lock;

//----- (0000000000412840) ----------------------------------------------------
unsigned __int64 __fastcall realloc(
        unsigned __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  bool v18; // zf
  __int64 v19; // x0
  unsigned __int64 v20; // x4
  unsigned __int64 v21; // x5
  char *v22; // x6
  _QWORD *v23; // x5
  unsigned __int64 v25; // x1
  __int64 v26; // x0
  int *v27; // x22
  __int64 v28; // x1
  unsigned __int64 v29; // x8
  __int64 v30; // x1
  __int64 v31; // x2
  __int64 v32; // x3
  void *v33; // x6
  double v34; // d0
  double v35; // d1
  double v36; // d2
  double v37; // d3
  double v38; // d4
  double v39; // d5
  double v40; // d6
  double v41; // d7
  unsigned __int64 v42; // x4
  unsigned __int64 v43; // x5
  unsigned __int64 v44; // x8
  int v45; // w0
  __int64 v46; // x1
  __int64 v47; // x2
  void *v48; // x3
  void *v49; // x6
  __int64 v50; // x7
  double v51; // d0
  double v52; // d1
  double v53; // d2
  double v54; // d3
  double v55; // d4
  double v56; // d5
  double v57; // d6
  double v58; // d7
  void *v59; // x4
  int v60; // w0
  __int64 v61; // x1
  int *v62; // x0
  unsigned int v63; // w2
  __int64 v64; // x9
  size_t v65; // x21
  unsigned __int64 v66; // x22
  __int64 v67; // x1
  __int64 v68; // x2
  unsigned __int64 v69; // x3
  __int64 v70; // x7
  double v71; // d0
  double v72; // d1
  double v73; // d2
  double v74; // d3
  double v75; // d4
  double v76; // d5
  double v77; // d6
  double v78; // d7
  __int64 v79; // x9
  __int64 v80; // x0
  unsigned __int64 v81; // x20
  __int64 *v82; // x3
  unsigned __int64 v83; // x21
  __int64 v84; // x0
  unsigned __int64 v85; // x0
  __int64 v86; // x1
  unsigned __int64 v87; // x0
  int *v88; // x0
  unsigned __int64 v89; // x0
  double v90; // d0
  double v91; // d1
  double v92; // d2
  double v93; // d3
  double v94; // d4
  double v95; // d5
  double v96; // d6
  double v97; // d7
  __int64 v98; // x1
  unsigned __int64 v99; // x0
  double v100; // d0
  double v101; // d1
  double v102; // d2
  double v103; // d3
  double v104; // d4
  double v105; // d5
  double v106; // d6
  double v107; // d7
  __int64 *v108; // x4
  __int64 v109; // x0
  unsigned __int64 v110; // x2
  __int64 v111; // x6
  unsigned __int64 v112; // x1
  __int64 v113; // x21
  __int64 v114; // x7
  unsigned __int16 v115; // w0
  __int64 v116; // x1
  __int64 v117; // x1
  void *v118; // x0
  size_t v119; // x1
  __int64 v120; // x1
  unsigned __int64 v121; // [xsp+30h] [xbp+30h]
  _QWORD *v122; // [xsp+30h] [xbp+30h]
  unsigned __int64 v123; // [xsp+30h] [xbp+30h]
  __int64 *v124; // [xsp+30h] [xbp+30h]
  unsigned __int64 v125; // [xsp+30h] [xbp+30h]
  unsigned __int64 v126; // [xsp+30h] [xbp+30h]
  unsigned __int64 v127; // [xsp+30h] [xbp+30h]
  _QWORD *v128; // [xsp+30h] [xbp+30h]
  unsigned __int64 v129; // [xsp+30h] [xbp+30h]
  void *v130; // [xsp+38h] [xbp+38h]
  void *v131; // [xsp+38h] [xbp+38h]
  unsigned __int64 v132; // [xsp+38h] [xbp+38h]
  _QWORD *v133; // [xsp+38h] [xbp+38h]
  unsigned __int64 v134; // [xsp+38h] [xbp+38h]
  unsigned __int64 v135; // [xsp+38h] [xbp+38h]
  void *v136; // [xsp+40h] [xbp+40h]
  void *v137; // [xsp+40h] [xbp+40h]
  unsigned __int64 v138; // [xsp+40h] [xbp+40h]
  __int64 v139; // [xsp+40h] [xbp+40h]
  _QWORD *v140; // [xsp+48h] [xbp+48h]
  _QWORD *v141; // [xsp+48h] [xbp+48h]
  __int64 v142; // [xsp+50h] [xbp+50h]
  __int64 *v143; // [xsp+50h] [xbp+50h]

  if ( (_malloc_initialized & 1) == 0 )
    ptmalloc_init_part_0((unsigned __int8)_malloc_initialized, a2, a3, a4, a5, a6, a7);
  if ( a2 )
    v18 = 1;
  else
    v18 = a1 == 0;
  if ( !v18 )
  {
    free(a1, a9, a10, a11, a12, a13, a14, a15, a16);
    return 0LL;
  }
  if ( a1 )
  {
    v19 = *(_QWORD *)(a1 - 8);
    v20 = a1 - 16;
    v21 = v19 & 0xFFFFFFFFFFFFFFF8LL;
    v22 = (char *)((v19 & 0xFFFFFFFFFFFFFFF8LL) - 16);
    if ( (v19 & 2) != 0 )
    {
      if ( a2 <= (unsigned __int64)v22
        && ((unsigned __int64)&v22[-a2] <= 0xF || dl_pagesize >= (unsigned __int64)&v22[-a2]) )
      {
        return a1;
      }
      v27 = 0LL;
LABEL_23:
      if ( -(__int64)v21 < v20 || (v20 & 0xF) != 0 )
        malloc_printerr((__int64)"realloc(): invalid pointer", a9, a10, a11, a12, a13, a14, a15, a16);
      if ( (a2 & 0x8000000000000000LL) != 0 )
      {
        *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 12;
        return 0LL;
      }
      v28 = *(_QWORD *)(v20 + 8);
      if ( a2 + 23 <= 0x1F )
        v29 = 32LL;
      else
        v29 = (a2 + 23) & 0xFFFFFFFFFFFFFFF0LL;
      if ( (v28 & 2) != 0 )
      {
        v64 = *(_QWORD *)(a1 - 16);
        v65 = (v28 & 0xFFFFFFFFFFFFFFF8LL) + v64;
        if ( ((v20 - v64) | v65) & (dl_pagesize - 1) | ((a1 & (dl_pagesize - 1)) - 1) & a1 & (dl_pagesize - 1) )
          malloc_printerr((__int64)"mremap_chunk(): invalid pointer", a9, a10, a11, a12, a13, a14, a15, a16);
        v66 = (dl_pagesize + 7 + v29 + v64) & -dl_pagesize;
        if ( v65 != v66 )
        {
          v123 = v29;
          v132 = v21;
          v137 = v22;
          v140 = (_QWORD *)v20;
          v142 = *(_QWORD *)(a1 - 16);
          v69 = mremap((void *)(v20 - v64), v65, (dl_pagesize + 7 + v29 + v64) & -dl_pagesize, 1u);
          if ( v69 == -1LL )
          {
            if ( v132 - 8 < v123 )
            {
              v89 = malloc(
                      a2,
                      v67,
                      v68,
                      (void *)0xFFFFFFFFFFFFFFFFLL,
                      v140,
                      (void *)(v132 - 8),
                      v137,
                      v70,
                      v71,
                      v72,
                      v73,
                      v74,
                      v75,
                      v76,
                      v77,
                      v78);
              v23 = (_QWORD *)v89;
              if ( v89 )
              {
                v138 = v89;
                j_memcpy();
                munmap_chunk(v140, v90, v91, v92, v93, v94, v95, v96, v97);
                return v138;
              }
              return (unsigned __int64)v23;
            }
          }
          else
          {
            v79 = v142;
            if ( v66 > qword_490600 - 1 )
            {
              v127 = v69;
              v118 = (void *)(v69 & -dl_pagesize);
              v119 = v66 + (v69 & (dl_pagesize - 1));
              if ( (v69 & (dl_pagesize - 1)) == 0 )
              {
                v118 = (void *)v69;
                v119 = v66;
              }
              madvise(v118, v119, 14);
              v69 = v127;
              v79 = v142;
            }
            a1 = v69 + v79 + 16;
            if ( ((v69 + v79) & 0xF) != 0 )
              _libc_assert_fail(
                (__int64)"aligned_OK (chunk2mem (p))",
                (__int64)"malloc.c",
                0xC11u,
                (__int64)"mremap_chunk");
            if ( v79 != *(_QWORD *)(v69 + v79) )
              _libc_assert_fail(
                (__int64)"prev_size (p) == offset",
                (__int64)"malloc.c",
                0xC13u,
                (__int64)"mremap_chunk");
            *(_QWORD *)(v69 + v79 + 8) = (v66 - v79) | 2;
            _aarch64_ldadd8_relax();
            v81 = v80 + v66 - v65;
            v82 = &mp_;
            do
            {
              v83 = v82[11];
              if ( v81 <= v83 )
                break;
              v124 = v82;
              _aarch64_cas8_acq();
              v82 = v124;
            }
            while ( v84 != v83 );
          }
        }
        return a1;
      }
      if ( _libc_single_threaded )
      {
        v85 = int_realloc(v27, v20, v21, v29, a9, a10, a11, a12, a13, a14, a15, a16);
        v23 = (_QWORD *)v85;
        if ( !v85 )
          return 0LL;
        v86 = *(_QWORD *)(v85 - 8);
        v87 = v85 - 16;
        if ( (v86 & 2) == 0 )
        {
          if ( (v86 & 4) != 0 )
          {
            v120 = -4 * qword_490608;
            if ( !qword_490608 )
              v120 = -67108864LL;
            v88 = *(int **)(v87 & v120);
          }
          else
          {
            v88 = &main_arena;
          }
          if ( v27 != v88 )
          {
            v63 = 3587;
            goto LABEL_40;
          }
        }
      }
      else
      {
        v121 = v29;
        v130 = (void *)v21;
        v136 = (void *)v20;
        _aarch64_cas4_acq();
        v42 = (unsigned __int64)v136;
        v44 = v121;
        v43 = (unsigned __int64)v130;
        if ( v45 )
        {
          _lll_lock_wait_private(v27, v34, v35, v36, v37, v38, v39, v40, v41, v30, v31, v32, v136, v130, v33);
          v42 = (unsigned __int64)v136;
          v44 = v121;
          v43 = (unsigned __int64)v130;
        }
        v131 = (void *)v42;
        v122 = (_QWORD *)int_realloc(v27, v42, v43, v44, v34, v35, v36, v37, v38, v39, v40, v41);
        _aarch64_swp4_rel();
        v23 = v122;
        v59 = v131;
        if ( v60 > 1 )
        {
          _lll_lock_wake_private(v27, v46, v47, (__int64)v48, v131, v122, v49);
          v23 = v122;
          v59 = v131;
          if ( v122 )
          {
LABEL_35:
            v61 = *(v23 - 1);
            if ( (v61 & 2) != 0 )
              return (unsigned __int64)v23;
            if ( (v61 & 4) != 0 )
            {
              v98 = -4 * qword_490608;
              if ( !qword_490608 )
                v98 = -67108864LL;
              v62 = *(int **)((unsigned __int64)(v23 - 2) & v98);
            }
            else
            {
              v62 = &main_arena;
            }
            if ( v27 == v62 )
              return (unsigned __int64)v23;
            v63 = 3598;
LABEL_40:
            _libc_assert_fail(
              (__int64)"!newp || chunk_is_mmapped (mem2chunk (newp)) || ar_ptr == arena_for_chunk (mem2chunk (newp))",
              (__int64)"malloc.c",
              v63,
              (__int64)"__libc_realloc");
          }
        }
        else if ( v122 )
        {
          goto LABEL_35;
        }
        v125 = (unsigned __int64)v59;
        v99 = malloc(a2, v46, v47, v48, v59, v23, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58);
        if ( !v99 )
          return 0LL;
        v133 = (_QWORD *)v99;
        j_memcpy();
        v108 = (__int64 *)v125;
        v23 = v133;
        v109 = *(_QWORD *)(v125 + 8);
        v110 = v109 & 0xFFFFFFFFFFFFFFF8LL;
        if ( v125 > -(__int64)(v109 & 0xFFFFFFFFFFFFFFF8LL) )
          malloc_printerr((__int64)"free(): invalid pointer", v100, v101, v102, v103, v104, v105, v106, v107);
        if ( v110 <= 0x1F || (v109 & 8) != 0 )
          malloc_printerr((__int64)"free(): invalid size", v100, v101, v102, v103, v104, v105, v106, v107);
        v111 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 48);
        if ( !v111 )
          goto LABEL_93;
        v112 = (v110 - 17) >> 4;
        if ( v112 >= qword_490640 )
          goto LABEL_93;
        v113 = tcache_key;
        if ( *(_QWORD *)(a1 + 8) == tcache_key )
        {
          v129 = (v110 - 17) >> 4;
          v135 = v109 & 0xFFFFFFFFFFFFFFF8LL;
          v139 = v111;
          v141 = v23;
          v143 = v108;
          tcache_double_free_verify((_QWORD *)a1, v112, v100, v101, v102, v103, v104, v105, v106, v107);
          v108 = v143;
          v112 = v129;
          v110 = v135;
          v111 = v139;
          v23 = v141;
        }
        v114 = 2 * v112;
        v115 = *(_WORD *)(v111 + 2 * v112);
        if ( qword_490650 > (unsigned __int64)v115 )
        {
          v116 = v111 + 8 * v112;
          *(_QWORD *)a1 = *(_QWORD *)(v116 + 128) ^ (a1 >> 12);
          *(_QWORD *)(a1 + 8) = v113;
          *(_QWORD *)(v116 + 128) = a1;
          *(_WORD *)(v111 + v114) = v115 + 1;
        }
        else
        {
LABEL_93:
          v128 = v23;
          int_free_chunk(v27, v108, v110, 0, v100, v101, v102, v103, v104, v105, v106, v107);
          return (unsigned __int64)v128;
        }
      }
      return (unsigned __int64)v23;
    }
    if ( (*(_QWORD *)&v22[a1 + 8] & 1) != 0 )
    {
      if ( a2 <= v21 - 8 && v21 - 8 - a2 <= 0xF )
        return a1;
    }
    else if ( !a2 )
    {
      return a1;
    }
    v25 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 48;
    if ( *(_QWORD *)v25 || (v117 = *(unsigned __int8 *)(v25 + 0x10), (v117 & 1) != 0) )
    {
      if ( (v19 & 4) != 0 )
      {
LABEL_18:
        v26 = -4 * qword_490608;
        if ( !qword_490608 )
          v26 = -67108864LL;
        v27 = *(int **)(v20 & v26);
        goto LABEL_23;
      }
    }
    else
    {
      v126 = v19 & 0xFFFFFFFFFFFFFFF8LL;
      v134 = (v19 & 0xFFFFFFFFFFFFFFF8LL) - 16;
      tcache_init_part_0(v19, v117, 0LL, (__int64)a4, (void *)v20, (void *)v21, v22, a8);
      v20 = a1 - 16;
      v21 = v126;
      v22 = (char *)v134;
      if ( (*(_QWORD *)(a1 - 8) & 4) != 0 )
        goto LABEL_18;
    }
    v27 = &main_arena;
    goto LABEL_23;
  }
  return malloc(a2, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
}
// 412BA8: variable 'a9' is possibly undefined
// 412BA8: variable 'a10' is possibly undefined
// 412BA8: variable 'a11' is possibly undefined
// 412BA8: variable 'a12' is possibly undefined
// 412BA8: variable 'a13' is possibly undefined
// 412BA8: variable 'a14' is possibly undefined
// 412BA8: variable 'a15' is possibly undefined
// 412BA8: variable 'a16' is possibly undefined
// 41297C: variable 'v45' is possibly undefined
// 412DB8: variable 'v34' is possibly undefined
// 412DB8: variable 'v35' is possibly undefined
// 412DB8: variable 'v36' is possibly undefined
// 412DB8: variable 'v37' is possibly undefined
// 412DB8: variable 'v38' is possibly undefined
// 412DB8: variable 'v39' is possibly undefined
// 412DB8: variable 'v40' is possibly undefined
// 412DB8: variable 'v41' is possibly undefined
// 412DB8: variable 'v30' is possibly undefined
// 412DB8: variable 'v31' is possibly undefined
// 412DB8: variable 'v32' is possibly undefined
// 412DB8: variable 'v33' is possibly undefined
// 4129B4: variable 'v60' is possibly undefined
// 412B10: variable 'v80' is possibly undefined
// 412B44: variable 'v84' is possibly undefined
// 412BD4: variable 'a2' is possibly undefined
// 412BD4: variable 'a3' is possibly undefined
// 412BD4: variable 'a4' is possibly undefined
// 412BD4: variable 'a5' is possibly undefined
// 412BD4: variable 'a6' is possibly undefined
// 412BD4: variable 'a7' is possibly undefined
// 412BD4: variable 'a8' is possibly undefined
// 412BEC: variable 'v67' is possibly undefined
// 412BEC: variable 'v68' is possibly undefined
// 412BEC: variable 'v70' is possibly undefined
// 412BEC: variable 'v71' is possibly undefined
// 412BEC: variable 'v72' is possibly undefined
// 412BEC: variable 'v73' is possibly undefined
// 412BEC: variable 'v74' is possibly undefined
// 412BEC: variable 'v75' is possibly undefined
// 412BEC: variable 'v76' is possibly undefined
// 412BEC: variable 'v77' is possibly undefined
// 412BEC: variable 'v78' is possibly undefined
// 412C0C: variable 'v90' is possibly undefined
// 412C0C: variable 'v91' is possibly undefined
// 412C0C: variable 'v92' is possibly undefined
// 412C0C: variable 'v93' is possibly undefined
// 412C0C: variable 'v94' is possibly undefined
// 412C0C: variable 'v95' is possibly undefined
// 412C0C: variable 'v96' is possibly undefined
// 412C0C: variable 'v97' is possibly undefined
// 412C60: variable 'v46' is possibly undefined
// 412C60: variable 'v47' is possibly undefined
// 412C60: variable 'v48' is possibly undefined
// 412C60: variable 'v49' is possibly undefined
// 412C60: variable 'v50' is possibly undefined
// 412C60: variable 'v51' is possibly undefined
// 412C60: variable 'v52' is possibly undefined
// 412C60: variable 'v53' is possibly undefined
// 412C60: variable 'v54' is possibly undefined
// 412C60: variable 'v55' is possibly undefined
// 412C60: variable 'v56' is possibly undefined
// 412C60: variable 'v57' is possibly undefined
// 412C60: variable 'v58' is possibly undefined
// 412E2C: variable 'v100' is possibly undefined
// 412E2C: variable 'v101' is possibly undefined
// 412E2C: variable 'v102' is possibly undefined
// 412E2C: variable 'v103' is possibly undefined
// 412E2C: variable 'v104' is possibly undefined
// 412E2C: variable 'v105' is possibly undefined
// 412E2C: variable 'v106' is possibly undefined
// 412E2C: variable 'v107' is possibly undefined
// 412E80: using guessed type __int64 memalign(void);
// 4905D8: using guessed type __int64 mp_;
// 490600: using guessed type __int64 qword_490600;
// 490608: using guessed type __int64 qword_490608;
// 490640: using guessed type __int64 qword_490640;
// 490650: using guessed type __int64 qword_490650;
// 490670: using guessed type int main_arena;
// 490F08: using guessed type char _libc_single_threaded;
// 490F10: using guessed type __int64 dl_pagesize;
// 496B05: using guessed type char _malloc_initialized;
// 496B08: using guessed type __int64 tcache_key;

//----- (0000000000412E80) ----------------------------------------------------
unsigned __int64 __fastcall memalign(
        unsigned __int64 a1,
        __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        void *a12,
        void *a13,
        void *a14,
        void *a15,
        __int64 a16)
{
  __int64 v16; // x2
  unsigned __int64 v18; // [xsp+10h] [xbp-10h]
  __int64 v19; // [xsp+18h] [xbp-8h]

  v16 = (unsigned __int8)_malloc_initialized;
  if ( (_malloc_initialized & 1) == 0 )
  {
    v18 = a1;
    v19 = a2;
    ptmalloc_init_part_0(a1, a2, (unsigned __int8)_malloc_initialized, a12, a13, a14, a15);
    a1 = v18;
    a2 = v19;
  }
  return mid_memalign_isra_0(
           a1,
           a2,
           v16,
           a12,
           (unsigned __int64)a13,
           (unsigned __int64)a14,
           a15,
           a16,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10);
}
// 412E8C: variable 'v16' is possibly undefined
// 412E8C: variable 'a12' is possibly undefined
// 412E8C: variable 'a13' is possibly undefined
// 412E8C: variable 'a14' is possibly undefined
// 412E8C: variable 'a15' is possibly undefined
// 412E8C: variable 'a16' is possibly undefined
// 412E8C: variable 'a3' is possibly undefined
// 412E8C: variable 'a4' is possibly undefined
// 412E8C: variable 'a5' is possibly undefined
// 412E8C: variable 'a6' is possibly undefined
// 412E8C: variable 'a7' is possibly undefined
// 412E8C: variable 'a8' is possibly undefined
// 412E8C: variable 'a9' is possibly undefined
// 412E8C: variable 'a10' is possibly undefined
// 496B05: using guessed type char _malloc_initialized;

//----- (0000000000412EAC) ----------------------------------------------------
unsigned __int64 __fastcall aligned_alloc(
        unsigned __int64 a1,
        __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        void *a12,
        void *a13,
        void *a14,
        void *a15,
        __int64 a16)
{
  __int64 v16; // x2
  unsigned __int64 v20; // [xsp+10h] [xbp-10h]
  __int64 v21; // [xsp+18h] [xbp-8h]

  if ( (_malloc_initialized & 1) != 0 )
  {
    v16 = a1 - 1;
    if ( ((a1 - 1) & a1) == 0 && a1 != 0 )
      return mid_memalign_isra_0(
               a1,
               a2,
               v16,
               a12,
               (unsigned __int64)a13,
               (unsigned __int64)a14,
               a15,
               a16,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10);
  }
  else
  {
    v20 = a1;
    v21 = a2;
    ptmalloc_init_part_0(a1, a2, (unsigned __int8)_malloc_initialized, a12, a13, a14, a15);
    a1 = v20;
    a2 = v21;
    v16 = v20 - 1;
    if ( ((v20 - 1) & v20) == 0 && v20 != 0 )
      return mid_memalign_isra_0(
               a1,
               a2,
               v16,
               a12,
               (unsigned __int64)a13,
               (unsigned __int64)a14,
               a15,
               a16,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10);
  }
  *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
  return 0LL;
}
// 412EC8: variable 'a12' is possibly undefined
// 412EC8: variable 'a13' is possibly undefined
// 412EC8: variable 'a14' is possibly undefined
// 412EC8: variable 'a15' is possibly undefined
// 412EC8: variable 'a16' is possibly undefined
// 412EC8: variable 'a3' is possibly undefined
// 412EC8: variable 'a4' is possibly undefined
// 412EC8: variable 'a5' is possibly undefined
// 412EC8: variable 'a6' is possibly undefined
// 412EC8: variable 'a7' is possibly undefined
// 412EC8: variable 'a8' is possibly undefined
// 412EC8: variable 'a9' is possibly undefined
// 412EC8: variable 'a10' is possibly undefined
// 496B05: using guessed type char _malloc_initialized;

//----- (0000000000412F40) ----------------------------------------------------
unsigned __int64 __fastcall valloc(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        void *a12,
        void *a13,
        void *a14,
        void *a15,
        __int64 a16)
{
  __int64 v16; // x1

  if ( (_malloc_initialized & 1) != 0 )
  {
    v16 = a1;
  }
  else
  {
    ptmalloc_init_part_0(a1, (unsigned __int8)_malloc_initialized, a11, a12, a13, a14, a15);
    v16 = a1;
  }
  return mid_memalign_isra_0(
           dl_pagesize,
           v16,
           a11,
           a12,
           (unsigned __int64)a13,
           (unsigned __int64)a14,
           a15,
           a16,
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9);
}
// 412F88: variable 'a11' is possibly undefined
// 412F88: variable 'a12' is possibly undefined
// 412F88: variable 'a13' is possibly undefined
// 412F88: variable 'a14' is possibly undefined
// 412F88: variable 'a15' is possibly undefined
// 412F88: variable 'a16' is possibly undefined
// 412F88: variable 'a2' is possibly undefined
// 412F88: variable 'a3' is possibly undefined
// 412F88: variable 'a4' is possibly undefined
// 412F88: variable 'a5' is possibly undefined
// 412F88: variable 'a6' is possibly undefined
// 412F88: variable 'a7' is possibly undefined
// 412F88: variable 'a8' is possibly undefined
// 412F88: variable 'a9' is possibly undefined
// 490F10: using guessed type __int64 dl_pagesize;
// 496B05: using guessed type char _malloc_initialized;

//----- (0000000000412F8C) ----------------------------------------------------
unsigned __int64 __fastcall pvalloc(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        void *a12,
        void *a13,
        void *a14,
        void *a15,
        __int64 a16)
{
  __int64 v16; // x2
  __int64 v17; // x1
  unsigned __int64 v18; // x0

  if ( (_malloc_initialized & 1) != 0 )
  {
    v16 = dl_pagesize;
    if ( !__CFADD__(dl_pagesize - 1, a1) )
    {
      v17 = (1 - dl_pagesize) & (dl_pagesize - 1 + a1);
      v18 = dl_pagesize;
      return mid_memalign_isra_0(
               v18,
               v17,
               v16,
               a12,
               (unsigned __int64)a13,
               (unsigned __int64)a14,
               a15,
               a16,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9);
    }
  }
  else
  {
    ptmalloc_init_part_0(a1, (unsigned __int8)_malloc_initialized, a11, a12, a13, a14, a15);
    v16 = dl_pagesize;
    if ( !__CFADD__(dl_pagesize - 1, a1) )
    {
      v17 = (1 - dl_pagesize) & (dl_pagesize - 1 + a1);
      v18 = dl_pagesize;
      return mid_memalign_isra_0(
               v18,
               v17,
               v16,
               a12,
               (unsigned __int64)a13,
               (unsigned __int64)a14,
               a15,
               a16,
               a2,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9);
    }
  }
  *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 12;
  return 0LL;
}
// 413004: variable 'a12' is possibly undefined
// 413004: variable 'a13' is possibly undefined
// 413004: variable 'a14' is possibly undefined
// 413004: variable 'a15' is possibly undefined
// 413004: variable 'a16' is possibly undefined
// 413004: variable 'a2' is possibly undefined
// 413004: variable 'a3' is possibly undefined
// 413004: variable 'a4' is possibly undefined
// 413004: variable 'a5' is possibly undefined
// 413004: variable 'a6' is possibly undefined
// 413004: variable 'a7' is possibly undefined
// 413004: variable 'a8' is possibly undefined
// 413004: variable 'a9' is possibly undefined
// 490F10: using guessed type __int64 dl_pagesize;
// 496B05: using guessed type char _malloc_initialized;

//----- (0000000000413044) ----------------------------------------------------
int8x16_t *(__fastcall *__fastcall calloc(
        unsigned __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        void *a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        __int64 a13,
        void *a14,
        __int64 a15,
        __int64 a16))(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3)
{
  __int64 v16; // x4
  __int64 v17; // x1
  void *v18; // x6
  __int64 StatusReg; // x1
  __int64 v20; // x3
  unsigned __int64 v21; // x0
  __int64 v22; // x2
  __int16 v23; // w5
  __int64 v24; // x1
  unsigned __int64 v25; // x3
  __int64 v26; // x0
  unsigned __int64 v27; // x0
  unsigned __int64 v28; // x4
  __int64 v30; // x2
  __int64 v31; // x1
  __int64 v32; // x3
  void *v33; // x6
  int *v34; // x2
  int v35; // w0
  unsigned __int64 v36; // x10
  unsigned __int64 v37; // x7
  __int64 v38; // x1
  unsigned __int64 v39; // x1
  unsigned __int64 v40; // x0
  _DWORD *v41; // x6
  int *v42; // x2
  void *v43; // x4
  unsigned __int64 v44; // x7
  unsigned __int64 v45; // x10
  unsigned __int64 v46; // x8
  __int64 v47; // x0
  __int64 v48; // x1
  __int64 v49; // x2
  void *v50; // x5
  int v51; // w0
  __int64 v52; // x1
  unsigned __int64 v53; // x0
  unsigned __int64 v55; // x1
  __int64 v56; // x0
  int *retry; // x19
  double v58; // d0
  double v59; // d1
  double v60; // d2
  double v61; // d3
  double v62; // d4
  double v63; // d5
  double v64; // d6
  double v65; // d7
  void *v66; // x4
  __int64 v67; // x1
  __int64 v68; // x2
  void *v69; // x5
  int v70; // w0
  unsigned __int64 v71; // x0
  __int64 v72; // x1
  __int64 *v73; // [xsp+20h] [xbp+20h]
  int *v74; // [xsp+20h] [xbp+20h]
  int *v75; // [xsp+20h] [xbp+20h]
  __int64 v76; // [xsp+20h] [xbp+20h]
  int *v77; // [xsp+20h] [xbp+20h]
  unsigned __int64 v78; // [xsp+20h] [xbp+20h]
  __int64 v79; // [xsp+20h] [xbp+20h]
  __int64 v80; // [xsp+28h] [xbp+28h]
  void *v81; // [xsp+28h] [xbp+28h]
  __int64 v82; // [xsp+28h] [xbp+28h]
  unsigned __int64 v83; // [xsp+28h] [xbp+28h]
  unsigned __int64 v84; // [xsp+28h] [xbp+28h]
  __int64 v85; // [xsp+30h] [xbp+30h]
  unsigned __int64 v86; // [xsp+30h] [xbp+30h]
  unsigned __int64 v87; // [xsp+30h] [xbp+30h]
  __int64 v88; // [xsp+30h] [xbp+30h]
  unsigned __int64 v89; // [xsp+38h] [xbp+38h]
  unsigned __int64 v90; // [xsp+38h] [xbp+38h]
  __int64 v91; // [xsp+38h] [xbp+38h]
  void *v92; // [xsp+38h] [xbp+38h]
  void *v93; // [xsp+40h] [xbp+40h]
  unsigned __int64 v94; // [xsp+48h] [xbp+48h]

  v16 = a2 * a1;
  v17 = (a2 * (unsigned __int128)a1) >> 64;
  if ( (v16 & 0x8000000000000000LL) == 0 && !v17 )
  {
    v18 = &unk_496000;
    if ( (_malloc_initialized & 1) == 0 )
    {
      v76 = v16;
      ptmalloc_init_part_0((unsigned __int8)_malloc_initialized, 0LL, a3, a4, (void *)v16, a14, &unk_496000);
      v16 = v76;
    }
    if ( v16 < 0 )
    {
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 12;
      return 0LL;
    }
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v20 = StatusReg + 48;
    v21 = (((v16 + 23) & 0xFFFFFFFFFFFFFFF0LL) - 17) >> 4;
    if ( (unsigned __int64)(v16 + 23) <= 0x1F )
      v21 = 0LL;
    v22 = *(_QWORD *)v20;
    if ( *(_QWORD *)v20 )
    {
      v20 = qword_490640;
      if ( v21 < qword_490640 )
        goto LABEL_10;
    }
    else
    {
      v30 = *(unsigned __int8 *)(v20 + 0x10);
      if ( (v30 & 1) == 0 )
      {
        v73 = (__int64 *)(StatusReg + 48);
        v80 = v16;
        v85 = StatusReg;
        v89 = v21;
        tcache_init_part_0(v21, StatusReg, v30, v20, (void *)v16, a14, v18, a16);
        v21 = v89;
        v16 = v80;
        StatusReg = v85;
        if ( v89 < qword_490640 )
        {
          v20 = (__int64)v73;
          v22 = *v73;
          if ( *v73 )
          {
LABEL_10:
            a16 = 2 * v21;
            v23 = *(_WORD *)(v22 + 2 * v21);
            if ( v23 )
            {
              v24 = v22 + 8 * v21;
              v25 = *(_QWORD *)(v24 + 128);
              if ( (v25 & 0xF) != 0 )
                malloc_printerr((__int64)"malloc(): unaligned tcache chunk detected", a5, a6, a7, a8, a9, a10, a11, a12);
              *(_QWORD *)(v24 + 128) = *(_QWORD *)v25 ^ (v25 >> 12);
              v26 = *(_QWORD *)(v25 - 8);
              *(_WORD *)(v22 + a16) = v23 - 1;
              *(_QWORD *)(v25 + 8) = 0LL;
              v27 = v26 & 0xFFFFFFFFFFFFFFF8LL;
              v28 = (v27 - 8) >> 3;
              if ( v27 - 8 <= 0x48 )
              {
                *(_QWORD *)v25 = 0LL;
                *(_QWORD *)(v25 + 16) = 0LL;
                *(_OWORD *)(v25 + 8LL * (unsigned int)(v28 - 2)) = 0u;
                if ( v28 > 5 )
                {
                  *(_OWORD *)(v25 + 24) = 0uLL;
                  *(_OWORD *)(v25 + v27 - 40) = 0uLL;
                }
                return (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))v25;
              }
              return memset();
            }
          }
        }
      }
    }
    if ( _libc_single_threaded )
    {
      v34 = &main_arena;
      v36 = (unsigned __int64)off_4906D0;
      v37 = *((_QWORD *)off_4906D0 + 1) & 0xFFFFFFFFFFFFFFF8LL;
    }
    else
    {
      if ( *(_QWORD *)(StatusReg + 56) )
      {
        v74 = *(int **)(StatusReg + 56);
        v81 = (void *)v16;
        _aarch64_cas4_acq();
        v34 = v74;
        v16 = (__int64)v81;
        if ( v35 )
        {
          _lll_lock_wait_private(
            v74,
            a5,
            a6,
            a7,
            a8,
            a9,
            a10,
            a11,
            a12,
            v31,
            (__int64)v74,
            v32,
            v81,
            &_libc_single_threaded,
            v33);
          v34 = v74;
          v16 = (__int64)v81;
        }
      }
      else
      {
        v79 = v16;
        v34 = arena_get2(v16, 0LL, 0LL, v20, (void *)v16, &_libc_single_threaded, v18, a16);
        v16 = v79;
        if ( !v34 )
        {
          v71 = int_malloc(0LL, v79, a5, a6, a7, a8, a9, a10, a11, a12);
          v25 = v71;
          v43 = (void *)v79;
          v42 = 0LL;
          v41 = (_DWORD *)&unk_496000;
          if ( v71 )
          {
            v47 = *(_QWORD *)(v71 - 8);
            v46 = v25 - 16;
            v44 = v47 & 2;
            if ( (v47 & 2) != 0 )
              goto LABEL_31;
            if ( (v47 & 4) == 0 )
              goto LABEL_71;
            v45 = 0LL;
            goto LABEL_62;
          }
          return 0LL;
        }
      }
      v36 = *((_QWORD *)v34 + 12);
      v37 = *(_QWORD *)(v36 + 8) & 0xFFFFFFFFFFFFFFF8LL;
      if ( v34 != &main_arena )
      {
        v38 = -4 * qword_490608;
        if ( !qword_490608 )
          v38 = -67108864LL;
        v39 = (v36 & v38) + *(_QWORD *)((v36 & v38) + 0x18) - v36;
        if ( v37 < v39 )
          v37 = v39;
      }
    }
    v75 = v34;
    v82 = v16;
    v86 = v36;
    v90 = v37;
    v40 = int_malloc(v34, v16, a5, a6, a7, a8, a9, a10, a11, a12);
    v41 = &unk_496000;
    v25 = v40;
    v42 = v75;
    v43 = (void *)v82;
    v45 = v86;
    v44 = v90;
    if ( v40 )
    {
      v46 = v40 - 16;
      v47 = *(_QWORD *)(v40 - 8);
      if ( (v47 & 2) != 0 )
      {
        if ( _libc_single_threaded )
          goto LABEL_31;
        goto LABEL_39;
      }
      if ( (v47 & 4) == 0 )
      {
        if ( v75 == &main_arena )
        {
          if ( !_libc_single_threaded )
            goto LABEL_39;
          goto LABEL_67;
        }
        goto LABEL_71;
      }
LABEL_62:
      v72 = -4 * qword_490608;
      if ( !qword_490608 )
        v72 = -67108864LL;
      if ( v42 == *(int **)(v46 & v72) )
      {
        if ( !_libc_single_threaded && v42 )
        {
LABEL_39:
          v77 = v42;
          v83 = v45;
          v87 = v44;
          v91 = v25;
          v93 = v43;
          v94 = v46;
          _aarch64_swp4_rel();
          v41 = &unk_496000;
          v46 = v94;
          v45 = v83;
          v44 = v87;
          v25 = v91;
          if ( v51 > 1 )
          {
            _lll_lock_wake_private(v77, v48, v49, v91, v93, v50, &unk_496000);
            v46 = v94;
            v41 = (_DWORD *)&unk_496000;
            v45 = v83;
            v44 = v87;
            v25 = v91;
          }
LABEL_41:
          v52 = *(_QWORD *)(v46 + 8);
          v53 = v52 & 0xFFFFFFFFFFFFFFF8LL;
          if ( (v52 & 2) == 0 )
          {
LABEL_42:
            if ( !v41[704] && v46 == v45 && v44 < v53 )
              v53 = v44;
            v55 = (v53 - 8) >> 3;
            if ( v53 - 8 <= 0x4F )
            {
              *(_QWORD *)(v25 + 16) = 0LL;
              v56 = 8LL * (unsigned int)(v55 - 2);
              *(_OWORD *)v25 = 0u;
              *(_OWORD *)(v25 + v56) = 0u;
              if ( v55 > 5 )
              {
                *(_OWORD *)(v25 + 24) = 0uLL;
                *(_OWORD *)(v25 + v56 - 16) = 0uLL;
              }
              return (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))v25;
            }
            return memset();
          }
LABEL_31:
          if ( !v41[704] )
            return (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))v25;
          return memset();
        }
LABEL_67:
        v53 = v47 & 0xFFFFFFFFFFFFFFF8LL;
        goto LABEL_42;
      }
LABEL_71:
      _libc_assert_fail(
        (__int64)"!mem || chunk_is_mmapped (mem2chunk (mem)) || av == arena_for_chunk (mem2chunk (mem))",
        (__int64)"malloc.c",
        0xF06u,
        (__int64)"__libc_calloc");
    }
    if ( !_libc_single_threaded )
    {
      retry = arena_get_retry(v75, v82);
      v25 = int_malloc(retry, v82, v58, v59, v60, v61, v62, v63, v64, v65);
      v44 = v90;
      v66 = (void *)v82;
      v45 = v86;
      v41 = (_DWORD *)&unk_496000;
      if ( retry )
      {
        v78 = v86;
        v84 = v90;
        v88 = v25;
        v92 = v66;
        _aarch64_swp4_rel();
        v41 = (_DWORD *)&unk_496000;
        v45 = v78;
        v44 = v84;
        v25 = v88;
        if ( v70 > 1 )
        {
          _lll_lock_wake_private(retry, v67, v68, v88, v92, v69, &unk_496000);
          v41 = (_DWORD *)&unk_496000;
          v45 = v78;
          v44 = v84;
          v25 = v88;
        }
      }
      if ( v25 )
      {
        v46 = v25 - 16;
        goto LABEL_41;
      }
    }
    return 0LL;
  }
  *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 12;
  return 0LL;
}
// 413148: variable 'a14' is possibly undefined
// 413148: variable 'v18' is possibly undefined
// 413148: variable 'a16' is possibly undefined
// 4131B0: variable 'v35' is possibly undefined
// 4134B8: variable 'a5' is possibly undefined
// 4134B8: variable 'a6' is possibly undefined
// 4134B8: variable 'a7' is possibly undefined
// 4134B8: variable 'a8' is possibly undefined
// 4134B8: variable 'a9' is possibly undefined
// 4134B8: variable 'a10' is possibly undefined
// 4134B8: variable 'a11' is possibly undefined
// 4134B8: variable 'a12' is possibly undefined
// 4134B8: variable 'v31' is possibly undefined
// 4134B8: variable 'v32' is possibly undefined
// 4134B8: variable 'v33' is possibly undefined
// 4132F4: variable 'v51' is possibly undefined
// 4134D8: variable 'v48' is possibly undefined
// 4134D8: variable 'v49' is possibly undefined
// 4134D8: variable 'v50' is possibly undefined
// 413380: variable 'v58' is possibly undefined
// 413380: variable 'v59' is possibly undefined
// 413380: variable 'v60' is possibly undefined
// 413380: variable 'v61' is possibly undefined
// 413380: variable 'v62' is possibly undefined
// 413380: variable 'v63' is possibly undefined
// 413380: variable 'v64' is possibly undefined
// 413380: variable 'v65' is possibly undefined
// 4133BC: variable 'v70' is possibly undefined
// 413480: variable 'v67' is possibly undefined
// 413480: variable 'v68' is possibly undefined
// 413480: variable 'v69' is possibly undefined
// 4133DC: variable 'v20' is possibly undefined
// 413520: using guessed type __int64 malloc_trim(void);
// 490608: using guessed type __int64 qword_490608;
// 490640: using guessed type __int64 qword_490640;
// 490670: using guessed type int main_arena;
// 4906D0: using guessed type _UNKNOWN *off_4906D0;
// 490F08: using guessed type char _libc_single_threaded;
// 496B05: using guessed type char _malloc_initialized;

//----- (0000000000413520) ----------------------------------------------------
__int64 __fastcall malloc_trim(unsigned __int64 a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7)
{
  int *v7; // x21
  unsigned int v8; // w22
  __int64 v9; // x1
  __int64 v10; // x2
  __int64 v11; // x3
  void *v12; // x4
  void *v13; // x5
  void *v14; // x6
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  int v23; // w0
  signed int v24; // w20
  unsigned __int64 v25; // x24
  unsigned __int64 v26; // x25
  int *v27; // x27
  __int64 v28; // x28
  int v29; // w4
  int v30; // w26
  __int64 i; // x19
  unsigned __int64 v34; // x1
  void *v35; // x0
  unsigned __int64 v36; // x1
  __int64 v37; // x1
  __int64 v38; // x2
  __int64 v39; // x3
  void *v40; // x4
  void *v41; // x5
  void *v42; // x6
  int v43; // w0
  int v45; // w0
  unsigned __int64 v46; // x20

  if ( (_malloc_initialized & 1) == 0 )
    ptmalloc_init_part_0((unsigned __int8)_malloc_initialized, a2, a3, a4, a5, a6, a7);
  v7 = &main_arena;
  v8 = 0;
  do
  {
    _aarch64_cas4_acq();
    if ( v23 )
      _lll_lock_wait_private(v7, v15, v16, v17, v18, v19, v20, v21, v22, v9, v10, v11, v12, v13, v14);
    malloc_consolidate((__int64)v7);
    v24 = (unsigned int)dl_pagesize >> 4;
    if ( (unsigned __int64)dl_pagesize > 0x3FF )
    {
      v24 = ((unsigned __int64)dl_pagesize >> 6) + 48;
      if ( (unsigned __int64)dl_pagesize > 0xC3F )
      {
        if ( (unsigned __int64)dl_pagesize >> 9 <= 0x14 )
        {
          v24 = ((unsigned __int64)dl_pagesize >> 9) + 91;
        }
        else if ( (unsigned __int64)dl_pagesize >> 12 > 0xA )
        {
          if ( (unsigned __int64)dl_pagesize >> 15 > 4 )
          {
            v46 = (unsigned __int64)dl_pagesize >> 18;
            if ( (unsigned __int64)dl_pagesize >> 18 > 2 )
              LODWORD(v46) = 2;
            v24 = v46 + 124;
          }
          else
          {
            v24 = ((unsigned __int64)dl_pagesize >> 15) + 119;
          }
        }
        else
        {
          v24 = ((unsigned __int64)dl_pagesize >> 12) + 110;
        }
      }
    }
    v25 = dl_pagesize - 1;
    v26 = dl_pagesize + 47;
    v27 = v7 + 24;
    v28 = -dl_pagesize;
    v29 = 0;
    v30 = 1;
    while ( 1 )
    {
      for ( ; v30 != 1 && v30 < v24; v27 += 4 )
        ++v30;
      for ( i = *((_QWORD *)v27 + 3); v27 != (int *)i; v29 = 1 )
      {
        while ( 1 )
        {
          v34 = *(_QWORD *)(i + 8) & 0xFFFFFFFFFFFFFFF8LL;
          if ( v34 > v26 )
          {
            v35 = (void *)((i + v26) & v28);
            if ( (unsigned __int64)v35 < i + 48 )
              _libc_assert_fail(
                (__int64)"(char *) chunk2mem (p) + 2 * CHUNK_HDR_SZ <= paligned_mem",
                (__int64)"malloc.c",
                0x1470u,
                (__int64)"mtrim");
            if ( (unsigned __int64)v35 >= i + v34 )
              _libc_assert_fail(
                (__int64)"(char *) p + size > paligned_mem",
                (__int64)"malloc.c",
                0x1472u,
                (__int64)"mtrim");
            v36 = v34 - ((unsigned __int64)v35 - i);
            if ( v25 < v36 )
              break;
          }
          i = *(_QWORD *)(i + 24);
          if ( v27 == (int *)i )
            goto LABEL_29;
        }
        madvise(v35, v28 & v36, 4);
        i = *(_QWORD *)(i + 24);
      }
LABEL_29:
      if ( ++v30 == 128 )
        break;
      v27 += 4;
    }
    if ( v7 == &main_arena )
    {
      v8 |= v29 | systrim_constprop_0(a1);
      _aarch64_swp4_rel();
      if ( v45 <= 1 )
        goto LABEL_33;
    }
    else
    {
      v8 |= v29;
      _aarch64_swp4_rel();
      if ( v43 <= 1 )
        goto LABEL_33;
    }
    _lll_lock_wake_private(v7, v37, v38, v39, v40, v41, v42);
LABEL_33:
    v7 = (int *)*((_QWORD *)v7 + 270);
  }
  while ( v7 != &main_arena );
  return v8;
}
// 413578: variable 'v23' is possibly undefined
// 41372C: variable 'v15' is possibly undefined
// 41372C: variable 'v16' is possibly undefined
// 41372C: variable 'v17' is possibly undefined
// 41372C: variable 'v18' is possibly undefined
// 41372C: variable 'v19' is possibly undefined
// 41372C: variable 'v20' is possibly undefined
// 41372C: variable 'v21' is possibly undefined
// 41372C: variable 'v22' is possibly undefined
// 41372C: variable 'v9' is possibly undefined
// 41372C: variable 'v10' is possibly undefined
// 41372C: variable 'v11' is possibly undefined
// 41372C: variable 'v12' is possibly undefined
// 41372C: variable 'v13' is possibly undefined
// 41372C: variable 'v14' is possibly undefined
// 4136B8: variable 'v43' is possibly undefined
// 413718: variable 'v45' is possibly undefined
// 413720: variable 'v37' is possibly undefined
// 413720: variable 'v38' is possibly undefined
// 413720: variable 'v39' is possibly undefined
// 413720: variable 'v40' is possibly undefined
// 413720: variable 'v41' is possibly undefined
// 413720: variable 'v42' is possibly undefined
// 490670: using guessed type int main_arena;
// 490F10: using guessed type __int64 dl_pagesize;
// 496B05: using guessed type char _malloc_initialized;

//----- (00000000004137A8) ----------------------------------------------------
__int64 __fastcall malloc_usable_size(__int64 a1)
{
  __int64 v2; // x3
  __int64 result; // x0

  if ( !a1 )
    return 0LL;
  v2 = *(_QWORD *)(a1 - 8);
  result = (v2 & 0xFFFFFFFFFFFFFFF8LL) - 16;
  if ( (v2 & 2) == 0 )
  {
    result = *(_QWORD *)(a1 + result + 8) & 1LL;
    if ( result )
      return (v2 & 0xFFFFFFFFFFFFFFF8LL) - 8;
  }
  return result;
}

//----- (00000000004137E0) ----------------------------------------------------
void __usercall mallinfo2(
        __int64 a1@<X1>,
        __int64 a2@<X2>,
        void *a3@<X3>,
        void *a4@<X4>,
        void *a5@<X5>,
        void *a6@<X6>,
        _OWORD *a7@<X8>)
{
  int *v8; // x19
  __int64 v9; // x1
  __int64 v10; // x2
  __int64 v11; // x3
  void *v12; // x4
  void *v13; // x5
  void *v14; // x6
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  int v23; // w0
  __int64 v24; // x1
  __int64 v25; // x2
  __int64 v26; // x3
  void *v27; // x4
  void *v28; // x5
  void *v29; // x6
  int v30; // w0
  __int128 v31; // q27
  __int128 v32; // q28
  __int128 v33; // q29
  __int128 v34; // q30
  __int128 v35; // [xsp+30h] [xbp+30h] BYREF
  __int128 v36; // [xsp+40h] [xbp+40h]
  __int128 v37; // [xsp+50h] [xbp+50h]
  __int128 v38; // [xsp+60h] [xbp+60h]
  __int128 v39; // [xsp+70h] [xbp+70h]

  if ( (_malloc_initialized & 1) == 0 )
    ptmalloc_init_part_0((unsigned __int8)_malloc_initialized, a1, a2, a3, a4, a5, a6);
  v8 = &main_arena;
  v35 = 0u;
  v36 = 0u;
  v37 = 0u;
  v38 = 0u;
  v39 = 0u;
  do
  {
    _aarch64_cas4_acq();
    if ( v23 )
      _lll_lock_wait_private(v8, v15, v16, v17, v18, v19, v20, v21, v22, v9, v10, v11, v12, v13, v14);
    int_mallinfo((__int64)v8, (__int64 *)&v35, v15, v16, v17, v18, v19, v20, v21, v22);
    _aarch64_swp4_rel();
    if ( v30 > 1 )
      _lll_lock_wake_private(v8, v24, v25, v26, v27, v28, v29);
    v8 = (int *)*((_QWORD *)v8 + 270);
  }
  while ( v8 != &main_arena );
  v32 = v35;
  v31 = v36;
  v34 = v37;
  v33 = v38;
  a7[4] = v39;
  *a7 = v32;
  a7[1] = v31;
  a7[2] = v34;
  a7[3] = v33;
}
// 413830: variable 'v23' is possibly undefined
// 413898: variable 'v15' is possibly undefined
// 413898: variable 'v16' is possibly undefined
// 413898: variable 'v17' is possibly undefined
// 413898: variable 'v18' is possibly undefined
// 413898: variable 'v19' is possibly undefined
// 413898: variable 'v20' is possibly undefined
// 413898: variable 'v21' is possibly undefined
// 413898: variable 'v22' is possibly undefined
// 413898: variable 'v9' is possibly undefined
// 413898: variable 'v10' is possibly undefined
// 413898: variable 'v11' is possibly undefined
// 413898: variable 'v12' is possibly undefined
// 413898: variable 'v13' is possibly undefined
// 413898: variable 'v14' is possibly undefined
// 413850: variable 'v30' is possibly undefined
// 41388C: variable 'v24' is possibly undefined
// 41388C: variable 'v25' is possibly undefined
// 41388C: variable 'v26' is possibly undefined
// 41388C: variable 'v27' is possibly undefined
// 41388C: variable 'v28' is possibly undefined
// 41388C: variable 'v29' is possibly undefined
// 490670: using guessed type int main_arena;
// 496B05: using guessed type char _malloc_initialized;

//----- (00000000004138A8) ----------------------------------------------------
long double __usercall mallinfo@<Q0>(
        __int64 a1@<X1>,
        __int64 a2@<X2>,
        void *a3@<X3>,
        void *a4@<X4>,
        void *a5@<X5>,
        void *a6@<X6>,
        __int64 a7@<X8>)
{
  long double result; // q0
  int32x4_t v9; // q31
  int32x4_t v10; // q30
  int32x4_t v11[2]; // [xsp+20h] [xbp+20h] BYREF
  long double v12; // [xsp+40h] [xbp+40h]
  int32x4_t v13; // [xsp+50h] [xbp+50h]
  int64x2_t v14; // [xsp+60h] [xbp+60h]

  mallinfo2(a1, a2, a3, a4, a5, a6, v11);
  result = v12;
  v9 = vuzp1q_s32(v11[0], v11[1]);
  v10 = vuzp1q_s32(*(int32x4_t *)&v12, v13);
  *(int32x2_t *)(a7 + 32) = vmovn_s64(v14);
  *(int32x4_t *)a7 = v9;
  *(int32x4_t *)(a7 + 16) = v10;
  return result;
}

//----- (00000000004138EC) ----------------------------------------------------
__int64 *__fastcall malloc_stats(__int64 a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7)
{
  int v7; // w21
  int v8; // w22
  __int128 v9; // q31
  __int64 *v10; // x1
  int v11; // w20
  int *v12; // x27
  __int64 v13; // x1
  __int64 v14; // x2
  __int64 v15; // x3
  void *v16; // x4
  void *v17; // x5
  void *v18; // x6
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7
  int v27; // w0
  int v28; // w26
  __int64 v29; // x1
  __int64 v30; // x2
  __int64 v31; // x3
  void *v32; // x4
  void *v33; // x5
  void *v34; // x6
  double v35; // d0
  double v36; // d1
  double v37; // d2
  double v38; // d3
  double v39; // d4
  double v40; // d5
  double v41; // d6
  double v42; // d7
  int v43; // w0
  __int64 *result; // x0
  int v45; // [xsp+7Ch] [xbp+7Ch]
  _OWORD v46[3]; // [xsp+80h] [xbp+80h] BYREF
  __int128 v47; // [xsp+B0h] [xbp+B0h]
  __int128 v48; // [xsp+C0h] [xbp+C0h]

  v7 = qword_490628;
  if ( (_malloc_initialized & 1) == 0 )
    ptmalloc_init_part_0((unsigned __int8)_malloc_initialized, a2, a3, a4, a5, a6, a7);
  v8 = v7;
  v9 = 0uLL;
  v10 = stderr;
  v11 = 0;
  v45 = (int)((unsigned __int64)stderr[14] >> 24) >> 8;
  *((_WORD *)stderr + 58) = v45 | 2;
  v12 = &main_arena;
  *((_BYTE *)v10 + 118) = BYTE2(v45);
  while ( 1 )
  {
    v46[0] = v9;
    v46[1] = v9;
    v46[2] = v9;
    v47 = v9;
    v48 = v9;
    _aarch64_cas4_acq();
    if ( v27 )
      _lll_lock_wait_private(v12, v19, v20, v21, v22, v23, v24, v25, v26, v13, v14, v15, v16, v17, v18);
    int_mallinfo((__int64)v12, (__int64 *)v46, v19, v20, v21, v22, v23, v24, v25, v26);
    fprintf((__int64)stderr, (__int64)"Arena %d:\n", v11);
    v28 = v46[0];
    fprintf((__int64)stderr, (__int64)"system bytes     = %10u\n", LODWORD(v46[0]));
    v7 += v28;
    v8 += DWORD2(v47);
    fprintf((__int64)stderr, (__int64)"in use bytes     = %10u\n", DWORD2(v47));
    _aarch64_swp4_rel();
    v9 = 0uLL;
    if ( v43 > 1 )
    {
      _lll_lock_wake_private(v12, v29, v30, v31, v32, v33, v34);
      v9 = 0uLL;
    }
    v12 = (int *)*((_QWORD *)v12 + 270);
    if ( v12 == &main_arena )
      break;
    ++v11;
  }
  fwrite((__int64)"Total (incl. mmap):\n", 1uLL, 20LL, (__int64)stderr, v35, v36, v37, v38, v39, v40, v41, v42);
  fprintf((__int64)stderr, (__int64)"system bytes     = %10u\n", v7);
  fprintf((__int64)stderr, (__int64)"in use bytes     = %10u\n", v8);
  fprintf((__int64)stderr, (__int64)"max mmap regions = %10u\n", dword_49061C);
  fprintf((__int64)stderr, (__int64)"max mmap bytes   = %10lu\n", qword_490630);
  result = stderr;
  *((_WORD *)stderr + 58) = v45;
  *((_BYTE *)result + 118) = BYTE2(v45);
  return result;
}
// 4139A0: variable 'v27' is possibly undefined
// 413ACC: variable 'v19' is possibly undefined
// 413ACC: variable 'v20' is possibly undefined
// 413ACC: variable 'v21' is possibly undefined
// 413ACC: variable 'v22' is possibly undefined
// 413ACC: variable 'v23' is possibly undefined
// 413ACC: variable 'v24' is possibly undefined
// 413ACC: variable 'v25' is possibly undefined
// 413ACC: variable 'v26' is possibly undefined
// 413ACC: variable 'v13' is possibly undefined
// 413ACC: variable 'v14' is possibly undefined
// 413ACC: variable 'v15' is possibly undefined
// 413ACC: variable 'v16' is possibly undefined
// 413ACC: variable 'v17' is possibly undefined
// 413ACC: variable 'v18' is possibly undefined
// 413A04: variable 'v43' is possibly undefined
// 413ABC: variable 'v29' is possibly undefined
// 413ABC: variable 'v30' is possibly undefined
// 413ABC: variable 'v31' is possibly undefined
// 413ABC: variable 'v32' is possibly undefined
// 413ABC: variable 'v33' is possibly undefined
// 413ABC: variable 'v34' is possibly undefined
// 413A2C: variable 'v35' is possibly undefined
// 413A2C: variable 'v36' is possibly undefined
// 413A2C: variable 'v37' is possibly undefined
// 413A2C: variable 'v38' is possibly undefined
// 413A2C: variable 'v39' is possibly undefined
// 413A2C: variable 'v40' is possibly undefined
// 413A2C: variable 'v41' is possibly undefined
// 413A2C: variable 'v42' is possibly undefined
// 4905B8: using guessed type __int64 *stderr;
// 49061C: using guessed type int dword_49061C;
// 490628: using guessed type __int64 qword_490628;
// 490630: using guessed type __int64 qword_490630;
// 490670: using guessed type int main_arena;
// 496B05: using guessed type char _malloc_initialized;

//----- (0000000000413AE0) ----------------------------------------------------
__int64 __fastcall mallopt(int a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7)
{
  __int64 v8; // x20
  __int64 v9; // x1
  __int64 v10; // x2
  __int64 v11; // x3
  void *v12; // x4
  void *v13; // x5
  void *v14; // x6
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  int v23; // w0
  unsigned int v24; // w21
  __int64 v25; // x1
  __int64 v26; // x2
  __int64 v27; // x3
  void *v28; // x4
  void *v29; // x5
  void *v30; // x6
  int v31; // w0
  int v33; // w0
  bool v34; // cc
  char v35; // w20
  char v36; // w0

  v8 = (int)a2;
  if ( (_malloc_initialized & 1) != 0 )
  {
    _aarch64_cas4_acq();
    if ( !v23 )
      goto LABEL_3;
  }
  else
  {
    ptmalloc_init_part_0((unsigned __int8)_malloc_initialized, a2, a3, a4, a5, a6, a7);
    _aarch64_cas4_acq();
    if ( !v33 )
    {
LABEL_3:
      malloc_consolidate((__int64)&main_arena);
      if ( a1 != -3 )
        goto LABEL_4;
LABEL_21:
      qword_4905E8 = v8;
      dword_490620 = 1;
LABEL_11:
      v24 = 1;
      goto LABEL_12;
    }
  }
  _lll_lock_wait_private(&main_arena, v15, v16, v17, v18, v19, v20, v21, v22, v9, v10, v11, v12, v13, v14);
  malloc_consolidate((__int64)&main_arena);
  if ( a1 == -3 )
    goto LABEL_21;
LABEL_4:
  if ( a1 < -2 )
  {
    if ( a1 == -6 )
    {
      perturb_byte = v8;
    }
    else if ( a1 >= -5 )
    {
      if ( a1 == -4 )
      {
        dword_490618 = v8;
        dword_490620 = 1;
      }
    }
    else if ( a1 == -8 )
    {
      if ( (int)v8 > 0 )
        qword_4905F8 = v8;
    }
    else if ( a1 == -7 && (int)v8 > 0 )
    {
      qword_4905F0 = v8;
    }
    goto LABEL_11;
  }
  if ( a1 == -1 )
  {
    mp_ = v8;
    dword_490620 = 1;
    goto LABEL_11;
  }
  if ( a1 != 1 )
  {
    if ( a1 == -2 )
    {
      qword_4905E0 = v8;
      dword_490620 = 1;
    }
    goto LABEL_11;
  }
  v24 = 0;
  if ( (unsigned __int64)(int)v8 <= 0xA0 )
  {
    v34 = (unsigned __int64)(int)v8 > 7;
    v35 = (v8 + 8) & 0xF0;
    if ( v34 )
      v36 = v35;
    else
      v36 = 16;
    global_max_fast = v36;
    goto LABEL_11;
  }
LABEL_12:
  _aarch64_swp4_rel();
  if ( v31 > 1 )
    _lll_lock_wake_private(&main_arena, v25, v26, v27, v28, v29, v30);
  return v24;
}
// 413B20: variable 'v23' is possibly undefined
// 413B80: variable 'v31' is possibly undefined
// 413CA0: variable 'v25' is possibly undefined
// 413CA0: variable 'v26' is possibly undefined
// 413CA0: variable 'v27' is possibly undefined
// 413CA0: variable 'v28' is possibly undefined
// 413CA0: variable 'v29' is possibly undefined
// 413CA0: variable 'v30' is possibly undefined
// 413BE4: variable 'v33' is possibly undefined
// 413BEC: variable 'v15' is possibly undefined
// 413BEC: variable 'v16' is possibly undefined
// 413BEC: variable 'v17' is possibly undefined
// 413BEC: variable 'v18' is possibly undefined
// 413BEC: variable 'v19' is possibly undefined
// 413BEC: variable 'v20' is possibly undefined
// 413BEC: variable 'v21' is possibly undefined
// 413BEC: variable 'v22' is possibly undefined
// 413BEC: variable 'v9' is possibly undefined
// 413BEC: variable 'v10' is possibly undefined
// 413BEC: variable 'v11' is possibly undefined
// 413BEC: variable 'v12' is possibly undefined
// 413BEC: variable 'v13' is possibly undefined
// 413BEC: variable 'v14' is possibly undefined
// 4905D8: using guessed type __int64 mp_;
// 4905E0: using guessed type __int64 qword_4905E0;
// 4905E8: using guessed type __int64 qword_4905E8;
// 4905F0: using guessed type __int64 qword_4905F0;
// 4905F8: using guessed type __int64 qword_4905F8;
// 490618: using guessed type int dword_490618;
// 490620: using guessed type int dword_490620;
// 490670: using guessed type int main_arena;
// 496B00: using guessed type int perturb_byte;
// 496B04: using guessed type char global_max_fast;
// 496B05: using guessed type char _malloc_initialized;

//----- (0000000000413CC0) ----------------------------------------------------
__int64 __fastcall posix_memalign(
        unsigned __int64 *a1,
        void *a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        __int64 a12,
        __int64 a13,
        void *a14,
        void *a15,
        __int64 a16)
{
  unsigned __int64 v16; // x4
  __int64 result; // x0
  void *v19; // x3
  bool v20; // zf
  unsigned __int64 v21; // x1
  __int64 v23; // [xsp+28h] [xbp+28h]

  v16 = (unsigned __int64)a2;
  if ( (_malloc_initialized & 1) == 0 )
  {
    v23 = a3;
    ptmalloc_init_part_0((__int64)a1, (__int64)a2, a3, (void *)(unsigned __int8)_malloc_initialized, a2, a14, a15);
    v16 = (unsigned __int64)a2;
    a3 = v23;
  }
  result = 22LL;
  v19 = (void *)(((v16 >> 3) - 1) & (v16 >> 3) | v16 & 7);
  if ( v19 )
    v20 = 1;
  else
    v20 = v16 == 0;
  if ( !v20 )
  {
    v21 = mid_memalign_isra_0(v16, a3, a3, v19, v16, v16 & 7, a15, a16, a4, a5, a6, a7, a8, a9, a10, a11);
    result = 12LL;
    if ( v21 )
    {
      result = 0LL;
      *a1 = v21;
    }
  }
  return result;
}
// 413D0C: variable 'a15' is possibly undefined
// 413D0C: variable 'a16' is possibly undefined
// 413D0C: variable 'a4' is possibly undefined
// 413D0C: variable 'a5' is possibly undefined
// 413D0C: variable 'a6' is possibly undefined
// 413D0C: variable 'a7' is possibly undefined
// 413D0C: variable 'a8' is possibly undefined
// 413D0C: variable 'a9' is possibly undefined
// 413D0C: variable 'a10' is possibly undefined
// 413D0C: variable 'a11' is possibly undefined
// 496B05: using guessed type char _malloc_initialized;

//----- (0000000000413D40) ----------------------------------------------------
__int64 __fastcall malloc_info(int a1, __int64 a2, __int64 a3, void *a4, void *a5, void *a6, void *a7)
{
  if ( a1 )
    return 22LL;
  if ( (_malloc_initialized & 1) != 0 )
  {
    fputs((__int64)"<malloc version=\"1\">\n", a2);
  }
  else
  {
    ptmalloc_init_part_0((unsigned __int8)_malloc_initialized, a2, a3, a4, a5, a6, a7);
    fputs((__int64)"<malloc version=\"1\">\n", a2);
  }
  return _malloc_info_part_0(a2);
}
// 496B05: using guessed type char _malloc_initialized;

//----- (0000000000413DC0) ----------------------------------------------------
__int64 __fastcall _libc_scratch_buffer_grow_preserve(
        unsigned __int64 *a1,
        __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        void *a12,
        __int64 a13,
        void *a14,
        void *a15,
        __int64 a16)
{
  unsigned __int64 v17; // x2
  void *v18; // x4
  unsigned __int64 *v19; // x20
  unsigned __int64 v20; // x21
  unsigned __int64 v21; // x3
  __int64 result; // x0
  unsigned __int64 v23; // x0
  unsigned __int64 v24; // [xsp+30h] [xbp+30h]

  v17 = a1[1];
  v19 = a1 + 2;
  v18 = (void *)*a1;
  v20 = 2 * v17;
  if ( (unsigned __int64 *)*a1 == a1 + 2 )
  {
    v23 = malloc(2 * v17, a2, v17, a12, v18, a14, a15, a16, a3, a4, a5, a6, a7, a8, a9, a10);
    if ( v23 )
    {
      v24 = v23;
      j_memcpy();
      v21 = v24;
      goto LABEL_4;
    }
    return 0LL;
  }
  if ( v17 > v20 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 12;
LABEL_9:
    free((unsigned __int64)v18, a3, a4, a5, a6, a7, a8, a9, a10);
    *a1 = (unsigned __int64)v19;
    a1[1] = 1024LL;
    return 0LL;
  }
  v21 = realloc(*a1, 2 * v17, v17, a12, v18, a14, a15, a16, a3, a4, a5, a6, a7, a8, a9, a10);
  if ( !v21 )
  {
    v18 = (void *)*a1;
    goto LABEL_9;
  }
LABEL_4:
  result = 1LL;
  *a1 = v21;
  a1[1] = v20;
  return result;
}
// 413E5C: variable 'a3' is possibly undefined
// 413E5C: variable 'a4' is possibly undefined
// 413E5C: variable 'a5' is possibly undefined
// 413E5C: variable 'a6' is possibly undefined
// 413E5C: variable 'a7' is possibly undefined
// 413E5C: variable 'a8' is possibly undefined
// 413E5C: variable 'a9' is possibly undefined
// 413E5C: variable 'a10' is possibly undefined

//----- (0000000000413E80) ----------------------------------------------------
__int64 __fastcall _libc_scratch_buffer_set_array_size(
        unsigned __int64 *a1,
        unsigned __int64 a2,
        __int64 a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  unsigned __int64 v17; // x20
  bool v18; // zf
  unsigned __int64 v19; // x0

  v17 = a2 * a3;
  if ( (a2 | a3) >> 32 )
    v18 = a2 == 0;
  else
    v18 = 1;
  if ( v18 || (a2 = v17 / a2, a2 == a3) )
  {
    if ( a1[1] < v17 )
    {
      if ( (unsigned __int64 *)*a1 != a1 + 2 )
        free(*a1, a9, a10, a11, a12, a13, a14, a15, a16);
      v19 = malloc(v17, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
      if ( !v19 )
      {
        *a1 = (unsigned __int64)(a1 + 2);
        a1[1] = 1024LL;
        return 0LL;
      }
      *a1 = v19;
      a1[1] = v17;
    }
    return 1LL;
  }
  if ( (unsigned __int64 *)*a1 != a1 + 2 )
    free(*a1, a9, a10, a11, a12, a13, a14, a15, a16);
  *a1 = (unsigned __int64)(a1 + 2);
  a1[1] = 1024LL;
  *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 12;
  return 0LL;
}
// 413ECC: variable 'a2' is possibly undefined
// 413ECC: variable 'a3' is possibly undefined
// 413ECC: variable 'a4' is possibly undefined
// 413ECC: variable 'a5' is possibly undefined
// 413ECC: variable 'a6' is possibly undefined
// 413ECC: variable 'a7' is possibly undefined
// 413ECC: variable 'a8' is possibly undefined
// 413ECC: variable 'a9' is possibly undefined
// 413ECC: variable 'a10' is possibly undefined
// 413ECC: variable 'a11' is possibly undefined
// 413ECC: variable 'a12' is possibly undefined
// 413ECC: variable 'a13' is possibly undefined
// 413ECC: variable 'a14' is possibly undefined
// 413ECC: variable 'a15' is possibly undefined
// 413ECC: variable 'a16' is possibly undefined

//----- (0000000000413F60) ----------------------------------------------------
unsigned __int64 *__fastcall strerror_r(unsigned int a1, _BYTE *a2, __int64 a3)
{
  unsigned __int64 *errlist; // x0
  unsigned __int64 *v8; // x0
  __int64 v9; // x5
  __int64 v10; // x6
  __int64 v11; // x7
  long double v12; // q0
  long double v13; // q1
  long double v14; // q2
  long double v15; // q3
  long double v16; // q4
  long double v17; // q5
  long double v18; // q6
  long double v19; // q7

  errlist = (unsigned __int64 *)_get_errlist(a1);
  if ( errlist )
    return dcgettext((unsigned __int64 *)"libc", errlist, 5u);
  v8 = dcgettext((unsigned __int64 *)"libc", (unsigned __int64 *)"Unknown error ", 5u);
  snprintf(a2, a3, v12, v13, v14, v15, v16, v17, v18, v19, (__int64)"%s%d", (__int64)v8, a1, v9, v10, v11);
  return (unsigned __int64 *)a2;
}
// 413FD0: variable 'v12' is possibly undefined
// 413FD0: variable 'v13' is possibly undefined
// 413FD0: variable 'v14' is possibly undefined
// 413FD0: variable 'v15' is possibly undefined
// 413FD0: variable 'v16' is possibly undefined
// 413FD0: variable 'v17' is possibly undefined
// 413FD0: variable 'v18' is possibly undefined
// 413FD0: variable 'v19' is possibly undefined
// 413FD0: variable 'v9' is possibly undefined
// 413FD0: variable 'v10' is possibly undefined
// 413FD0: variable 'v11' is possibly undefined

//----- (0000000000414000) ----------------------------------------------------
__int64 __fastcall memcmp(int8x16_t *a1, int8x16_t *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x3
  unsigned __int64 v4; // x5
  unsigned __int64 v5; // x4
  unsigned __int64 v6; // x6
  char *v9; // x7
  char *v10; // x8
  unsigned __int64 v11; // x2
  bool v14; // cc
  unsigned __int64 v15; // x3
  unsigned __int64 v16; // x4
  __int64 result; // x0
  char *v18; // x7
  char *v19; // x8
  __int64 v21; // x6
  unsigned __int64 v22; // x2
  int8x16_t v23; // q2
  int8x16_t v24; // q3
  uint8x16_t v25; // q0
  int8x16_t v26; // t1
  int8x16_t v27; // q4
  int8x16_t v28; // t1
  uint8x16_t v29; // q0
  unsigned __int64 v30; // d0
  unsigned __int64 v32; // x6

  if ( a3 < 0x10 )
  {
    v18 = (char *)a1 + a3;
    v19 = (char *)a2 + a3;
    if ( (a3 & 8) != 0 )
    {
      v3 = a1->n128_u64[0];
      v5 = a2->n128_u64[0];
      v4 = *((_QWORD *)v18 - 1);
      v6 = *((_QWORD *)v19 - 1);
      goto LABEL_27;
    }
    if ( (a3 & 4) != 0 )
    {
      v3 = a1->n128_u32[0];
      v5 = a2->n128_u32[0];
      v4 = *((unsigned int *)v18 - 1);
      v6 = *((unsigned int *)v19 - 1);
      goto LABEL_27;
    }
    if ( (a3 & 2) != 0 )
    {
      v3 = a1->n128_u16[0];
      v5 = a2->n128_u16[0];
      if ( (_DWORD)v3 != (_DWORD)v5 )
      {
LABEL_29:
        v15 = bswap64(v3);
        v16 = bswap64(v5);
        if ( v15 >= v16 )
          return v15 != v16;
        else
          return (unsigned int)-(v15 != v16);
      }
    }
    result = 0LL;
    if ( (a3 & 1) != 0 )
      return (unsigned __int8)*(v18 - 1) - (unsigned int)(unsigned __int8)*(v19 - 1);
  }
  else
  {
    v3 = a1->n128_u64[0];
    v4 = a1->n128_u64[1];
    v5 = a2->n128_u64[0];
    v6 = a2->n128_u64[1];
    if ( a3 == 16 || v3 != v5 || v4 != v6 )
      goto LABEL_27;
    v9 = (char *)a1 + a3;
    v10 = (char *)a2 + a3;
    if ( a3 <= 0x20 )
    {
LABEL_26:
      v3 = *((_QWORD *)v9 - 2);
      v4 = *((_QWORD *)v9 - 1);
      v5 = *((_QWORD *)v10 - 2);
      v6 = *((_QWORD *)v10 - 1);
      goto LABEL_27;
    }
    if ( a3 < 0xA0 )
    {
      v11 = a3 - 32;
      while ( 1 )
      {
        v3 = a1[1].n128_u64[0];
        v4 = a1[1].n128_u64[1];
        v5 = a2[1].n128_u64[0];
        v6 = a2[1].n128_u64[1];
        if ( v3 != v5 || v4 != v6 )
          goto LABEL_27;
        if ( v11 <= 0x10 )
          goto LABEL_26;
        v3 = a1[2].n128_u64[0];
        v4 = a1[2].n128_u64[1];
        v5 = a2[2].n128_u64[0];
        v6 = a2[2].n128_u64[1];
        if ( v3 != v5 || v4 != v6 )
          goto LABEL_27;
        a1 += 2;
        a2 += 2;
LABEL_25:
        v14 = v11 > 0x20;
        v11 -= 32LL;
        if ( !v14 )
          goto LABEL_26;
      }
    }
    v3 = a1[1].n128_u64[0];
    v4 = a1[1].n128_u64[1];
    v5 = a2[1].n128_u64[0];
    v6 = a2[1].n128_u64[1];
    if ( v3 != v5 || v4 != v6 )
    {
LABEL_27:
      if ( v3 == v5 )
      {
        v3 = v4;
        v5 = v6;
      }
      goto LABEL_29;
    }
    v21 = ((unsigned __int8)a2 & 0xF) - 16LL;
    a2 = (int8x16_t *)((char *)a2 - v21);
    a1 = (int8x16_t *)((char *)a1 - v21);
    v22 = a3 + v21 - 80;
    do
    {
      v14 = v22 > 0x40;
      v22 -= 64LL;
      v23 = a1[3];
      v24 = a2[3];
      v25 = vpmaxq_u8(veorq_s8(a1[1], a2[1]), veorq_s8(a1[2], a2[2]));
      v26 = a1[4];
      a1 += 4;
      v27 = v26;
      v28 = a2[4];
      a2 += 4;
      v29 = vpmaxq_u8(v25, vpmaxq_u8(veorq_s8(v23, v24), veorq_s8(v27, v28)));
      v30 = vpmaxq_u8(v29, v29).n128_u64[0];
    }
    while ( v14 && v30 == 0 );
    v11 = v22 + 80;
    if ( !v30 )
      goto LABEL_25;
    v32 = (__clz(bswap64(v30)) & 0xFFFFFFFFFFFFFFF8LL) - 48;
    if ( bswap64(*(unsigned __int64 *)((char *)a1->n128_u64 + v32)) >= bswap64(*(unsigned __int64 *)((char *)a2->n128_u64 + v32)) )
      return 1LL;
    else
      return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (00000000004141E0) ----------------------------------------------------
__int64 (__fastcall *memcpy())(__int64 result, __int64 *a2, unsigned __int64 a3)
{
  __int64 (__fastcall *result)(__int64, __int64 *, unsigned __int64); // x0

  if ( (byte_496CD8 & 1) != 0 )
    return (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))&_memcpy_mops;
  if ( (byte_496CD6 & 1) != 0 )
  {
    if ( (dl_aarch64_cpu_features & 0xFFFFFFFFFF00FFF0LL) == 0x46000010 )
    {
      return (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))&_memcpy_a64fx;
    }
    else
    {
      result = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))&_memcpy_sve;
      if ( (byte_496CD7 & 1) == 0 )
        return (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))_memcpy_generic;
    }
  }
  else
  {
    result = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))_memcpy_generic;
    if ( (unsigned __int64)dl_aarch64_cpu_features >> 24 == 81 )
    {
      if ( (dl_aarch64_cpu_features & 0xFFF0) == 0x10 )
      {
        return _memcpy_oryon1;
      }
      else if ( (dl_aarch64_cpu_features & 0xF0FFF0) == 0x20 )
      {
        return _memcpy_oryon1;
      }
    }
  }
  return result;
}
// 414FD8: using guessed type __int64[23];
// 496CC8: using guessed type __int64 dl_aarch64_cpu_features;
// 496CD6: using guessed type char byte_496CD6;
// 496CD7: using guessed type char byte_496CD7;
// 496CD8: using guessed type char byte_496CD8;

//----- (00000000004142A0) ----------------------------------------------------
long double (__fastcall *memmove())(__int64 a1, __int64 a2, unsigned __int64 a3, long double result)
{
  long double (__fastcall *result)(__int64, __int64, unsigned __int64, long double); // x0

  if ( (byte_496CD8 & 1) != 0 )
    return (long double (__fastcall *)(__int64, __int64, unsigned __int64, long double))&_memmove_mops;
  if ( (byte_496CD6 & 1) == 0 )
    return _memmove_generic;
  if ( (dl_aarch64_cpu_features & 0xFFFFFFFFFF00FFF0LL) == 0x46000010 )
    return (long double (__fastcall *)(__int64, __int64, unsigned __int64, long double))&_memmove_a64fx;
  result = (long double (__fastcall *)(__int64, __int64, unsigned __int64, long double))&_memmove_sve;
  if ( (byte_496CD7 & 1) == 0 )
    return _memmove_generic;
  return result;
}
// 496CC8: using guessed type __int64 dl_aarch64_cpu_features;
// 496CD6: using guessed type char byte_496CD6;
// 496CD7: using guessed type char byte_496CD7;
// 496CD8: using guessed type char byte_496CD8;

//----- (0000000000414320) ----------------------------------------------------
int8x16_t *(__fastcall *memset())(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3)
{
  unsigned __int64 v0; // x2
  int8x16_t *(__fastcall *result)(int8x16_t *, unsigned __int8, unsigned __int64); // x0

  if ( (byte_496CD8 & 1) != 0 )
    return (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))&_memset_mops;
  v0 = (unsigned __int64)dl_aarch64_cpu_features >> 24;
  if ( (byte_496CD6 & 1) != 0 && v0 == 70 )
  {
    if ( (dl_aarch64_cpu_features & 0xFFF0) == 0x10 && dword_496CD0 == 256 )
      return (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))&_memset_a64fx;
    goto LABEL_11;
  }
  if ( v0 != 81 )
  {
    if ( v0 == 72 )
    {
      if ( (dl_aarch64_cpu_features & 0xFFF0) == 0xD010 )
        return (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))_memset_kunpeng;
    }
    else if ( v0 == 80 && (dl_aarch64_cpu_features & 0xFFF0) == 0 )
    {
      return (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))_memset_emag;
    }
    goto LABEL_11;
  }
  if ( (dl_aarch64_cpu_features & 0xFFF0) != 0x10 && (dl_aarch64_cpu_features & 0xF0FFF0) != 0x20 )
  {
LABEL_11:
    result = _memset_zva64;
    if ( dword_496CD0 != 64 )
      return _memset_generic;
    return result;
  }
  result = (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))_memset_oryon1;
  if ( dword_496CD0 != 64 )
    return _memset_generic;
  return result;
}
// 496CC8: using guessed type __int64 dl_aarch64_cpu_features;
// 496CD0: using guessed type int dword_496CD0;
// 496CD6: using guessed type char byte_496CD6;
// 496CD8: using guessed type char byte_496CD8;

//----- (0000000000414440) ----------------------------------------------------
unsigned __int64 __fastcall strchrnul(__int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // x2
  int8x16_t v3; // q0
  unsigned __int64 v4; // x1
  int16x8_t v6; // q3
  int8x16_t v7; // t1

  v2 = a1 & 0xFFFFFFFFFFFFFFF0LL;
  v3 = vdupq_n_s8(a2);
  v4 = vshrn_n_s16(
         vcgeq_u8(vceqq_s8(*(int8x16_t *)(a1 & 0xFFFFFFFFFFFFFFF0LL), v3), *(uint8x16_t *)(a1 & 0xFFFFFFFFFFFFFFF0LL)),
         4uLL).n64_u64[0] >> (4 * (unsigned __int8)a1);
  if ( v4 )
    return a1 + (__clz(__rbit64(v4)) >> 2);
  while ( 1 )
  {
    v6 = vcgeq_u8(vceqq_s8(*(int8x16_t *)(v2 + 16), v3), *(uint8x16_t *)(v2 + 16));
    if ( vpmaxq_u8(v6, v6).n128_u64[0] )
      break;
    v7 = *(int8x16_t *)(v2 + 32);
    v2 += 32LL;
    v6 = vcgeq_u8(vceqq_s8(v7, v3), v7);
    if ( vpmaxq_u8(v6, v6).n128_u64[0] )
    {
      v2 -= 16LL;
      return v2 + 16 + (__clz(__rbit64(vshrn_n_s16(v6, 4uLL).n64_u64[0])) >> 2);
    }
  }
  return v2 + 16 + (__clz(__rbit64(vshrn_n_s16(v6, 4uLL).n64_u64[0])) >> 2);
}

//----- (00000000004144E0) ----------------------------------------------------
unsigned __int64 (__fastcall *strlen())(__int64 a1)
{
  unsigned __int64 (__fastcall *result)(__int64); // x0

  result = (unsigned __int64 (__fastcall *)(__int64))_strlen_asimd;
  if ( (dl_hwcap2 & 0x40000) != 0 )
    return _strlen_generic;
  return result;
}
// 496BE8: using guessed type __int64 dl_hwcap2;

//----- (0000000000414540) ----------------------------------------------------
unsigned __int64 __fastcall strnlen(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x2
  unsigned __int64 v3; // x3
  unsigned __int64 result; // x0
  unsigned __int64 v5; // x4
  unsigned __int64 v6; // x5
  int8x16_t v7; // t1
  int16x8_t v8; // q1
  bool v9; // cf

  v2 = a1 & 0xFFFFFFFFFFFFFFF0LL;
  if ( !a2 )
    return a2;
  v3 = vshrn_n_s16(vceqzq_s8(*(int8x16_t *)v2), 4uLL).n64_u64[0] >> (4 * (unsigned __int8)a1);
  if ( v3 )
  {
    result = __clz(__rbit64(v3)) >> 2;
    if ( a2 <= result )
      return a2;
    return result;
  }
  v5 = v2 - a1 + 17;
  v6 = a2 - v5;
  if ( a2 < v5 )
    return a2;
  if ( (v6 & 0x10) == 0 )
    goto LABEL_11;
  v2 -= 16LL;
  while ( 1 )
  {
    v7 = *(int8x16_t *)(v2 + 32);
    v2 += 32LL;
    v8 = vceqzq_s8(v7);
    if ( vpmaxq_u8(v8, v8).n128_u64[0] )
      break;
LABEL_11:
    v9 = v6 >= 0x20;
    v6 -= 32LL;
    v8 = vceqzq_s8(*(int8x16_t *)(v2 + 16));
    if ( !v9 || vpmaxq_u8(v8, v8).n128_u64[0] )
    {
      v2 += 16LL;
      break;
    }
  }
  result = v2 - a1 + (__clz(__rbit64(vshrn_n_s16(v8, 4uLL).n64_u64[0])) >> 2);
  if ( a2 <= result )
    return a2;
  return result;
}

//----- (0000000000414600) ----------------------------------------------------
__int64 __fastcall two_way_long_needle(
        __int64 a1,
        unsigned __int64 a2,
        int8x16_t *a3,
        unsigned __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  __int64 v9; // x8
  __int64 v10; // x4
  __int64 v13; // x2
  unsigned __int64 v14; // x21
  __int64 v17; // x0
  __int64 v18; // x1
  unsigned int v19; // w5
  unsigned int v20; // w3
  unsigned __int64 v21; // x25
  __int64 v22; // x3
  __int64 v23; // x1
  __int64 v24; // x0
  __int64 v25; // x2
  unsigned int v26; // w6
  unsigned int v27; // w5
  unsigned __int64 v28; // x24
  unsigned __int64 v29; // x4
  char *v30; // x0
  int8x16_t *v31; // x0
  __int64 v32; // x3
  unsigned __int64 v33; // x1
  unsigned __int64 v34; // x6
  __int64 v35; // x26
  unsigned __int64 v36; // x22
  unsigned __int64 v37; // x0
  bool v38; // cf
  unsigned __int64 v39; // x0
  unsigned __int64 i; // x0
  unsigned __int64 v42; // x0
  __int64 v43; // x26
  unsigned __int64 v44; // x25
  __int64 v45; // x0
  unsigned __int64 v46; // x0
  __int64 v47; // x3
  unsigned __int64 v48; // x0
  unsigned __int64 v49; // [xsp+60h] [xbp+60h]
  unsigned __int64 v50; // [xsp+68h] [xbp+68h]
  _QWORD v51[256]; // [xsp+80h] [xbp+80h] BYREF

  v9 = 1LL;
  v10 = -1LL;
  v13 = 0LL;
  v14 = a4 - 1;
  v17 = 1LL;
  v18 = 1LL;
  do
  {
    while ( 1 )
    {
      v19 = a3->n128_u8[v17];
      v20 = a3->n128_u8[v10 + v18];
      if ( v19 >= v20 )
        break;
      v9 = v17 - v10;
      v13 = v17;
      v18 = 1LL;
LABEL_3:
      v17 = v13 + v18;
      if ( a4 <= v13 + v18 )
        goto LABEL_7;
    }
    if ( v19 == v20 )
    {
      if ( v18 == v9 )
      {
        v13 += v18;
        v18 = 1LL;
      }
      else
      {
        ++v18;
      }
      goto LABEL_3;
    }
    v10 = v13;
    v9 = 1LL;
    ++v13;
    v18 = 1LL;
    v17 = v13 + 1;
  }
  while ( a4 > v13 + 1 );
LABEL_7:
  v21 = 1LL;
  v22 = 0LL;
  v23 = 1LL;
  v24 = 1LL;
  v25 = -1LL;
  do
  {
    while ( 1 )
    {
      v26 = a3->n128_u8[v24];
      v27 = a3->n128_u8[v23 + v25];
      if ( v26 <= v27 )
        break;
      v21 = v24 - v25;
      v22 = v24;
      v23 = 1LL;
LABEL_9:
      v24 = v22 + v23;
      if ( a4 <= v22 + v23 )
        goto LABEL_13;
    }
    if ( v26 == v27 )
    {
      if ( v23 == v21 )
      {
        v22 += v23;
        v23 = 1LL;
      }
      else
      {
        ++v23;
      }
      goto LABEL_9;
    }
    v25 = v22;
    v21 = 1LL;
    ++v22;
    v23 = 1LL;
    v24 = v22 + 1;
  }
  while ( a4 > v22 + 1 );
LABEL_13:
  v28 = v25 + 1;
  v29 = v10 + 1;
  if ( v25 + 1 < v29 )
  {
    v21 = v9;
    v28 = v29;
  }
  v30 = (char *)v51;
  do
  {
    *(_QWORD *)v30 = a4;
    v30 += 8;
  }
  while ( &a9 != v30 );
  v31 = a3;
  do
  {
    v32 = v31->n128_u8[0];
    v33 = (char *)a3 - (char *)v31 + v14;
    v31 = (int8x16_t *)((char *)v31 + 1);
    v51[v32] = v33;
  }
  while ( v31 != (int8x16_t *)((char *)a3 + a4) );
  if ( !(unsigned int)memcmp(a3, (int8x16_t *)((char *)a3 + v21), v28) )
  {
    v34 = 0LL;
    v35 = 0LL;
    while ( 1 )
    {
      v36 = v35 + a4;
      if ( v35 + a4 <= a2 )
        goto LABEL_23;
      while ( 1 )
      {
        v49 = v34;
        a2 += strnlen(a1 + a2, a4 + 512);
        v34 = v49;
        if ( v36 > a2 )
          return 0LL;
LABEL_23:
        v37 = v51[*(unsigned __int8 *)(a1 + v36 - 1)];
        if ( !v37 )
          break;
        while ( 1 )
        {
          if ( v34 )
            v38 = v37 >= v21;
          else
            v38 = 1;
          v34 = 0LL;
          if ( !v38 )
            v37 = a4 - v21;
          v35 += v37;
          v36 = v35 + a4;
          if ( v35 + a4 > a2 )
            break;
          v37 = v51[*(unsigned __int8 *)(a1 + v36 - 1)];
          if ( !v37 )
            goto LABEL_31;
        }
      }
LABEL_31:
      if ( v34 < v28 )
        v39 = v28;
      else
        v39 = v34;
      if ( v14 <= v39 )
        goto LABEL_44;
      while ( a3->n128_u8[v39] == *(unsigned __int8 *)(a1 + v35 + v39) )
      {
        if ( v14 == ++v39 )
          goto LABEL_44;
      }
      if ( v14 <= v39 )
      {
LABEL_44:
        if ( v34 >= v28 )
        {
          i = v28;
        }
        else
        {
          for ( i = v28 - 1; a3->n128_u8[i] == *(unsigned __int8 *)(a1 + v35 + i); --i )
          {
            if ( v34 == i )
              goto LABEL_50;
          }
          ++i;
        }
LABEL_50:
        if ( v34 + 1 > i )
          return a1 + v35;
        v34 = a4 - v21;
        v35 += v21;
      }
      else
      {
        v34 = 0LL;
        v35 += 1 - v28 + v39;
      }
    }
  }
  v42 = a4 - v28;
  v43 = 0LL;
  if ( a4 - v28 < v28 )
    v42 = v28;
  v50 = v42 + 1;
  while ( 1 )
  {
    v44 = v43 + a4;
    if ( v43 + a4 > a2 )
    {
      a2 += strnlen(a1 + a2, a4 + 512);
      if ( v44 > a2 )
        return 0LL;
    }
    v45 = v51[*(unsigned __int8 *)(a1 + v44 - 1)];
    if ( v45 )
    {
      v43 += v45;
    }
    else
    {
      v46 = v28;
      v47 = a1 + v43;
      if ( v14 > v28 )
      {
        while ( a3->n128_u8[v46] == *(unsigned __int8 *)(v47 + v46) )
        {
          if ( v14 == ++v46 )
            goto LABEL_67;
        }
        if ( v14 > v46 )
        {
          v43 += 1 - v28 + v46;
          continue;
        }
LABEL_67:
        if ( !v28 )
          return v47;
      }
      v48 = v28 - 1;
      while ( a3->n128_u8[v48] == *(unsigned __int8 *)(a1 + v43 + v48) )
      {
        if ( --v48 == -1LL )
          return a1 + v43;
      }
      v43 += v50;
    }
  }
}

//----- (0000000000414A2C) ----------------------------------------------------
__int64 __fastcall strstr(
        __int64 result,
        int8x16_t *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  unsigned int v9; // w21
  int8x16_t *v11; // x19
  int v12; // w2
  int v13; // w0
  unsigned __int64 v14; // x23
  unsigned __int64 v15; // x20
  __int64 v16; // x4
  __int64 v17; // x5
  __int64 v18; // x6
  __int64 v19; // x7
  int8x16_t *v20; // x24
  unsigned __int64 v21; // x20
  __int64 v22; // x1
  char v23; // w0
  unsigned __int64 v24; // x27
  __int64 v25; // x0
  __int64 v26; // x21
  __int64 v27; // x21
  __int64 v28; // x3
  unsigned __int64 v29; // x0
  bool v30; // cc
  int v31; // w1
  int v32; // w21
  int8x16_t *v33; // x2
  int v34; // t1
  bool v35; // zf
  int v36; // w1
  int v37; // w2
  int v38; // w0
  int v39; // w0
  int8x16_t *v40; // x3
  int v41; // t1
  bool v42; // zf
  _BYTE v43[256]; // [xsp+60h] [xbp+60h] BYREF

  v9 = a2->n128_u8[0];
  if ( !a2->n128_u8[0] )
    return result;
  v11 = (int8x16_t *)strchr(result, v9);
  if ( !v11 )
    return 0LL;
  v12 = a2->n128_u8[1];
  if ( !a2->n128_u8[1] )
    return (__int64)v11;
  v13 = a2->n128_u8[2];
  if ( !a2->n128_u8[2] )
  {
    v31 = v11->n128_u8[0];
    if ( v11->n128_u8[0] )
    {
      v32 = v12 | (v9 << 16);
      do
      {
        v13 = v31 | (v13 << 16);
        v33 = v11;
        v34 = v11->n128_u8[1];
        v11 = (int8x16_t *)((char *)v11 + 1);
        v31 = v34;
        if ( v34 )
          v35 = v32 == v13;
        else
          v35 = 1;
      }
      while ( !v35 );
      if ( v32 == v13 )
        return (__int64)&v33[-1].n128_i64[1] + 7;
    }
    return 0LL;
  }
  if ( !a2->n128_u8[3] )
  {
    v36 = v11->n128_u8[0];
    if ( v11->n128_u8[0] )
    {
      v37 = (v12 << 16) | (v9 << 24) | (v13 << 8);
      v38 = 0;
      do
      {
        v39 = v36 | v38;
        v40 = v11;
        v41 = v11->n128_u8[1];
        v11 = (int8x16_t *)((char *)v11 + 1);
        v36 = v41;
        v38 = v39 << 8;
        if ( v41 )
          v42 = v37 == v38;
        else
          v42 = 1;
      }
      while ( !v42 );
      if ( v37 == v38 )
        return (__int64)&v40[-1].n128_i64[1] + 6;
    }
    return 0LL;
  }
  v14 = (unsigned __int64)strlen();
  v15 = strnlen((__int64)v11, v14 | 0x200);
  if ( v14 > v15 )
    return 0LL;
  if ( !(unsigned int)memcmp(v11, a2, v14) )
    return (__int64)v11;
  if ( v14 <= 0x100 )
  {
    v20 = (int8x16_t *)((char *)v11 + v15 - v14);
    v21 = v14 - 1;
    memset(v43, 0, sizeof(v43));
    if ( v14 - 1 > 1 )
    {
      v22 = 1LL;
      do
      {
        v23 = v9;
        LOBYTE(v9) = a2->n128_u8[v22];
        v43[(unsigned __int8)(v9 - 8 * v23)] = v22++;
      }
      while ( v21 != v22 );
    }
    v24 = 0LL;
    v25 = (unsigned __int8)(a2->n128_u8[v21] - 8 * a2->n128_u8[v14 - 2]);
    v26 = (unsigned __int8)v43[v25];
    v43[v25] = v21;
    v27 = v21 - v26;
    while ( 1 )
    {
      if ( v11 > v20 )
      {
LABEL_27:
        v20 = (int8x16_t *)((char *)v20 + strnlen((__int64)v20 + v14, 0x800uLL));
        if ( v11 > v20 )
          return 0LL;
      }
      while ( 1 )
      {
        do
        {
          v11 = (int8x16_t *)((char *)v11 + v21);
          v28 = (unsigned __int8)(v11->n128_u8[0] - 8 * v11[-1].n128_u8[15]);
          v29 = (unsigned __int8)v43[v28];
          if ( v43[v28] )
            v30 = 1;
          else
            v30 = v11 > v20;
        }
        while ( !v30 );
        v11 = (int8x16_t *)((char *)v11 - v29);
        if ( v21 > v29 )
          break;
        if ( v21 <= 0xE
          || *(unsigned __int64 *)((char *)v11->n128_u64 + v24) == *(unsigned __int64 *)((char *)a2->n128_u64 + v24) )
        {
          if ( !(unsigned int)memcmp(v11, a2, v14 - 1) )
            return (__int64)v11;
          if ( v24 >= 8 )
            v24 -= 8LL;
          else
            v24 = v14 - 9;
        }
        v11 = (int8x16_t *)((char *)v11 + v27);
        if ( v11 > v20 )
          goto LABEL_27;
      }
    }
  }
  return two_way_long_needle((__int64)v11, v15, a2, v14, v16, v17, v18, v19, a9);
}
// 414D00: variable 'v16' is possibly undefined
// 414D00: variable 'v17' is possibly undefined
// 414D00: variable 'v18' is possibly undefined
// 414D00: variable 'v19' is possibly undefined

//----- (00000000004150C0) ----------------------------------------------------
long double __fastcall _memcpy_generic(_OWORD *a1, unsigned __int64 a2, unsigned __int64 a3, long double result)
{
  char *v4; // x4
  char *v5; // x5
  __int128 v6; // q1
  __int64 v7; // x7
  int v8; // w8
  char v9; // w10
  char v10; // w8
  __int128 v11; // q1
  __int128 v12; // q2
  __int128 v13; // q3
  __int128 v14; // q4
  __int128 v15; // q5
  __int128 v16; // q7
  long double v17; // q3
  unsigned __int64 v18; // x14
  _OWORD *v19; // x1
  _OWORD *v20; // x3
  unsigned __int64 v21; // x2
  __int128 v22; // q0
  __int128 v23; // q1
  __int128 v24; // q2
  __int128 v25; // q3
  bool v26; // cc
  unsigned __int64 i; // x2
  __int128 v28; // q4
  __int128 v29; // q5
  __int128 v30; // q1

  v4 = (char *)(a2 + a3);
  v5 = (char *)a1 + a3;
  if ( a3 > 0x80 )
  {
    v17 = *(long double *)a2;
    v18 = a2 & 0xF;
    v19 = (_OWORD *)(a2 & 0xFFFFFFFFFFFFFFF0LL);
    v20 = (_OWORD *)((char *)a1 - v18);
    v21 = a3 + v18;
    v22 = v19[1];
    v23 = v19[2];
    *(long double *)a1 = v17;
    v24 = v19[3];
    v25 = v19[4];
    v26 = v21 > 0x90;
    for ( i = v21 - 144; v26; i -= 64LL )
    {
      v20[1] = v22;
      v20[2] = v23;
      v22 = v19[5];
      v23 = v19[6];
      v20[3] = v24;
      v20[4] = v25;
      v24 = v19[7];
      v25 = v19[8];
      v19 += 4;
      v20 += 4;
      v26 = i > 0x40;
    }
    v28 = *((_OWORD *)v4 - 4);
    v29 = *((_OWORD *)v4 - 3);
    v20[1] = v22;
    v20[2] = v23;
    result = *((long double *)v4 - 2);
    v30 = *((_OWORD *)v4 - 1);
    v20[3] = v24;
    v20[4] = v25;
    *((_OWORD *)v5 - 4) = v28;
    *((_OWORD *)v5 - 3) = v29;
    *((long double *)v5 - 2) = result;
    *((_OWORD *)v5 - 1) = v30;
  }
  else if ( a3 > 0x20 )
  {
    result = *(long double *)a2;
    v11 = *(_OWORD *)(a2 + 16);
    v12 = *((_OWORD *)v4 - 2);
    v13 = *((_OWORD *)v4 - 1);
    if ( a3 > 0x40 )
    {
      v14 = *(_OWORD *)(a2 + 32);
      v15 = *(_OWORD *)(a2 + 48);
      if ( a3 > 0x60 )
      {
        v16 = *((_OWORD *)v4 - 3);
        *((_OWORD *)v5 - 4) = *((_OWORD *)v4 - 4);
        *((_OWORD *)v5 - 3) = v16;
      }
      *(long double *)a1 = result;
      a1[1] = v11;
      a1[2] = v14;
      a1[3] = v15;
      *((_OWORD *)v5 - 2) = v12;
      *((_OWORD *)v5 - 1) = v13;
    }
    else
    {
      *(long double *)a1 = result;
      a1[1] = v11;
      *((_OWORD *)v5 - 2) = v12;
      *((_OWORD *)v5 - 1) = v13;
    }
  }
  else if ( a3 < 0x10 )
  {
    if ( (a3 & 8) != 0 )
    {
      v7 = *((_QWORD *)v4 - 1);
      *(_QWORD *)a1 = *(_QWORD *)a2;
      *((_QWORD *)v5 - 1) = v7;
    }
    else if ( (a3 & 4) != 0 )
    {
      v8 = *((_DWORD *)v4 - 1);
      *(_DWORD *)a1 = *(_DWORD *)a2;
      *((_DWORD *)v5 - 1) = v8;
    }
    else if ( a3 )
    {
      v9 = *(v4 - 1);
      v10 = *(_BYTE *)(a2 + (a3 >> 1));
      *(_BYTE *)a1 = *(_BYTE *)a2;
      *((_BYTE *)a1 + (a3 >> 1)) = v10;
      *(v5 - 1) = v9;
    }
  }
  else
  {
    result = *(long double *)a2;
    v6 = *((_OWORD *)v4 - 1);
    *a1 = *(_OWORD *)a2;
    *((_OWORD *)v5 - 1) = v6;
  }
  return result;
}

//----- (0000000000415200) ----------------------------------------------------
long double __fastcall _memmove_generic(__int64 a1, __int64 a2, unsigned __int64 a3, long double result)
{
  __int64 v4; // x4
  __int64 v5; // x5
  __int128 v6; // q1
  __int128 v7; // q3
  __int64 v8; // x14
  unsigned __int64 v9; // x4
  unsigned __int64 v10; // x2
  __int128 v11; // q0
  __int128 v12; // q1
  __int128 v13; // q2
  __int128 v14; // q3
  __int64 v15; // x5
  bool v16; // cc
  unsigned __int64 i; // x2
  __int128 v18; // q4
  __int128 v19; // q5
  __int128 v20; // q1

  v4 = a2 + a3;
  v5 = a1 + a3;
  if ( a3 > 0x80 )
  {
    if ( a1 != a2 )
    {
      if ( a1 - a2 >= a3 )
        JUMPOUT(0x415198LL);
      v7 = *(_OWORD *)(v4 - 16);
      v8 = v4 & 0xF;
      v9 = v4 & 0xFFFFFFFFFFFFFFF0LL;
      v10 = a3 - v8;
      v11 = *(_OWORD *)(v9 - 32);
      v12 = *(_OWORD *)(v9 - 16);
      *(_OWORD *)(v5 - 16) = v7;
      v13 = *(_OWORD *)(v9 - 64);
      v14 = *(_OWORD *)(v9 - 48);
      v15 = v5 - v8;
      v16 = v10 > 0x80;
      for ( i = v10 - 128; v16; i -= 64LL )
      {
        *(_OWORD *)(v15 - 16) = v12;
        *(_OWORD *)(v15 - 32) = v11;
        v11 = *(_OWORD *)(v9 - 96);
        v12 = *(_OWORD *)(v9 - 80);
        *(_OWORD *)(v15 - 48) = v14;
        *(_OWORD *)(v15 - 64) = v13;
        v15 -= 64LL;
        v13 = *(_OWORD *)(v9 - 128);
        v14 = *(_OWORD *)(v9 - 112);
        v9 -= 64LL;
        v16 = i > 0x40;
      }
      v18 = *(_OWORD *)(a2 + 32);
      v19 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)(v15 - 32) = v11;
      *(_OWORD *)(v15 - 16) = v12;
      result = *(long double *)a2;
      v20 = *(_OWORD *)(a2 + 16);
      *(_OWORD *)(v15 - 64) = v13;
      *(_OWORD *)(v15 - 48) = v14;
      *(_OWORD *)(a1 + 32) = v18;
      *(_OWORD *)(a1 + 48) = v19;
      *(long double *)a1 = result;
      *(_OWORD *)(a1 + 16) = v20;
    }
  }
  else
  {
    if ( a3 > 0x20 )
      JUMPOUT(0x415150LL);
    if ( a3 < 0x10 )
      JUMPOUT(0x4150F8LL);
    result = *(long double *)a2;
    v6 = *(_OWORD *)(v4 - 16);
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)(v5 - 16) = v6;
  }
  return result;
}
// 415218: control flows out of bounds to 415150
// 415220: control flows out of bounds to 4150F8
// 415244: control flows out of bounds to 415198

//----- (0000000000415300) ----------------------------------------------------
char *__fastcall _memmove_oryon1(char *result, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x14
  bool v4; // cf
  char *v5; // x5
  __int64 v6; // x14
  __int64 v7; // x12
  __int64 v8; // x13
  char *v9; // x4
  unsigned __int64 v10; // x2
  __int64 v11; // x6
  __int64 v12; // x7
  __int64 v13; // x8
  __int64 v14; // x9
  __int64 v15; // x10
  __int64 v16; // x11
  char *v17; // x4
  __int64 v18; // x12
  __int64 v19; // x13
  char *v20; // x5
  bool v21; // zf
  unsigned __int64 i; // x2
  __int64 v23; // x2
  __int64 v24; // x3
  __int64 v25; // x6
  __int64 v26; // x7
  __int64 v27; // x8
  __int64 v28; // x9
  __int64 v29; // x10
  __int64 v30; // x11

  v3 = result - a2;
  v4 = a3 <= 0x60 || v3 >= a3;
  if ( v4 )
    return (char *)_memcpy_oryon1();
  if ( v3 )
  {
    v5 = &result[a3];
    v6 = (unsigned __int64)&result[a3] & 0xF;
    v7 = *(_QWORD *)&a2[a3 - 16];
    v8 = *(_QWORD *)&a2[a3 - 8];
    v9 = &a2[a3 - v6];
    v10 = a3 - v6;
    v11 = *((_QWORD *)v9 - 2);
    v12 = *((_QWORD *)v9 - 1);
    *((_QWORD *)v5 - 2) = v7;
    *((_QWORD *)v5 - 1) = v8;
    v13 = *((_QWORD *)v9 - 4);
    v14 = *((_QWORD *)v9 - 3);
    v15 = *((_QWORD *)v9 - 6);
    v16 = *((_QWORD *)v9 - 5);
    v18 = *((_QWORD *)v9 - 8);
    v19 = *((_QWORD *)v9 - 7);
    v17 = v9 - 64;
    v20 = &v5[-v6];
    v4 = v10 >= 0x80;
    v21 = v10 == 128;
    for ( i = v10 - 128; !v21 && v4; i -= 64LL )
    {
      *((_QWORD *)v20 - 2) = v11;
      *((_QWORD *)v20 - 1) = v12;
      v11 = *((_QWORD *)v17 - 2);
      v12 = *((_QWORD *)v17 - 1);
      *((_QWORD *)v20 - 4) = v13;
      *((_QWORD *)v20 - 3) = v14;
      v13 = *((_QWORD *)v17 - 4);
      v14 = *((_QWORD *)v17 - 3);
      *((_QWORD *)v20 - 6) = v15;
      *((_QWORD *)v20 - 5) = v16;
      v15 = *((_QWORD *)v17 - 6);
      v16 = *((_QWORD *)v17 - 5);
      *((_QWORD *)v20 - 8) = v18;
      *((_QWORD *)v20 - 7) = v19;
      v20 -= 64;
      v18 = *((_QWORD *)v17 - 8);
      v19 = *((_QWORD *)v17 - 7);
      v17 -= 64;
      v4 = i >= 0x40;
      v21 = i == 64;
    }
    v23 = *((_QWORD *)a2 + 6);
    v24 = *((_QWORD *)a2 + 7);
    *((_QWORD *)v20 - 2) = v11;
    *((_QWORD *)v20 - 1) = v12;
    v25 = *((_QWORD *)a2 + 4);
    v26 = *((_QWORD *)a2 + 5);
    *((_QWORD *)v20 - 4) = v13;
    *((_QWORD *)v20 - 3) = v14;
    v27 = *((_QWORD *)a2 + 2);
    v28 = *((_QWORD *)a2 + 3);
    *((_QWORD *)v20 - 6) = v15;
    *((_QWORD *)v20 - 5) = v16;
    v29 = *(_QWORD *)a2;
    v30 = *((_QWORD *)a2 + 1);
    *((_QWORD *)v20 - 8) = v18;
    *((_QWORD *)v20 - 7) = v19;
    *((_QWORD *)result + 6) = v23;
    *((_QWORD *)result + 7) = v24;
    *((_QWORD *)result + 4) = v25;
    *((_QWORD *)result + 5) = v26;
    *((_QWORD *)result + 2) = v27;
    *((_QWORD *)result + 3) = v28;
    *(_QWORD *)result = v29;
    *((_QWORD *)result + 1) = v30;
  }
  return result;
}
// 415340: using guessed type __int64 _memcpy_oryon1(void);

//----- (0000000000415340) ----------------------------------------------------
__int64 __fastcall _memcpy_oryon1(__int64 result, __int64 *a2, unsigned __int64 a3)
{
  __int64 v3; // x4
  __int64 v4; // x5
  __int64 v5; // x6
  __int64 v6; // x7
  __int64 v7; // x12
  __int64 v8; // x13
  __int64 v9; // x9
  __int64 v10; // x10
  __int64 v11; // x11
  __int64 v12; // x7
  int v13; // w7
  char v14; // w7
  char v15; // w8
  __int64 v16; // x8
  __int64 v17; // x9
  __int64 v18; // x10
  __int64 v19; // x11
  __int64 v20; // x12
  __int64 v21; // x13
  __int64 v22; // x1
  __int64 v23; // x2
  __int64 v24; // x3
  __int64 v25; // x4
  __int64 v26; // t2
  _QWORD *v27; // x3
  __int64 v28; // x12
  __int64 v29; // x13
  _QWORD *v30; // x1
  unsigned __int64 v31; // x2
  __int64 v32; // x6
  __int64 v33; // x7
  __int64 v34; // x8
  __int64 v35; // x9
  __int64 v36; // x10
  __int64 v37; // x11
  _QWORD *v38; // x1
  __int64 v39; // x12
  __int64 v40; // x13
  bool v41; // cc
  unsigned __int64 i; // x2
  __int64 v43; // x1
  __int64 v44; // x2
  __int64 v45; // x6
  __int64 v46; // x7
  __int64 v47; // x8
  __int64 v48; // x9
  __int64 v49; // x10
  __int64 v50; // x11

  v3 = (__int64)a2 + a3;
  v4 = result + a3;
  if ( a3 <= 0x10 )
  {
    if ( a3 < 8 )
    {
      if ( (a3 & 4) != 0 )
      {
        v13 = *(_DWORD *)(v3 - 4);
        *(_DWORD *)result = *(_DWORD *)a2;
        *(_DWORD *)(v4 - 4) = v13;
      }
      else if ( a3 )
      {
        v14 = *(_BYTE *)(v3 - 1);
        v15 = *((_BYTE *)a2 + (a3 >> 1));
        *(_BYTE *)result = *(_BYTE *)a2;
        *(_BYTE *)(result + (a3 >> 1)) = v15;
        *(_BYTE *)(v4 - 1) = v14;
      }
    }
    else
    {
      v12 = *(_QWORD *)(v3 - 8);
      *(_QWORD *)result = *a2;
      *(_QWORD *)(v4 - 8) = v12;
    }
  }
  else if ( a3 > 0x60 )
  {
    v27 = (_QWORD *)(result & 0xFFFFFFFFFFFFFFF0LL);
    v28 = *a2;
    v29 = a2[1];
    v30 = (__int64 *)((char *)a2 - (result & 0xF));
    v31 = a3 + (result & 0xF);
    v32 = v30[2];
    v33 = v30[3];
    *(_QWORD *)result = v28;
    *(_QWORD *)(result + 8) = v29;
    v34 = v30[4];
    v35 = v30[5];
    v36 = v30[6];
    v37 = v30[7];
    v39 = v30[8];
    v40 = v30[9];
    v38 = v30 + 8;
    v41 = v31 > 0x90;
    for ( i = v31 - 144; v41; i -= 64LL )
    {
      v27[2] = v32;
      v27[3] = v33;
      v32 = v38[2];
      v33 = v38[3];
      v27[4] = v34;
      v27[5] = v35;
      v34 = v38[4];
      v35 = v38[5];
      v27[6] = v36;
      v27[7] = v37;
      v36 = v38[6];
      v37 = v38[7];
      v27[8] = v39;
      v27[9] = v40;
      v27 += 8;
      v39 = v38[8];
      v40 = v38[9];
      v38 += 8;
      v41 = i > 0x40;
    }
    v43 = *(_QWORD *)(v3 - 64);
    v44 = *(_QWORD *)(v3 - 56);
    v27[2] = v32;
    v27[3] = v33;
    v45 = *(_QWORD *)(v3 - 48);
    v46 = *(_QWORD *)(v3 - 40);
    v27[4] = v34;
    v27[5] = v35;
    v47 = *(_QWORD *)(v3 - 32);
    v48 = *(_QWORD *)(v3 - 24);
    v27[6] = v36;
    v27[7] = v37;
    v49 = *(_QWORD *)(v3 - 16);
    v50 = *(_QWORD *)(v3 - 8);
    v27[8] = v39;
    v27[9] = v40;
    *(_QWORD *)(v4 - 64) = v43;
    *(_QWORD *)(v4 - 56) = v44;
    *(_QWORD *)(v4 - 48) = v45;
    *(_QWORD *)(v4 - 40) = v46;
    *(_QWORD *)(v4 - 32) = v47;
    *(_QWORD *)(v4 - 24) = v48;
    *(_QWORD *)(v4 - 16) = v49;
    *(_QWORD *)(v4 - 8) = v50;
  }
  else
  {
    v5 = *a2;
    v6 = a2[1];
    if ( (((_DWORD)a3 - 1) & 0x40) != 0 )
    {
      v16 = a2[2];
      v17 = a2[3];
      v18 = a2[4];
      v19 = a2[5];
      v20 = a2[6];
      v21 = a2[7];
      v22 = *(_QWORD *)(v3 - 32);
      v23 = *(_QWORD *)(v3 - 24);
      v26 = v3 - 16;
      v25 = *(_QWORD *)(v3 - 16);
      v24 = *(_QWORD *)(v26 + 8);
      *(_QWORD *)result = v5;
      *(_QWORD *)(result + 8) = v6;
      *(_QWORD *)(result + 16) = v16;
      *(_QWORD *)(result + 24) = v17;
      *(_QWORD *)(result + 32) = v18;
      *(_QWORD *)(result + 40) = v19;
      *(_QWORD *)(result + 48) = v20;
      *(_QWORD *)(result + 56) = v21;
      *(_QWORD *)(v4 - 32) = v22;
      *(_QWORD *)(v4 - 24) = v23;
      *(_QWORD *)(v4 - 16) = v25;
      *(_QWORD *)(v4 - 8) = v24;
    }
    else
    {
      v7 = *(_QWORD *)(v3 - 16);
      v8 = *(_QWORD *)(v3 - 8);
      if ( (((_BYTE)a3 - 1) & 0x20) != 0 )
      {
        v9 = a2[3];
        v10 = *(_QWORD *)(v3 - 32);
        v11 = *(_QWORD *)(v3 - 24);
        *(_QWORD *)(result + 16) = a2[2];
        *(_QWORD *)(result + 24) = v9;
        *(_QWORD *)(v4 - 32) = v10;
        *(_QWORD *)(v4 - 24) = v11;
      }
      *(_QWORD *)result = v5;
      *(_QWORD *)(result + 8) = v6;
      *(_QWORD *)(v4 - 16) = v7;
      *(_QWORD *)(v4 - 8) = v8;
    }
  }
  return result;
}

//----- (0000000000415634) ----------------------------------------------------
_OWORD *__fastcall sub_415634(_OWORD *result, __int128 *a2, unsigned __int64 a3)
{
  char *v3; // x4
  char *v4; // x5
  __int128 v5; // q0
  __int128 v6; // q1
  __int128 v7; // q2
  __int128 v8; // q3
  __int128 v9; // q4
  __int128 v10; // q5
  __int128 v11; // q7

  v3 = (char *)a2 + a3;
  v4 = (char *)result + a3;
  v5 = *a2;
  v6 = a2[1];
  v7 = *(__int128 *)((char *)a2 + a3 - 32);
  v8 = *(__int128 *)((char *)a2 + a3 - 16);
  if ( a3 > 0x40 )
  {
    v9 = a2[2];
    v10 = a2[3];
    if ( a3 > 0x60 )
    {
      v11 = *((_OWORD *)v3 - 3);
      *((_OWORD *)v4 - 4) = *((_OWORD *)v3 - 4);
      *((_OWORD *)v4 - 3) = v11;
    }
    *result = v5;
    result[1] = v6;
    result[2] = v9;
    result[3] = v10;
    *((_OWORD *)v4 - 2) = v7;
    *((_OWORD *)v4 - 1) = v8;
  }
  else
  {
    *result = v5;
    result[1] = v6;
    *((_OWORD *)v4 - 2) = v7;
    *((_OWORD *)v4 - 1) = v8;
  }
  return result;
}

//----- (00000000004159C0) ----------------------------------------------------
unsigned __int64 *__fastcall _memset_emag(unsigned __int64 *result, unsigned __int8 a2, unsigned __int64 a3)
{
  unsigned int v3; // w1
  unsigned __int64 v4; // x1
  char *v5; // x4
  _QWORD *v6; // x3
  unsigned __int64 v7; // x2
  bool v8; // cf

  v3 = (unsigned __int16)(a2 | (a2 << 8)) | ((unsigned __int16)(a2 | (a2 << 8)) << 16);
  v4 = v3 | ((unsigned __int64)v3 << 32);
  v5 = (char *)result + a3;
  if ( a3 > 0x60 )
  {
    *result = v4;
    result[1] = v4;
    v6 = (_QWORD *)((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL);
    v7 = (unsigned __int64)&v5[-((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) - 81];
    do
    {
      v6[2] = v4;
      v6[3] = v4;
      v6[4] = v4;
      v6[5] = v4;
      v6[6] = v4;
      v6[7] = v4;
      v6[8] = v4;
      v6[9] = v4;
      v6 += 8;
      v8 = v7 >= 0x40;
      v7 -= 64LL;
    }
    while ( v8 );
    if ( (v7 & 0x20) != 0 )
    {
      v6[2] = v4;
      v6[3] = v4;
      v6[4] = v4;
      v6[5] = v4;
    }
    *((_QWORD *)v5 - 4) = v4;
    *((_QWORD *)v5 - 3) = v4;
    *((_QWORD *)v5 - 2) = v4;
    *((_QWORD *)v5 - 1) = v4;
  }
  else if ( a3 >= 0x10 )
  {
    *result = v4;
    result[1] = v4;
    if ( (a3 & 0x40) != 0 )
    {
      result[2] = v4;
      result[3] = v4;
      result[4] = v4;
      result[5] = v4;
      result[6] = v4;
      result[7] = v4;
      *((_QWORD *)v5 - 4) = v4;
      *((_QWORD *)v5 - 3) = v4;
      *((_QWORD *)v5 - 2) = v4;
      *((_QWORD *)v5 - 1) = v4;
    }
    else
    {
      *((_QWORD *)v5 - 2) = v4;
      *((_QWORD *)v5 - 1) = v4;
      if ( (a3 & 0x20) != 0 )
      {
        result[2] = v4;
        result[3] = v4;
        *((_QWORD *)v5 - 4) = v4;
        *((_QWORD *)v5 - 3) = v4;
      }
    }
  }
  else if ( (a3 & 8) != 0 )
  {
    *result = v4;
    *((_QWORD *)v5 - 1) = v4;
  }
  else if ( (a3 & 4) != 0 )
  {
    *(_DWORD *)result = v4;
    *((_DWORD *)v5 - 1) = v4;
  }
  else if ( a3 )
  {
    *(_BYTE *)result = v4;
    if ( (a3 & 2) != 0 )
      *((_WORD *)v5 - 1) = v4;
  }
  return result;
}

//----- (0000000000415AC0) ----------------------------------------------------
int8x16_t *__fastcall _memset_generic(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3)
{
  int8x16_t v3; // q0
  int8x16_t *v4; // x4
  __int64 v5; // x3
  char *v6; // x4
  char *v7; // x3
  unsigned __int64 v8; // x3
  unsigned __int64 v9; // x2
  bool v14; // cc
  unsigned __int64 v15; // x2

  v3 = vdupq_n_s8(a2);
  if ( a3 < 0x10 )
  {
    v6 = (char *)result + a3;
    if ( a3 < 4 )
    {
      if ( a3 )
      {
        result->n128_u8[0] = a2;
        result->n128_u8[a3 >> 1] = a2;
        *(v6 - 1) = a2;
      }
    }
    else
    {
      result->n128_u32[0] = v3.n128_u32[0];
      result->n128_u32[a3 >> 3] = v3.n128_u32[0];
      *(_DWORD *)&v6[-4 * (a3 >> 3) - 4] = v3.n128_u32[0];
      *((_DWORD *)v6 - 1) = v3.n128_u32[0];
    }
  }
  else
  {
    v4 = (int8x16_t *)((char *)result + a3);
    if ( a3 >= 0x40 )
    {
      v7 = (char *)((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL);
      if ( a3 > 0x80 )
      {
        *result = v3;
        *(int8x16_t *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = v3;
        if ( a2 || (_ReadStatusReg(ARM64_SYSREG(3, 3, 0, 0, 7)) & 0x1F) != 4 )
        {
          v15 = (char *)v4 - v7 - 96;
          do
          {
            *((int8x16_t *)v7 + 2) = v3;
            *((int8x16_t *)v7 + 3) = v3;
            *((int8x16_t *)v7 + 4) = v3;
            *((int8x16_t *)v7 + 5) = v3;
            v7 += 64;
            v14 = v15 > 0x40;
            v15 -= 64LL;
          }
          while ( v14 );
          v4[-4] = v3;
          v4[-3] = v3;
          v4[-2] = v3;
          v4[-1] = v3;
        }
        else
        {
          *(int8x16_t *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) + 0x20) = v3;
          *(int8x16_t *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) + 0x30) = v3;
          v8 = (unsigned __int64)result & 0xFFFFFFFFFFFFFFC0LL;
          v9 = (unsigned __int64)v4[-8].n128_u64 - ((unsigned __int64)result & 0xFFFFFFFFFFFFFFC0LL);
          v4[-4] = v3;
          v4[-3] = v3;
          v4[-2] = v3;
          v4[-1] = v3;
          do
          {
            v8 += 64LL;
            __asm { DC              ZVA, X3 }
            v14 = v9 > 0x40;
            v9 -= 64LL;
          }
          while ( v14 );
        }
      }
      else
      {
        *result = v3;
        result[1] = v3;
        result[2] = v3;
        result[3] = v3;
        v4[-4] = v3;
        v4[-3] = v3;
        v4[-2] = v3;
        v4[-1] = v3;
      }
    }
    else
    {
      v5 = (a3 >> 1) & 0x10;
      *result = v3;
      *(int8x16_t *)((char *)result + v5) = v3;
      *(int8x16_t *)((char *)v4 - v5 - 16) = v3;
      v4[-1] = v3;
    }
  }
  return result;
}

//----- (0000000000415C00) ----------------------------------------------------
int8x16_t *__fastcall _memset_kunpeng(int8x16_t *result, unsigned int a2, unsigned __int64 a3)
{
  int8x16_t v3; // q0
  int8x16_t *v4; // x4
  _OWORD *v5; // x3
  unsigned __int64 v6; // x2
  _OWORD *v7; // x3
  bool v8; // cf
  unsigned __int64 v9; // x2
  _OWORD *v10; // x3
  unsigned __int64 v11; // x2
  _OWORD *v12; // x3
  unsigned __int64 v13; // x2

  v3 = vdupq_n_s8(a2);
  v4 = (int8x16_t *)((char *)result + a3);
  if ( a3 >= 0x80 )
  {
    *result = v3;
    v5 = (_OWORD *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) - 16);
    v6 = (unsigned __int64)&v4[-5] - ((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) - 1;
    do
    {
      v5[2] = v3;
      v5[3] = v3;
      v5[4] = v3;
      v5[5] = v3;
      v7 = v5 + 4;
      v8 = v6 >= 0x40;
      v9 = v6 - 64;
      if ( !v8 )
        break;
      v7[2] = v3;
      v7[3] = v3;
      v7[4] = v3;
      v7[5] = v3;
      v10 = v7 + 4;
      v8 = v9 >= 0x40;
      v11 = v9 - 64;
      if ( !v8 )
        break;
      v10[2] = v3;
      v10[3] = v3;
      v10[4] = v3;
      v10[5] = v3;
      v12 = v10 + 4;
      v8 = v11 >= 0x40;
      v13 = v11 - 64;
      if ( !v8 )
        break;
      v12[2] = v3;
      v12[3] = v3;
      v12[4] = v3;
      v12[5] = v3;
      v5 = v12 + 4;
      v8 = v13 >= 0x40;
      v6 = v13 - 64;
    }
    while ( v8 );
    v4[-4] = v3;
    v4[-3] = v3;
    v4[-2] = v3;
    v4[-1] = v3;
  }
  else if ( a3 < 0x10 )
  {
    if ( (a3 & 8) != 0 )
    {
      result->n128_u64[0] = v3.n128_u64[0];
      v4[-1].n128_u64[1] = v3.n128_u64[0];
    }
    else if ( (a3 & 4) != 0 )
    {
      result->n128_u32[0] = v3.n128_u32[0];
      v4[-1].n128_u32[3] = v3.n128_u32[0];
    }
    else if ( a3 )
    {
      result->n128_u8[0] = v3.n128_u8[0];
      if ( (a3 & 2) != 0 )
        v4[-1].n128_u16[7] = v3.n128_u16[0];
    }
  }
  else
  {
    *result = v3;
    if ( (a3 & 0x40) != 0 )
    {
      result[1] = v3;
      result[2] = v3;
      result[3] = v3;
      v4[-4] = v3;
      v4[-3] = v3;
      v4[-2] = v3;
      v4[-1] = v3;
    }
    else
    {
      v4[-1] = v3;
      if ( (a3 & 0x20) != 0 )
      {
        result[1] = v3;
        v4[-2] = v3;
      }
    }
  }
  return result;
}

//----- (0000000000415D40) ----------------------------------------------------
unsigned __int64 *__fastcall _memset_oryon1(unsigned __int64 *result, unsigned __int8 a2, unsigned __int64 a3)
{
  unsigned int v3; // w1
  unsigned __int64 v4; // x1
  char *v5; // x4
  char *v6; // x3
  unsigned __int64 v8; // x2
  _QWORD *v10; // x3
  unsigned __int64 v11; // x2
  unsigned __int64 *v12; // x3
  bool v15; // cc

  v3 = (unsigned __int16)(a2 | (a2 << 8)) | ((unsigned __int16)(a2 | (a2 << 8)) << 16);
  v4 = v3 | ((unsigned __int64)v3 << 32);
  v5 = (char *)result + a3;
  if ( a3 > 0x60 )
  {
    *result = v4;
    result[1] = v4;
    v6 = (char *)((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL);
    if ( a3 >= 0x100 && (_DWORD)v4 == 0 )
    {
      *(_QWORD *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = v4;
      *(_QWORD *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) + 0x18) = v4;
      *(_QWORD *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) + 0x20) = v4;
      *(_QWORD *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) + 0x28) = v4;
      *(_QWORD *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) + 0x30) = v4;
      *(_QWORD *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) + 0x38) = v4;
      v10 = (_QWORD *)((unsigned __int64)result & 0xFFFFFFFFFFFFFFC0LL);
      v10[8] = v4;
      v10[9] = v4;
      v10[10] = v4;
      v10[11] = v4;
      v10[12] = v4;
      v10[13] = v4;
      v10[14] = v4;
      v10[15] = v4;
      v11 = (unsigned __int64)&v5[-((unsigned __int64)result & 0xFFFFFFFFFFFFFFC0LL) - 256];
      v12 = (unsigned __int64 *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFC0LL) + 128);
      do
      {
        __asm { DC              ZVA, X3 }
        v12 += 8;
        v15 = v11 > 0x40;
        v11 -= 64LL;
      }
      while ( v15 );
      *v12 = v4;
      v12[1] = v4;
      v12[2] = v4;
      v12[3] = v4;
      v12[4] = v4;
      v12[5] = v4;
      v12[6] = v4;
      v12[7] = v4;
      *((_QWORD *)v5 - 8) = v4;
      *((_QWORD *)v5 - 7) = v4;
      *((_QWORD *)v5 - 6) = v4;
      *((_QWORD *)v5 - 5) = v4;
      *((_QWORD *)v5 - 4) = v4;
      *((_QWORD *)v5 - 3) = v4;
      *((_QWORD *)v5 - 2) = v4;
      *((_QWORD *)v5 - 1) = v4;
    }
    else
    {
      v8 = v5 - v6 - 81;
      do
      {
        *((_QWORD *)v6 + 2) = v4;
        *((_QWORD *)v6 + 3) = v4;
        *((_QWORD *)v6 + 4) = v4;
        *((_QWORD *)v6 + 5) = v4;
        *((_QWORD *)v6 + 6) = v4;
        *((_QWORD *)v6 + 7) = v4;
        *((_QWORD *)v6 + 8) = v4;
        *((_QWORD *)v6 + 9) = v4;
        v6 += 64;
        _CF = v8 >= 0x40;
        v8 -= 64LL;
      }
      while ( _CF );
      if ( (v8 & 0x20) != 0 )
      {
        *((_QWORD *)v6 + 2) = v4;
        *((_QWORD *)v6 + 3) = v4;
        *((_QWORD *)v6 + 4) = v4;
        *((_QWORD *)v6 + 5) = v4;
      }
      *((_QWORD *)v5 - 4) = v4;
      *((_QWORD *)v5 - 3) = v4;
      *((_QWORD *)v5 - 2) = v4;
      *((_QWORD *)v5 - 1) = v4;
    }
  }
  else if ( a3 >= 0x10 )
  {
    *result = v4;
    result[1] = v4;
    if ( (a3 & 0x40) != 0 )
    {
      result[2] = v4;
      result[3] = v4;
      result[4] = v4;
      result[5] = v4;
      result[6] = v4;
      result[7] = v4;
      *((_QWORD *)v5 - 4) = v4;
      *((_QWORD *)v5 - 3) = v4;
      *((_QWORD *)v5 - 2) = v4;
      *((_QWORD *)v5 - 1) = v4;
    }
    else
    {
      *((_QWORD *)v5 - 2) = v4;
      *((_QWORD *)v5 - 1) = v4;
      if ( (a3 & 0x20) != 0 )
      {
        result[2] = v4;
        result[3] = v4;
        *((_QWORD *)v5 - 4) = v4;
        *((_QWORD *)v5 - 3) = v4;
      }
    }
  }
  else if ( (a3 & 8) != 0 )
  {
    *result = v4;
    *((_QWORD *)v5 - 1) = v4;
  }
  else if ( (a3 & 4) != 0 )
  {
    *(_DWORD *)result = v4;
    *((_DWORD *)v5 - 1) = v4;
  }
  else if ( a3 )
  {
    *(_BYTE *)result = v4;
    if ( (a3 & 2) != 0 )
      *((_WORD *)v5 - 1) = v4;
  }
  return result;
}

//----- (0000000000415F00) ----------------------------------------------------
int8x16_t *__fastcall _memset_zva64(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3)
{
  int8x16_t v3; // q0
  int8x16_t *v4; // x4
  __int64 v5; // x3
  char *v6; // x4
  char *v7; // x3
  unsigned __int64 v8; // x3
  unsigned __int64 v9; // x2
  bool v14; // cc
  unsigned __int64 v15; // x2

  v3 = vdupq_n_s8(a2);
  if ( a3 < 0x10 )
  {
    v6 = (char *)result + a3;
    if ( a3 < 4 )
    {
      if ( a3 )
      {
        result->n128_u8[0] = a2;
        result->n128_u8[a3 >> 1] = a2;
        *(v6 - 1) = a2;
      }
    }
    else
    {
      result->n128_u32[0] = v3.n128_u32[0];
      result->n128_u32[a3 >> 3] = v3.n128_u32[0];
      *(_DWORD *)&v6[-4 * (a3 >> 3) - 4] = v3.n128_u32[0];
      *((_DWORD *)v6 - 1) = v3.n128_u32[0];
    }
  }
  else
  {
    v4 = (int8x16_t *)((char *)result + a3);
    if ( a3 >= 0x40 )
    {
      v7 = (char *)((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL);
      if ( a3 > 0x80 )
      {
        *result = v3;
        *(int8x16_t *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) + 0x10) = v3;
        if ( a2 )
        {
          v15 = (char *)v4 - v7 - 96;
          do
          {
            *((int8x16_t *)v7 + 2) = v3;
            *((int8x16_t *)v7 + 3) = v3;
            *((int8x16_t *)v7 + 4) = v3;
            *((int8x16_t *)v7 + 5) = v3;
            v7 += 64;
            v14 = v15 > 0x40;
            v15 -= 64LL;
          }
          while ( v14 );
          v4[-4] = v3;
          v4[-3] = v3;
          v4[-2] = v3;
          v4[-1] = v3;
        }
        else
        {
          *(int8x16_t *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) + 0x20) = v3;
          *(int8x16_t *)(((unsigned __int64)result & 0xFFFFFFFFFFFFFFF0LL) + 0x30) = v3;
          v8 = (unsigned __int64)result & 0xFFFFFFFFFFFFFFC0LL;
          v9 = (unsigned __int64)v4[-8].n128_u64 - ((unsigned __int64)result & 0xFFFFFFFFFFFFFFC0LL);
          v4[-4] = v3;
          v4[-3] = v3;
          v4[-2] = v3;
          v4[-1] = v3;
          do
          {
            v8 += 64LL;
            __asm { DC              ZVA, X3 }
            v14 = v9 > 0x40;
            v9 -= 64LL;
          }
          while ( v14 );
        }
      }
      else
      {
        *result = v3;
        result[1] = v3;
        result[2] = v3;
        result[3] = v3;
        v4[-4] = v3;
        v4[-3] = v3;
        v4[-2] = v3;
        v4[-1] = v3;
      }
    }
    else
    {
      v5 = (a3 >> 1) & 0x10;
      *result = v3;
      *(int8x16_t *)((char *)result + v5) = v3;
      *(int8x16_t *)((char *)v4 - v5 - 16) = v3;
      v4[-1] = v3;
    }
  }
  return result;
}

//----- (0000000000416040) ----------------------------------------------------
unsigned __int64 __fastcall _strlen_asimd(unsigned __int64 a1)
{
  __int64 v1; // x3
  unsigned __int64 v2; // x4
  char v3; // cf
  bool v4; // zf
  __int64 v5; // x0
  unsigned __int64 v6; // x4
  __int64 v8; // x3
  unsigned __int64 v9; // x4
  char v10; // cf
  bool v11; // zf
  __int64 v12; // x0
  unsigned __int64 v13; // x4
  unsigned __int64 v14; // x1
  int8x16_t v15; // q1
  int8x16_t v16; // q2
  uint8x16_t v17; // q0
  unsigned __int64 v18; // x3
  int16x8_t v19; // q0
  unsigned __int64 v20; // x0
  int8x16_t v21; // q0
  int8x16_t v22; // q0
  unsigned __int64 v23; // x3

  if ( (a1 & 0xFFF) > 0xFE0 )
  {
    v14 = a1 & 0xFFFFFFFFFFFFFFE0LL;
    v21 = vdupq_n_s32(0xC0300C03);
    v22 = vpaddq_s8(
            vandq_s8(vceqzq_s8(*(int8x16_t *)(a1 & 0xFFFFFFFFFFFFFFE0LL)), v21),
            vandq_s8(vceqzq_s8(*(int8x16_t *)((a1 & 0xFFFFFFFFFFFFFFE0LL) + 0x10)), v21));
    v23 = vpaddq_s8(v22, v22).n128_u64[0] >> (2 * (unsigned __int8)a1);
    if ( v23 )
      return __clz(__rbit64(v23)) >> 1;
  }
  else
  {
    v1 = *(_QWORD *)(a1 + 8);
    v2 = (*(_QWORD *)a1 - 0x101010101010101LL) & ~(*(_QWORD *)a1 | 0x7F7F7F7F7F7F7F7FLL);
    if ( v2 )
    {
      v3 = 0;
      v4 = 0;
    }
    else
    {
      v3 = 1;
      v4 = ((v1 - 0x101010101010101LL) & ~(v1 | 0x7F7F7F7F7F7F7F7FLL)) == 0;
    }
    if ( !v4 )
    {
      if ( v3 )
        v2 = (v1 - 0x101010101010101LL) & ~(v1 | 0x7F7F7F7F7F7F7F7FLL);
      v5 = 8LL;
      v6 = bswap64(v2);
      if ( !v3 )
        v5 = 0LL;
      return v5 + (__clz(v6) >> 3);
    }
    v8 = *(_QWORD *)(a1 + 24);
    v9 = (*(_QWORD *)(a1 + 16) - 0x101010101010101LL) & ~(*(_QWORD *)(a1 + 16) | 0x7F7F7F7F7F7F7F7FLL);
    if ( v9 )
    {
      v10 = 0;
      v11 = 0;
    }
    else
    {
      v10 = 1;
      v11 = ((v8 - 0x101010101010101LL) & ~(v8 | 0x7F7F7F7F7F7F7F7FLL)) == 0;
    }
    if ( !v11 )
    {
      if ( v10 )
        v9 = (v8 - 0x101010101010101LL) & ~(v8 | 0x7F7F7F7F7F7F7F7FLL);
      v12 = 24LL;
      v13 = __clz(bswap64(v9));
      if ( !v10 )
        v12 = 16LL;
      return v12 + (v13 >> 3);
    }
    v14 = a1 & 0xFFFFFFFFFFFFFFE0LL;
  }
  do
  {
    v15 = *(int8x16_t *)(v14 + 32);
    v16 = *(int8x16_t *)(v14 + 48);
    v14 += 32LL;
    v17 = vpminq_u8(v15, v16);
    v18 = vceqz_s8((int8x8_t)vpminq_u8(v17, v17).n128_u64[0]).n64_u64[0];
  }
  while ( !v18 );
  v19 = vceqzq_s8(v15);
  v20 = v14 - a1;
  if ( !(_DWORD)v18 )
  {
    v19 = vceqzq_s8(v16);
    v20 += 16LL;
  }
  return v20 + (__clz(__rbit64(vshrn_n_s16(v19, 4uLL).n64_u64[0])) >> 2);
}

//----- (0000000000416180) ----------------------------------------------------
unsigned __int64 __fastcall _strlen_generic(__int64 a1)
{
  unsigned __int64 v1; // x1
  unsigned __int64 v2; // x2
  unsigned __int64 v4; // d2
  int8x16_t v5; // t1
  int16x8_t v6; // q1
  unsigned __int64 v7; // x2
  int16x8_t v8; // q1

  v1 = a1 & 0xFFFFFFFFFFFFFFF0LL;
  v2 = vshrn_n_s16(vceqzq_s8(*(int8x16_t *)(a1 & 0xFFFFFFFFFFFFFFF0LL)), 4uLL).n64_u64[0] >> (4 * (unsigned __int8)a1);
  if ( v2 )
    return __clz(__rbit64(v2)) >> 2;
  v4 = vshrn_n_s16(vceqzq_s8(*(int8x16_t *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 0x10)), 4uLL).n64_u64[0];
  if ( v4 )
    return v1 + 16 - a1 + (__clz(__rbit64(v4)) >> 2);
  while ( 1 )
  {
    v5 = *(int8x16_t *)(v1 + 32);
    v1 += 32LL;
    v6 = vceqzq_s8(v5);
    v7 = vaddhn_s16(v6, v6).n64_u64[0];
    if ( v7 )
      break;
    v8 = vceqzq_s8(*(int8x16_t *)(v1 + 16));
    v7 = vaddhn_s16(v8, v8).n64_u64[0];
    if ( v7 )
    {
      v1 += 16LL;
      return (__clz(__rbit64(v7)) - (4 * a1 - 4 * v1 - 3)) >> 2;
    }
  }
  return (__clz(__rbit64(v7)) - (4 * a1 - 4 * v1 - 3)) >> 2;
}

//----- (0000000000416240) ----------------------------------------------------
__int64 __fastcall _wcrtomb_internal(__int64 a1, int a2, void *a3, unsigned __int64 a4)
{
  unsigned __int64 StatusReg; // x21
  void *v6; // x0
  __int64 *v8; // x0
  __int64 v9; // x0
  __int64 *v10; // x3
  __int64 v11; // x2
  _QWORD *v12; // x0
  unsigned __int64 v13; // x8
  int v14; // w0
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  _BYTE *v23; // x0
  unsigned __int64 v24; // x21
  __int64 *v26; // [xsp+38h] [xbp+38h]
  int v27; // [xsp+4Ch] [xbp+4Ch] BYREF
  int *v28; // [xsp+58h] [xbp+58h]
  _BYTE v29[16]; // [xsp+60h] [xbp+60h] BYREF
  _QWORD v30[3]; // [xsp+70h] [xbp+70h] BYREF
  int v31; // [xsp+88h] [xbp+88h]
  void *v32; // [xsp+90h] [xbp+90h]

  v31 = 1;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v6 = &state;
  if ( a3 )
    v6 = a3;
  v32 = v6;
  if ( !a1 )
    a2 = 0;
  v27 = a2;
  v30[0] = v29;
  v8 = *(__int64 **)(StatusReg + 16);
  v30[2] = 1LL;
  v9 = *v8;
  v10 = *(__int64 **)(v9 + 32);
  v11 = *v10;
  v30[1] = v30;
  if ( !v11 )
  {
    v26 = v10;
    _wcsmbs_load_conv(v9);
    v11 = *v26;
  }
  v12 = *(_QWORD **)(v11 + 16);
  v13 = v12[5];
  if ( *v12 )
    v13 ^= _pointer_chk_guard_local;
  if ( v27 )
  {
    v28 = &v27;
    v14 = ((__int64 (*)(void))v13)();
    if ( (v14 & 0xFFFFFFFB) == 0 )
      goto LABEL_12;
  }
  else
  {
    v14 = ((__int64 (*)(void))v13)();
    if ( (v14 & 0xFFFFFFFB) == 0 )
    {
      v23 = (_BYTE *)v30[0]++;
      *v23 = 0;
      goto LABEL_12;
    }
  }
  if ( (unsigned int)(v14 - 6) <= 1 )
  {
    *(_DWORD *)(StatusReg + 40) = 84;
    return -1LL;
  }
  if ( v14 != 5 )
    _libc_assert_fail(
      (__int64)"status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status == __G"
               "CONV_INCOMPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
      (__int64)"wcrtomb.c",
      0x5Eu,
      (__int64)"__wcrtomb_internal");
LABEL_12:
  v24 = v30[0] - (_QWORD)v29;
  if ( a1 )
  {
    if ( v24 > a4 )
      _chk_fail(v15, v16, v17, v18, v19, v20, v21, v22);
    j_memcpy();
  }
  return v24;
}
// 4163E8: variable 'v15' is possibly undefined
// 4163E8: variable 'v16' is possibly undefined
// 4163E8: variable 'v17' is possibly undefined
// 4163E8: variable 'v18' is possibly undefined
// 4163E8: variable 'v19' is possibly undefined
// 4163E8: variable 'v20' is possibly undefined
// 4163E8: variable 'v21' is possibly undefined
// 4163E8: variable 'v22' is possibly undefined
// 4163EC: using guessed type __int64 wcrtomb(void);
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (00000000004163EC) ----------------------------------------------------
__int64 __fastcall wcrtomb(__int64 a1, int a2, void *a3)
{
  return _wcrtomb_internal(a1, a2, a3, 0xFFFFFFFFFFFFFFFFLL);
}

//----- (0000000000416400) ----------------------------------------------------
unsigned __int64 __fastcall _wcsmbs_getfct(unsigned __int8 *a1, unsigned __int8 *a2, unsigned __int64 *a3)
{
  unsigned __int64 result; // x0
  unsigned __int64 v5; // [xsp+20h] [xbp+20h] BYREF
  unsigned __int64 v6; // [xsp+28h] [xbp+28h] BYREF

  if ( (unsigned int)_gconv_find_transform(a1, a2, &v6, (__int64 *)&v5, 0) )
    return 0LL;
  result = v6;
  if ( v5 > 1 )
  {
    _gconv_close_transform(v6, v5);
    return 0LL;
  }
  else
  {
    *a3 = v5;
  }
  return result;
}

//----- (0000000000416464) ----------------------------------------------------
__int64 __fastcall _wcsmbs_load_conv(__int64 a1)
{
  int8x16_t *(__fastcall **v2)(int8x16_t *, unsigned __int8, unsigned __int64); // x20
  __int64 v3; // x2
  void *v4; // x3
  __int64 v5; // x4
  void *v6; // x5
  __int64 v7; // x6
  __int64 v8; // x7
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  int8x16_t *(__fastcall *v17)(int8x16_t *, unsigned __int8, unsigned __int64); // x21
  unsigned __int8 *v18; // x4
  unsigned __int8 v19; // w1
  __int64 *v20; // x0
  __int64 v21; // x7
  __int64 v22; // x3
  int v23; // w2
  unsigned __int64 v24; // x5
  bool v25; // zf
  int v26; // t1
  unsigned __int8 *v27; // x23
  __int64 *v28; // x2
  __int64 *v29; // x6
  int v30; // t1
  int transform; // w0
  double v32; // d0
  double v33; // d1
  double v34; // d2
  double v35; // d3
  double v36; // d4
  double v37; // d5
  double v38; // d6
  double v39; // d7
  __int64 *v40; // x3
  unsigned __int64 v41; // x0
  unsigned __int64 v42; // x1
  unsigned __int64 v43; // x0
  unsigned __int64 v44; // x1
  __int64 *v46; // x6
  __int16 v47; // [xsp+0h] [xbp-10h] BYREF
  _BYTE v48[14]; // [xsp+2h] [xbp-Eh] BYREF
  __int64 v49; // [xsp+10h] [xbp+0h] BYREF
  unsigned __int64 *v50; // [xsp+58h] [xbp+48h]
  unsigned __int64 v51; // [xsp+60h] [xbp+50h] BYREF
  unsigned __int64 v52; // [xsp+68h] [xbp+58h] BYREF

  v2 = *(int8x16_t *(__fastcall ***)(int8x16_t *, unsigned __int8, unsigned __int64))(a1 + 32);
  pthread_rwlock_wrlock((pthread_rwlock_t *)_libc_setlocale_lock);
  if ( *v2 )
    return pthread_rwlock_unlock((int *)_libc_setlocale_lock);
  v17 = calloc(1uLL, 0x20uLL, v3, v4, v9, v10, v11, v12, v13, v14, v15, v16, v5, v6, v7, v8);
  if ( v17 )
  {
    v18 = *(unsigned __int8 **)(a1 + 168);
    v19 = *v18;
    if ( *(_DWORD *)(a1 + 44) )
    {
      if ( !*v18 )
      {
        v27 = (unsigned __int8 *)&v47;
        v47 = 12079;
        v46 = (__int64 *)v48;
        v20 = (__int64 *)"TRANSLIT";
LABEL_35:
        *v46 = *v20;
        v28 = v46 + 1;
        goto LABEL_13;
      }
      v20 = (__int64 *)"TRANSLIT";
      v21 = 8LL;
    }
    else
    {
      if ( !*v18 )
      {
        v27 = (unsigned __int8 *)&v47;
        v47 = 12079;
        v28 = (__int64 *)v48;
        goto LABEL_13;
      }
      v20 = &qword_454610;
      v21 = 0LL;
    }
    v22 = *(_QWORD *)(a1 + 168);
    v23 = *v18;
    v24 = 0LL;
    do
    {
      v25 = v23 == 47;
      v26 = *(unsigned __int8 *)++v22;
      v23 = v26;
      if ( v25 )
        ++v24;
    }
    while ( v23 );
    v27 = (unsigned __int8 *)&v49;
    v28 = &v49;
    do
    {
      v29 = v28;
      *(_BYTE *)v28 = dword_45E140[v19];
      v28 = (__int64 *)((char *)v28 + 1);
      v30 = *++v18;
      v19 = v30;
    }
    while ( v30 );
    if ( v24 <= 1 )
    {
      *(_BYTE *)v28 = 47;
      if ( v24 )
      {
        v28 = (__int64 *)((char *)v29 + 2);
        goto LABEL_13;
      }
      *((_BYTE *)v28 + 1) = 47;
      v46 = (__int64 *)((char *)v29 + 3);
      v28 = v46;
      if ( v21 )
        goto LABEL_35;
    }
LABEL_13:
    *(_BYTE *)v28 = 0;
    v50 = &v51;
    transform = _gconv_find_transform((unsigned __int8 *)"INTERNAL", v27, &v52, (__int64 *)&v51, 0);
    v40 = (__int64 *)v50;
    if ( !transform )
    {
      v42 = v51;
      v41 = v52;
      if ( v51 <= 1 )
      {
        *(_QWORD *)v17 = v52;
        *((_QWORD *)v17 + 1) = v42;
        if ( v41 )
        {
          if ( !(unsigned int)_gconv_find_transform(v27, (unsigned __int8 *)"INTERNAL", &v52, v40, 0) )
          {
            v44 = v51;
            v43 = v52;
            if ( v51 <= 1 )
            {
              *((_QWORD *)v17 + 2) = v52;
              *((_QWORD *)v17 + 3) = v44;
              if ( v43 )
              {
LABEL_19:
                *v2 = v17;
                return pthread_rwlock_unlock((int *)_libc_setlocale_lock);
              }
              goto LABEL_32;
            }
            _gconv_close_transform(v52, v51);
          }
          *((_QWORD *)v17 + 2) = 0LL;
LABEL_32:
          if ( *(_QWORD *)v17 )
            _gconv_close_transform(*(_QWORD *)v17, *((_QWORD *)v17 + 1));
LABEL_26:
          free((unsigned __int64)v17, v32, v33, v34, v35, v36, v37, v38, v39);
          goto LABEL_27;
        }
LABEL_25:
        if ( *((_QWORD *)v17 + 2) )
          goto LABEL_19;
        goto LABEL_26;
      }
      _gconv_close_transform(v52, v51);
    }
    *(_QWORD *)v17 = 0LL;
    goto LABEL_25;
  }
LABEL_27:
  *v2 = (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))&_wcsmbs_gconv_fcts_c;
  return pthread_rwlock_unlock((int *)_libc_setlocale_lock);
}
// 41649C: variable 'v3' is possibly undefined
// 41649C: variable 'v4' is possibly undefined
// 41649C: variable 'v9' is possibly undefined
// 41649C: variable 'v10' is possibly undefined
// 41649C: variable 'v11' is possibly undefined
// 41649C: variable 'v12' is possibly undefined
// 41649C: variable 'v13' is possibly undefined
// 41649C: variable 'v14' is possibly undefined
// 41649C: variable 'v15' is possibly undefined
// 41649C: variable 'v16' is possibly undefined
// 41649C: variable 'v5' is possibly undefined
// 41649C: variable 'v6' is possibly undefined
// 41649C: variable 'v7' is possibly undefined
// 41649C: variable 'v8' is possibly undefined
// 4165FC: variable 'v32' is possibly undefined
// 4165FC: variable 'v33' is possibly undefined
// 4165FC: variable 'v34' is possibly undefined
// 4165FC: variable 'v35' is possibly undefined
// 4165FC: variable 'v36' is possibly undefined
// 4165FC: variable 'v37' is possibly undefined
// 4165FC: variable 'v38' is possibly undefined
// 4165FC: variable 'v39' is possibly undefined
// 454610: using guessed type __int64 qword_454610;
// 45E140: using guessed type int dword_45E140[256];
// 48C990: using guessed type _UNKNOWN *_wcsmbs_gconv_fcts_c;
// 496D78: using guessed type unsigned int _libc_setlocale_lock[14];

//----- (00000000004166C0) ----------------------------------------------------
void __fastcall _wcsmbs_clone_conv(_OWORD *a1)
{
  __int64 v2; // x0
  _OWORD **v3; // x19
  _OWORD *v4; // x1
  __int128 v5; // q30
  __int64 v6; // x1
  __int64 v7; // x2
  __int64 v8; // x3
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  int v20; // w0
  __int64 v21; // x1
  char v22; // w20
  int v23; // w0
  __int64 v24; // x1
  int v25; // w0
  bool v26; // w0
  __int64 v27; // x1
  __int64 v28; // x2
  __int64 v29; // x3
  void *v30; // x4
  void *v31; // x5
  void *v32; // x6
  double v33; // d0
  double v34; // d1
  double v35; // d2
  double v36; // d3
  double v37; // d4
  double v38; // d5
  double v39; // d6
  double v40; // d7
  int v41; // w0
  __int128 v42; // q30
  int v43; // w0

  v2 = **(_QWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 16);
  v3 = *(_OWORD ***)(v2 + 32);
  v4 = *v3;
  if ( *v3 )
  {
    v5 = v4[1];
    *a1 = *v4;
    a1[1] = v5;
    _aarch64_cas4_acq();
    if ( !v20 )
      goto LABEL_3;
  }
  else
  {
    _wcsmbs_load_conv(v2);
    v42 = (*v3)[1];
    *a1 = **v3;
    a1[1] = v42;
    _aarch64_cas4_acq();
    if ( !v43 )
      goto LABEL_3;
  }
  _lll_lock_wait_private(_gconv_lock, v12, v13, v14, v15, v16, v17, v18, v19, v6, v7, v8, v9, v10, v11);
LABEL_3:
  v21 = *(_QWORD *)a1;
  v22 = 0;
  if ( **(_QWORD **)a1 )
  {
    v23 = *(_DWORD *)(v21 + 16);
    *(_DWORD *)(v21 + 16) = v23 + 1;
    v22 = __OFADD__(v23, 1);
  }
  v24 = *((_QWORD *)a1 + 2);
  if ( *(_QWORD *)v24 )
  {
    v25 = *(_DWORD *)(v24 + 16);
    *(_DWORD *)(v24 + 16) = v25 + 1;
    v26 = __OFADD__(v25, 1);
    v22 |= v26;
  }
  _aarch64_swp4_rel();
  if ( v41 > 1 )
    _lll_lock_wake_private(_gconv_lock, v27, v28, v29, v30, v31, v32);
  if ( (v22 & 1) != 0 )
    _libc_fatal(
      (__int64)"Fatal glibc error: gconv module reference counter overflow\n",
      v33,
      v34,
      v35,
      v36,
      v37,
      v38,
      v39,
      v40);
}
// 416710: variable 'v20' is possibly undefined
// 416764: variable 'v41' is possibly undefined
// 416780: variable 'v27' is possibly undefined
// 416780: variable 'v28' is possibly undefined
// 416780: variable 'v29' is possibly undefined
// 416780: variable 'v30' is possibly undefined
// 416780: variable 'v31' is possibly undefined
// 416780: variable 'v32' is possibly undefined
// 4167AC: variable 'v43' is possibly undefined
// 4167B4: variable 'v12' is possibly undefined
// 4167B4: variable 'v13' is possibly undefined
// 4167B4: variable 'v14' is possibly undefined
// 4167B4: variable 'v15' is possibly undefined
// 4167B4: variable 'v16' is possibly undefined
// 4167B4: variable 'v17' is possibly undefined
// 4167B4: variable 'v18' is possibly undefined
// 4167B4: variable 'v19' is possibly undefined
// 4167B4: variable 'v6' is possibly undefined
// 4167B4: variable 'v7' is possibly undefined
// 4167B4: variable 'v8' is possibly undefined
// 4167B4: variable 'v9' is possibly undefined
// 4167B4: variable 'v10' is possibly undefined
// 4167B4: variable 'v11' is possibly undefined
// 4167C4: variable 'v33' is possibly undefined
// 4167C4: variable 'v34' is possibly undefined
// 4167C4: variable 'v35' is possibly undefined
// 4167C4: variable 'v36' is possibly undefined
// 4167C4: variable 'v37' is possibly undefined
// 4167C4: variable 'v38' is possibly undefined
// 4167C4: variable 'v39' is possibly undefined
// 4167C4: variable 'v40' is possibly undefined
// 496D30: using guessed type _DWORD _gconv_lock[2];

//----- (00000000004167C8) ----------------------------------------------------
__int64 __fastcall _wcsmbs_named_conv(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 v4; // x0
  unsigned __int64 v5; // x1
  __int64 result; // x0
  unsigned __int64 v7; // x1
  unsigned __int64 v8; // x2
  unsigned __int64 v9; // [xsp+40h] [xbp+40h] BYREF
  unsigned __int64 v10; // [xsp+48h] [xbp+48h] BYREF

  if ( (unsigned int)_gconv_find_transform("INTERNAL", a2, &v10, &v9, 0LL) )
    goto LABEL_9;
  v5 = v9;
  v4 = v10;
  if ( v9 > 1 )
  {
    _gconv_close_transform(v10, v9);
LABEL_9:
    *a1 = 0LL;
    return 1LL;
  }
  *a1 = v10;
  a1[1] = v5;
  if ( v4 )
  {
    result = _gconv_find_transform(a2, "INTERNAL", &v10, &v9, 0LL);
    if ( !(_DWORD)result )
    {
      v7 = v9;
      v8 = v10;
      if ( v9 <= 1 )
      {
        a1[2] = v10;
        a1[3] = v7;
        if ( v8 )
          return result;
LABEL_14:
        _gconv_close_transform(*a1, a1[1]);
        return 1LL;
      }
      _gconv_close_transform(v10, v9);
    }
    a1[2] = 0LL;
    goto LABEL_14;
  }
  return 1LL;
}
// 41FF6C: using guessed type __int64 __fastcall _gconv_find_transform(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000000416888) ----------------------------------------------------
void __fastcall nl_cleanup_ctype(__int64 a1)
{
  unsigned __int64 **v1; // x19
  unsigned __int64 *v2; // x1
  bool v3; // zf
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double v7; // d3
  double v8; // d4
  double v9; // d5
  double v10; // d6
  double v11; // d7

  v1 = *(unsigned __int64 ***)(a1 + 32);
  v2 = *v1;
  if ( *v1 )
    v3 = v2 == (unsigned __int64 *)&_wcsmbs_gconv_fcts_c;
  else
    v3 = 1;
  if ( !v3 )
  {
    _gconv_close_transform(v2[2], v2[3]);
    _gconv_close_transform(**v1, (*v1)[1]);
    free((unsigned __int64)*v1, v4, v5, v6, v7, v8, v9, v10, v11);
    *v1 = 0LL;
  }
}
// 4168C8: variable 'v4' is possibly undefined
// 4168C8: variable 'v5' is possibly undefined
// 4168C8: variable 'v6' is possibly undefined
// 4168C8: variable 'v7' is possibly undefined
// 4168C8: variable 'v8' is possibly undefined
// 4168C8: variable 'v9' is possibly undefined
// 4168C8: variable 'v10' is possibly undefined
// 4168C8: variable 'v11' is possibly undefined
// 48C990: using guessed type _UNKNOWN *_wcsmbs_gconv_fcts_c;

//----- (00000000004168E0) ----------------------------------------------------
__int64 __fastcall wcsrtombs(
        _BYTE *a1,
        _DWORD **a2,
        unsigned __int64 a3,
        __int64 *a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  unsigned __int64 StatusReg; // x24
  __int64 *v11; // x0
  __int64 *v14; // x0
  __int64 v15; // x0
  __int64 *v16; // x20
  __int64 v17; // x1
  _QWORD *v18; // x20
  unsigned __int64 v19; // x21
  __int64 v20; // x25
  unsigned __int64 v21; // x0
  int v22; // w1
  __int64 result; // x0
  __int64 v24; // x0
  __int64 v25; // x23
  int v26; // w0
  __int64 v27; // [xsp+68h] [xbp+68h] BYREF
  __int64 v28; // [xsp+70h] [xbp+70h] BYREF
  char v29[8]; // [xsp+78h] [xbp+78h] BYREF
  _BYTE *v30; // [xsp+80h] [xbp+80h] BYREF
  char *v31; // [xsp+88h] [xbp+88h]
  __int64 v32; // [xsp+90h] [xbp+90h]
  int v33; // [xsp+98h] [xbp+98h]
  __int64 *v34; // [xsp+A0h] [xbp+A0h]
  _BYTE v35[256]; // [xsp+B0h] [xbp+B0h] BYREF

  v33 = 1;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v11 = (__int64 *)&state_0;
  if ( a4 )
    v11 = a4;
  v34 = v11;
  v14 = *(__int64 **)(StatusReg + 16);
  v32 = 1LL;
  v15 = *v14;
  v16 = *(__int64 **)(v15 + 32);
  v17 = *v16;
  if ( !*v16 )
  {
    _wcsmbs_load_conv(v15);
    v17 = *v16;
  }
  v18 = *(_QWORD **)(v17 + 16);
  v19 = v18[5];
  if ( *v18 )
    v19 ^= _pointer_chk_guard_local;
  v20 = (__int64)*a2;
  if ( a1 )
  {
    v21 = wcsnlen(*a2, a3);
    v30 = a1;
    v31 = &a1[a3];
    v22 = ((__int64 (__fastcall *)(_QWORD *, _BYTE **, _DWORD **, unsigned __int64, _QWORD, _BYTE *, _QWORD, __int64))v19)(
            v18,
            &v30,
            a2,
            v20 + 4 * (v21 + 1),
            0LL,
            v35,
            0LL,
            1LL);
    result = v30 - a1;
    if ( (v22 & 0xFFFFFFFB) != 0 )
    {
      if ( (unsigned int)(v22 - 6) > 1 )
      {
        if ( v22 == 5 )
          return result;
LABEL_24:
        _libc_assert_fail(
          (__int64)"status == __GCONV_OK || status == __GCONV_EMPTY_INPUT || status == __GCONV_ILLEGAL_INPUT || status =="
                   " __GCONV_INCOMPLETE_INPUT || status == __GCONV_FULL_OUTPUT",
          (__int64)"wcsrtombs.c",
          0x80u,
          (__int64)"__wcsrtombs");
      }
LABEL_22:
      *(_DWORD *)(StatusReg + 40) = 84;
      return -1LL;
    }
    if ( !*(v30 - 1) )
    {
      if ( v30 == a1 )
        _libc_assert_fail(
          (__int64)"data.__outbuf != (unsigned char *) dst",
          (__int64)"wcsrtombs.c",
          0x77u,
          (__int64)"__wcsrtombs");
      if ( *(_DWORD *)v34 )
        _libc_assert_fail((__int64)"__mbsinit (data.__statep)", (__int64)"wcsrtombs.c", 0x78u, (__int64)"__wcsrtombs");
      *a2 = 0LL;
      --result;
    }
  }
  else
  {
    v24 = wcslen(*a2);
    v28 = (__int64)*a2;
    v25 = v20 + 4 * (v24 + 1);
    v27 = *v34;
    v34 = &v27;
    v31 = &a9;
    do
    {
      v30 = v35;
      v26 = ((__int64 (__fastcall *)(_QWORD *, _BYTE **, __int64 *, __int64, _QWORD, char *, _QWORD, __int64))v19)(
              v18,
              &v30,
              &v28,
              v25,
              0LL,
              v29,
              0LL,
              1LL);
      a1 += v30 - v35;
    }
    while ( v26 == 5 );
    if ( (v26 & 0xFFFFFFFB) != 0 )
    {
      if ( (unsigned int)(v26 - 6) > 1 )
        goto LABEL_24;
      goto LABEL_22;
    }
    result = (__int64)(a1 - 1);
    if ( *(v30 - 1) )
      _libc_assert_fail((__int64)"data.__outbuf[-1] == '\\0'", (__int64)"wcsrtombs.c", 0x5Bu, (__int64)"__wcsrtombs");
  }
  return result;
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000416BA0) ----------------------------------------------------
int __fastcall clock_gettime(clockid_t a1, struct timespec *a2)
{
  int result; // w0

  if ( dl_vdso_clock_gettime64 )
  {
    result = dl_vdso_clock_gettime64();
    if ( result )
    {
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -result;
      return -1;
    }
  }
  else
  {
    result = linux_eabi_syscall(__NR_clock_gettime, a1, a2);
    if ( result )
    {
      if ( result == -38 )
        *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 38;
      else
        *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -result;
      return -1;
    }
  }
  return result;
}
// 48F7A0: using guessed type __int64 (*dl_vdso_clock_gettime64)(void);

//----- (0000000000416C40) ----------------------------------------------------
void __noreturn exit(int status)
{
  void *v1; // x4
  void *v2; // x5
  void *v3; // x6
  void *v4; // x1
  _DWORD *StatusReg; // x3
  unsigned __int64 v6; // x0

  v4 = (void *)status;
  StatusReg = (_DWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v6 = linux_eabi_syscall(__NR_exit_group, v4, v4, (void *)0x28, StatusReg, v1, v2, v3);
  if ( v6 > 0xFFFFFFFFFFFFF000LL )
    goto LABEL_4;
  while ( 1 )
  {
    __break(0x3E8u);
    while ( 1 )
    {
      v6 = linux_eabi_syscall(__NR_exit_group, v4, v4, (void *)0x28, StatusReg, v1, v2, v3);
      if ( v6 <= 0xFFFFFFFFFFFFF000LL )
        break;
LABEL_4:
      StatusReg[10] = -(int)v6;
      __break(0x3E8u);
    }
  }
}
// 416C58: variable 'v1' is possibly undefined
// 416C58: variable 'v2' is possibly undefined
// 416C58: variable 'v3' is possibly undefined

//----- (0000000000416CC0) ----------------------------------------------------
__pid_t getpid()
{
  return linux_eabi_syscall(__NR_getpid);
}

//----- (0000000000416D00) ----------------------------------------------------
unsigned __int64 __fastcall uname(struct utsname *a1)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_uname, a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
    return _syscall_error(result);
  return result;
}

//----- (0000000000416D20) ----------------------------------------------------
unsigned __int64 __fastcall fstat64(int a1, struct stat *a2)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_fstat, a1, a2);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000416D60) ----------------------------------------------------
unsigned __int64 __fastcall lseek64(int a1, __off_t a2, int a3)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_lseek, a1, a2, a3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
    return -1LL;
  }
  return result;
}

//----- (0000000000416DA0) ----------------------------------------------------
__int64 __fastcall open64(void *a1, int a2, int a3)
{
  void *v3; // x3

  if ( (a2 & 0x40) != 0 || (v3 = 0LL, (a2 & ((a2 & 0x40) + 4210688)) == 0x404000) )
    v3 = (void *)a3;
  return _syscall_cancel((void *)0xFFFFFFFFFFFFFF9CLL, a1, (void *)a2, v3, 0LL, 0LL, (void *)0x38);
}

//----- (0000000000416E20) ----------------------------------------------------
__int64 __fastcall read(int a1, void *a2, void *a3)
{
  return _syscall_cancel((void *)a1, a2, a3, 0LL, 0LL, 0LL, (void *)0x3F);
}

//----- (0000000000416E40) ----------------------------------------------------
__int64 __fastcall write(int a1, void *a2, void *a3)
{
  return _syscall_cancel((void *)a1, a2, a3, 0LL, 0LL, 0LL, (void *)0x40);
}

//----- (0000000000416E60) ----------------------------------------------------
unsigned __int64 __fastcall _close_nocancel(int a1)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_close, a1);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (0000000000416EA0) ----------------------------------------------------
unsigned __int64 __fastcall _open_nocancel(const char *a1, int a2)
{
  unsigned __int64 result; // x0

  if ( (a2 & 0x40) == 0 && (a2 & ((a2 & 0x40) + 4210688)) != 0x404000 )
  {
    result = linux_eabi_syscall(__NR_openat, -100, a1, a2);
    if ( result <= 0xFFFFFFFFFFFFF000LL )
      return result;
LABEL_6:
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
    return 0xFFFFFFFFLL;
  }
  result = linux_eabi_syscall(__NR_openat, -100, a1, a2);
  if ( result > 0xFFFFFFFFFFFFF000LL )
    goto LABEL_6;
  return result;
}

//----- (0000000000416F60) ----------------------------------------------------
unsigned __int64 __fastcall _read_nocancel(int a1, void *a2, size_t a3)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_read, a1, a2, a3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
    return -1LL;
  }
  return result;
}

//----- (0000000000416FA0) ----------------------------------------------------
unsigned __int64 __fastcall _write_nocancel(int a1, const void *a2, size_t a3)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_write, a1, a2, a3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
    return -1LL;
  }
  return result;
}

//----- (0000000000416FE0) ----------------------------------------------------
__int64 __fastcall brk(void *a1)
{
  _curbrk = linux_eabi_syscall(__NR_brk, a1);
  if ( (unsigned __int64)a1 <= _curbrk )
    return 0LL;
  *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 12;
  return 0xFFFFFFFFLL;
}
// 496B60: using guessed type __int64 _curbrk;

//----- (0000000000417020) ----------------------------------------------------
__int64 getpagesize()
{
  __int64 result; // x0

  result = dl_pagesize;
  if ( !dl_pagesize )
    _libc_assert_fail(
      (__int64)"GLRO(dl_pagesize) != 0",
      (__int64)"../sysdeps/unix/sysv/linux/getpagesize.c",
      0x1Cu,
      (__int64)"__getpagesize");
  return result;
}
// 490F10: using guessed type __int64 dl_pagesize;

//----- (0000000000417060) ----------------------------------------------------
char *__fastcall next_line(int a1, char *a2, void **a3, void **a4, char *a5)
{
  char *v10; // x20
  char *v11; // x21
  unsigned __int64 (__fastcall *v12)(__int64, unsigned int, unsigned __int64); // x0
  unsigned __int64 nocancel; // x0
  char *v15; // x20
  unsigned __int64 v16; // x22
  _BYTE *v17; // x21

  v10 = (char *)*a3;
  v11 = (char *)*a4;
  v12 = memchr();
  if ( !v12 )
  {
    if ( v10 == a2 || v11 != a5 )
      goto LABEL_3;
    j_memmove();
    *a4 = &a2[(_BYTE *)*a4 - (_BYTE *)*a3];
    *a3 = a2;
    nocancel = _read_nocancel(a1, *a4, a5 - (_BYTE *)*a4);
    if ( (nocancel & 0x8000000000000000LL) != 0 )
      return 0LL;
    v11 = (char *)*a4 + nocancel;
    *a4 = v11;
    v10 = (char *)*a3;
    v12 = memchr();
    if ( !v12 )
    {
      v15 = &a2[3 * (a5 - a2) / 4];
      do
      {
        if ( v11 != a5 )
        {
          v10 = (char *)*a3;
          goto LABEL_3;
        }
        *a4 = v15;
        v16 = _read_nocancel(a1, &a2[3 * (a5 - a2) / 4], a5 - v15);
        if ( (v16 & 0x8000000000000000LL) != 0 )
          return 0LL;
        v17 = *a4;
        v12 = memchr();
        *v17 = 10;
        v11 = (char *)*a4 + v16;
        *a4 = v11;
      }
      while ( !v12 );
      v10 = (char *)*a3;
    }
  }
  v11 = (char *)v12 + 1;
LABEL_3:
  *a3 = v11;
  if ( *a4 < v11 )
    _libc_assert_fail(
      (__int64)"*cp <= *re",
      (__int64)"../sysdeps/unix/sysv/linux/getsysstats.c",
      0x67u,
      (__int64)"next_line");
  if ( *a4 != v10 )
    return v10;
  return 0LL;
}
// 417210: using guessed type __int64 read_sysfs_file(void);

//----- (0000000000417210) ----------------------------------------------------
__int64 __fastcall read_sysfs_file(
        const char *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  int v9; // w0
  int v11; // w22
  unsigned __int8 *v12; // x0
  unsigned __int8 *v13; // x19
  unsigned __int64 v14; // x0
  unsigned __int8 *v15; // x1
  unsigned __int64 v16; // x20
  unsigned int v17; // w21
  int v18; // w2
  unsigned __int8 *v19; // x19
  unsigned __int8 *v20; // x19
  char *v21; // [xsp+48h] [xbp+48h] BYREF
  char *v22; // [xsp+50h] [xbp+50h] BYREF
  unsigned __int8 *v23; // [xsp+58h] [xbp+58h] BYREF
  char v24[1024]; // [xsp+60h] [xbp+60h] BYREF

  v21 = &a9;
  v22 = &a9;
  v9 = _open_nocancel(a1, 0x80000);
  if ( v9 == -1 )
    return 0LL;
  v11 = v9;
  v12 = (unsigned __int8 *)next_line(v9, v24, (void **)&v21, (void **)&v22, &a9);
  v13 = v12;
  if ( v12 )
  {
    v14 = _isoc23_strtoumax(v12, &v23, 10);
    v15 = v23;
    v16 = v14;
    v17 = 0;
    if ( v23 != v13 )
    {
      do
      {
        if ( *v15 != 45 )
          goto LABEL_6;
        v20 = v15 + 1;
        v14 = _isoc23_strtoumax(v15 + 1, &v23, 10);
        v15 = v23;
        if ( v23 == v20 )
          break;
        if ( v16 <= v14 )
LABEL_6:
          v17 += v14 - v16 + 1;
        if ( v22 <= (char *)v15 )
          goto LABEL_8;
        v18 = *v15;
        v19 = v15;
        if ( v18 == 44 )
        {
          v19 = v15 + 1;
          if ( v22 <= (char *)v15 + 1 )
            goto LABEL_8;
          v18 = v15[1];
        }
        if ( v18 == 10 )
          goto LABEL_8;
        v14 = _isoc23_strtoumax(v19, &v23, 10);
        v15 = v23;
        v16 = v14;
      }
      while ( v23 != v19 );
    }
  }
  v17 = 0;
LABEL_8:
  _close_nocancel(v11);
  return v17;
}

//----- (0000000000417364) ----------------------------------------------------
__int64 __fastcall get_nproc_stat(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  unsigned int v9; // w19
  int v10; // w0
  int v11; // w20
  char *v12; // x0
  char *v14; // [xsp+40h] [xbp+40h] BYREF
  char *v15; // [xsp+48h] [xbp+48h] BYREF
  char v16[1024]; // [xsp+50h] [xbp+50h] BYREF

  v9 = 0;
  v14 = &a9;
  v15 = &a9;
  v10 = _open_nocancel("/proc/stat", 0x80000);
  if ( v10 != -1 )
  {
    v11 = v10;
    v9 = 0;
    while ( 1 )
    {
      v12 = next_line(v11, v16, (void **)&v14, (void **)&v15, &a9);
      if ( !v12 || *v12 != 99 || v12[1] != 112 || v12[2] != 117 )
        break;
      if ( (unsigned int)(unsigned __int8)v12[3] - 48 < 0xA )
        ++v9;
    }
    _close_nocancel(v11);
  }
  return v9;
}

//----- (0000000000417410) ----------------------------------------------------
unsigned __int64 _get_nprocs_sched()
{
  int v0; // w0
  cpu_set_t v2[32]; // [xsp+10h] [xbp-1000h] BYREF

  v0 = linux_eabi_syscall(__NR_sched_getaffinity, 0, 0x1000uLL, v2);
  if ( v0 > 0 )
    return _sched_cpucount(v0, (int8x8_t *)v2);
  else
    return (unsigned __int8)(v0 == -22) << 15;
}

//----- (0000000000417480) ----------------------------------------------------
__int64 __fastcall get_nprocs(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  __int64 result; // x0
  __int64 v9; // x1
  __int64 v10; // x2
  __int64 v11; // x3
  __int64 v12; // x4
  __int64 v13; // x5
  __int64 v14; // x6
  __int64 v15; // x7
  char vars0; // [xsp+0h] [xbp+0h]
  char vars0a; // [xsp+0h] [xbp+0h]

  result = read_sysfs_file("/sys/devices/system/cpu/online", a2, a3, a4, a5, a6, a7, a8, vars0);
  if ( !(_DWORD)result )
  {
    result = get_nproc_stat(result, v9, v10, v11, v12, v13, v14, v15, vars0a);
    if ( !(_DWORD)result )
    {
      LODWORD(result) = _get_nprocs_sched();
      if ( (_DWORD)result )
        return (unsigned int)result;
      else
        return 2LL;
    }
  }
  return result;
}
// 417490: variable 'vars0' is possibly undefined
// 4174A0: variable 'v9' is possibly undefined
// 4174A0: variable 'v10' is possibly undefined
// 4174A0: variable 'v11' is possibly undefined
// 4174A0: variable 'v12' is possibly undefined
// 4174A0: variable 'v13' is possibly undefined
// 4174A0: variable 'v14' is possibly undefined
// 4174A0: variable 'v15' is possibly undefined
// 4174A0: variable 'vars0a' is possibly undefined

//----- (00000000004174C0) ----------------------------------------------------
__int64 __fastcall get_nprocs_conf(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  __int64 result; // x0
  __int64 v9; // x1
  __int64 v10; // x2
  __int64 v11; // x3
  __int64 v12; // x4
  __int64 v13; // x5
  __int64 v14; // x6
  __int64 v15; // x7
  char vars0; // [xsp+0h] [xbp+0h]
  char vars0a; // [xsp+0h] [xbp+0h]

  result = read_sysfs_file("/sys/devices/system/cpu/possible", a2, a3, a4, a5, a6, a7, a8, vars0);
  if ( !(_DWORD)result )
  {
    result = get_nproc_stat(result, v9, v10, v11, v12, v13, v14, v15, vars0a);
    if ( !(_DWORD)result )
    {
      LODWORD(result) = _get_nprocs_sched();
      if ( (_DWORD)result )
        return (unsigned int)result;
      else
        return 2LL;
    }
  }
  return result;
}
// 4174D0: variable 'vars0' is possibly undefined
// 4174E0: variable 'v9' is possibly undefined
// 4174E0: variable 'v10' is possibly undefined
// 4174E0: variable 'v11' is possibly undefined
// 4174E0: variable 'v12' is possibly undefined
// 4174E0: variable 'v13' is possibly undefined
// 4174E0: variable 'v14' is possibly undefined
// 4174E0: variable 'v15' is possibly undefined
// 4174E0: variable 'vars0a' is possibly undefined

//----- (0000000000417500) ----------------------------------------------------
__kernel_ulong_t get_phys_pages()
{
  int v0; // w0
  __u32 mem_unit; // w19
  unsigned __int64 v2; // x1
  __kernel_ulong_t result; // x0
  struct sysinfo v6; // [xsp+20h] [xbp+20h] BYREF

  sysinfo(&v6);
  v0 = getpagesize();
  mem_unit = v6.mem_unit;
  v2 = v0;
  if ( v6.mem_unit > 1 && (unsigned __int64)v0 > 1 )
  {
    do
    {
      mem_unit >>= 1;
      v2 >>= 1;
    }
    while ( mem_unit != 1 && v2 != 1 );
  }
  result = mem_unit * v6.totalram;
  if ( v2 > 1 )
  {
    do
    {
      v2 >>= 1;
      result >>= 1;
    }
    while ( v2 != 1 );
  }
  return result;
}

//----- (0000000000417580) ----------------------------------------------------
__kernel_ulong_t get_avphys_pages()
{
  int v0; // w0
  __u32 mem_unit; // w19
  unsigned __int64 v2; // x1
  __kernel_ulong_t result; // x0
  struct sysinfo v6; // [xsp+20h] [xbp+20h] BYREF

  sysinfo(&v6);
  v0 = getpagesize();
  mem_unit = v6.mem_unit;
  v2 = v0;
  if ( v6.mem_unit > 1 && (unsigned __int64)v0 > 1 )
  {
    do
    {
      mem_unit >>= 1;
      v2 >>= 1;
    }
    while ( mem_unit != 1 && v2 != 1 );
  }
  result = mem_unit * v6.freeram;
  if ( v2 > 1 )
  {
    do
    {
      v2 >>= 1;
      result >>= 1;
    }
    while ( v2 != 1 );
  }
  return result;
}

//----- (0000000000417600) ----------------------------------------------------
unsigned __int64 __fastcall madvise(void *a1, size_t a2, int a3)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_madvise, a1, a2, a3);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
    return _syscall_error(result);
  return result;
}

//----- (0000000000417620) ----------------------------------------------------
unsigned __int64 __fastcall mmap64(void *a1, size_t a2, int a3, int a4, int a5, __off_t a6)
{
  unsigned __int64 result; // x0

  if ( (a6 & 0xFFF) != 0 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return -1LL;
  }
  else
  {
    result = (unsigned __int64)linux_eabi_syscall(__NR_mmap, a1, a2, a3, a4, a5, a6);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
      return -1LL;
    }
  }
  return result;
}

//----- (0000000000417680) ----------------------------------------------------
unsigned __int64 __fastcall mprotect(void *a1, size_t a2, int a3)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_mprotect, a1, a2, a3);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
    return _syscall_error(result);
  return result;
}

//----- (00000000004176C0) ----------------------------------------------------
unsigned __int64 __fastcall munmap(void *a1, size_t a2)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_munmap, a1, a2);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
    return _syscall_error(result);
  return result;
}

//----- (00000000004176E0) ----------------------------------------------------
__int64 __fastcall sbrk(__int64 a1)
{
  __int64 v1; // x1
  unsigned __int64 v2; // x2
  void *v3; // x0
  int v4; // w0
  unsigned __int64 v6; // [xsp+18h] [xbp+18h]

  v1 = a1;
  v2 = _curbrk;
  if ( !_curbrk )
  {
    if ( (brk(0LL) & 0x80000000) != 0 )
      return -1LL;
    v1 = a1;
    v2 = _curbrk;
  }
  if ( !v1 )
    return v2;
  if ( v1 > 0 )
  {
    v3 = (void *)(v2 + v1);
    if ( v2 + v1 >= v2 )
      goto LABEL_5;
LABEL_8:
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 12;
    return -1LL;
  }
  if ( -v1 > v2 )
    goto LABEL_8;
  v3 = (void *)(v2 + v1);
LABEL_5:
  v6 = v2;
  v4 = brk(v3);
  v2 = v6;
  if ( (v4 & 0x80000000) == 0 )
    return v2;
  return -1LL;
}
// 496B60: using guessed type __int64 _curbrk;

//----- (00000000004177A0) ----------------------------------------------------
unsigned __int64 __fastcall mremap(void *a1, size_t a2, size_t a3, unsigned int a4)
{
  unsigned __int64 result; // x0

  if ( a4 > 7 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return -1LL;
  }
  else
  {
    result = (unsigned __int64)linux_eabi_syscall(__NR_mremap, a1, a2, a3, a4);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
      return -1LL;
    }
  }
  return result;
}

//----- (0000000000417840) ----------------------------------------------------
int __fastcall _set_vma_name(void *a1)
{
  void *v1; // x19
  int v3; // [xsp+3Ch] [xbp-4h] BYREF

  if ( prctl_supported_0 )
  {
    v1 = a1;
    _tunable_get_val(23LL, (char **)&v3, 0LL);
    LODWORD(a1) = v3;
    if ( !v3 || (LODWORD(a1) = linux_eabi_syscall(__NR_prctl, 1398164801, 0LL, v1), (_DWORD)a1 == -22) )
      prctl_supported_0 = 0;
  }
  return (int)a1;
}
// 490F0C: using guessed type int prctl_supported_0;

//----- (0000000000417900) ----------------------------------------------------
unsigned __int64 __fastcall sysinfo(struct sysinfo *a1)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_sysinfo, a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
    return _syscall_error(result);
  return result;
}

//----- (0000000000417940) ----------------------------------------------------
signed __int64 __fastcall gettid(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  return linux_eabi_syscall(__NR_gettid, a1, a2, a3, a4, a5, a6, a7);
}

//----- (0000000000417960) ----------------------------------------------------
__int64 _malloc_default_thp_pagesize()
{
  int v0; // w0
  _BYTE *v1; // x1
  __int64 result; // x0
  int v3; // w2
  signed __int64 nocancel; // [xsp+18h] [xbp+18h]
  int v5; // [xsp+24h] [xbp+24h]
  _BYTE v6[24]; // [xsp+38h] [xbp+38h] BYREF

  v0 = _open_nocancel("/sys/kernel/mm/transparent_hugepage/hpage_pmd_size", 0);
  if ( v0 == -1 )
    return 0LL;
  v5 = v0;
  nocancel = _read_nocancel(v0, v6, 0x15uLL);
  _close_nocancel(v5);
  if ( nocancel <= 0 )
    return 0LL;
  v1 = v6;
  result = 0LL;
  do
  {
    v3 = (unsigned __int8)*v1;
    if ( v3 == 10 )
      break;
    ++v1;
    result = v3 - 48 + 10 * result;
  }
  while ( &v6[nocancel] != v1 );
  return result;
}

//----- (0000000000417A00) ----------------------------------------------------
__int64 _malloc_thp_mode()
{
  int v0; // w0
  int v1; // w20
  unsigned __int64 nocancel; // x0
  int v3; // w1
  __int64 result; // x0
  int v5; // w1
  unsigned __int64 v6; // [xsp+28h] [xbp+28h]
  unsigned __int64 v7[3]; // [xsp+38h] [xbp+38h] BYREF

  v0 = _open_nocancel("/sys/kernel/mm/transparent_hugepage/enabled", 0);
  if ( v0 == -1 )
    return 3LL;
  v1 = v0;
  nocancel = _read_nocancel(v0, v7, 0x18uLL);
  if ( nocancel > 0x17 )
    return 3LL;
  *((_BYTE *)v7 + nocancel) = 0;
  v6 = nocancel;
  _close_nocancel(v1);
  if ( v6 != 23 )
    return 3LL;
  v3 = strcmp(v7, (unsigned __int64)"[always] madvise never\n");
  result = 0LL;
  if ( v3 )
  {
    v5 = strcmp(v7, (unsigned __int64)"always [madvise] never\n");
    result = 1LL;
    if ( v5 )
    {
      if ( !(unsigned int)strcmp(v7, (unsigned __int64)"always madvise [never]\n") )
        return 2LL;
      return 3LL;
    }
  }
  return result;
}

//----- (0000000000417AE0) ----------------------------------------------------
unsigned __int64 __fastcall _malloc_hugepage_config(unsigned __int64 a1, unsigned __int64 *a2, unsigned int *a3)
{
  unsigned __int64 v3; // x21
  unsigned __int64 result; // x0
  __int64 v7; // x3
  void *v8; // x4
  void *v9; // x5
  void *v10; // x6
  int v11; // w23
  unsigned __int64 v12; // x0
  _BYTE *v13; // x19
  _BYTE *v14; // x26
  unsigned __int8 *v15; // x1
  __int64 v16; // x0
  int v17; // t1
  __off64_t v18; // x23
  int v19; // w19
  unsigned __int64 v20; // x0
  __int64 v21; // x2
  __int64 v22; // x3
  __int64 v23; // x4
  __int64 v24; // x5
  __int64 v25; // x6
  __int64 v26; // x7
  __int64 v27; // x0
  __int64 v28; // x2
  __int64 v29; // x3
  __int64 v30; // x4
  __int64 v31; // x5
  unsigned __int64 v32; // x6
  unsigned __int64 v33; // x0
  int v34; // w1
  unsigned __int8 *v35; // x0
  int v36; // w2
  bool v38; // zf
  int v39; // t1
  __int64 v40; // x2
  unsigned __int64 v42; // x21
  char v43; // [xsp+0h] [xbp+0h]
  _BYTE v44[1024]; // [xsp+50h] [xbp+50h] BYREF

  v3 = a1;
  *a2 = 0LL;
  *a3 = 0;
  if ( !a1 )
  {
    v18 = 0LL;
    result = _open_nocancel("/proc/meminfo", 0);
    v19 = result;
    if ( (_DWORD)result != -1 )
    {
      v20 = _pread64_nocancel(result, v44, 0x1FFuLL, 0LL);
      if ( (v20 & 0x8000000000000000LL) == 0 )
      {
        while ( 1 )
        {
          v44[v20] = 0;
          v27 = strstr((__int64)v44, (int8x16_t *)"Hugepagesize:", v21, v22, v23, v24, v25, v26, v43);
          if ( v27 )
            break;
          v33 = strrchr((__int64)v44, 0xAu, v28, v29, v30, v31, v32);
          if ( v33 )
          {
            v18 += v33 + 1 - (_QWORD)v44;
            v20 = _pread64_nocancel(v19, v44, 0x1FFuLL, v18);
            if ( (v20 & 0x8000000000000000LL) == 0 )
              continue;
          }
          goto LABEL_20;
        }
        v34 = *(unsigned __int8 *)(v27 + 14);
        v35 = (unsigned __int8 *)(v27 + 15);
        v36 = v34 - 48;
        if ( v34 == 32 || (unsigned __int8)(v34 - 48) <= 9u )
        {
          do
          {
            v38 = v34 == 32;
            v39 = *v35++;
            v34 = v39;
            v40 = v36 + 10 * v3;
            if ( !v38 )
              v3 = v40;
            v36 = v34 - 48;
          }
          while ( v34 == 32 || (unsigned __int8)(v34 - 48) <= 9u );
          v42 = v3 << 10;
          result = _close_nocancel(v19);
          *a2 = v42;
          if ( v42 )
          {
            result = ((unsigned int)__clz(__rbit64(v42)) << 26) | 0x40000;
            *a3 = result;
          }
          return result;
        }
      }
LABEL_20:
      result = _close_nocancel(v19);
    }
    *a2 = 0LL;
    return result;
  }
  result = _open_nocancel("/sys/kernel/mm/hugepages", 0x4000);
  v11 = result;
  if ( (_DWORD)result != -1 )
  {
LABEL_3:
    v12 = getdents64(v11, v44, 0x400uLL, v7, v8, v9, v10);
    if ( v12 + 1 > 1 )
    {
      v13 = &v44[v12];
      v14 = v44;
      while ( 1 )
      {
        if ( v14[19] != 46
          && !(unsigned int)strncmp((unsigned __int64)(v14 + 19), (unsigned __int64)"hugepages-", 0xAuLL) )
        {
          v7 = (unsigned int)(unsigned __int8)v14[29] - 48;
          if ( (unsigned __int8)(v14[29] - 48) <= 9u )
          {
            v15 = v14 + 30;
            v16 = 0LL;
            do
            {
              v16 = (int)v7 + 10 * v16;
              v17 = *v15++;
              v7 = (unsigned int)(v17 - 48);
            }
            while ( (unsigned __int8)(v17 - 48) <= 9u );
            if ( v3 == v16 << 10 )
              break;
          }
        }
        v14 += *((unsigned __int16 *)v14 + 8);
        if ( v14 == v13 )
          goto LABEL_3;
      }
      *a2 = v3;
      *a3 = ((unsigned int)__clz(__rbit64(v3)) << 26) | 0x40000;
    }
    return _close_nocancel(v11);
  }
  return result;
}
// 417B4C: variable 'v7' is possibly undefined
// 417B4C: variable 'v8' is possibly undefined
// 417B4C: variable 'v9' is possibly undefined
// 417B4C: variable 'v10' is possibly undefined
// 417C78: variable 'v21' is possibly undefined
// 417C78: variable 'v22' is possibly undefined
// 417C78: variable 'v23' is possibly undefined
// 417C78: variable 'v24' is possibly undefined
// 417C78: variable 'v25' is possibly undefined
// 417C78: variable 'v26' is possibly undefined
// 417C78: variable 'v43' is possibly undefined
// 417C88: variable 'v28' is possibly undefined
// 417C88: variable 'v29' is possibly undefined
// 417C88: variable 'v30' is possibly undefined
// 417C88: variable 'v31' is possibly undefined
// 417C88: variable 'v32' is possibly undefined

//----- (0000000000417D80) ----------------------------------------------------
void __fastcall __noreturn _chk_fail(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  _fortify_fail((__int64)"buffer overflow detected", a1, a2, a3, a4, a5, a6, a7, a8);
}

//----- (0000000000417DA0) ----------------------------------------------------
void __fastcall __noreturn _fortify_fail(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  _libc_message_impl("*** %s ***: terminated\n", a2, a3, a4, a5, a6, a7, a8, a9, a1);
}
// 417DC0: using guessed type __int64 _readonly_area(void);

//----- (0000000000417DC0) ----------------------------------------------------
__int64 __fastcall _readonly_area(
        unsigned __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  __int64 *v18; // x0
  unsigned __int8 *v19; // x2
  __int64 v20; // x3
  void *v21; // x4
  void *v22; // x5
  void *v23; // x6
  __int64 v24; // x7
  double v25; // d0
  double v26; // d1
  double v27; // d2
  double v28; // d3
  double v29; // d4
  double v30; // d5
  double v31; // d6
  double v32; // d7
  __int64 *v33; // x20
  int v34; // w0
  __int64 v35; // x1
  unsigned __int64 v36; // x22
  unsigned __int64 v37; // x19
  unsigned __int8 *v38; // x0
  unsigned __int64 v39; // x0
  bool v41; // cc
  double v42; // d0
  double v43; // d1
  double v44; // d2
  double v45; // d3
  double v46; // d4
  double v47; // d5
  double v48; // d6
  double v49; // d7
  unsigned int v51; // w1
  double v52; // d0
  double v53; // d1
  double v54; // d2
  double v55; // d3
  double v56; // d4
  double v57; // d5
  double v58; // d6
  double v59; // d7
  unsigned __int8 *v60; // [xsp+60h] [xbp+60h] BYREF
  __int64 v61; // [xsp+68h] [xbp+68h] BYREF
  unsigned __int8 *v62; // [xsp+70h] [xbp+70h] BYREF
  unsigned __int8 *v63; // [xsp+78h] [xbp+78h] BYREF

  v18 = (__int64 *)fopen64("/proc/self/maps", "rce", a9, a10, a11, a12, a13, a14, a15, a16, a3, a4, a5, a6, a7, a8);
  if ( v18 )
  {
    v33 = v18;
    v34 = *(_DWORD *)v18;
    v35 = v34 | 0x8000u;
    *(_DWORD *)v33 = v35;
    v60 = 0LL;
    v61 = 0LL;
    if ( (v34 & 0x10) == 0 )
    {
      v36 = a1 + a2;
      do
      {
        if ( getdelim(
               (unsigned __int64 *)&v60,
               (__int64)&v61,
               10LL,
               v33,
               v21,
               v22,
               v23,
               v24,
               v25,
               v26,
               v27,
               v28,
               v29,
               v30,
               v31,
               v32) <= 0 )
          break;
        v37 = _isoc23_strtoumax(v60, &v62, 16);
        v35 = (__int64)v62;
        if ( v62 == v60 )
          break;
        v38 = ++v62;
        v35 = *(unsigned __int8 *)v35;
        if ( (_DWORD)v35 != 45 )
          break;
        v39 = _isoc23_strtoumax(v38, &v63, 16);
        v35 = (__int64)v62;
        v19 = v63;
        if ( v63 == v62 )
          break;
        ++v63;
        v35 = *v19;
        if ( (_DWORD)v35 != 32 )
          break;
        if ( v36 > v37 && a1 < v39 )
        {
          v63 = v19 + 2;
          v35 = v19[1];
          if ( (_DWORD)v35 != 114 )
            break;
          v63 = v19 + 3;
          v35 = v19[2];
          if ( (_DWORD)v35 != 45 )
            break;
          v41 = a1 < v37 || v36 > v39;
          if ( !v41
            || (a1 < v37
              ? ((v19 = (unsigned __int8 *)(a2 - v36 + v37), v35 = a2 + v37 - v39, v36 <= v39)
               ? (a2 = a2 - v36 + v37)
               : (a2 = a2 + v37 - v39))
              : (a2 = a1 + a2 - v39),
                !a2) )
          {
            fclose(v33, v25, v26, v27, v28, v29, v30, v31, v32, v35, (__int64)v19, v20, v21, v22, v23, v24);
            free((unsigned __int64)v60, v52, v53, v54, v55, v56, v57, v58, v59);
            return 1LL;
          }
        }
      }
      while ( (*(_DWORD *)v33 & 0x10) == 0 );
    }
    fclose(v33, v25, v26, v27, v28, v29, v30, v31, v32, v35, (__int64)v19, v20, v21, v22, v23, v24);
    free((unsigned __int64)v60, v42, v43, v44, v45, v46, v47, v48, v49);
    if ( a2 )
      return 0xFFFFFFFFLL;
  }
  else
  {
    v51 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
    if ( v51 > 0x18 || ((0x1002004uLL >> v51) & 1) == 0 )
      return 0xFFFFFFFFLL;
  }
  return 1LL;
}
// 417E20: variable 'v21' is possibly undefined
// 417E20: variable 'v22' is possibly undefined
// 417E20: variable 'v23' is possibly undefined
// 417E20: variable 'v24' is possibly undefined
// 417E20: variable 'v25' is possibly undefined
// 417E20: variable 'v26' is possibly undefined
// 417E20: variable 'v27' is possibly undefined
// 417E20: variable 'v28' is possibly undefined
// 417E20: variable 'v29' is possibly undefined
// 417E20: variable 'v30' is possibly undefined
// 417E20: variable 'v31' is possibly undefined
// 417E20: variable 'v32' is possibly undefined
// 417EF0: variable 'v35' is possibly undefined
// 417EF0: variable 'v19' is possibly undefined
// 417EF0: variable 'v20' is possibly undefined
// 417EF8: variable 'v42' is possibly undefined
// 417EF8: variable 'v43' is possibly undefined
// 417EF8: variable 'v44' is possibly undefined
// 417EF8: variable 'v45' is possibly undefined
// 417EF8: variable 'v46' is possibly undefined
// 417EF8: variable 'v47' is possibly undefined
// 417EF8: variable 'v48' is possibly undefined
// 417EF8: variable 'v49' is possibly undefined
// 417F7C: variable 'v52' is possibly undefined
// 417F7C: variable 'v53' is possibly undefined
// 417F7C: variable 'v54' is possibly undefined
// 417F7C: variable 'v55' is possibly undefined
// 417F7C: variable 'v56' is possibly undefined
// 417F7C: variable 'v57' is possibly undefined
// 417F7C: variable 'v58' is possibly undefined
// 417F7C: variable 'v59' is possibly undefined

//----- (0000000000417FA4) ----------------------------------------------------
int *__fastcall dl_debug_update(__int64 a1)
{
  int *result; // x0

  if ( a1 )
  {
    result = (int *)&(&dl_ns)[21 * a1 + 15];
    if ( *((_QWORD *)result + 1) )
      return result;
LABEL_5:
    atomic_store((unsigned __int64)(&dl_ns)[21 * a1], (unsigned __int64 *)result + 1);
    return result;
  }
  result = &r_debug_extended;
  if ( !qword_496B70 )
    goto LABEL_5;
  return result;
}
// 4914A8: using guessed type __int64 *dl_ns;
// 496B68: using guessed type int r_debug_extended;
// 496B70: using guessed type __int64 qword_496B70;

//----- (0000000000418004) ----------------------------------------------------
int *__fastcall dl_debug_initialize(__int64 a1, __int64 a2)
{
  if ( !a2 && !r_debug_extended )
    r_debug_extended = 1;
  if ( !qword_496B78 )
  {
    if ( !a1 )
      a1 = qword_496B88;
    qword_496B88 = a1;
    unk_496B90 = 0LL;
    qword_496B78 = (__int64)dl_debug_state;
  }
  if ( !qword_496B70 )
    atomic_store((unsigned __int64)(&dl_ns)[21 * a2], (unsigned __int64 *)&qword_496B70);
  return &r_debug_extended;
}
// 417FA0: using guessed type __int64 __fastcall dl_debug_state();
// 4914A8: using guessed type __int64 *dl_ns;
// 496B68: using guessed type int r_debug_extended;
// 496B70: using guessed type __int64 qword_496B70;
// 496B78: using guessed type __int64 qword_496B78;
// 496B88: using guessed type __int64 qword_496B88;

//----- (00000000004180A0) ----------------------------------------------------
unsigned __int64 (__fastcall *__fastcall is_dst(_BYTE *a1, unsigned __int64 a2))(__int64 a1)
{
  unsigned __int64 (__fastcall *v3)(__int64); // x2
  unsigned __int64 v4; // x1
  unsigned __int64 (__fastcall *v5)(__int64); // x2
  unsigned int v7; // w0
  unsigned int v8; // w0
  unsigned __int64 v9; // x19
  char *v10; // x2
  unsigned __int64 (__fastcall *v12)(__int64); // [xsp+28h] [xbp+28h]
  unsigned __int64 (__fastcall *v13)(__int64); // [xsp+28h] [xbp+28h]

  v3 = strlen();
  v4 = a2;
  if ( *a1 == 123 )
  {
    v9 = (unsigned __int64)(a1 + 1);
    v13 = v3;
    if ( (unsigned int)strncmp(v9, v4, (unsigned __int64)v3) )
      return 0LL;
    v10 = (char *)v13 + 2;
    if ( *((_BYTE *)v13 + v9) != 125 )
      return 0LL;
    return (unsigned __int64 (__fastcall *)(__int64))v10;
  }
  else
  {
    v12 = v3;
    if ( (unsigned int)strncmp((unsigned __int64)a1, v4, (unsigned __int64)v3) )
      return 0LL;
    v5 = v12;
    v7 = *((unsigned __int8 *)v12 + (_QWORD)a1);
    if ( v7 <= 0x39 )
    {
      if ( v7 >= 0x30 )
        return 0LL;
      return v5;
    }
    else
    {
      v8 = (unsigned __int8)(v7 - 65);
      if ( v8 > 0x39 )
        return v5;
      if ( ((0x3FFFFFF43FFFFFFuLL >> v8) & 1) != 0 )
        return 0LL;
      return v5;
    }
  }
}

//----- (0000000000418188) ----------------------------------------------------
bool __fastcall is_trusted_path_normalize(unsigned __int8 *a1, __int64 a2)
{
  int v2; // w3
  int *v3; // x1
  int v4; // w2
  char *v5; // x0
  _BOOL4 v6; // w0
  int v8; // w5
  int v10; // w5
  int v12; // t1
  int vars0; // [xsp+0h] [xbp+0h] BYREF
  char vars0_4; // [xsp+4h] [xbp+4h]

  if ( !a2 )
    return 0LL;
  v2 = *a1;
  v3 = &vars0;
  if ( !*a1 )
    goto LABEL_13;
  v4 = a1[1];
  if ( v2 == 47 )
    goto LABEL_7;
LABEL_4:
  while ( 1 )
  {
    *(_BYTE *)v3 = v2;
    v3 = (int *)((char *)v3 + 1);
    ++a1;
    if ( !v4 )
      break;
LABEL_5:
    v2 = v4;
LABEL_6:
    v4 = a1[1];
    if ( v2 == 47 )
    {
LABEL_7:
      while ( v4 == 46 )
      {
        v8 = a1[2];
        if ( v8 == 46 )
        {
          v10 = a1[3];
          if ( v10 != 47 && v10 != 0 )
          {
            if ( &vars0 >= v3 )
              goto LABEL_32;
LABEL_24:
            if ( *((_BYTE *)v3 - 1) != 47 )
              goto LABEL_4;
            ++a1;
            v2 = 46;
            goto LABEL_6;
          }
          do
          {
            if ( v3 <= &vars0 )
              break;
            v12 = *((unsigned __int8 *)v3 - 1);
            v3 = (int *)((char *)v3 - 1);
          }
          while ( v12 != 47 );
          if ( !a1[3] )
            goto LABEL_11;
          v4 = a1[4];
          a1 += 3;
        }
        else
        {
          if ( v8 != 47 && v8 != 0 )
          {
            if ( &vars0 >= v3 )
            {
LABEL_32:
              ++a1;
              *(_BYTE *)v3 = 47;
              v3 = (int *)((char *)v3 + 1);
              v2 = 46;
              goto LABEL_6;
            }
            goto LABEL_24;
          }
          if ( !a1[2] )
            goto LABEL_11;
          a1 += 2;
          v4 = a1[1];
        }
      }
      if ( &vars0 >= v3 || *((_BYTE *)v3 - 1) != 47 )
        continue;
      ++a1;
      if ( v4 )
        goto LABEL_5;
      break;
    }
  }
LABEL_11:
  if ( &vars0 == v3 || (v5 = (char *)v3, *((_BYTE *)v3 - 1) != 47) )
  {
LABEL_13:
    *(_BYTE *)v3 = 47;
    v5 = (char *)v3 + 1;
  }
  if ( (unsigned __int64)(v5 - (char *)&vars0) <= 4 )
    return 0LL;
  v6 = vars0 != 1651076143 || vars0_4 != 47;
  return !v6;
}

//----- (0000000000418320) ----------------------------------------------------
__int64 __fastcall open_verify_constprop_0(const char *a1, __int64 a2, _BYTE *a3, char a4)
{
  unsigned int v8; // w0
  unsigned __int64 StatusReg; // x21
  unsigned int v10; // w26
  __int64 v11; // x4
  __int64 v12; // x23
  signed __int64 nocancel; // x0
  __int64 v14; // x0
  int v16; // w0
  unsigned int v17; // w19
  __off64_t v18; // x3
  __int64 v19; // x19
  double v20; // d0
  double v21; // d1
  double v22; // d2
  double v23; // d3
  double v24; // d4
  double v25; // d5
  double v26; // d6
  double v27; // d7
  bool v28; // cc
  bool v29; // zf
  bool v30; // cc
  __int64 v31; // [xsp+0h] [xbp+0h] BYREF
  __int64 (__fastcall *v32[3])(__int64, __int64 *, unsigned __int64); // [xsp+68h] [xbp+68h] BYREF

  v8 = _open_nocancel(a1, 0x80000);
  if ( v8 == -1 )
    return (unsigned int)-1;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v10 = v8;
  v11 = 0LL;
  *(_DWORD *)(StatusReg + 40) = 0;
  *(_QWORD *)a2 = 0LL;
  v12 = a2 + 8;
  do
  {
    nocancel = _read_nocancel(v10, (void *)(v12 + v11), 832 - v11);
    v11 = *(_QWORD *)a2;
    if ( nocancel <= 0 )
      break;
    v11 += nocancel;
    *(_QWORD *)a2 = v11;
  }
  while ( (unsigned __int64)v11 <= 0x3F );
  if ( v11 <= 63 )
  {
    v17 = *(_DWORD *)(StatusReg + 40);
    goto LABEL_25;
  }
  v14 = *(_QWORD *)(a2 + 8);
  if ( v14 != 0x10102464C457FLL && v14 != 0x3010102464C457FLL
    || *(_BYTE *)(a2 + 16) && (*(_BYTE *)(a2 + 15) == 3 ? (v28 = *(unsigned __int8 *)(a2 + 16) > 2u) : (v28 = 1), v28)
    || *(_DWORD *)(a2 + 17)
    || *(_WORD *)(a2 + 21)
    || *(_BYTE *)(a2 + 23) )
  {
    if ( *(_DWORD *)(a2 + 8) != 1179403647 )
    {
      v17 = 0;
      goto LABEL_25;
    }
    if ( *(_BYTE *)(a2 + 12) == 2 )
    {
      if ( *(_BYTE *)(a2 + 13) == 1 )
      {
        if ( *(_BYTE *)(a2 + 14) == 1 )
        {
          if ( *(_BYTE *)(a2 + 15) )
            v29 = *(_BYTE *)(a2 + 15) == 3;
          else
            v29 = 1;
          if ( v29 )
          {
            if ( *(_BYTE *)(a2 + 16)
              && (*(_BYTE *)(a2 + 15) == 3 ? (v30 = *(unsigned __int8 *)(a2 + 16) > 2u) : (v30 = 1), v30) )
            {
              v17 = 0;
            }
            else
            {
              v17 = memcmp((int8x16_t *)(a2 + 17), (int8x16_t *)&unk_45B959, 7uLL);
              if ( v17 )
                v17 = 0;
            }
          }
          else
          {
            v17 = 0;
          }
        }
        else
        {
          v17 = 0;
        }
      }
      else
      {
        v17 = 0;
      }
LABEL_25:
      dl_exception_create(v32, (__int64)a1);
      if ( (a4 & 1) != 0 )
        free((unsigned __int64)a1, v20, v21, v22, v23, v24, v25, v26, v27);
      _close_nocancel(v10);
      dl_signal_exception(v17, (const char **)v32, 0LL);
    }
    *a3 = 1;
    goto LABEL_13;
  }
  v16 = *(_DWORD *)(a2 + 28);
  v17 = 0;
  if ( v16 != 1 )
    goto LABEL_25;
  if ( *(_WORD *)(v12 + 18) != 183 )
  {
LABEL_13:
    _close_nocancel(v10);
    *(_DWORD *)(StatusReg + 40) = 2;
    return (unsigned int)-1;
  }
  if ( (unsigned __int16)(*(_WORD *)(v12 + 16) - 2) > 1u || *(_WORD *)(v12 + 54) != 56 )
    goto LABEL_25;
  v18 = *(_QWORD *)(v12 + 32);
  v19 = 56LL * *(unsigned __int16 *)(v12 + 56);
  if ( v19 + v18 > (unsigned __int64)v11
    && _pread64_nocancel(v10, &v31, 56LL * *(unsigned __int16 *)(v12 + 56), v18) != v19 )
  {
    v17 = *(_DWORD *)(StatusReg + 40);
    goto LABEL_25;
  }
  return v10;
}
// 418520: variable 'v20' is possibly undefined
// 418520: variable 'v21' is possibly undefined
// 418520: variable 'v22' is possibly undefined
// 418520: variable 'v23' is possibly undefined
// 418520: variable 'v24' is possibly undefined
// 418520: variable 'v25' is possibly undefined
// 418520: variable 'v26' is possibly undefined
// 418520: variable 'v27' is possibly undefined

//----- (000000000041864C) ----------------------------------------------------
_BYTE *__fastcall add_path_constprop_0_isra_0(_BYTE *result, __int64 *a2)
{
  _BYTE *v2; // x19
  __int64 *v3; // x21
  __int64 v4; // x3
  unsigned __int64 v5; // x2
  __int64 v6; // x1
  unsigned int v7; // w22
  __int64 v8; // x22
  _BYTE *v9; // x0

  if ( a2 != (__int64 *)-1LL )
  {
    v2 = result;
    v3 = a2;
    v4 = *a2;
    do
    {
      while ( 1 )
      {
        ++v3;
        v6 = *((_QWORD *)v2 + 1);
        v5 = *(_QWORD *)(v4 + 32);
        if ( (*v2 & 1) != 0 )
          break;
        v7 = *((_DWORD *)v2 + 1);
        *((_DWORD *)v2 + 1) = v7 + 1;
        v8 = v6 + 16LL * v7;
        v9 = (_BYTE *)*((_QWORD *)v2 + 2);
        *(_QWORD *)(v8 + 16) = v9;
        if ( v5 > 1 )
        {
          result = (char *)j_memcpy() + v5 - 1;
        }
        else
        {
          *((_QWORD *)v2 + 2) = v9 + 1;
          *v9 = (v5 != 0) + 46;
          result = (_BYTE *)*((_QWORD *)v2 + 2);
        }
        *((_QWORD *)v2 + 2) = result + 1;
        *result = 0;
        *(_DWORD *)(v8 + 24) = 0;
        v4 = *v3;
        if ( !*v3 )
          return result;
      }
      v4 = *v3;
      ++*(_DWORD *)(v6 + 8);
      if ( v5 < 2 )
        v5 = 2LL;
      result = (_BYTE *)(*(_QWORD *)v6 + v5);
      *(_QWORD *)v6 = result;
    }
    while ( v4 );
  }
  return result;
}

//----- (0000000000418740) ----------------------------------------------------
__int64 __fastcall open_path_isra_0(
        __int64 *a1,
        __int64 a2,
        int a3,
        __int64 *a4,
        unsigned __int64 *a5,
        __int64 a6,
        __int64 a7,
        _BYTE *a8)
{
  const char **v8; // x8
  __int64 *v12; // x20
  const char *v14; // x19
  const char *v15; // x22
  int v16; // w3
  double v17; // d0
  double v18; // d1
  double v19; // d2
  double v20; // d3
  double v21; // d4
  double v22; // d5
  double v23; // d6
  double v24; // d7
  char *v25; // x21
  __int64 v26; // x1
  __int64 v27; // x2
  void *v28; // x3
  void *v29; // x4
  void *v30; // x5
  void *v31; // x6
  __int64 v32; // x7
  unsigned int v33; // w26
  int v34; // w0
  _BOOL4 v35; // w27
  unsigned __int64 v36; // x0
  const char *v37; // x0
  __int64 *v38; // x3
  int v40; // w0
  const char *v41; // x1
  const char *v42; // x2
  const char *v43; // x1
  const char *v44; // x2
  const char *v45; // x5
  const char *v46; // x20
  int v47; // w23
  const char *v48; // x22
  const char **v49; // x19
  __int64 (__fastcall *v50)(__int64, __int64 *, unsigned __int64); // x0
  const char *v51; // t1
  const char *v52; // x1
  bool v53; // zf
  unsigned __int64 v54; // x0
  __int64 v55; // [xsp+0h] [xbp+0h] BYREF
  __int64 v56; // [xsp+68h] [xbp+68h]
  __int64 *v57; // [xsp+70h] [xbp+70h]
  const char *v58; // [xsp+78h] [xbp+78h]
  const char *v59; // [xsp+80h] [xbp+80h]
  const char *v60; // [xsp+88h] [xbp+88h]
  __int64 *v61; // [xsp+90h] [xbp+90h]
  const char *v62; // [xsp+98h] [xbp+98h]
  int *v63; // [xsp+A0h] [xbp+A0h]
  _DWORD *v64; // [xsp+A8h] [xbp+A8h]
  __int64 **v65; // [xsp+B0h] [xbp+B0h]
  __int64 v66; // [xsp+B8h] [xbp+B8h]
  int v67; // [xsp+C0h] [xbp+C0h]
  int v68; // [xsp+C4h] [xbp+C4h]
  const char **v69; // [xsp+C8h] [xbp+C8h]
  __int64 v70; // [xsp+D0h] [xbp+D0h]
  __int64 *v71; // [xsp+D8h] [xbp+D8h]
  _BYTE v72[16]; // [xsp+E0h] [xbp+E0h] BYREF
  int v73; // [xsp+F0h] [xbp+F0h]

  v8 = (const char **)*a4;
  if ( !*a4 )
    return (unsigned int)-1;
  v12 = &dl_debug_mask;
  v64 = (_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  v14 = (const char *)&v55;
  v63 = &_libc_enable_secure;
  v61 = a4;
  v62 = 0LL;
  v65 = &dl_ns;
  v66 = a7;
  v68 = 0;
  v69 = v8;
  LODWORD(v70) = a3;
  v71 = a1;
  while ( 1 )
  {
    v15 = *v69;
    v16 = *(_DWORD *)v12 & 1;
    if ( v16 )
    {
      v41 = (const char *)*((_QWORD *)v15 + 1);
      if ( v41 != v62 )
      {
        v62 = (const char *)&v55;
        v42 = (const char *)*((_QWORD *)v15 + 2);
        v59 = v41;
        v60 = v42;
        v67 = v16;
        dl_debug_printf(" search path=");
        v43 = v59;
        v44 = v60;
        v45 = *v69;
        if ( *v69 )
        {
          v56 = a6;
          v57 = v12;
          v46 = v45;
          v47 = v67;
          v58 = v60;
          v59 = v15;
          v48 = v43;
          v60 = v14;
          v49 = v69;
          do
          {
            if ( v48 != *((const char **)v46 + 1) )
              break;
            v50 = j_memcpy();
            if ( *((_DWORD *)*v49 + 10) != 1 )
            {
              v53 = v47 == 0;
              v47 = 0;
              *((_BYTE *)v50 + *((_QWORD *)v46 + 4)) = 0;
              if ( v53 )
                dl_debug_printf_c(":%s", &v55);
              else
                dl_debug_printf_c("%s", &v55);
            }
            v51 = v49[1];
            ++v49;
            v46 = v51;
          }
          while ( v51 );
          v43 = v48;
          a6 = v56;
          v12 = v57;
          v44 = v58;
          v15 = v59;
          v14 = v60;
        }
        if ( v44 )
        {
          if ( !*v44 )
          {
            v44 = (const char *)program_invocation_short_name[0];
            if ( !program_invocation_short_name[0] )
              v44 = "<main program>";
          }
          v60 = v43;
          dl_debug_printf_c("\t\t(%s from file %s)\n", v43, v44);
          v52 = v60;
        }
        else
        {
          v60 = v43;
          dl_debug_printf_c("\t\t(%s)\n", v43);
          v52 = v60;
        }
        v62 = v52;
      }
    }
    j_memcpy();
    if ( *((_DWORD *)v15 + 10) == 1 )
    {
      v35 = 0;
      goto LABEL_14;
    }
    v25 = (char *)((char *)((char *)j_memcpy() + a2) - (char *)v14);
    if ( (*(_DWORD *)v12 & 1) != 0 )
      dl_debug_printf("  trying file=%s\n", v14);
    v33 = open_verify_constprop_0(v14, a6, a8, 0);
    v34 = *((_DWORD *)v15 + 10);
    if ( v34 )
    {
      v35 = v34 != 1;
      if ( v33 == -1 )
        goto LABEL_19;
    }
    else
    {
      if ( v33 == -1 )
      {
        if ( v66 && (*((_BYTE *)v65[21 * *(_QWORD *)(v66 + 48)] + 870) & 1) != 0 )
        {
          v35 = 1;
LABEL_20:
          if ( *v64 > 0x14u || ((0x102004uLL >> *v64) & 1) == 0 )
            return (unsigned int)-1;
          goto LABEL_14;
        }
        v25[(_QWORD)v14 - a2] = 0;
        if ( (unsigned int)stat64(v14, (struct stat *)v72) )
        {
          v35 = 0;
          *((_DWORD *)v15 + 10) = 1;
        }
        else
        {
          v35 = (v73 & 0xF000) == 0x4000;
          if ( (v73 & 0xF000) == 0x4000 )
            v40 = 2;
          else
            v40 = 1;
          *((_DWORD *)v15 + 10) = v40;
        }
        goto LABEL_19;
      }
      v35 = 1;
      *((_DWORD *)v15 + 10) = 2;
    }
    if ( (v70 & 0x4000000) == 0 || !*v63 || !(unsigned int)fstat64(v33, (struct stat *)v72) && (v73 & 0x800) != 0 )
      break;
    _close_nocancel(v33);
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 2;
LABEL_19:
    if ( v35 )
      goto LABEL_20;
LABEL_14:
    v68 |= v35;
    v37 = v69[1];
    ++v69;
    if ( !v37 )
    {
      v38 = v61;
      if ( v68 != 1 )
      {
        if ( *((_DWORD *)v61 + 2) )
        {
          v54 = *v61;
          v71 = v61;
          free(v54, v17, v18, v19, v20, v21, v22, v23, v24);
          v38 = v71;
        }
        v53 = v38 == (__int64 *)&_rtld_env_path_list || v38 == &_rtld_search_dirs;
        if ( !v53 )
          *v38 = -1LL;
      }
      return (unsigned int)-1;
    }
  }
  v36 = malloc((__int64)v25, v26, v27, v28, v29, v30, v31, v32, v17, v18, v19, v20, v21, v22, v23, v24);
  *a5 = v36;
  if ( v36 )
  {
    j_memcpy();
    return v33;
  }
  _close_nocancel(v33);
  return (unsigned int)-1;
}
// 418874: conditional instruction was optimized away because w26.4!=FFFFFFFF
// 41887C: variable 'v26' is possibly undefined
// 41887C: variable 'v27' is possibly undefined
// 41887C: variable 'v28' is possibly undefined
// 41887C: variable 'v29' is possibly undefined
// 41887C: variable 'v30' is possibly undefined
// 41887C: variable 'v31' is possibly undefined
// 41887C: variable 'v32' is possibly undefined
// 41887C: variable 'v17' is possibly undefined
// 41887C: variable 'v18' is possibly undefined
// 41887C: variable 'v19' is possibly undefined
// 41887C: variable 'v20' is possibly undefined
// 41887C: variable 'v21' is possibly undefined
// 41887C: variable 'v22' is possibly undefined
// 41887C: variable 'v23' is possibly undefined
// 41887C: variable 'v24' is possibly undefined
// 48E660: using guessed type _UNKNOWN *_rtld_env_path_list;
// 48E670: using guessed type __int64 _rtld_search_dirs;
// 4914A8: using guessed type __int64 *dl_ns;
// 491570: using guessed type int _libc_enable_secure;
// 491928: using guessed type __int64 *program_invocation_short_name[2];
// 496C20: using guessed type __int64 dl_debug_mask;

//----- (0000000000418B8C) ----------------------------------------------------
unsigned __int64 __fastcall add_name_to_object_isra_0(unsigned __int64 *a1, unsigned __int64 *a2)
{
  unsigned __int64 *v2; // x19
  unsigned __int64 result; // x0
  unsigned __int64 (__fastcall *v5)(__int64); // x0
  __int64 v6; // x1
  void *v7; // x3
  void *v8; // x4
  void *v9; // x5
  void *v10; // x6
  __int64 v11; // x7
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  unsigned __int64 v20; // x3
  unsigned __int64 v21; // [xsp+28h] [xbp+28h]

  v2 = a1;
  if ( !a1 )
    _libc_assert_fail((__int64)"lastp != NULL", (__int64)"dl-load.c", 0x1ACu, (__int64)"add_name_to_object");
  while ( 1 )
  {
    result = strcmp(a2, *v2);
    if ( !(_DWORD)result )
      break;
    if ( !v2[1] )
    {
      v5 = strlen();
      v20 = malloc((__int64)v5 + 25, v6, (__int64)v5 + 1, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);
      if ( !v20 )
        dl_signal_error(0xCu, (__int64)a2, 0LL, "cannot allocate name record");
      v21 = v20;
      result = (unsigned __int64)j_memcpy();
      *(_QWORD *)v21 = result;
      *(_QWORD *)(v21 + 8) = 0LL;
      *(_DWORD *)(v21 + 16) = 0;
      v2[1] = v21;
      return result;
    }
    v2 = (unsigned __int64 *)v2[1];
  }
  return result;
}
// 418BE4: variable 'v6' is possibly undefined
// 418BE4: variable 'v7' is possibly undefined
// 418BE4: variable 'v8' is possibly undefined
// 418BE4: variable 'v9' is possibly undefined
// 418BE4: variable 'v10' is possibly undefined
// 418BE4: variable 'v11' is possibly undefined
// 418BE4: variable 'v12' is possibly undefined
// 418BE4: variable 'v13' is possibly undefined
// 418BE4: variable 'v14' is possibly undefined
// 418BE4: variable 'v15' is possibly undefined
// 418BE4: variable 'v16' is possibly undefined
// 418BE4: variable 'v17' is possibly undefined
// 418BE4: variable 'v18' is possibly undefined
// 418BE4: variable 'v19' is possibly undefined
// 418C60: using guessed type __int64 dl_dst_count(void);

//----- (0000000000418C60) ----------------------------------------------------
__int64 __fastcall dl_dst_count(__int64 a1)
{
  __int64 v1; // x0
  __int64 v3; // x20
  _BYTE *v4; // x19
  unsigned __int64 (__fastcall *v5)(__int64); // x0

  v1 = strchr(a1, 0x24u);
  if ( !v1 )
    return 0LL;
  v3 = 0LL;
  do
  {
    v4 = (_BYTE *)(v1 + 1);
    v5 = is_dst((_BYTE *)(v1 + 1), (unsigned __int64)"ORIGIN");
    if ( v5
      || (v5 = is_dst(v4, (unsigned __int64)"PLATFORM")) != 0LL
      || (v5 = is_dst(v4, (unsigned __int64)"LIB")) != 0LL )
    {
      ++v3;
      v4 = (char *)v5 + (_QWORD)v4;
    }
    v1 = strchr((__int64)v4, 0x24u);
  }
  while ( v1 );
  return v3;
}

//----- (0000000000418D20) ----------------------------------------------------
unsigned __int8 *__fastcall dl_dst_substitute(__int64 a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  char *v3; // x19
  _BOOL4 v6; // w24
  int v8; // w20
  unsigned __int8 *v9; // x26
  unsigned __int64 (__fastcall *v10)(__int64); // x2
  const char *v11; // x1
  int v13; // w0
  bool v14; // zf
  unsigned __int64 (__fastcall *v15)(__int64); // [xsp+58h] [xbp+58h]

  v3 = (char *)a3;
  v6 = 0;
  v8 = *a2;
  v9 = a2;
  do
  {
    ++v9;
    if ( v8 != 36 )
    {
LABEL_2:
      *v3++ = v8;
      goto LABEL_3;
    }
    v10 = is_dst(v9, (unsigned __int64)"ORIGIN");
    if ( v10 )
    {
      if ( _libc_enable_secure )
      {
        if ( v9 != a2 + 1
          || ((v13 = *((unsigned __int8 *)v10 + (_QWORD)v9), v13 != 47) ? (v14 = v13 == 0) : (v14 = 1), !v14) )
        {
LABEL_9:
          *a3 = 0;
          return a3;
        }
        v11 = *(const char **)(a1 + 912);
        v6 = (*(_WORD *)(a1 + 868) & 3LL) == 0;
      }
      else
      {
        v11 = *(const char **)(a1 + 912);
        v6 = 0;
      }
      goto LABEL_8;
    }
    v10 = is_dst(v9, (unsigned __int64)"PLATFORM");
    if ( v10 )
    {
      v11 = (const char *)dl_platform;
LABEL_8:
      if ( (unsigned __int64)(v11 - 1) > 0xFFFFFFFFFFFFFFFDLL )
        goto LABEL_9;
      goto LABEL_16;
    }
    v10 = is_dst(v9, (unsigned __int64)"LIB");
    if ( !v10 )
      goto LABEL_2;
    v11 = "lib";
    if ( "b" != 0LL && (unsigned __int64)&algn_4561D4[3] >= 0xFFFFFFFFFFFFFFFDLL )
      goto LABEL_9;
LABEL_16:
    v15 = v10;
    v3 = stpcpy(v3, (unsigned __int64)v11);
    v9 = (unsigned __int8 *)v15 + (_QWORD)v9;
LABEL_3:
    v8 = *v9;
  }
  while ( *v9 );
  if ( !v6 || is_trusted_path_normalize(a3, v3 - (char *)a3) )
    *v3 = 0;
  else
    *a3 = 0;
  return a3;
}
// 4561D4: using guessed type _BYTE[4];
// 491570: using guessed type int _libc_enable_secure;
// 496BD8: using guessed type __int64 dl_platform;

//----- (0000000000418EA0) ----------------------------------------------------
unsigned __int8 *__fastcall expand_dynamic_string_token(__int64 a1, unsigned __int8 *a2)
{
  __int64 v4; // x0
  unsigned __int8 *result; // x0
  __int64 v6; // x2
  unsigned __int64 (__fastcall *v7)(__int64); // x3
  void *v8; // x4
  void *v9; // x5
  void *v10; // x6
  __int64 v11; // x7
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  __int64 v20; // x0
  __int64 v21; // x1
  unsigned __int64 (__fastcall *v22)(__int64); // x0
  unsigned __int64 v23; // x2
  unsigned __int64 (__fastcall *v24)(__int64); // x0
  unsigned __int64 origin; // x0
  __int64 v26; // [xsp+20h] [xbp+20h]
  unsigned __int64 (__fastcall *v27)(__int64); // [xsp+28h] [xbp+28h]
  unsigned __int64 (__fastcall *v28)(__int64); // [xsp+28h] [xbp+28h]

  v4 = dl_dst_count((__int64)a2);
  if ( !v4 )
    return (unsigned __int8 *)strdup();
  v26 = v4;
  v7 = strlen();
  v20 = *(_QWORD *)(a1 + 912);
  v21 = v26;
  if ( !v20 )
  {
    if ( **(_BYTE **)(a1 + 8) )
      _libc_assert_fail(
        (__int64)"(l)->l_name[0] == '\\0' || is_rtld_link_map (l)",
        (__int64)"dl-load.c",
        0x188u,
        (__int64)"expand_dynamic_string_token");
    v28 = v7;
    origin = dl_get_origin(
               v12,
               v13,
               v14,
               v15,
               v16,
               v17,
               v18,
               v19,
               **(unsigned __int8 **)(a1 + 8),
               v26,
               v6,
               (__int64)v7,
               v8,
               (__int64)v9,
               v10,
               v11);
    v21 = v26;
    v7 = v28;
    *(_QWORD *)(a1 + 912) = origin;
    if ( origin - 1 <= 0xFFFFFFFFFFFFFFFDLL )
    {
      v22 = strlen();
      v21 = v26;
      v7 = v28;
      goto LABEL_6;
    }
    goto LABEL_12;
  }
  if ( v20 == -1 )
  {
LABEL_12:
    v22 = 0LL;
    goto LABEL_6;
  }
  v27 = v7;
  v22 = strlen();
  v21 = v26;
  v7 = v27;
LABEL_6:
  v23 = dl_platformlen;
  if ( dl_platformlen < (unsigned __int64)v22 )
    v23 = (unsigned __int64)v22;
  v24 = (unsigned __int64 (__fastcall *)(__int64))((char *)v7 + (v23 - 4) * v21);
  if ( v23 < 5 )
    v24 = v7;
  result = (unsigned __int8 *)malloc(
                                (__int64)v24 + 1,
                                v21,
                                v23,
                                v7,
                                v8,
                                v9,
                                v10,
                                v11,
                                v12,
                                v13,
                                v14,
                                v15,
                                v16,
                                v17,
                                v18,
                                v19);
  if ( result )
    return dl_dst_substitute(a1, a2, result);
  return result;
}
// 418F2C: variable 'v8' is possibly undefined
// 418F2C: variable 'v9' is possibly undefined
// 418F2C: variable 'v10' is possibly undefined
// 418F2C: variable 'v11' is possibly undefined
// 418F2C: variable 'v12' is possibly undefined
// 418F2C: variable 'v13' is possibly undefined
// 418F2C: variable 'v14' is possibly undefined
// 418F2C: variable 'v15' is possibly undefined
// 418F2C: variable 'v16' is possibly undefined
// 418F2C: variable 'v17' is possibly undefined
// 418F2C: variable 'v18' is possibly undefined
// 418F2C: variable 'v19' is possibly undefined
// 418F64: variable 'v6' is possibly undefined
// 418FC0: using guessed type __int64 fillin_rpath_isra_0(void);
// 496C58: using guessed type __int64 dl_platformlen;

//----- (0000000000418FC0) ----------------------------------------------------
__int64 __fastcall fillin_rpath_isra_0(__int64 a1, __int64 a2, unsigned __int8 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v8; // x19
  __int64 result; // x0
  __int64 v10; // x2
  void *v11; // x3
  void *v12; // x4
  void *v13; // x5
  void *v14; // x6
  __int64 v15; // x7
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  int8x16_t *i; // x28
  unsigned __int64 (__fastcall *v25)(__int64); // x27
  unsigned __int64 v26; // x22
  __int64 v27; // x21
  __int64 v28; // x25
  __int64 v29; // x0
  unsigned __int64 v30; // x0
  __int64 (__fastcall *v31)(__int64, __int64 *, unsigned __int64); // x0
  char *v32; // [xsp+60h] [xbp+60h]
  __int64 v36; // [xsp+88h] [xbp+88h] BYREF

  v8 = 0LL;
  v36 = a1;
LABEL_2:
  result = strsep(&v36, a3);
  for ( i = (int8x16_t *)result; result; i = (int8x16_t *)result )
  {
    if ( i->n128_u8[0] )
    {
      i = (int8x16_t *)expand_dynamic_string_token(a6, (unsigned __int8 *)i);
      if ( !i )
        goto LABEL_2;
      v25 = strlen();
      if ( !v25 )
      {
        free((unsigned __int64)i, v16, v17, v18, v19, v20, v21, v22, v23);
        goto LABEL_2;
      }
      while ( v25 != (unsigned __int64 (__fastcall *)(__int64))1 )
      {
        if ( *((_BYTE *)v25 + (_QWORD)i - 1) != 47 )
          goto LABEL_33;
        v25 = (unsigned __int64 (__fastcall *)(__int64))((char *)v25 - 1);
      }
      v26 = (unsigned __int64)i;
      if ( i->n128_u8[0] == 47 )
        goto LABEL_11;
LABEL_33:
      v26 = (unsigned __int64)i;
      *((_BYTE *)v25 + (_QWORD)i) = 47;
      v25 = (unsigned __int64 (__fastcall *)(__int64))((char *)v25 + 1);
LABEL_11:
      v27 = dl_all_dirs;
      if ( dl_all_dirs )
      {
LABEL_12:
        v28 = v27;
        while ( *(unsigned __int64 (__fastcall **)(__int64))(v28 + 32) != v25
             || (unsigned int)memcmp(i, *(int8x16_t **)(v28 + 24), (unsigned __int64)v25) )
        {
          v28 = *(_QWORD *)v28;
          if ( !v28 )
            goto LABEL_24;
        }
        v29 = 0LL;
        if ( v8 )
        {
          while ( *(_QWORD *)(a2 + 8 * v29) != v28 )
          {
            if ( ++v29 == v8 )
              goto LABEL_32;
          }
          if ( v8 != v29 )
            goto LABEL_21;
        }
        goto LABEL_32;
      }
    }
    else
    {
      v27 = dl_all_dirs;
      v25 = 0LL;
      v26 = 0LL;
      if ( dl_all_dirs )
        goto LABEL_12;
    }
LABEL_24:
    v32 = 0LL;
    if ( a5 )
      v32 = (char *)strlen() + 1;
    v30 = malloc(
            (__int64)&v32[(_QWORD)v25 + 45],
            (__int64)v32,
            v10,
            v11,
            v12,
            v13,
            v14,
            v15,
            v16,
            v17,
            v18,
            v19,
            v20,
            v21,
            v22,
            v23);
    v28 = v30;
    if ( !v30 )
      dl_signal_error(0xCu, 0LL, 0LL, "cannot create cache for search path");
    *(_QWORD *)(v30 + 24) = v30 + 44;
    *((_BYTE *)v25 + (_QWORD)j_memcpy()) = 0;
    *(_QWORD *)(v28 + 32) = v25;
    if ( (unsigned __int64)v25 > max_dirnamelen )
      max_dirnamelen = (__int64)v25;
    *(_DWORD *)(v28 + 40) = 2 * (i->n128_u8[0] != 47);
    *(_QWORD *)(v28 + 8) = a4;
    if ( a5 )
      v31 = j_memcpy();
    else
      v31 = 0LL;
    *(_QWORD *)v28 = v27;
    dl_all_dirs = v28;
    *(_QWORD *)(v28 + 16) = v31;
LABEL_32:
    *(_QWORD *)(a2 + 8 * v8++) = v28;
LABEL_21:
    free(v26, v16, v17, v18, v19, v20, v21, v22, v23);
    result = strsep(&v36, a3);
  }
  *(_QWORD *)(a2 + 8 * v8) = 0LL;
  return result;
}
// 4191EC: variable 'v16' is possibly undefined
// 4191EC: variable 'v17' is possibly undefined
// 4191EC: variable 'v18' is possibly undefined
// 4191EC: variable 'v19' is possibly undefined
// 4191EC: variable 'v20' is possibly undefined
// 4191EC: variable 'v21' is possibly undefined
// 4191EC: variable 'v22' is possibly undefined
// 4191EC: variable 'v23' is possibly undefined
// 419148: variable 'v10' is possibly undefined
// 419148: variable 'v11' is possibly undefined
// 419148: variable 'v12' is possibly undefined
// 419148: variable 'v13' is possibly undefined
// 419148: variable 'v14' is possibly undefined
// 419148: variable 'v15' is possibly undefined
// 496B98: using guessed type __int64 max_dirnamelen;
// 496C40: using guessed type __int64 dl_all_dirs;

//----- (0000000000419220) ----------------------------------------------------
__int64 __fastcall decompose_rpath(__int64 a1, _BYTE *a2, __int64 a3, __int64 a4)
{
  unsigned __int8 *v5; // x20
  _BYTE *v6; // x6
  __int64 result; // x0
  __int64 (__fastcall *v10)(__int64, __int64 *, unsigned __int64); // x0
  __int64 v11; // x2
  void *v12; // x3
  void *v13; // x4
  void *v14; // x5
  void *v15; // x6
  __int64 v16; // x7
  double v17; // d0
  double v18; // d1
  double v19; // d2
  double v20; // d3
  double v21; // d4
  double v22; // d5
  double v23; // d6
  double v24; // d7
  unsigned __int64 v25; // x21
  __int64 v26; // x1
  __int64 v27; // x6
  unsigned int v28; // t1
  __int64 v29; // x0
  unsigned __int64 v30; // x1
  double v31; // d0
  double v32; // d1
  double v33; // d2
  double v34; // d3
  double v35; // d4
  double v36; // d5
  double v37; // d6
  double v38; // d7
  double v39; // d0
  double v40; // d1
  double v41; // d2
  double v42; // d3
  double v43; // d4
  double v44; // d5
  double v45; // d6
  double v46; // d7
  double v47; // d0
  double v48; // d1
  double v49; // d2
  double v50; // d3
  double v51; // d4
  double v52; // d5
  double v53; // d6
  double v54; // d7
  int v55; // w8
  __int64 v56; // x9
  int v57; // w7
  int v58; // t1
  int v59; // t1
  int v60; // w7
  bool v61; // zf
  const char *v62; // x3
  _QWORD *v63; // [xsp+48h] [xbp+48h]

  v5 = *(unsigned __int8 **)(a3 + 8);
  v6 = (_BYTE *)dl_inhibit_rpath;
  if ( dl_inhibit_rpath && !_libc_enable_secure )
  {
    v55 = *(unsigned __int8 *)dl_inhibit_rpath;
    do
    {
      v56 = *(_QWORD *)(a3 + 8);
      v57 = v55;
      if ( v55 == *v5 )
      {
        while ( v57 )
        {
          v58 = (unsigned __int8)*++v6;
          v55 = v58;
          v59 = *(unsigned __int8 *)++v56;
          v57 = v59;
          if ( v55 != v59 )
            goto LABEL_19;
        }
      }
      else
      {
        v57 = *v5;
LABEL_19:
        if ( v57 )
          goto LABEL_20;
      }
      v61 = v55 == 58 || v55 == 0;
      if ( v61 )
        goto LABEL_3;
      do
      {
LABEL_20:
        v60 = (unsigned __int8)*v6;
        if ( !*v6 )
          goto LABEL_2;
        ++v6;
      }
      while ( v60 != 58 );
      v55 = (unsigned __int8)*v6;
    }
    while ( *v6 );
  }
LABEL_2:
  if ( !*a2 )
  {
LABEL_3:
    *(_QWORD *)a1 = -1LL;
    return 0LL;
  }
  v10 = strdup();
  v25 = (unsigned __int64)v10;
  if ( !v10 )
  {
    v62 = "cannot create RUNPATH/RPATH copy";
LABEL_34:
    dl_signal_error(0xCu, 0LL, 0LL, v62);
  }
  v26 = *(unsigned __int8 *)v10;
  if ( *(_BYTE *)v10 )
  {
    v27 = 0LL;
    do
    {
      v61 = (_DWORD)v26 == 58;
      v28 = *((unsigned __int8 *)v10 + 1);
      v10 = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))((char *)v10 + 1);
      v26 = v28;
      if ( v61 )
        ++v27;
    }
    while ( (_DWORD)v26 );
    v15 = (void *)(v27 + 2);
    v29 = 8LL * (_QWORD)v15;
  }
  else
  {
    v29 = 16LL;
  }
  v30 = malloc(v29, v26, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24);
  if ( !v30 )
  {
    free(v25, v31, v32, v33, v34, v35, v36, v37, v38);
    v62 = "cannot create cache for search path";
    goto LABEL_34;
  }
  v63 = (_QWORD *)v30;
  fillin_rpath_isra_0(v25, v30, ":", a4, (__int64)v5, a3);
  free(v25, v39, v40, v41, v42, v43, v44, v45, v46);
  if ( !*v63 )
  {
    free((unsigned __int64)v63, v47, v48, v49, v50, v51, v52, v53, v54);
    goto LABEL_3;
  }
  result = 1LL;
  *(_QWORD *)a1 = v63;
  *(_DWORD *)(a1 + 8) = 1;
  return result;
}
// 4192A8: variable 'v11' is possibly undefined
// 4192A8: variable 'v12' is possibly undefined
// 4192A8: variable 'v13' is possibly undefined
// 4192A8: variable 'v14' is possibly undefined
// 4192A8: variable 'v15' is possibly undefined
// 4192A8: variable 'v16' is possibly undefined
// 4192A8: variable 'v17' is possibly undefined
// 4192A8: variable 'v18' is possibly undefined
// 4192A8: variable 'v19' is possibly undefined
// 4192A8: variable 'v20' is possibly undefined
// 4192A8: variable 'v21' is possibly undefined
// 4192A8: variable 'v22' is possibly undefined
// 4192A8: variable 'v23' is possibly undefined
// 4192A8: variable 'v24' is possibly undefined
// 4192D8: variable 'v39' is possibly undefined
// 4192D8: variable 'v40' is possibly undefined
// 4192D8: variable 'v41' is possibly undefined
// 4192D8: variable 'v42' is possibly undefined
// 4192D8: variable 'v43' is possibly undefined
// 4192D8: variable 'v44' is possibly undefined
// 4192D8: variable 'v45' is possibly undefined
// 4192D8: variable 'v46' is possibly undefined
// 41938C: variable 'v47' is possibly undefined
// 41938C: variable 'v48' is possibly undefined
// 41938C: variable 'v49' is possibly undefined
// 41938C: variable 'v50' is possibly undefined
// 41938C: variable 'v51' is possibly undefined
// 41938C: variable 'v52' is possibly undefined
// 41938C: variable 'v53' is possibly undefined
// 41938C: variable 'v54' is possibly undefined
// 4193A0: variable 'v31' is possibly undefined
// 4193A0: variable 'v32' is possibly undefined
// 4193A0: variable 'v33' is possibly undefined
// 4193A0: variable 'v34' is possibly undefined
// 4193A0: variable 'v35' is possibly undefined
// 4193A0: variable 'v36' is possibly undefined
// 4193A0: variable 'v37' is possibly undefined
// 4193A0: variable 'v38' is possibly undefined
// 491570: using guessed type int _libc_enable_secure;
// 496D00: using guessed type __int64 dl_inhibit_rpath;

//----- (00000000004193C8) ----------------------------------------------------
__int64 __fastcall cache_rpath(__int64 a1, __int64 *a2, int a3, __int64 a4)
{
  __int64 v5; // x1
  __int64 v7; // x2
  __int64 v8; // x5

  v5 = *a2;
  if ( v5 == -1 )
    return 0LL;
  if ( v5 )
    return 1LL;
  v7 = *(_QWORD *)(a1 + 8LL * a3 + 64);
  if ( !v7 )
  {
    *a2 = -1LL;
    return 0LL;
  }
  v8 = 0LL;
  if ( (*(_BYTE *)(a1 + 870) & 0x20) != 0 )
    v8 = *(_QWORD *)a1;
  return decompose_rpath(
           (__int64)a2,
           (_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 8LL) + *(_QWORD *)(v7 + 8) + v8),
           a1,
           a4);
}

//----- (0000000000419440) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall dl_init_paths(
        _BYTE *a1,
        __int64 a2,
        __int64 a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  unsigned __int64 v18; // x0
  __int64 v19; // x1
  __int64 v20; // x2
  void *v21; // x3
  void *v22; // x4
  void *v23; // x5
  void *v24; // x6
  __int64 v25; // x7
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7
  _QWORD *v34; // x19
  unsigned __int64 v35; // x0
  __int64 *v36; // x19
  __int64 v37; // x2
  __int64 v38; // x4
  __int64 result; // x0
  __int64 v40; // x1
  __int64 v41; // x2
  void *v42; // x3
  void *v43; // x4
  void *v44; // x5
  void *v45; // x6
  __int64 v46; // x7
  __int64 (__fastcall *v47)(__int64, __int64 *, unsigned __int64); // x21
  double v48; // d0
  double v49; // d1
  double v50; // d2
  double v51; // d3
  double v52; // d4
  double v53; // d5
  double v54; // d6
  double v55; // d7
  int v56; // w0
  bool v57; // cf
  int v58; // t1
  __int64 v59; // x0
  double v60; // d0
  double v61; // d1
  double v62; // d2
  double v63; // d3
  double v64; // d4
  double v65; // d5
  double v66; // d6
  double v67; // d7
  __int64 v68; // x2
  __int64 v69; // x4
  const char *v70; // x3

  v18 = malloc(16LL, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
  _rtld_search_dirs = v18;
  if ( !v18 )
  {
    v70 = "cannot create search path array";
LABEL_28:
    dl_signal_error(0xCu, 0LL, 0LL, v70);
  }
  v34 = (_QWORD *)v18;
  v35 = malloc(80LL, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33);
  *v34 = v35;
  if ( !v35 )
    goto LABEL_27;
  dword_48E678 = 0;
  *(_DWORD *)(v35 + 40) = 0;
  dl_all_dirs = v35;
  *(_QWORD *)v35 = 0LL;
  *(_QWORD *)(v35 + 8) = "system search path";
  *(_QWORD *)(v35 + 16) = 0LL;
  *(_QWORD *)(v35 + 24) = "/lib/";
  *(_QWORD *)(v35 + 32) = 5LL;
  v34[1] = 0LL;
  max_dirnamelen = 5LL;
  v36 = dl_ns;
  if ( (*((_WORD *)dl_ns + 434) & 3) == 2 )
    _libc_assert_fail((__int64)"l->l_type != lt_loaded", (__int64)"dl-load.c", 0x2F9u, (__int64)"_dl_init_paths");
  v37 = dl_ns[37];
  if ( v37 )
  {
    v38 = 0LL;
    if ( (*((_BYTE *)dl_ns + 870) & 0x20) != 0 )
      v38 = *dl_ns;
    decompose_rpath(
      (__int64)(dl_ns + 127),
      (_BYTE *)(*(_QWORD *)(dl_ns[13] + 8) + *(_QWORD *)(v37 + 8) + v38),
      (__int64)dl_ns,
      (__int64)"RUNPATH");
    v36[110] = -1LL;
    *((_DWORD *)v36 + 256) = 0;
  }
  else
  {
    v68 = dl_ns[23];
    dl_ns[127] = -1LL;
    if ( v68 )
    {
      v69 = 0LL;
      if ( (*((_BYTE *)v36 + 870) & 0x20) != 0 )
        v69 = *v36;
      decompose_rpath(
        (__int64)(v36 + 110),
        (_BYTE *)(*(_QWORD *)(v36[13] + 8) + *(_QWORD *)(v68 + 8) + v69),
        (__int64)v36,
        (__int64)"RPATH");
      *((_DWORD *)v36 + 222) = 0;
    }
    else
    {
      v36[110] = -1LL;
    }
  }
  if ( !a1 || !*a1 )
  {
    result = -1LL;
    _rtld_env_path_list = (_UNKNOWN *)-1LL;
    return result;
  }
  strlen();
  v47 = j_memcpy();
  LOBYTE(v56) = *(_BYTE *)v47;
  if ( *(_BYTE *)v47 )
  {
    v41 = (__int64)v47;
    v40 = 1LL;
    do
    {
      v57 = (unsigned __int8)(v56 - 58) >= 2u;
      v58 = *(unsigned __int8 *)++v41;
      v56 = v58;
      if ( !v57 )
        ++v40;
    }
    while ( v56 );
    v59 = 8 * (v40 + 1);
  }
  else
  {
    v59 = 16LL;
  }
  _rtld_env_path_list = (_UNKNOWN *)malloc(
                                      v59,
                                      v40,
                                      v41,
                                      v42,
                                      v43,
                                      v44,
                                      v45,
                                      v46,
                                      v48,
                                      v49,
                                      v50,
                                      v51,
                                      v52,
                                      v53,
                                      v54,
                                      v55);
  if ( !_rtld_env_path_list )
  {
LABEL_27:
    v70 = "cannot create cache for search path";
    goto LABEL_28;
  }
  fillin_rpath_isra_0((__int64)v47, (__int64)_rtld_env_path_list, ":;", a2, 0LL, (__int64)v36);
  result = (__int64)_rtld_env_path_list;
  if ( !*(_QWORD *)_rtld_env_path_list )
  {
    free((unsigned __int64)_rtld_env_path_list, v60, v61, v62, v63, v64, v65, v66, v67);
    result = -1LL;
    _rtld_env_path_list = (_UNKNOWN *)-1LL;
  }
  dword_48E668 = 0;
  return result;
}
// 419540: write access to const memory at 48E660 has been detected
// 4195FC: write access to const memory at 48E668 has been detected
// 419678: write access to const memory at 48E660 has been detected
// 4195C4: write access to const memory at 48E660 has been detected
// 419490: write access to const memory at 48E678 has been detected
// 41946C: write access to const memory at 48E670 has been detected
// 41947C: variable 'v19' is possibly undefined
// 41947C: variable 'v20' is possibly undefined
// 41947C: variable 'v21' is possibly undefined
// 41947C: variable 'v22' is possibly undefined
// 41947C: variable 'v23' is possibly undefined
// 41947C: variable 'v24' is possibly undefined
// 41947C: variable 'v25' is possibly undefined
// 41947C: variable 'v26' is possibly undefined
// 41947C: variable 'v27' is possibly undefined
// 41947C: variable 'v28' is possibly undefined
// 41947C: variable 'v29' is possibly undefined
// 41947C: variable 'v30' is possibly undefined
// 41947C: variable 'v31' is possibly undefined
// 41947C: variable 'v32' is possibly undefined
// 41947C: variable 'v33' is possibly undefined
// 4195C0: variable 'v40' is possibly undefined
// 4195C0: variable 'v41' is possibly undefined
// 4195C0: variable 'v42' is possibly undefined
// 4195C0: variable 'v43' is possibly undefined
// 4195C0: variable 'v44' is possibly undefined
// 4195C0: variable 'v45' is possibly undefined
// 4195C0: variable 'v46' is possibly undefined
// 4195C0: variable 'v48' is possibly undefined
// 4195C0: variable 'v49' is possibly undefined
// 4195C0: variable 'v50' is possibly undefined
// 4195C0: variable 'v51' is possibly undefined
// 4195C0: variable 'v52' is possibly undefined
// 4195C0: variable 'v53' is possibly undefined
// 4195C0: variable 'v54' is possibly undefined
// 4195C0: variable 'v55' is possibly undefined
// 419670: variable 'v60' is possibly undefined
// 419670: variable 'v61' is possibly undefined
// 419670: variable 'v62' is possibly undefined
// 419670: variable 'v63' is possibly undefined
// 419670: variable 'v64' is possibly undefined
// 419670: variable 'v65' is possibly undefined
// 419670: variable 'v66' is possibly undefined
// 419670: variable 'v67' is possibly undefined
// 48E660: using guessed type _UNKNOWN *_rtld_env_path_list;
// 48E668: using guessed type int dword_48E668;
// 48E670: using guessed type __int64 _rtld_search_dirs;
// 48E678: using guessed type int dword_48E678;
// 4914A8: using guessed type __int64 *dl_ns;
// 496B98: using guessed type __int64 max_dirnamelen;
// 496C40: using guessed type __int64 dl_all_dirs;

//----- (00000000004196CC) ----------------------------------------------------
__int64 __fastcall dl_process_pt_gnu_property(__int64 result, int a2, _QWORD *a3)
{
  unsigned __int64 v3; // x6
  unsigned int *v4; // x3
  __int64 v5; // x5
  unsigned int v6; // w5
  int v7; // w4
  int *v8; // x3
  unsigned __int64 v9; // x5
  unsigned int v10; // w2
  unsigned int v11; // w7
  int v12; // w2
  __int64 v13; // [xsp+10h] [xbp-10h]
  int v14; // [xsp+1Ch] [xbp-4h]

  if ( a3[6] == 8LL )
  {
    v3 = a3[5];
    if ( v3 > 0xC )
    {
      v4 = (unsigned int *)(a3[2] + *(_QWORD *)result);
      v5 = 12LL - (_QWORD)v4;
      while ( *v4 != 4 || v4[2] != 5 || v4[3] != 5590599 )
      {
        v4 = (unsigned int *)((char *)v4 + ((((*v4 + 19LL) & 0xFFFFFFFFFFFFFFF8LL) + v4[1] + 7LL) & 0xFFFFFFFFFFFFFFF8LL));
        if ( (unsigned __int64)v4 + v5 >= v3 )
          return result;
      }
      v6 = v4[1];
      if ( v6 > 7 )
      {
        v7 = v4[1] & 7;
        if ( (v6 & 7) == 0 )
        {
          v8 = (int *)(v4 + 4);
          v9 = (unsigned __int64)v8 + v6;
          do
          {
            v10 = v7;
            v7 = *v8;
            if ( v10 > *v8 )
              break;
            v11 = v8[1];
            if ( v9 < (unsigned __int64)v8 + v11 + 8 )
              break;
            if ( v7 == -1073741824 )
            {
              if ( v11 == 4 )
              {
                v12 = v8[2];
                if ( (v12 & 1) != 0 && (byte_496CD4 & 1) != 0 )
                {
                  v13 = result;
                  v14 = v8[2];
                  dl_bti_protect(result, a2);
                  result = v13;
                  if ( (v14 & 4) != 0 )
                    *(_BYTE *)(v13 + 1089) = 1;
                }
                else if ( (v12 & 4) != 0 )
                {
                  *(_BYTE *)(result + 1089) = 1;
                }
              }
              return result;
            }
            v8 = (int *)((char *)v8 + ((v11 + 7LL) & 0xFFFFFFFFFFFFFFF8LL) + 8);
          }
          while ( (__int64)(v9 - (_QWORD)v8) > 7 );
        }
      }
    }
  }
  return result;
}
// 496CD4: using guessed type char byte_496CD4;

//----- (0000000000419828) ----------------------------------------------------
__int64 *__fastcall dl_map_object_from_fd_constprop_0(
        unsigned __int64 *a1,
        int a2,
        __int64 a3,
        char *a4,
        __int64 a5,
        char a6,
        int a7,
        _QWORD *a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16,
        __int64 a17)
{
  __int64 v22; // x25
  int8x16_t *(__fastcall *v23)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  size_t v24; // x4
  void **v25; // x7
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7
  __int64 *v34; // x19
  __int64 v35; // x24
  unsigned int v36; // w2
  __off64_t v37; // x3
  __int64 v38; // x26
  char **v39; // x23
  char **v40; // x0
  int v41; // w9
  unsigned __int64 v42; // x5
  int v43; // w30
  char *v44; // x3
  __int64 v45; // x16
  __int64 v46; // x14
  __int64 v47; // x20
  char **v48; // x1
  char *v49; // x4
  char *v50; // x7
  void *v51; // x11
  void **v52; // x10
  char *v53; // x8
  unsigned __int64 v54; // x7
  bool v55; // zf
  __int64 v56; // x2
  unsigned int v57; // w2
  void **v58; // x0
  __int64 i; // x6
  __int64 v60; // x6
  size_t v61; // x28
  size_t v62; // x1
  unsigned __int64 v63; // x0
  char *v64; // x6
  __int64 v65; // x11
  size_t v66; // x10
  unsigned __int64 v67; // x2
  int v68; // w9
  __int64 v69; // x10
  char *v70; // x1
  unsigned __int64 v71; // x6
  unsigned __int64 v72; // x0
  unsigned __int64 v73; // x1
  char *v74; // x9
  size_t v75; // x1
  char *v76; // x10
  int v77; // w5
  size_t v78; // x0
  unsigned __int64 v79; // x1
  size_t v80; // x1
  __off_t v81; // x5
  int v82; // w2
  void *v83; // x0
  unsigned __int64 v84; // x0
  const char *v85; // x28
  __int64 v86; // x2
  __int64 v87; // x2
  __int64 v88; // x6
  char v89; // w2
  int v90; // w4
  double v91; // d0
  double v92; // d1
  double v93; // d2
  double v94; // d3
  double v95; // d4
  double v96; // d5
  double v97; // d6
  double v98; // d7
  double v100; // d0
  double v101; // d1
  double v102; // d2
  double v103; // d3
  double v104; // d4
  double v105; // d5
  double v106; // d6
  double v107; // d7
  void *v108; // x0
  unsigned __int64 v109; // x0
  unsigned __int64 v110; // x0
  double v111; // d0
  double v112; // d1
  double v113; // d2
  double v114; // d3
  double v115; // d4
  double v116; // d5
  double v117; // d6
  double v118; // d7
  __int64 v119; // x0
  __int64 v120; // x1
  unsigned __int64 v121; // x0
  unsigned __int64 v122; // t1
  __int64 v123; // x0
  __int64 v124; // x0
  __int64 v125; // x0
  __int64 v126; // x0
  __int64 v127; // x0
  __int64 v128; // x1
  __int64 v129; // x1
  __int64 v130; // x1
  __int64 v131; // x1
  __int64 v132; // x0
  __int64 v133; // x0
  __int64 v134; // x1
  __int64 v135; // x0
  __int64 v136; // x0
  int v137; // w0
  __int64 v138; // x1
  bool v140; // zf
  __int64 v141; // x0
  __int64 v142; // x0
  _QWORD *v143; // x3
  _QWORD *v144; // x20
  int v145; // t1
  __int64 v146; // x4
  int v147; // w1
  __int64 v148; // x0
  __int64 v149; // x2
  __int64 v150; // x3
  __int64 v151; // x4
  void *v152; // x5
  void *v153; // x6
  double v154; // d0
  double v155; // d1
  double v156; // d2
  double v157; // d3
  double v158; // d4
  double v159; // d5
  double v160; // d6
  double v161; // d7
  int *v162; // x0
  int v163; // w1
  unsigned __int64 v164; // x0
  unsigned __int64 v165; // x1
  int v166; // w2
  unsigned __int64 v167; // x0
  __int64 v168; // x1
  char v169; // w0
  size_t v170; // x0
  unsigned __int64 v171; // x0
  unsigned __int64 v172; // x13
  void *v173; // x0
  char *v174; // x0
  __int64 v175; // x13
  char *v176; // x0
  char *v177; // x13
  __int64 v178; // x0
  __int64 v179; // x2
  __int64 v180; // x0
  int8x16_t *(__fastcall *v181)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  __int64 v182; // [xsp+0h] [xbp-30h] BYREF
  char *v183; // [xsp+30h] [xbp+0h] BYREF
  unsigned __int64 v184; // [xsp+38h] [xbp+8h]
  __int64 v185; // [xsp+48h] [xbp+18h]
  unsigned __int64 v186; // [xsp+50h] [xbp+20h] BYREF
  __off_t v187; // [xsp+58h] [xbp+28h]
  __int64 v188; // [xsp+60h] [xbp+30h]
  __int64 v189; // [xsp+90h] [xbp+60h]
  __int64 v190; // [xsp+98h] [xbp+68h]
  char *v191; // [xsp+A0h] [xbp+70h]
  __int64 v192; // [xsp+A8h] [xbp+78h]
  __int64 v193; // [xsp+B0h] [xbp+80h]
  __int64 v194; // [xsp+B8h] [xbp+88h]
  char *v195; // [xsp+C0h] [xbp+90h]
  __int64 v196; // [xsp+C8h] [xbp+98h]
  char *v197; // [xsp+D0h] [xbp+A0h]
  size_t *v198; // [xsp+D8h] [xbp+A8h]
  __int64 *v199; // [xsp+E0h] [xbp+B0h]
  _QWORD *v200; // [xsp+E8h] [xbp+B8h]
  __int64 *v201; // [xsp+F0h] [xbp+C0h]
  int v202; // [xsp+F8h] [xbp+C8h]
  int v203; // [xsp+FCh] [xbp+CCh]
  __int64 v204; // [xsp+100h] [xbp+D0h]
  unsigned int stack_executable; // [xsp+108h] [xbp+D8h]
  int v206; // [xsp+10Ch] [xbp+DCh]
  char *v207; // [xsp+110h] [xbp+E0h]
  unsigned __int64 *v208; // [xsp+118h] [xbp+E8h]
  int v209; // [xsp+12Ch] [xbp+FCh] BYREF
  __int64 v210; // [xsp+130h] [xbp+100h] BYREF
  __int64 v211; // [xsp+138h] [xbp+108h]

  v200 = a8;
  v207 = a4;
  v208 = a1;
  v202 = a7 & 0x20000000;
  if ( (a7 & 0x20000000) != 0 )
  {
    if ( a17 )
      _libc_assert_fail((__int64)"nsid == LM_ID_BASE", (__int64)"dl-load.c", 0x3C6u, (__int64)"_dl_map_object_from_fd");
    v22 = 0LL;
    v204 = 0LL;
    v210 = 0LL;
    v211 = 0LL;
  }
  else
  {
    if ( (fstat64(a2, (struct stat *)&v210) & 0x80000000) != 0 )
    {
      v34 = 0LL;
      v85 = "cannot stat shared object";
      stack_executable = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
      _close_nocancel(a2);
      goto LABEL_90;
    }
    v22 = v210;
    v204 = v211;
    v34 = (&dl_ns)[21 * a17];
    if ( v34 )
    {
      while ( (*((_BYTE *)v34 + 870) & 4) != 0 || v34[125] != v210 || v34[126] != v204 )
      {
        v34 = (__int64 *)v34[3];
        if ( !v34 )
          goto LABEL_4;
      }
      _close_nocancel(a2);
      free((unsigned __int64)v207, v91, v92, v93, v94, v95, v96, v97, v98);
      add_name_to_object_isra_0((unsigned __int64 *)v34[7], v208);
      return v34;
    }
  }
LABEL_4:
  stack_executable = a7 & 4;
  if ( (a7 & 4) != 0 )
  {
    v34 = 0LL;
    free((unsigned __int64)v207, a9, a10, a11, a12, a13, a14, a15, a16);
    _close_nocancel(a2);
    return v34;
  }
  v199 = &dl_debug_mask;
  if ( (dl_debug_mask & 0x40) != 0 )
    dl_debug_printf("file=%s [%lu];  generating link map\n", (const char *)v208, a17);
  v23 = dl_new_object(v207, (__int64)v208, a6, a5, a7, a17);
  v34 = (__int64 *)v23;
  if ( !v23 )
  {
    v85 = "cannot create shared object descriptor";
    stack_executable = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
    _close_nocancel(a2);
    goto LABEL_90;
  }
  v35 = a3 + 8;
  v36 = *(unsigned __int16 *)(a3 + 64);
  *((_QWORD *)v23 + 95) = *(_QWORD *)(a3 + 32);
  v203 = *(unsigned __int16 *)(a3 + 24);
  *((_WORD *)v23 + 384) = v36;
  v37 = *(_QWORD *)(a3 + 40);
  v38 = 56LL * v36;
  v39 = (char **)(a3 + 8 + v37);
  if ( (unsigned __int64)(v38 + v37) > *(_QWORD *)a3 )
  {
    v39 = &v183;
    if ( _pread64_nocancel(a2, &v183, 56LL * v36, v37) != v38 )
    {
      v85 = "cannot read file data";
LABEL_232:
      stack_executable = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
      goto LABEL_81;
    }
  }
  v201 = &v182;
  v40 = &v39[7 * *((unsigned __int16 *)v34 + 384)];
  if ( v39 >= v40 )
  {
LABEL_192:
    v85 = "object file has no loadable segments";
    goto LABEL_81;
  }
  v41 = 0;
  v42 = dl_pagesize;
  v43 = 0;
  v44 = 0LL;
  v45 = dl_pagesize - 1;
  v46 = -dl_pagesize;
  v47 = 0LL;
  v198 = (size_t *)&dl_pagesize;
  v48 = v39;
  v206 = 6;
  do
  {
    while ( 1 )
    {
      v57 = *(_DWORD *)v48;
      if ( *(_DWORD *)v48 == 7 )
      {
        v86 = (__int64)v48[5];
        if ( v86 )
        {
          v34[143] = v86;
          v87 = (__int64)v48[6];
          v34[144] = v87;
          v88 = (__int64)v48[2];
          v24 = (v87 - 1) & v88;
          if ( v87 )
            v87 = (v87 - 1) & v88;
          v34[145] = v87;
          v34[142] = (__int64)v48[4];
          v89 = *((_WORD *)v34 + 434);
          v34[141] = v88;
          if ( (v89 & 3) != 1 && !dl_tls_dtv_slotinfo_list )
            _libc_assert_fail(
              (__int64)"false && \"TLS not initialized in static application\"",
              (__int64)"dl-load.c",
              0x4BAu,
              (__int64)"_dl_map_object_from_fd");
        }
        goto LABEL_26;
      }
      if ( v57 <= 7 )
      {
        switch ( v57 )
        {
          case 2u:
            if ( v48[4] )
            {
              v34[2] = (__int64)v48[2];
              v90 = *((unsigned __int8 *)v34 + 870);
              *((_WORD *)v34 + 385) = (unsigned __int64)v48[5] >> 4;
              v24 = v90 & 0xFFFFFFDF | (32 * ((*((_DWORD *)v48 + 1) & 2) == 0));
              *((_BYTE *)v34 + 870) = v24;
            }
            else
            {
              v43 = 1;
            }
            break;
          case 6u:
            v34[94] = (__int64)v48[2];
            break;
          case 1u:
            v49 = v48[1];
            v50 = v48[2];
            if ( ((v50 - v49) & v45) != 0 )
            {
              v85 = "ELF load command address/offset not page-aligned";
              goto LABEL_81;
            }
            v51 = (void *)((unsigned __int64)v50 & v46);
            v52 = (void **)&(&v183)[7 * v47];
            *v52 = (void *)((unsigned __int64)v50 & v46);
            v53 = &v48[4][(_QWORD)v50];
            v52[3] = &v50[(_QWORD)v48[5]];
            v52[1] = (void *)((unsigned __int64)&v53[v45] & v46);
            v52[2] = v53;
            v54 = (unsigned __int64)v48[6];
            if ( ((v54 - 1) & v54) == 0 && (unsigned __int64)v44 < v54 )
              v44 = v48[6];
            v25 = (void **)&(&v183)[7 * v47];
            v25[5] = (void *)((unsigned __int64)v49 & v46);
            if ( (unsigned __int64)(v47 + 1) > 1 )
            {
              if ( v41 )
                v55 = 0;
              else
                v55 = *(v52 - 6) == v51;
              v41 = !v55;
            }
            v56 = 7 * v47++;
            v24 = (1934713408 >> (4 * (*((_BYTE *)v48 + 4) & 7))) & 0xF;
            *((_DWORD *)&v188 + 2 * v56) = v24;
            break;
        }
        goto LABEL_26;
      }
      if ( v57 == 1685382481 )
      {
        v206 = *((_DWORD *)v48 + 1);
        goto LABEL_26;
      }
      if ( v57 == 1685382482 )
        break;
LABEL_26:
      v48 += 7;
      if ( v48 >= v40 )
        goto LABEL_32;
    }
    v34[149] = (__int64)v48[2];
    v48 += 7;
    v34[150] = (__int64)*(v48 - 2);
  }
  while ( v48 < v40 );
LABEL_32:
  if ( !v47 )
    goto LABEL_192;
  v58 = (void **)&v186;
  for ( i = 0LL; i != v47; ++i )
  {
    *v58 = v44;
    v58 += 7;
  }
  if ( v203 != 3 )
  {
    if ( !v202 )
    {
      v85 = "cannot dynamically load executable";
      goto LABEL_81;
    }
    if ( v34[2] )
    {
      v85 = "object file has no dynamic section";
      if ( v43 )
        goto LABEL_81;
    }
    else if ( v43 )
    {
LABEL_191:
      v85 = "object file has no dynamic section";
      goto LABEL_81;
    }
    v71 = (unsigned __int64)&v183;
    v168 = *v34;
    v67 = *(&v185 + 7 * v47 - 7);
    v61 = v67 - (_QWORD)v183;
    v34[115] = (__int64)&v183[*v34];
    v169 = *((_BYTE *)v34 + 870);
    v34[116] = v168 + v67;
    *((_BYTE *)v34 + 870) = v169 & 0xF7 | (8 * ((v41 ^ 1) & 1));
    goto LABEL_54;
  }
  if ( !v34[2] || v43 )
    goto LABEL_191;
  v60 = i - 1;
  v61 = *(&v185 + 7 * v60) - (_QWORD)v183;
  if ( v42 >= v186 )
  {
    v62 = *(&v185 + 7 * v60) - (_QWORD)v183;
    v194 = 8 * v60;
    v195 = (char *)v60;
    LODWORD(v196) = v41;
    v197 = v183;
    v63 = mmap64(v183, v62, v188, 2050, a2, v187);
    v65 = v194;
    v64 = v195;
    v34[115] = v63;
    v66 = (size_t)v197;
    v67 = v63;
    v68 = v196;
    if ( v63 != -1LL )
      goto LABEL_40;
LABEL_57:
    v85 = "failed to map segment from shared object";
LABEL_195:
    v34[115] = 0LL;
    v34[116] = 0LL;
LABEL_81:
    _close_nocancel(a2);
LABEL_82:
    v108 = (void *)v34[115];
    if ( v108 )
      munmap(v108, v34[116] - (_QWORD)v108);
    v109 = v34[114];
    if ( v109 != -1LL )
      free(v109, v100, v101, v102, v103, v104, v105, v106, v107);
    v110 = v34[7];
    if ( !*(_DWORD *)(v110 + 16) )
      free(v110, v100, v101, v102, v103, v104, v105, v106, v107);
    if ( (*((_WORD *)v34 + 434) & 0x1000) != 0 )
      free(v34[94], v100, v101, v102, v103, v104, v105, v106, v107);
LABEL_90:
    free((unsigned __int64)v34, v100, v101, v102, v103, v104, v105, v106, v107);
    free((unsigned __int64)v207, v111, v112, v113, v114, v115, v116, v117, v118);
    dl_signal_error(stack_executable, (__int64)v208, 0LL, v85);
  }
  v170 = v186 + v61;
  if ( v186 > v61 )
    v170 = 2 * v186;
  v192 = 8 * v60;
  v193 = v60;
  LODWORD(v194) = v41;
  v195 = v183;
  v196 = v186;
  v197 = (char *)v170;
  v171 = mmap64(v183, v170, 0, 2082, -1, 0LL);
  v172 = v171;
  if ( v171 == -1LL )
    goto LABEL_57;
  v173 = (void *)((v171 + v196 - 1) & -v196);
  v196 = v172;
  v174 = (char *)mmap64(v173, v61, v188, 2066, a2, v187);
  v44 = v174;
  v65 = v192;
  v64 = (char *)v193;
  v66 = (size_t)v195;
  v175 = v196;
  v68 = v194;
  if ( v174 == (char *)-1LL )
  {
    munmap((void *)v196, (size_t)v197);
    goto LABEL_57;
  }
  v67 = (unsigned __int64)v174;
  v24 = (size_t)&v174[v61];
  if ( v174 != (char *)v196 )
  {
    v189 = v192;
    v190 = v193;
    v191 = v195;
    v192 = (__int64)&v174[v61];
    LODWORD(v193) = v194;
    v194 = (__int64)v174;
    v195 = v174;
    munmap((void *)v196, (size_t)&v174[-v196]);
    v175 = v196;
    v65 = v189;
    v64 = (char *)v190;
    v66 = (size_t)v191;
    v24 = v192;
    v44 = (char *)v194;
    v67 = (unsigned __int64)v195;
    v68 = v193;
  }
  v176 = (char *)((*v198 - 1 + v24) & -(__int64)*v198);
  v177 = &v197[v175];
  if ( v177 == v176 )
  {
    v34[115] = (__int64)v44;
  }
  else
  {
    v192 = v65;
    v193 = (__int64)v64;
    v194 = v66;
    LODWORD(v195) = v68;
    v196 = (__int64)v44;
    v197 = (char *)v67;
    munmap(v176, v177 - v176);
    v68 = (int)v195;
    v44 = (char *)v196;
    v67 = (unsigned __int64)v197;
    v66 = v194;
    v65 = v192;
    v64 = (char *)v193;
    v34[115] = v196;
  }
LABEL_40:
  v69 = v67 - v66;
  *v34 = v69;
  v34[116] = v61 + v67;
  if ( v68 )
  {
    v70 = (&v183)[v65 - (_QWORD)v64];
    if ( (unsigned __int64)v70 < v184 )
    {
      v85 = "ELF load command address/offset not page-aligned";
      goto LABEL_195;
    }
    if ( (mprotect((void *)(v69 + v184), (size_t)&v70[-v184], 0) & 0x80000000) != 0 )
    {
LABEL_198:
      v85 = "cannot change memory protections";
      goto LABEL_195;
    }
  }
  v71 = (unsigned __int64)&v183;
  *((_BYTE *)v34 + 870) |= 8u;
  while ( 1 )
  {
    if ( !v34[94] )
    {
      v164 = *(_QWORD *)(v35 + 32);
      v165 = *(_QWORD *)(v71 + 40);
      if ( v165 <= v164 )
      {
        v24 = *(_QWORD *)v71;
        v42 = 56LL;
        v44 = (char *)(v164 + 56LL * *(unsigned __int16 *)(v35 + 56));
        v67 = v165 + *(_QWORD *)(v71 + 8) - *(_QWORD *)v71;
        if ( v67 >= (unsigned __int64)v44 )
          v34[94] = v164 + v24 - v165;
      }
    }
    v73 = *(_QWORD *)(v71 + 16);
    v72 = *(_QWORD *)(v71 + 24);
    if ( v72 > v73 )
    {
      v67 = *v34;
      v74 = (char *)(v72 + *v34);
      v24 = v73 + *v34;
      v75 = *v198;
      v44 = (char *)((v75 - 1 + v24) & -(__int64)v75);
      if ( v74 > v44 )
        v76 = (char *)((v75 - 1 + v24) & -(__int64)v75);
      else
        v76 = (char *)(v72 + *v34);
      if ( v24 < (unsigned __int64)v76 )
      {
        v77 = *(_DWORD *)(v71 + 48);
        if ( (v77 & 2) != 0 )
        {
          v194 = (v75 - 1 + v24) & -(__int64)v75;
          v195 = v74;
          v196 = v71;
          v197 = v76;
          memset();
          v44 = (char *)v194;
          v74 = v195;
          v71 = v196;
          v76 = v197;
        }
        else
        {
          v192 = (__int64)v76;
          v193 = (v75 - 1 + v24) & -(__int64)v75;
          v194 = (__int64)v74;
          v195 = (char *)v71;
          LODWORD(v196) = v77;
          v197 = (char *)v24;
          if ( (mprotect((void *)(v24 & -(__int64)v75), v75, v77 | 2u) & 0x80000000) != 0 )
            goto LABEL_198;
          v197 = (char *)v192;
          v181 = memset();
          mprotect((void *)(-(__int64)*v198 & (unsigned __int64)v181), *v198, v196);
          v71 = (unsigned __int64)v195;
          v76 = v197;
          v44 = (char *)v193;
          v74 = (char *)v194;
        }
      }
      if ( v74 > v44 )
      {
        v166 = *(_DWORD *)(v71 + 48);
        v197 = (char *)v71;
        v167 = mmap64(v76, v74 - v76, v166, 50, -1, 0LL);
        v71 = (unsigned __int64)v197;
        if ( v167 == -1LL )
        {
          v85 = "cannot map zero-fill pages";
          goto LABEL_195;
        }
      }
    }
    v71 += 56LL;
LABEL_54:
    if ( v71 >= (unsigned __int64)&(&v183)[7 * v47] )
      break;
    v78 = *(_QWORD *)v71;
    v79 = *(_QWORD *)(v71 + 8);
    if ( v79 > *(_QWORD *)v71 )
    {
      v80 = v79 - v78;
      v81 = *(_QWORD *)(v71 + 40);
      v82 = *(_DWORD *)(v71 + 48);
      v83 = (void *)(v78 + *v34);
      v197 = (char *)v71;
      v84 = mmap64(v83, v80, v82, 2066, a2, v81);
      v71 = (unsigned __int64)v197;
      if ( v84 == -1LL )
        goto LABEL_57;
    }
  }
  v119 = v34[2];
  if ( v119 && (v67 = *v34, v120 = v119 + *v34, (v34[2] = v120) != 0) )
  {
    v121 = *(_QWORD *)(v119 + v67);
    v44 = (char *)(v34 + 8);
    if ( v121 )
    {
      v71 = 1879048191LL;
      v24 = -1879048192LL;
      do
      {
        if ( v121 > 0x25 )
        {
          v42 = v121 - 1879048192;
          if ( v121 - 1879048192 > 5 )
          {
            v42 = 1879048191 - v121;
            if ( 1879048191 - v121 > 0xF )
            {
              v42 = (unsigned int)(2 * v121);
              if ( (unsigned int)v42 > 0xFFFFFFF8 )
              {
                LODWORD(v121) = 59 - ((int)v42 >> 1);
              }
              else
              {
                v25 = (void **)(1879047679 - v121);
                if ( 1879047679 - v121 > 0xB )
                {
                  v42 = 1879047935LL;
                  v25 = (void **)(1879047935 - v121);
                  if ( 1879047935 - v121 > 0xA )
                    goto LABEL_99;
                  v42 = 1879048010LL;
                  LODWORD(v121) = 1879048010 - v121;
                }
                else
                {
                  v42 = 1879047742LL;
                  LODWORD(v121) = 1879047742 - v121;
                }
              }
            }
            else
            {
              LODWORD(v121) = 1879048235 - v121;
            }
          }
          else
          {
            LODWORD(v121) = v121 - 1879048154;
          }
        }
        *(_QWORD *)&v44[8 * (unsigned int)v121] = v120;
LABEL_99:
        v122 = *(_QWORD *)(v120 + 16);
        v120 += 16LL;
        v121 = v122;
      }
      while ( v122 );
    }
    if ( !v67 || (*((_BYTE *)v34 + 870) & 0x20) != 0 )
    {
      v131 = v34[28];
      if ( v131 )
        goto LABEL_122;
LABEL_123:
      if ( v34[15] )
      {
LABEL_124:
        if ( *(_QWORD *)(v34[17] + 8) != 24LL )
          _libc_assert_fail(
            (__int64)"info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela))",
            (__int64)"get-dynamic-info.h",
            0x7Bu,
            (__int64)"elf_get_dynamic_info");
      }
      v127 = v34[44];
    }
    else
    {
      v123 = v34[12];
      if ( v123 )
        *(_QWORD *)(v123 + 8) += v67;
      v124 = v34[11];
      if ( v124 )
        *(_QWORD *)(v124 + 8) += v67;
      v125 = v34[13];
      if ( v125 )
        *(_QWORD *)(v125 + 8) += v67;
      v126 = v34[14];
      if ( v126 )
        *(_QWORD *)(v126 + 8) += v67;
      v127 = v34[44];
      if ( v127 )
        *(_QWORD *)(v127 + 8) += v67;
      v128 = v34[31];
      if ( v128 )
        *(_QWORD *)(v128 + 8) += v67;
      v129 = v34[67];
      if ( v129 )
        *(_QWORD *)(v129 + 8) += v67;
      v130 = v34[93];
      if ( v130 )
        *(_QWORD *)(v130 + 8) += v67;
      v44 = (char *)v34[15];
      v131 = v34[28];
      if ( v44 )
      {
        v132 = *((_QWORD *)v44 + 1);
        if ( v132 )
        {
          v67 += v132;
          *((_QWORD *)v44 + 1) = v67;
        }
        if ( v131 )
        {
LABEL_122:
          if ( *(_QWORD *)(v131 + 8) != 7LL )
            _libc_assert_fail(
              (__int64)"info[DT_PLTREL]->d_un.d_val == DT_RELA",
              (__int64)"get-dynamic-info.h",
              0x73u,
              (__int64)"elf_get_dynamic_info");
          goto LABEL_123;
        }
        goto LABEL_124;
      }
      if ( v131 )
        goto LABEL_122;
    }
    if ( v127 && *(_QWORD *)(v34[45] + 8) != 8LL )
      _libc_assert_fail(
        (__int64)"info[DT_RELRENT]->d_un.d_val == sizeof (ElfW(Relr))",
        (__int64)"get-dynamic-info.h",
        0x82u,
        (__int64)"elf_get_dynamic_info");
    v133 = v34[38];
    if ( v133 )
    {
      v134 = *(_QWORD *)(v133 + 8);
      *((_DWORD *)v34 + 266) = v134;
      if ( (v134 & 2) != 0 )
        v34[24] = v133;
      if ( (v134 & 4) != 0 )
        v34[30] = v133;
      if ( (v134 & 8) != 0 )
        v34[32] = v133;
    }
    v135 = v34[56];
    if ( v135 )
    {
      v136 = *(_QWORD *)(v135 + 8);
      *((_DWORD *)v34 + 265) = v136;
      v67 = (unsigned int)v136;
      if ( (v136 & 8) != 0 )
        *((_BYTE *)v34 + 872) = 1;
      if ( (*(_DWORD *)v199 & 0x40) != 0 && (v136 & 0xF7FFF716) != 0 )
      {
        dl_debug_printf("\nWARNING: Unsupported flag value(s) of 0x%x in DT_FLAGS_1.\n", v136 & 0xF7FFF716);
        v67 = *((unsigned int *)v34 + 265);
        v137 = v67;
        if ( (v67 & 1) != 0 )
LABEL_197:
          v34[32] = v34[56];
      }
      else
      {
        v137 = *((_DWORD *)v34 + 265);
        if ( (v67 & 1) != 0 )
          goto LABEL_197;
      }
    }
    else
    {
      v137 = *((_DWORD *)v34 + 265);
    }
    if ( v34[37] )
      v34[23] = 0LL;
  }
  else
  {
    v137 = *((_DWORD *)v34 + 265);
  }
  v138 = v137 & 0x8000000;
  if ( (v137 & 0x40) != 0 && a7 < 0 )
  {
    if ( (_DWORD)v138 )
    {
      _close_nocancel(a2);
      v85 = "cannot dynamically load position-independent executable";
    }
    else
    {
      _close_nocancel(a2);
      v85 = "shared object cannot be dlopen()ed";
    }
    goto LABEL_82;
  }
  if ( (_DWORD)v138 )
    v140 = v202 == 0;
  else
    v140 = 0;
  if ( v140 )
  {
    v85 = "cannot dynamically load position-independent executable";
    goto LABEL_81;
  }
  v141 = v34[94];
  if ( v141 )
  {
    v34[94] = v141 + *v34;
  }
  else
  {
    if ( !malloc(
            56LL * *(unsigned __int16 *)(v35 + 56),
            v138,
            v67,
            v44,
            (void *)v24,
            (void *)v42,
            (void *)v71,
            (__int64)v25,
            v26,
            v27,
            v28,
            v29,
            v30,
            v31,
            v32,
            v33) )
    {
      v85 = "cannot allocate memory for program header";
      goto LABEL_232;
    }
    v34[94] = (__int64)j_memcpy();
    *((_WORD *)v34 + 434) |= 0x1000u;
  }
  if ( (v206 & ~dl_stack_flags & 1) != 0 )
  {
    if ( a7 < 0 || (_tunable_get_val(31LL, (char **)&v209, 0LL), v209 != 1) )
    {
      _close_nocancel(a2);
      v85 = "cannot enable executable stack as shared object requires";
      stack_executable = 22;
      goto LABEL_82;
    }
    stack_executable = dl_make_stack_executable(v200);
    if ( stack_executable )
    {
      _close_nocancel(a2);
      v85 = "cannot enable executable stack as shared object requires";
      goto LABEL_82;
    }
  }
  v142 = v34[141];
  if ( v142 )
    v34[141] = v142 + *v34;
  v143 = (_QWORD *)v34[94];
  v144 = &v143[7 * *((unsigned __int16 *)v34 + 384)];
  while ( v143 != v144 )
  {
    v145 = *((_DWORD *)v144 - 14);
    v144 -= 7;
    if ( v145 == 1685382483 )
    {
      dl_process_pt_gnu_property((__int64)v34, a2, v144);
      v143 = (_QWORD *)v34[94];
    }
  }
  if ( (unsigned int)_close_nocancel(a2) )
  {
    v85 = "cannot close file descriptor";
    goto LABEL_232;
  }
  if ( v203 == 2 && (*((_WORD *)v34 + 434) & 3LL) != 0 )
    _libc_assert_fail(
      (__int64)"type != ET_EXEC || l->l_type == lt_executable",
      (__int64)"dl-load.c",
      0x558u,
      (__int64)"_dl_map_object_from_fd");
  v146 = *v34;
  v147 = *(_DWORD *)v199;
  v148 = *v34 + v34[95];
  v34[95] = v148;
  if ( (v147 & 0x40) != 0 )
    dl_debug_printf(
      "  dynamic: 0x%0*lx  base: 0x%0*lx   size: 0x%0*zx\n    entry: 0x%0*lx  phdr: 0x%0*lx  phnum:   %*u\n\n",
      16,
      v34[2],
      16,
      v146,
      16,
      v61,
      16,
      v148,
      16,
      v34[94],
      16,
      *((unsigned __int16 *)v34 + 384));
  dl_setup_hash((__int64)v34);
  if ( (a7 & 8) == 0 )
  {
    if ( v34[24] )
    {
      v149 = *(_QWORD *)v34[122];
      if ( (__int64 *)v149 != v34 + 97 )
      {
        *(_QWORD *)v34[99] = v34;
        *((_DWORD *)v34 + 200) = 1;
        j_memmove();
        *(_QWORD *)v34[122] = v34 + 99;
      }
    }
  }
  if ( (*((_DWORD *)v34 + 265) & 0x20) != 0 )
    dl_initfirst = (__int64)v34;
  v34[126] = v204;
  v34[125] = v22;
  if ( !(&dl_ns)[21 * a17 + 4] )
  {
    v178 = v34[22];
    if ( v178 )
    {
      v179 = 0LL;
      v180 = *(_QWORD *)(v178 + 8);
      if ( (*((_BYTE *)v34 + 870) & 0x20) != 0 )
        v179 = *v34;
      if ( !(unsigned int)strcmp(
                            (unsigned __int64 *)(v180 + *(_QWORD *)(v34[13] + 8) + v179),
                            (unsigned __int64)"libc.so.6") )
        (&dl_ns)[21 * a17 + 4] = v34;
    }
  }
  if ( v34[143] && ((*((_WORD *)v34 + 434) & 3) == 1 || dl_tls_dtv_slotinfo_list) )
    dl_assign_tls_modid((unsigned __int64)v34);
  dl_add_to_namespace_list(v34, a17, v149, v150, v151, v152, v153, v154, v155, v156, v157, v158, v159, v160, v161);
  if ( (a7 & 0x40000000) == 0 )
  {
    v162 = dl_debug_update(a17);
    v163 = v162[6];
    if ( v163 )
    {
      if ( v163 != 1 )
        _libc_assert_fail(
          (__int64)"r->r_state == RT_ADD",
          (__int64)"dl-load.c",
          0x3A1u,
          (__int64)"_dl_notify_new_object");
    }
    else
    {
      v162[6] = 1;
      dl_debug_state(v162);
    }
  }
  return v34;
}
// 419DC8: variable 'v91' is possibly undefined
// 419DC8: variable 'v92' is possibly undefined
// 419DC8: variable 'v93' is possibly undefined
// 419DC8: variable 'v94' is possibly undefined
// 419DC8: variable 'v95' is possibly undefined
// 419DC8: variable 'v96' is possibly undefined
// 419DC8: variable 'v97' is possibly undefined
// 419DC8: variable 'v98' is possibly undefined
// 419E28: variable 'v100' is possibly undefined
// 419E28: variable 'v101' is possibly undefined
// 419E28: variable 'v102' is possibly undefined
// 419E28: variable 'v103' is possibly undefined
// 419E28: variable 'v104' is possibly undefined
// 419E28: variable 'v105' is possibly undefined
// 419E28: variable 'v106' is possibly undefined
// 419E28: variable 'v107' is possibly undefined
// 419E4C: variable 'v111' is possibly undefined
// 419E4C: variable 'v112' is possibly undefined
// 419E4C: variable 'v113' is possibly undefined
// 419E4C: variable 'v114' is possibly undefined
// 419E4C: variable 'v115' is possibly undefined
// 419E4C: variable 'v116' is possibly undefined
// 419E4C: variable 'v117' is possibly undefined
// 419E4C: variable 'v118' is possibly undefined
// 41A210: variable 'v149' is possibly undefined
// 41A210: variable 'v150' is possibly undefined
// 41A210: variable 'v151' is possibly undefined
// 41A210: variable 'v152' is possibly undefined
// 41A210: variable 'v153' is possibly undefined
// 41A210: variable 'v154' is possibly undefined
// 41A210: variable 'v155' is possibly undefined
// 41A210: variable 'v156' is possibly undefined
// 41A210: variable 'v157' is possibly undefined
// 41A210: variable 'v158' is possibly undefined
// 41A210: variable 'v159' is possibly undefined
// 41A210: variable 'v160' is possibly undefined
// 41A210: variable 'v161' is possibly undefined
// 41A2C4: variable 'a9' is possibly undefined
// 41A2C4: variable 'a10' is possibly undefined
// 41A2C4: variable 'a11' is possibly undefined
// 41A2C4: variable 'a12' is possibly undefined
// 41A2C4: variable 'a13' is possibly undefined
// 41A2C4: variable 'a14' is possibly undefined
// 41A2C4: variable 'a15' is possibly undefined
// 41A2C4: variable 'a16' is possibly undefined
// 41A628: variable 'v67' is possibly undefined
// 41A628: variable 'v44' is possibly undefined
// 41A628: variable 'v24' is possibly undefined
// 41A628: variable 'v42' is possibly undefined
// 41A628: variable 'v71' is possibly undefined
// 41A628: variable 'v25' is possibly undefined
// 41A628: variable 'v26' is possibly undefined
// 41A628: variable 'v27' is possibly undefined
// 41A628: variable 'v28' is possibly undefined
// 41A628: variable 'v29' is possibly undefined
// 41A628: variable 'v30' is possibly undefined
// 41A628: variable 'v31' is possibly undefined
// 41A628: variable 'v32' is possibly undefined
// 41A628: variable 'v33' is possibly undefined
// 417FA0: using guessed type __int64 __fastcall dl_debug_state(_QWORD);
// 41A8C0: using guessed type __int64 dl_map_object(void);
// 490F10: using guessed type __int64 dl_pagesize;
// 490F28: using guessed type int dl_stack_flags;
// 4914A8: using guessed type __int64 *dl_ns;
// 4921E8: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 496C20: using guessed type __int64 dl_debug_mask;
// 496CB8: using guessed type __int64 dl_initfirst;

//----- (000000000041A8C0) ----------------------------------------------------
__int64 *__fastcall dl_map_object(__int64 a1, unsigned __int8 *a2, char a3, int a4, int a5, unsigned __int64 a6)
{
  __int64 *v12; // x23
  __int64 v13; // x0
  __int64 v14; // x24
  __int64 v15; // x0
  unsigned __int64 *v16; // x24
  char v18; // w23
  const char *v19; // x22
  int v20; // w1
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  __int64 (__fastcall *cache_lookup)(__int64, __int64 *, unsigned __int64); // x23
  __int64 *v30; // x6
  __int64 *v31; // x3
  const char *v32; // x3
  char *v33; // x0
  int v34; // w24
  __int64 v35; // x23
  char i; // w0
  bool v37; // zf
  int v38; // w0
  __int64 *v39; // x6
  char *v40; // x0
  double v41; // d0
  double v42; // d1
  double v43; // d2
  double v44; // d3
  double v45; // d4
  double v46; // d5
  double v47; // d6
  double v48; // d7
  unsigned __int64 v49; // x22
  int8x16_t *(__fastcall *v50)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  __int64 v51; // x3
  __int64 v52; // x4
  void *v53; // x5
  void *v54; // x6
  __int64 v55; // x6
  int v56; // w0
  __int64 v57; // x6
  int v58; // [xsp+70h] [xbp+60h]
  int v59; // [xsp+70h] [xbp+60h]
  int v60; // [xsp+80h] [xbp+70h]
  int v61; // [xsp+84h] [xbp+74h]
  char *v62; // [xsp+88h] [xbp+78h]
  __int64 *v63; // [xsp+90h] [xbp+80h]
  char v64; // [xsp+BFh] [xbp+AFh] BYREF
  unsigned __int8 *v65; // [xsp+C0h] [xbp+B0h] BYREF
  __int64 v66[2]; // [xsp+C8h] [xbp+B8h] BYREF
  _BYTE v67[840]; // [xsp+D8h] [xbp+C8h] BYREF

  if ( (a6 & 0x8000000000000000LL) != 0 )
    _libc_assert_fail((__int64)"nsid >= 0", (__int64)"dl-load.c", 0x76Fu, (__int64)"_dl_map_object");
  if ( a6 >= dl_nns )
    _libc_assert_fail((__int64)"nsid < GL(dl_nns)", (__int64)"dl-load.c", 0x770u, (__int64)"_dl_map_object");
  v12 = (&dl_ns)[21 * a6];
  if ( !v12 )
  {
LABEL_15:
    v18 = dl_debug_mask;
    v60 = a5 & 0x10000000;
    if ( (dl_debug_mask & 0x40) != 0 )
    {
      if ( a1 )
      {
        v32 = *(const char **)(a1 + 8);
        v33 = "\nfile=%s [%lu];  dynamically loaded by %s [%lu]\n";
        if ( !v60 )
          v33 = "\nfile=%s [%lu];  needed by %s [%lu]\n";
        if ( !*v32 )
        {
          v32 = (const char *)program_invocation_short_name[0];
          if ( !program_invocation_short_name[0] )
            v32 = "<main program>";
        }
        dl_debug_printf((unsigned __int8 *)v33, a2, a6, v32, *(_QWORD *)(a1 + 48));
        v64 = 0;
        if ( strchr((__int64)a2, 0x2Fu) )
        {
LABEL_18:
          v65 = expand_dynamic_string_token(a1, a2);
          v19 = (const char *)v65;
          if ( v65 )
            goto LABEL_19;
          goto LABEL_25;
        }
        v62 = (char *)strlen() + 1;
        if ( (dl_debug_mask & 1) != 0 )
          dl_debug_printf("find library=%s [%lu]; searching\n", (const char *)a2, a6);
        goto LABEL_34;
      }
      v64 = 0;
      if ( strchr((__int64)a2, 0x2Fu) )
        goto LABEL_24;
      v62 = (char *)strlen() + 1;
      if ( (v18 & 1) == 0 )
      {
        v63 = dl_ns;
        if ( dl_ns )
          goto LABEL_110;
LABEL_83:
        if ( _rtld_env_path_list != (_UNKNOWN *)-1LL )
          goto LABEL_70;
        goto LABEL_84;
      }
      dl_debug_printf("find library=%s [%lu]; searching\n", (const char *)a2, a6);
    }
    else
    {
      v64 = 0;
      if ( strchr((__int64)a2, 0x2Fu) )
      {
        if ( a1 )
          goto LABEL_18;
LABEL_24:
        v65 = (unsigned __int8 *)strdup();
        v19 = (const char *)v65;
        if ( v65 )
        {
LABEL_19:
          v20 = open_verify_constprop_0(v19, (__int64)v67, &v64, 1);
          if ( v20 != -1 )
          {
LABEL_20:
            cache_lookup = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))v65;
            goto LABEL_21;
          }
          free((unsigned __int64)v19, v21, v22, v23, v24, v25, v26, v27, v28);
          if ( !v60 )
            goto LABEL_26;
          goto LABEL_30;
        }
LABEL_25:
        if ( !v60 )
        {
LABEL_26:
          if ( !a4 )
          {
            if ( (v64 & 1) != 0 )
              dl_signal_error(0, (__int64)a2, 0LL, "wrong ELF class: ELFCLASS32");
            dl_signal_error(
              *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40),
              (__int64)a2,
              0LL,
              "cannot open shared object file");
          }
          v40 = (char *)strdup();
          v49 = (unsigned __int64)v40;
          if ( !v40 || (v50 = dl_new_object(v40, (__int64)a2, a3, a1, a5, a6), (v12 = (__int64 *)v50) == 0LL) )
          {
            free(v49, v41, v42, v43, v44, v45, v46, v47, v48);
            dl_signal_error(0xCu, (__int64)a2, 0LL, "cannot create shared object descriptor");
          }
          *((_QWORD *)v50 + 107) = &dummy_bucket_6;
          *((_DWORD *)v50 + 207) = 1;
          *((_WORD *)v50 + 434) |= 0x4008u;
          dl_add_to_namespace_list(
            (__int64 *)v50,
            a6,
            16392LL,
            v51,
            v52,
            v53,
            v54,
            v41,
            v42,
            v43,
            v44,
            v45,
            v46,
            v47,
            v48);
          return v12;
        }
LABEL_30:
        a1 = 0LL;
        goto LABEL_26;
      }
      v62 = (char *)strlen() + 1;
      if ( (v18 & 1) != 0 )
        dl_debug_printf("find library=%s [%lu]; searching\n", (const char *)a2, a6);
      if ( a1 )
      {
LABEL_34:
        if ( *(_QWORD *)(a1 + 296) )
          goto LABEL_35;
        v63 = dl_ns;
        v35 = a1;
        v61 = 0;
        for ( i = cache_rpath(v35, (__int64 *)(v35 + 880), 15, (__int64)"RPATH");
              ;
              i = cache_rpath(v35, (__int64 *)(v35 + 880), 15, (__int64)"RPATH") )
        {
          if ( (i & 1) != 0 )
          {
            v20 = open_path_isra_0(
                    (__int64 *)a2,
                    (__int64)v62,
                    a5,
                    (__int64 *)(v35 + 880),
                    (unsigned __int64 *)&v65,
                    (__int64)v67,
                    a1,
                    &v64);
            if ( v20 != -1 )
              goto LABEL_37;
            if ( v61 )
              v37 = 1;
            else
              v37 = v35 == (_QWORD)v63;
            v38 = v37;
            v61 = v38;
          }
          v35 = *(_QWORD *)(v35 + 808);
          if ( !v35 )
            break;
        }
        if ( v61 || !v63 )
        {
LABEL_35:
          if ( _rtld_env_path_list != (_UNKNOWN *)-1LL )
            goto LABEL_36;
LABEL_42:
          if ( (cache_rpath(a1, (__int64 *)(a1 + 1016), 29, (__int64)"RUNPATH") & 1) == 0 )
            goto LABEL_43;
          v30 = (__int64 *)a1;
          v31 = (__int64 *)(a1 + 1016);
LABEL_52:
          v20 = open_path_isra_0(
                  (__int64 *)a2,
                  (__int64)v62,
                  a5,
                  v31,
                  (unsigned __int64 *)&v65,
                  (__int64)v67,
                  (__int64)v30,
                  &v64);
          if ( v20 == -1 )
          {
LABEL_43:
            if ( (a5 & 0x4000000) != 0 && _libc_enable_secure
              || dl_inhibit_cache
              || (cache_lookup = dl_load_cache_lookup(a2)) == 0LL )
            {
LABEL_91:
              v39 = (__int64 *)a1;
              if ( a1 )
                goto LABEL_92;
              goto LABEL_117;
            }
            if ( a1 )
            {
              if ( (*(_DWORD *)(a1 + 1060) & 0x800) == 0 )
                goto LABEL_48;
LABEL_88:
              if ( *(_DWORD *)cache_lookup == 1651076143 && *((_BYTE *)cache_lookup + 4) == 47 )
              {
LABEL_90:
                free((unsigned __int64)cache_lookup, v21, v22, v23, v24, v25, v26, v27, v28);
                goto LABEL_91;
              }
LABEL_48:
              v20 = open_verify_constprop_0((const char *)cache_lookup, (__int64)v67, &v64, 0);
              if ( v20 != -1 )
              {
                v65 = (unsigned __int8 *)cache_lookup;
                if ( (dl_debug_mask & 1) == 0 )
                {
LABEL_21:
                  if ( v60 )
                    a1 = 0LL;
                  goto LABEL_23;
                }
                goto LABEL_38;
              }
              goto LABEL_90;
            }
LABEL_87:
            if ( (*((_DWORD *)dl_ns + 265) & 0x800) == 0 )
              goto LABEL_48;
            goto LABEL_88;
          }
LABEL_37:
          if ( (dl_debug_mask & 1) == 0 )
            goto LABEL_20;
LABEL_38:
          v58 = v20;
          dl_debug_printf((unsigned __int8 *)"\n");
          cache_lookup = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))v65;
          v20 = v58;
          if ( v60 )
            a1 = 0LL;
          goto LABEL_23;
        }
LABEL_110:
        if ( (*((_WORD *)v63 + 434) & 3) == 2 )
          goto LABEL_68;
LABEL_66:
        v34 = a5 & 0x8000000;
        if ( (cache_rpath((__int64)v63, v63 + 110, 15, (__int64)"RPATH") & 1) != 0 )
        {
          if ( a1 )
            v55 = a1;
          else
            v55 = (__int64)v63;
          v56 = open_path_isra_0(
                  (__int64 *)a2,
                  (__int64)v62,
                  a5,
                  v63 + 110,
                  (unsigned __int64 *)&v65,
                  (__int64)v67,
                  v55,
                  &v64);
          v20 = v56;
          if ( !v34 )
            goto LABEL_123;
          if ( v56 != -1 )
            goto LABEL_37;
        }
        else if ( !v34 )
        {
LABEL_68:
          if ( _rtld_env_path_list != (_UNKNOWN *)-1LL )
          {
            if ( a1 )
            {
LABEL_36:
              v20 = open_path_isra_0(
                      (__int64 *)a2,
                      (__int64)v62,
                      a5,
                      (__int64 *)&_rtld_env_path_list,
                      (unsigned __int64 *)&v65,
                      (__int64)v67,
                      a1,
                      &v64);
              if ( v20 != -1 )
                goto LABEL_37;
              goto LABEL_42;
            }
LABEL_70:
            v30 = dl_ns;
            v31 = (__int64 *)&_rtld_env_path_list;
            goto LABEL_52;
          }
          if ( a1 )
            goto LABEL_42;
LABEL_84:
          if ( (a5 & 0x4000000) != 0 )
          {
            if ( !(_libc_enable_secure | dl_inhibit_cache) )
            {
              cache_lookup = dl_load_cache_lookup(a2);
              if ( cache_lookup )
                goto LABEL_87;
            }
          }
          else if ( !dl_inhibit_cache )
          {
            cache_lookup = dl_load_cache_lookup(a2);
            if ( cache_lookup )
              goto LABEL_87;
          }
LABEL_117:
          v39 = (&dl_ns)[21 * a6];
          if ( !v39 )
          {
LABEL_93:
            if ( _rtld_search_dirs != -1 )
            {
              v20 = open_path_isra_0(
                      (__int64 *)a2,
                      (__int64)v62,
                      a5,
                      &_rtld_search_dirs,
                      (unsigned __int64 *)&v65,
                      (__int64)v67,
                      (__int64)v39,
                      &v64);
              if ( (dl_debug_mask & 1) != 0 )
              {
                v59 = v20;
                dl_debug_printf((unsigned __int8 *)"\n");
                v20 = v59;
              }
              if ( v60 )
                a1 = 0LL;
              if ( v20 != -1 )
              {
                cache_lookup = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))v65;
LABEL_23:
                v66[0] = _libc_stack_end;
                return dl_map_object_from_fd_constprop_0(
                         (unsigned __int64 *)a2,
                         v20,
                         (__int64)v67,
                         (char *)cache_lookup,
                         a1,
                         a3,
                         a5,
                         v66,
                         v21,
                         v22,
                         v23,
                         v24,
                         v25,
                         v26,
                         v27,
                         v28,
                         a6);
              }
              goto LABEL_26;
            }
LABEL_112:
            if ( (dl_debug_mask & 1) != 0 )
            {
              dl_debug_printf((unsigned __int8 *)"\n");
              if ( v60 )
                a1 = 0LL;
              goto LABEL_26;
            }
            goto LABEL_25;
          }
LABEL_92:
          if ( (*((_DWORD *)v39 + 265) & 0x800) != 0 )
            goto LABEL_112;
          goto LABEL_93;
        }
        if ( (*((_WORD *)v63 + 434) & 3) == 2 )
          goto LABEL_68;
        v66[0] = 0LL;
        if ( (cache_rpath((__int64)v63, v66, 29, (__int64)"RUNPATH") & 1) == 0 )
          goto LABEL_68;
        if ( a1 )
          v57 = a1;
        else
          v57 = (__int64)v63;
        v20 = open_path_isra_0((__int64 *)a2, (__int64)v62, a5, v66, (unsigned __int64 *)&v65, (__int64)v67, v57, &v64);
LABEL_123:
        if ( v20 != -1 )
          goto LABEL_37;
        goto LABEL_68;
      }
    }
    v63 = dl_ns;
    if ( dl_ns && (*((_WORD *)dl_ns + 434) & 3) != 2 )
      goto LABEL_66;
    goto LABEL_83;
  }
  while ( 1 )
  {
    if ( !(((unsigned __int64)v12[108] >> 46) & 1 | ((unsigned __int64)v12[108] >> 50) & 1) )
    {
      if ( (unsigned int)dl_name_match_p((unsigned __int64 *)a2, (__int64)v12) )
        return v12;
      if ( (v12[108] & 0x200000000000LL) == 0 )
      {
        v13 = v12[22];
        if ( v13 )
        {
          v14 = *(_QWORD *)(v13 + 8);
          v15 = 0LL;
          if ( (*((_BYTE *)v12 + 870) & 0x20) != 0 )
            v15 = *v12;
          v16 = (unsigned __int64 *)(v14 + *(_QWORD *)(v12[13] + 8) + v15);
          if ( !(unsigned int)strcmp((unsigned __int64 *)a2, (unsigned __int64)v16) )
            break;
        }
      }
    }
    v12 = (__int64 *)v12[3];
    if ( !v12 )
      goto LABEL_15;
  }
  add_name_to_object_isra_0((unsigned __int64 *)v12[7], v16);
  *((_WORD *)v12 + 434) |= 0x2000u;
  return v12;
}
// 41AA88: variable 'v21' is possibly undefined
// 41AA88: variable 'v22' is possibly undefined
// 41AA88: variable 'v23' is possibly undefined
// 41AA88: variable 'v24' is possibly undefined
// 41AA88: variable 'v25' is possibly undefined
// 41AA88: variable 'v26' is possibly undefined
// 41AA88: variable 'v27' is possibly undefined
// 41AA88: variable 'v28' is possibly undefined
// 41AF94: variable 'v51' is possibly undefined
// 41AF94: variable 'v52' is possibly undefined
// 41AF94: variable 'v53' is possibly undefined
// 41AF94: variable 'v54' is possibly undefined
// 41AF94: variable 'v41' is possibly undefined
// 41AF94: variable 'v42' is possibly undefined
// 41AF94: variable 'v43' is possibly undefined
// 41AF94: variable 'v44' is possibly undefined
// 41AF94: variable 'v45' is possibly undefined
// 41AF94: variable 'v46' is possibly undefined
// 41AF94: variable 'v47' is possibly undefined
// 41AF94: variable 'v48' is possibly undefined
// 41B1A0: using guessed type __int64 dl_rtld_di_serinfo(void);
// 48E660: using guessed type _UNKNOWN *_rtld_env_path_list;
// 48E670: using guessed type __int64 _rtld_search_dirs;
// 48F7C8: using guessed type __int64 _libc_stack_end;
// 490F20: using guessed type __int64 dl_nns;
// 4914A8: using guessed type __int64 *dl_ns;
// 491570: using guessed type int _libc_enable_secure;
// 491928: using guessed type __int64 *program_invocation_short_name[2];
// 496C20: using guessed type __int64 dl_debug_mask;
// 496CC0: using guessed type int dl_inhibit_cache;

//----- (000000000041B1A0) ----------------------------------------------------
__int64 __fastcall dl_rtld_di_serinfo(__int64 *a1, __int64 a2, char a3)
{
  int v5; // w23
  __int64 v6; // x0
  __int64 result; // x0
  __int64 v8; // x0
  __int64 v9; // x19
  __int64 *v10; // x19
  bool v11; // zf
  _BYTE v12[4]; // [xsp+48h] [xbp+48h] BYREF
  int v13; // [xsp+4Ch] [xbp+4Ch]
  __int64 v14; // [xsp+50h] [xbp+50h]
  __int64 v15; // [xsp+58h] [xbp+58h]

  v5 = a3 & 1;
  if ( (a3 & 1) != 0 )
  {
    *(_QWORD *)a2 = 0LL;
    *(_DWORD *)(a2 + 8) = 0;
    v14 = a2;
    v15 = a2 + 16;
    v8 = a1[37];
    v12[0] = a3;
    v13 = 0;
    if ( v8 )
      goto LABEL_3;
  }
  else
  {
    v6 = *(unsigned int *)(a2 + 8);
    v12[0] = a3;
    v13 = 0;
    v14 = a2;
    v15 = a2 + 16 * (v6 + 1);
    if ( a1[37] )
      goto LABEL_3;
  }
  v9 = (__int64)a1;
  do
  {
    while ( (cache_rpath(v9, (__int64 *)(v9 + 880), 15, (__int64)"RPATH") & 1) == 0 )
    {
      v9 = *(_QWORD *)(v9 + 808);
      if ( !v9 )
        goto LABEL_15;
    }
    add_path_constprop_0_isra_0(v12, *(__int64 **)(v9 + 880));
    v9 = *(_QWORD *)(v9 + 808);
  }
  while ( v9 );
LABEL_15:
  if ( !a1[6] )
  {
    v10 = dl_ns;
    if ( dl_ns )
    {
      v11 = (*((_WORD *)dl_ns + 434) & 3) == 2 || a1 == dl_ns;
      if ( !v11 && (cache_rpath((__int64)dl_ns, dl_ns + 110, 15, (__int64)"RPATH") & 1) != 0 )
        add_path_constprop_0_isra_0(v12, (__int64 *)v10[110]);
    }
  }
LABEL_3:
  add_path_constprop_0_isra_0(v12, (__int64 *)_rtld_env_path_list);
  if ( (cache_rpath((__int64)a1, a1 + 127, 29, (__int64)"RUNPATH") & 1) != 0 )
    add_path_constprop_0_isra_0(v12, (__int64 *)a1[127]);
  result = *((unsigned int *)a1 + 265);
  if ( (result & 0x800) == 0 )
    result = (__int64)add_path_constprop_0_isra_0(v12, (__int64 *)_rtld_search_dirs);
  if ( v5 )
  {
    result = *(_QWORD *)a2 + 16 * (*(unsigned int *)(a2 + 8) + 1LL);
    *(_QWORD *)a2 = result;
  }
  return result;
}
// 48E660: using guessed type _UNKNOWN *_rtld_env_path_list;
// 48E670: using guessed type __int64 _rtld_search_dirs;
// 4914A8: using guessed type __int64 *dl_ns;

//----- (000000000041B340) ----------------------------------------------------
__int64 __fastcall dl_sysdep_read_whole_file(const char *a1, size_t *a2, int a3)
{
  int v5; // w0
  int v7; // w0
  int v8; // w4
  size_t v9; // x1
  __int64 v10; // x1
  unsigned __int64 v11; // x0
  int v12; // [xsp+28h] [xbp+28h]
  __int64 v13; // [xsp+28h] [xbp+28h]
  char v14; // [xsp+30h] [xbp+30h] BYREF
  size_t v15; // [xsp+60h] [xbp+60h]

  v5 = _open_nocancel(a1, 0x80000);
  if ( v5 < 0 )
    return -1LL;
  v12 = v5;
  v7 = fstat64(v5, (struct stat *)&v14);
  v8 = v12;
  if ( (v7 & 0x80000000) == 0 && (v9 = v15, *a2 = v15, v9) )
  {
    v11 = mmap64(0LL, v9, a3, 2, v12, 0LL);
    v8 = v12;
    v10 = v11;
  }
  else
  {
    v10 = -1LL;
  }
  v13 = v10;
  _close_nocancel(v8);
  return v13;
}

//----- (000000000041B3E0) ----------------------------------------------------
__int64 __fastcall dl_name_match_p(unsigned __int64 *a1, __int64 a2)
{
  unsigned __int64 *v4; // x19

  if ( !(unsigned int)strcmp(a1, *(_QWORD *)(a2 + 8)) )
    return 1LL;
  v4 = *(unsigned __int64 **)(a2 + 56);
  if ( v4 )
  {
    while ( (unsigned int)strcmp(a1, *v4) )
    {
      v4 = (unsigned __int64 *)v4[1];
      if ( !v4 )
        return 0LL;
    }
    return 1LL;
  }
  return 0LL;
}

//----- (000000000041B444) ----------------------------------------------------
__int64 __fastcall dl_higher_prime_number(unsigned __int64 a1)
{
  int *v1; // x2
  int *v2; // x3
  int *v3; // x4

  v1 = (int *)&primes_0;
  v2 = &dword_45B9D8;
  while ( v2 != v1 )
  {
    v3 = &v1[(__int64)(((unsigned __int64)((char *)v2 - (char *)v1) >> 63) + v2 - v1) >> 1];
    if ( (unsigned int)*v3 < a1 )
      v1 = v3 + 1;
    else
      v2 = &v1[(__int64)(((unsigned __int64)((char *)v2 - (char *)v1) >> 63) + v2 - v1) >> 1];
  }
  return (unsigned int)*v2;
}
// 45B9D8: using guessed type int dword_45B9D8;

//----- (000000000041B490) ----------------------------------------------------
unsigned __int64 __fastcall dl_strtoul(unsigned __int8 *a1, _QWORD *a2)
{
  unsigned __int8 *v2; // x3
  int v3; // w0
  int v5; // t1
  int v7; // w10
  int v8; // w2
  int v9; // w0
  int v10; // w9
  unsigned __int64 v11; // x5
  unsigned __int64 v12; // x4
  unsigned int v13; // w2
  unsigned int v14; // w8
  unsigned __int64 result; // x0
  signed int v16; // w2
  bool v17; // zf

  v2 = a1;
  v3 = *a1;
  if ( v3 == 32 || v3 == 9 )
  {
    do
    {
      v5 = *++v2;
      v3 = v5;
    }
    while ( v5 == 32 || v3 == 9 );
  }
  if ( v3 == 45 )
  {
    ++v2;
    v7 = 0;
  }
  else
  {
    v7 = 1;
    if ( v3 == 43 )
      ++v2;
  }
  v8 = *v2;
  if ( (unsigned __int8)(v8 - 48) <= 9u )
  {
    if ( v8 == 48 )
    {
      if ( (v2[1] & 0xDF) == 0x58 )
      {
        v2 += 2;
        v9 = 0;
        v10 = 16;
        v11 = 15LL;
        v12 = 0xFFFFFFFFFFFFFFFLL;
      }
      else
      {
        v9 = 1;
        v10 = 8;
        v11 = 7LL;
        v12 = 0x1FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      v9 = 0;
      v10 = 10;
      v11 = 5LL;
      v12 = 0x1999999999999999LL;
    }
    v13 = *v2;
    if ( v9 )
      v14 = 55;
    else
      v14 = 57;
    result = 0LL;
    if ( v13 <= 0x2F )
    {
LABEL_28:
      if ( a2 )
        *a2 = v2;
      if ( !v7 )
        return -(__int64)result;
      return result;
    }
    while ( v13 > v14 )
    {
      if ( v10 != 16 )
        goto LABEL_28;
      if ( (unsigned __int8)(v13 - 97) > 5u )
      {
        if ( (unsigned __int8)(v13 - 65) > 5u )
          goto LABEL_28;
        v16 = v13 - 55;
LABEL_22:
        v17 = result == v12;
        if ( result > v12 )
          goto LABEL_38;
        goto LABEL_23;
      }
      v16 = v13 - 87;
      v17 = result == v12;
      if ( result > v12 )
        goto LABEL_38;
LABEL_23:
      if ( v17 && v16 > v11 )
      {
LABEL_38:
        if ( a2 )
          *a2 = v2;
        return -1LL;
      }
      ++v2;
      result = v16 + v10 * result;
      v13 = *v2;
      if ( v13 <= 0x2F )
        goto LABEL_28;
    }
    v16 = v13 - 48;
    goto LABEL_22;
  }
  if ( a2 )
    *a2 = v2;
  return 0LL;
}

//----- (000000000041B620) ----------------------------------------------------
__int64 __fastcall dl_add_to_namespace_list(
        __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        void *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  __int64 *v24; // x2
  __int64 *v25; // x3
  __int64 v26; // x0

  pthread_mutex_lock(dl_load_write_lock, a8, a9, a10, a11, a12, a13, a14, a15, a2, a3, a4, a5, a6, a7);
  v24 = (&dl_ns)[21 * a2];
  if ( v24 )
  {
    do
    {
      v25 = v24;
      v24 = (__int64 *)v24[3];
    }
    while ( v24 );
    a1[4] = (__int64)v25;
    v25[3] = (__int64)a1;
  }
  else
  {
    (&dl_ns)[21 * a2] = a1;
  }
  ++LODWORD((&dl_ns)[21 * a2 + 1]);
  v26 = dl_load_adds;
  a1[151] = dl_load_adds;
  dl_load_adds = v26 + 1;
  return pthread_mutex_unlock(dl_load_write_lock, v16, v17, v18, v19, v20, v21, v22, v23);
}
// 41B6B4: variable 'v16' is possibly undefined
// 41B6B4: variable 'v17' is possibly undefined
// 41B6B4: variable 'v18' is possibly undefined
// 41B6B4: variable 'v19' is possibly undefined
// 41B6B4: variable 'v20' is possibly undefined
// 41B6B4: variable 'v21' is possibly undefined
// 41B6B4: variable 'v22' is possibly undefined
// 41B6B4: variable 'v23' is possibly undefined
// 490F60: using guessed type int dl_load_write_lock[12];
// 490FC8: using guessed type __int64 dl_load_adds;
// 4914A8: using guessed type __int64 *dl_ns;

//----- (000000000041B6C0) ----------------------------------------------------
int8x16_t *(__fastcall *__fastcall dl_new_object(
        char *a1,
        __int64 a2,
        char a3,
        __int64 a4,
        char a5,
        __int64 a6))(int8x16_t *result, unsigned __int8 a2, unsigned __int64 a3)
{
  unsigned __int64 (__fastcall *v11)(__int64); // x25
  __int64 v12; // x2
  void *v13; // x3
  __int64 v14; // x4
  void *v15; // x5
  __int64 v16; // x6
  __int64 v17; // x7
  double v18; // d0
  double v19; // d1
  double v20; // d2
  double v21; // d3
  double v22; // d4
  double v23; // d5
  double v24; // d6
  double v25; // d7
  int8x16_t *(__fastcall *v26)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  int8x16_t *(__fastcall *v27)(int8x16_t *, unsigned __int8, unsigned __int64); // x20
  __int64 (__fastcall *v28)(__int64, __int64 *, unsigned __int64); // x0
  int v29; // w27
  char *v30; // x0
  __int16 v31; // w0
  _QWORD *v32; // x3
  __int64 *v33; // x0
  __int64 *v34; // x1
  int v35; // w1
  int8x16_t *(__fastcall *v36)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  char *v37; // x4
  unsigned __int64 (__fastcall *v38)(__int64); // x0
  __int64 v39; // x1
  __int64 v40; // x2
  void *v41; // x3
  void *v42; // x4
  void *v43; // x5
  void *v44; // x6
  __int64 v45; // x7
  double v46; // d0
  double v47; // d1
  double v48; // d2
  double v49; // d3
  double v50; // d4
  double v51; // d5
  double v52; // d6
  double v53; // d7
  char *v54; // x24
  unsigned __int64 (__fastcall *v55)(__int64); // x26
  unsigned __int64 v56; // x21
  unsigned __int64 v57; // x19
  _DWORD *v58; // x25
  unsigned __int64 v59; // x22
  unsigned __int64 v60; // x0
  __int64 v61; // x2
  void *v62; // x3
  void *v63; // x4
  void *v64; // x5
  void *v65; // x6
  __int64 v66; // x7
  unsigned __int64 (__fastcall *v67)(__int64); // x1
  char *v68; // x0
  char *v69; // x2
  int v70; // t1

  v11 = strlen();
  v26 = calloc((unsigned __int64)v11 + 1249, 1uLL, v12, v13, v18, v19, v20, v21, v22, v23, v24, v25, v14, v15, v16, v17);
  v27 = v26;
  if ( !v26 )
    return v27;
  *((_QWORD *)v26 + 5) = v26;
  *((_QWORD *)v26 + 7) = (char *)v26 + 1224;
  *((_QWORD *)v26 + 99) = (char *)v26 + 1216;
  v28 = j_memcpy();
  v29 = (unsigned __int8)*a1;
  *((_QWORD *)v27 + 153) = v28;
  v30 = (char *)v11 + (_QWORD)v28;
  if ( v29 )
    v30 = a1;
  *((_QWORD *)v27 + 1) = v30;
  v31 = *((_WORD *)v27 + 434);
  *((_DWORD *)v27 + 310) = 1;
  *((_WORD *)v27 + 434) = v31 & 0xFFFC | a3 & 3;
  if ( (dl_debug_mask & 0x100) == 0 )
    *((_DWORD *)v27 + 263) = 1;
  *((_QWORD *)v27 + 121) = 4LL;
  v32 = (_QWORD *)((char *)v27 + 936);
  *((_QWORD *)v27 + 6) = a6;
  *((_QWORD *)v27 + 101) = a4;
  v33 = (&dl_ns)[21 * a6];
  *((_QWORD *)v27 + 122) = (char *)v27 + 936;
  if ( v33 )
  {
    v34 = v33 + 97;
    *((_QWORD *)v27 + 117) = v33 + 97;
    if ( !a4 )
    {
      v36 = v27;
      goto LABEL_27;
    }
    v35 = 1;
  }
  else
  {
    v35 = 0;
    if ( !a4 )
    {
      v37 = (char *)v27 + 776;
LABEL_11:
      *v32 = v37;
      goto LABEL_12;
    }
  }
  do
  {
    v36 = (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))a4;
    a4 = *(_QWORD *)(a4 + 808);
  }
  while ( a4 );
  v37 = (char *)v36 + 776;
  if ( !v35 )
    goto LABEL_11;
  v34 = (__int64 *)*((_QWORD *)v27 + 117);
LABEL_27:
  v37 = (char *)v36 + 776;
  if ( v34 != (__int64 *)((char *)v36 + 776) )
  {
    if ( (a5 & 8) != 0 )
      *((_QWORD *)v27 + 118) = v34;
    else
      v32 = (_QWORD *)((char *)v27 + 944);
    goto LABEL_11;
  }
LABEL_12:
  *((_QWORD *)v27 + 123) = (char *)v27 + 776;
  if ( v29 )
  {
    v38 = strlen();
    v54 = (char *)v38 + 1;
    v55 = v38;
    v56 = (unsigned __int64)v38 + 1;
    v57 = 0LL;
    if ( v29 == 47 )
    {
      v57 = malloc((__int64)v38 + 1, v39, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53);
      if ( !v57 )
      {
LABEL_35:
        *((_QWORD *)v27 + 114) = -1LL;
        return v27;
      }
    }
    else
    {
      v58 = (_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
      while ( 1 )
      {
        v56 += 128LL;
        v59 = v57;
        v60 = realloc(v57, v56, v40, v41, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53);
        v57 = v60;
        if ( !v60 )
        {
          v57 = v59;
LABEL_37:
          free(v57, v46, v47, v48, v49, v50, v51, v52, v53);
          goto LABEL_35;
        }
        if ( getcwd(v60, v56 - (_QWORD)v55 - 1, v61, v62, v63, v64, v65, v66, v46, v47, v48, v49, v50, v51, v52, v53) )
          break;
        if ( *v58 != 34 )
          goto LABEL_37;
      }
      v67 = strlen();
      if ( *((_BYTE *)v67 + v57 - 1) != 47 )
        *((_BYTE *)v67 + v57) = 47;
    }
    v68 = &v54[(_QWORD)j_memcpy()];
    do
    {
      v69 = v68;
      v70 = (unsigned __int8)*--v68;
    }
    while ( v70 != 47 );
    *((_QWORD *)v27 + 114) = v57;
    if ( (char *)v57 == v68 )
      v68 = v69;
    *v68 = 0;
  }
  return v27;
}
// 41B708: variable 'v12' is possibly undefined
// 41B708: variable 'v13' is possibly undefined
// 41B708: variable 'v18' is possibly undefined
// 41B708: variable 'v19' is possibly undefined
// 41B708: variable 'v20' is possibly undefined
// 41B708: variable 'v21' is possibly undefined
// 41B708: variable 'v22' is possibly undefined
// 41B708: variable 'v23' is possibly undefined
// 41B708: variable 'v24' is possibly undefined
// 41B708: variable 'v25' is possibly undefined
// 41B708: variable 'v14' is possibly undefined
// 41B708: variable 'v15' is possibly undefined
// 41B708: variable 'v16' is possibly undefined
// 41B708: variable 'v17' is possibly undefined
// 41B834: variable 'v40' is possibly undefined
// 41B834: variable 'v41' is possibly undefined
// 41B834: variable 'v42' is possibly undefined
// 41B834: variable 'v43' is possibly undefined
// 41B834: variable 'v44' is possibly undefined
// 41B834: variable 'v45' is possibly undefined
// 41B834: variable 'v46' is possibly undefined
// 41B834: variable 'v47' is possibly undefined
// 41B834: variable 'v48' is possibly undefined
// 41B834: variable 'v49' is possibly undefined
// 41B834: variable 'v50' is possibly undefined
// 41B834: variable 'v51' is possibly undefined
// 41B834: variable 'v52' is possibly undefined
// 41B834: variable 'v53' is possibly undefined
// 41B848: variable 'v61' is possibly undefined
// 41B848: variable 'v62' is possibly undefined
// 41B848: variable 'v63' is possibly undefined
// 41B848: variable 'v64' is possibly undefined
// 41B848: variable 'v65' is possibly undefined
// 41B848: variable 'v66' is possibly undefined
// 41B910: variable 'v39' is possibly undefined
// 4914A8: using guessed type __int64 *dl_ns;
// 496C20: using guessed type __int64 dl_debug_mask;

//----- (000000000041B940) ----------------------------------------------------
unsigned __int64 __fastcall dl_get_origin(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        __int64 a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        void *a13,
        __int64 a14,
        void *a15,
        __int64 a16)
{
  __int64 v16; // x3
  ssize_t v17; // x0
  __int64 v18; // x2
  char *v19; // x1
  int v20; // t1
  unsigned __int64 result; // x0
  __int64 v22; // x1
  void *v23; // x3
  void *v24; // x4
  void *v25; // x5
  void *v26; // x6
  __int64 v27; // x7
  double v28; // d0
  double v29; // d1
  double v30; // d2
  double v31; // d3
  double v32; // d4
  double v33; // d5
  double v34; // d6
  double v35; // d7
  unsigned __int64 v36; // x0
  __int64 (__fastcall *v37)(__int64, __int64 *, unsigned __int64); // x0
  char *v38; // x4
  char *v39; // x1
  unsigned __int64 v40; // x0
  __int64 (__fastcall *v41)(__int64, __int64 *, unsigned __int64); // x0
  char *v42; // x4
  unsigned __int64 (__fastcall *v43)(__int64); // [xsp+10h] [xbp-1010h]
  int v44; // [xsp+10h] [xbp-1010h]
  char *v45; // [xsp+18h] [xbp-1008h]
  char v46[4096]; // [xsp+20h] [xbp-1000h] BYREF

  v16 = 4096LL;
  v17 = linux_eabi_syscall(__NR_readlinkat, -100, "/proc/self/exe", v46, 0x1000uLL);
  if ( (int)v17 <= 0 || v46[0] == 91 )
  {
    if ( dl_origin_path
      && (HIBYTE(v45) = HIBYTE(dl_origin_path),
          v43 = strlen(),
          (v36 = malloc(
                   (__int64)v43 + 1,
                   v22,
                   (__int64)v43,
                   v23,
                   v24,
                   v25,
                   v26,
                   v27,
                   v28,
                   v29,
                   v30,
                   v31,
                   v32,
                   v33,
                   v34,
                   v35)) != 0) )
    {
      v45 = (char *)v36;
      v37 = j_memcpy();
      v38 = v45;
      v39 = (char *)v43 + (_QWORD)v37;
      if ( v45 + 1 < (char *)v43 + (unsigned __int64)v37 )
      {
        do
        {
          if ( *(v39 - 1) != 47 )
            break;
          --v39;
        }
        while ( v45 + 1 != v39 );
      }
      *v39 = 0;
      return (unsigned __int64)v38;
    }
    else
    {
      return -1LL;
    }
  }
  else
  {
    if ( v46[0] != 47 )
      _libc_assert_fail(
        (__int64)"linkval[0] == '/'",
        (__int64)"../sysdeps/unix/sysv/linux/dl-origin.c",
        0x29u,
        (__int64)"_dl_get_origin");
    v18 = (unsigned int)v17;
    v19 = &v46[(int)v17 - 1];
    while ( 1 )
    {
      if ( (_DWORD)v18 == 1 )
      {
        result = malloc(2LL, (__int64)v19, v18, (void *)v16, a13, v46, a15, a16, a1, a2, a3, a4, a5, a6, a7, a8);
        if ( !result )
          return -1LL;
        *(_WORD *)result = 47;
        return result;
      }
      v20 = (unsigned __int8)*v19--;
      v16 = (unsigned int)(v18 - 1);
      if ( v20 == 47 )
        break;
      v18 = (unsigned int)v16;
    }
    v44 = v18 - 1;
    v45 = v46;
    v40 = malloc((int)v18 + 1, (__int64)v19, v18, (void *)v16, a13, v46, a15, a16, a1, a2, a3, a4, a5, a6, a7, a8);
    if ( !v40 )
      return -1LL;
    v45 = (char *)v40;
    v41 = j_memcpy();
    v42 = v45;
    *((_BYTE *)v41 + v44) = 0;
    return (unsigned __int64)v42;
  }
}
// 41BA0C: variable 'v22' is possibly undefined
// 41BA0C: variable 'v23' is possibly undefined
// 41BA0C: variable 'v24' is possibly undefined
// 41BA0C: variable 'v25' is possibly undefined
// 41BA0C: variable 'v26' is possibly undefined
// 41BA0C: variable 'v27' is possibly undefined
// 41BA0C: variable 'v28' is possibly undefined
// 41BA0C: variable 'v29' is possibly undefined
// 41BA0C: variable 'v30' is possibly undefined
// 41BA0C: variable 'v31' is possibly undefined
// 41BA0C: variable 'v32' is possibly undefined
// 41BA0C: variable 'v33' is possibly undefined
// 41BA0C: variable 'v34' is possibly undefined
// 41BA0C: variable 'v35' is possibly undefined
// 496CF0: using guessed type __int64 dl_origin_path;

//----- (000000000041BB00) ----------------------------------------------------
ssize_t __fastcall dl_debug_vdprintf(int a1, int a2, unsigned __int8 *a3, __int64 a4)
{
  unsigned __int8 *v4; // x20
  int v5; // w27
  unsigned __int64 *v6; // x24
  int v7; // w25
  int v8; // w19
  __pid_t v9; // w0
  __pid_t v10; // w26
  __int64 v11; // x0
  int v12; // w1
  unsigned __int8 *v14; // x2
  int v16; // t1
  __int64 v18; // x4
  int v19; // w2
  unsigned int v21; // w1
  unsigned __int8 *v22; // x3
  char v23; // w5
  __int64 v24; // x20
  int v25; // w0
  unsigned int v27; // w1
  unsigned __int8 *v28; // x22
  __int64 v29; // x0
  unsigned __int64 *v30; // x0
  void **v31; // x1
  _BYTE *v32; // x3
  __int64 v33; // x5
  _BYTE *v34; // x1
  size_t v36; // x1
  unsigned int v37; // w7
  unsigned __int64 v38; // x0
  int v39; // w23
  char *v40; // x1
  unsigned int v41; // w2
  unsigned __int64 v42; // x0
  __int64 v43; // x0
  void **v44; // x1
  int *v45; // x0
  char *v46; // x0
  char *v47; // x1
  char v48; // w5
  size_t v49; // x3
  __int64 v50; // x19
  int v51; // w7
  char *v52; // x2
  unsigned int v53; // w2
  char *v54; // [xsp+68h] [xbp+68h]
  char *v55; // [xsp+68h] [xbp+68h]
  __int64 v56; // [xsp+70h] [xbp+70h]
  char v57; // [xsp+78h] [xbp+78h]
  char v58; // [xsp+78h] [xbp+78h]
  _BYTE v60[10]; // [xsp+80h] [xbp+80h] BYREF
  __int16 v61; // [xsp+8Ah] [xbp+8Ah] BYREF
  struct iovec v62[144]; // [xsp+90h] [xbp+90h] BYREF

  if ( !*a3 )
  {
    v19 = 0;
    return linux_eabi_syscall(__NR_writev, a1, v62, v19);
  }
  v4 = a3;
  v5 = a2;
  v6 = *(unsigned __int64 **)a4;
  v56 = *(_QWORD *)(a4 + 8);
  v7 = *(_DWORD *)(a4 + 24);
  if ( a2 == 1 )
  {
    v8 = 0;
    goto LABEL_4;
  }
  v10 = 0;
  v8 = 0;
  while ( 2 )
  {
    while ( 1 )
    {
      v12 = *v4;
      if ( v12 != 37 && v12 != 0 )
        break;
      if ( v8 > 63 )
        goto LABEL_152;
      v62[v8].iov_len = 0LL;
      if ( v12 != 37 )
        goto LABEL_30;
      v14 = v4;
LABEL_36:
      v21 = v14[1];
      if ( v21 == 48 )
      {
        v23 = 48;
        v21 = v14[2];
        v22 = v14 + 2;
        LODWORD(v24) = -1;
        if ( v21 != 42 )
        {
LABEL_38:
          v25 = -1;
          if ( v21 == 46 )
            goto LABEL_59;
          goto LABEL_39;
        }
      }
      else
      {
        v22 = v14 + 1;
        v23 = 32;
        LODWORD(v24) = -1;
        if ( v21 != 42 )
          goto LABEL_38;
      }
      if ( v7 < 0 )
      {
        if ( v7 + 8 <= 0 )
        {
          v30 = (unsigned __int64 *)(v56 + v7);
          v7 += 8;
        }
        else
        {
          v30 = v6;
          v7 += 8;
          v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 11) & 0xFFFFFFFFFFFFFFF8LL);
        }
      }
      else
      {
        v30 = v6;
        v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 11) & 0xFFFFFFFFFFFFFFF8LL);
      }
      LODWORD(v24) = *(_DWORD *)v30;
      if ( *(int *)v30 > 19 )
        _libc_assert_fail((__int64)"width < IFMTSIZE", (__int64)"dl-printf.c", 0x79u, (__int64)"_dl_debug_vdprintf");
      v21 = v22[1];
      v25 = -1;
      ++v22;
      if ( v21 == 46 )
      {
LABEL_59:
        if ( v22[1] != 42 )
          goto LABEL_60;
        if ( v7 < 0 )
        {
          if ( v7 + 8 <= 0 )
          {
            v45 = (int *)(v56 + v7);
            v7 += 8;
          }
          else
          {
            v45 = (int *)v6;
            v7 += 8;
            v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 11) & 0xFFFFFFFFFFFFFFF8LL);
          }
        }
        else
        {
          v45 = (int *)v6;
          v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 11) & 0xFFFFFFFFFFFFFFF8LL);
        }
        v21 = v22[2];
        v22 += 2;
        v25 = *v45;
      }
LABEL_39:
      if ( v21 == 108 || v21 == 122 )
      {
        v27 = v22[1];
        v28 = v22 + 1;
        if ( v27 == 115 )
          goto LABEL_62;
        if ( v27 > 0x73 )
        {
          if ( v27 == 117 )
          {
            if ( (v7 & 0x80000000) == 0 )
            {
              v38 = *v6;
              v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 15) & 0xFFFFFFFFFFFFFFF8LL);
LABEL_92:
              v39 = v8 + 1;
              v40 = (char *)&v62[65].iov_base + 20 * v8 + 4;
              v41 = 10;
              goto LABEL_93;
            }
            if ( v7 + 8 <= 0 )
            {
              v38 = *(_QWORD *)(v56 + v7);
              v7 += 8;
              goto LABEL_92;
            }
            v39 = v8 + 1;
            v38 = *v6;
            v7 += 8;
            v40 = (char *)&v62[65].iov_base + 20 * v8 + 4;
            v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 15) & 0xFFFFFFFFFFFFFFF8LL);
            v41 = 10;
          }
          else
          {
            if ( v27 != 120 )
LABEL_60:
              _libc_assert_fail(
                (__int64)"! \"invalid format specifier\"",
                (__int64)"dl-printf.c",
                0xDDu,
                (__int64)"_dl_debug_vdprintf");
            if ( (v7 & 0x80000000) == 0 )
            {
              v38 = *v6;
              v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 15) & 0xFFFFFFFFFFFFFFF8LL);
              goto LABEL_106;
            }
            if ( v7 + 8 <= 0 )
            {
              v38 = *(_QWORD *)(v56 + v7);
              v7 += 8;
              goto LABEL_106;
            }
            v39 = v8 + 1;
            v38 = *v6;
            v7 += 8;
            v40 = (char *)&v62[65].iov_base + 20 * v8 + 4;
            v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 15) & 0xFFFFFFFFFFFFFFF8LL);
            v41 = 16;
          }
LABEL_93:
          v54 = v40;
          v57 = v23;
          v46 = (char *)itoa_word(v38, (__int64)v40, v41, 0);
          v47 = v54;
          v48 = v57;
          if ( (_DWORD)v24 == -1 )
          {
            v49 = v54 - v46;
          }
          else
          {
            v24 = (int)v24;
            v49 = v54 - v46;
            if ( (int)v24 > v54 - v46 )
            {
              v51 = 0;
              goto LABEL_98;
            }
          }
LABEL_95:
          v50 = v8;
          v4 = v28 + 1;
          v62[v50].iov_base = v46;
          v62[v50].iov_len = v49;
          v8 = v39;
          goto LABEL_30;
        }
        if ( v27 != 37 )
        {
          if ( v27 != 100 )
            goto LABEL_60;
          if ( v7 < 0 )
          {
            if ( v7 + 8 <= 0 )
            {
              v38 = *(_QWORD *)(v56 + v7);
              v7 += 8;
            }
            else
            {
              v7 += 8;
              v38 = *v6;
              v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 15) & 0xFFFFFFFFFFFFFFF8LL);
            }
          }
          else
          {
            v38 = *v6;
            v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 15) & 0xFFFFFFFFFFFFFFF8LL);
          }
          v39 = v8 + 1;
          v40 = (char *)&v62[65].iov_base + 20 * v8 + 4;
          if ( (v38 & 0x8000000000000000LL) == 0 )
          {
            v41 = 10;
            goto LABEL_93;
          }
          v42 = -(__int64)v38;
          goto LABEL_113;
        }
      }
      else
      {
        if ( v21 == 115 )
        {
          v28 = v22;
LABEL_62:
          if ( (v7 & 0x80000000) == 0 )
          {
            v31 = (void **)v6;
            v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 15) & 0xFFFFFFFFFFFFFFF8LL);
            goto LABEL_64;
          }
          if ( v7 + 8 <= 0 )
          {
            v31 = (void **)(v56 + v7);
            v7 += 8;
LABEL_64:
            v32 = *v31;
            v33 = v8;
            v62[v8].iov_base = *v31;
            if ( *v32 )
              goto LABEL_65;
LABEL_85:
            v36 = 0LL;
          }
          else
          {
            v44 = (void **)v6;
            v7 += 8;
            v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 15) & 0xFFFFFFFFFFFFFFF8LL);
            v33 = v8;
            v32 = *v44;
            v62[v8].iov_base = *v44;
            if ( !*v32 )
              goto LABEL_85;
LABEL_65:
            v34 = v32;
            while ( *++v34 )
              ;
            v36 = v34 - v32;
          }
          if ( v25 != -1 && v36 > v25 )
            v36 = v25;
          ++v8;
          v4 = v28 + 1;
          v62[v33].iov_len = v36;
          goto LABEL_30;
        }
        if ( v21 > 0x73 )
        {
          if ( v21 != 117 )
          {
            if ( v21 != 120 )
              goto LABEL_60;
            if ( (v7 & 0x80000000) == 0 )
            {
              v38 = *(unsigned int *)v6;
              v28 = v22;
              v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 11) & 0xFFFFFFFFFFFFFFF8LL);
              goto LABEL_106;
            }
            if ( v7 + 8 > 0 )
            {
              v39 = v8 + 1;
              v38 = *(unsigned int *)v6;
              v7 += 8;
              v40 = (char *)&v62[65].iov_base + 20 * v8 + 4;
              v28 = v22;
              v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 11) & 0xFFFFFFFFFFFFFFF8LL);
              v41 = 16;
              goto LABEL_93;
            }
            v28 = v22;
            v38 = *(unsigned int *)(v56 + v7);
            v7 += 8;
LABEL_106:
            v39 = v8 + 1;
            v40 = (char *)&v62[65].iov_base + 20 * v8 + 4;
            v41 = 16;
            goto LABEL_93;
          }
          if ( (v7 & 0x80000000) == 0 )
          {
            v38 = *(unsigned int *)v6;
            v28 = v22;
            v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 11) & 0xFFFFFFFFFFFFFFF8LL);
            goto LABEL_92;
          }
          if ( v7 + 8 <= 0 )
          {
            v28 = v22;
            v38 = *(unsigned int *)(v56 + v7);
            v7 += 8;
            goto LABEL_92;
          }
          v39 = v8 + 1;
          v38 = *(unsigned int *)v6;
          v7 += 8;
          v40 = (char *)&v62[65].iov_base + 20 * v8 + 4;
          v28 = v22;
          v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 11) & 0xFFFFFFFFFFFFFFF8LL);
          v41 = 10;
          goto LABEL_93;
        }
        v28 = v22;
        if ( v21 != 37 )
        {
          if ( v21 != 100 )
            goto LABEL_60;
          if ( v7 < 0 )
          {
            if ( v7 + 8 <= 0 )
            {
              v37 = *(_DWORD *)(v56 + v7);
              v7 += 8;
            }
            else
            {
              v37 = *(_DWORD *)v6;
              v7 += 8;
              v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 11) & 0xFFFFFFFFFFFFFFF8LL);
            }
            v38 = v37;
          }
          else
          {
            v37 = *(_DWORD *)v6;
            v6 = (unsigned __int64 *)(((unsigned __int64)v6 + 11) & 0xFFFFFFFFFFFFFFF8LL);
            v38 = v37;
          }
          v39 = v8 + 1;
          v28 = v22;
          v40 = (char *)&v62[65].iov_base + 20 * v8 + 4;
          v41 = 10;
          if ( (v37 & 0x80000000) == 0 )
            goto LABEL_93;
          v42 = -v37;
LABEL_113:
          v55 = v40;
          v58 = v23;
          v46 = (char *)itoa_word(v42, (__int64)v40, 0xAu, 0);
          v47 = v55;
          v52 = v46;
          if ( (_DWORD)v24 == -1 || (v24 = (int)v24, v48 = v58, v51 = 1, v55 - v46 >= (int)v24) )
          {
LABEL_101:
            v46 = v52 - 1;
            *(v52 - 1) = 45;
            v49 = v47 - (v52 - 1);
            goto LABEL_95;
          }
LABEL_98:
          v52 = v46;
          do
          {
            *--v52 = v48;
            v49 = v47 - v52;
          }
          while ( v47 - v52 < v24 );
          if ( v51 )
            goto LABEL_101;
          v46 = v52;
          goto LABEL_95;
        }
      }
      v29 = v8++;
      v4 = v28 + 1;
      v62[v29].iov_base = v28;
      v62[v29].iov_len = 1LL;
LABEL_30:
      if ( !*v4 )
        goto LABEL_31;
    }
    v14 = v4;
    while ( !v5 || v12 != 10 )
    {
      v16 = *++v14;
      v12 = v16;
      if ( v16 == 37 || v12 == 0 )
        goto LABEL_24;
    }
    v12 = 10;
LABEL_24:
    if ( v8 > 63 )
    {
LABEL_152:
      v53 = 94;
      goto LABEL_150;
    }
    v18 = v8;
    v62[v18].iov_len = v14 - v4;
    if ( v14 != v4 )
    {
      ++v8;
      v62[v18].iov_base = v4;
    }
    if ( v12 == 37 )
      goto LABEL_36;
    if ( v12 != 10 )
    {
      v4 = v14;
      goto LABEL_30;
    }
    if ( v14 == v4 )
    {
      v43 = v8++;
      v62[v43].iov_base = v14;
      v62[v43].iov_len = 1LL;
    }
    else
    {
      ++v62[v8 - 1].iov_len;
    }
    if ( v14[1] )
    {
      v4 = v14 + 1;
      if ( !v10 )
      {
LABEL_4:
        v9 = getpid();
        v10 = v9;
        if ( v9 < 0 )
          _libc_assert_fail(
            (__int64)"pid >= 0 && sizeof (pid_t) <= 4",
            (__int64)"dl-printf.c",
            0x48u,
            (__int64)"_dl_debug_vdprintf");
        if ( itoa_word(v9, (__int64)&v61, 0xAu, 0) > (unsigned __int64)v60 )
          memset();
        v61 = 2362;
      }
      if ( v8 <= 63 )
      {
        v11 = v8++;
        v5 = -1;
        v62[v11].iov_len = 12LL;
        v62[v11].iov_base = v60;
        continue;
      }
      v53 = 81;
LABEL_150:
      _libc_assert_fail((__int64)"niov < NIOVMAX", (__int64)"dl-printf.c", v53, (__int64)"_dl_debug_vdprintf");
    }
    break;
  }
LABEL_31:
  v19 = v8;
  return linux_eabi_syscall(__NR_writev, a1, v62, v19);
}

//----- (000000000041C324) ----------------------------------------------------
ssize_t dl_debug_printf(unsigned __int8 *a1, ...)
{
  gcc_va_list va1; // [xsp+10h] [xbp+10h] BYREF
  gcc_va_list va; // [xsp+30h] [xbp+30h] BYREF
  __int64 vars88; // [xsp+D8h] [xbp+D8h]
  __int64 vars90; // [xsp+E0h] [xbp+E0h]
  __int64 vars98; // [xsp+E8h] [xbp+E8h]
  __int64 varsA0; // [xsp+F0h] [xbp+F0h]
  __int64 varsA8; // [xsp+F8h] [xbp+F8h]
  __int64 varsB0; // [xsp+100h] [xbp+100h]

  va_start(va, a1);
  vars88 = va_arg(va, _QWORD);
  vars90 = va_arg(va, _QWORD);
  vars98 = va_arg(va, _QWORD);
  varsA0 = va_arg(va, _QWORD);
  varsA8 = va_arg(va, _QWORD);
  varsB0 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a1);
  va_copy(va1, va);
  return dl_debug_vdprintf(dl_debug_fd, 1, a1, (__int64)va1);
}
// 490FC0: using guessed type int dl_debug_fd;

//----- (000000000041C3A0) ----------------------------------------------------
ssize_t dl_debug_printf_c(unsigned __int8 *a1, ...)
{
  gcc_va_list va1; // [xsp+10h] [xbp+10h] BYREF
  gcc_va_list va; // [xsp+30h] [xbp+30h] BYREF
  __int64 vars88; // [xsp+D8h] [xbp+D8h]
  __int64 vars90; // [xsp+E0h] [xbp+E0h]
  __int64 vars98; // [xsp+E8h] [xbp+E8h]
  __int64 varsA0; // [xsp+F0h] [xbp+F0h]
  __int64 varsA8; // [xsp+F8h] [xbp+F8h]
  __int64 varsB0; // [xsp+100h] [xbp+100h]

  va_start(va, a1);
  vars88 = va_arg(va, _QWORD);
  vars90 = va_arg(va, _QWORD);
  vars98 = va_arg(va, _QWORD);
  varsA0 = va_arg(va, _QWORD);
  varsA8 = va_arg(va, _QWORD);
  varsB0 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a1);
  va_copy(va1, va);
  return dl_debug_vdprintf(dl_debug_fd, -1, a1, (__int64)va1);
}
// 490FC0: using guessed type int dl_debug_fd;

//----- (000000000041C420) ----------------------------------------------------
ssize_t dl_dprintf(int a1, unsigned __int8 *a2, ...)
{
  gcc_va_list va1; // [xsp+10h] [xbp+10h] BYREF
  gcc_va_list va; // [xsp+30h] [xbp+30h] BYREF
  __int64 vars80; // [xsp+D0h] [xbp+D0h]
  __int64 vars88; // [xsp+D8h] [xbp+D8h]
  __int64 vars90; // [xsp+E0h] [xbp+E0h]
  __int64 vars98; // [xsp+E8h] [xbp+E8h]
  __int64 varsA0; // [xsp+F0h] [xbp+F0h]
  __int64 varsA8; // [xsp+F8h] [xbp+F8h]

  va_start(va, a2);
  vars80 = va_arg(va, _QWORD);
  vars88 = va_arg(va, _QWORD);
  vars90 = va_arg(va, _QWORD);
  vars98 = va_arg(va, _QWORD);
  varsA0 = va_arg(va, _QWORD);
  varsA8 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a2);
  va_copy(va1, va);
  return dl_debug_vdprintf(a1, 0, a2, (__int64)va1);
}

//----- (000000000041C48C) ----------------------------------------------------
ssize_t dl_printf(unsigned __int8 *a1, ...)
{
  gcc_va_list va1; // [xsp+10h] [xbp+10h] BYREF
  gcc_va_list va; // [xsp+30h] [xbp+30h] BYREF
  __int64 vars88; // [xsp+D8h] [xbp+D8h]
  __int64 vars90; // [xsp+E0h] [xbp+E0h]
  __int64 vars98; // [xsp+E8h] [xbp+E8h]
  __int64 varsA0; // [xsp+F0h] [xbp+F0h]
  __int64 varsA8; // [xsp+F8h] [xbp+F8h]
  __int64 varsB0; // [xsp+100h] [xbp+100h]

  va_start(va, a1);
  vars88 = va_arg(va, _QWORD);
  vars90 = va_arg(va, _QWORD);
  vars98 = va_arg(va, _QWORD);
  varsA0 = va_arg(va, _QWORD);
  varsA8 = va_arg(va, _QWORD);
  varsB0 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a1);
  va_copy(va1, va);
  return dl_debug_vdprintf(1, 0, a1, (__int64)va1);
}

//----- (000000000041C500) ----------------------------------------------------
ssize_t dl_error_printf(unsigned __int8 *a1, ...)
{
  gcc_va_list va1; // [xsp+10h] [xbp+10h] BYREF
  gcc_va_list va; // [xsp+30h] [xbp+30h] BYREF
  __int64 vars88; // [xsp+D8h] [xbp+D8h]
  __int64 vars90; // [xsp+E0h] [xbp+E0h]
  __int64 vars98; // [xsp+E8h] [xbp+E8h]
  __int64 varsA0; // [xsp+F0h] [xbp+F0h]
  __int64 varsA8; // [xsp+F8h] [xbp+F8h]
  __int64 varsB0; // [xsp+100h] [xbp+100h]

  va_start(va, a1);
  vars88 = va_arg(va, _QWORD);
  vars90 = va_arg(va, _QWORD);
  vars98 = va_arg(va, _QWORD);
  varsA0 = va_arg(va, _QWORD);
  varsA8 = va_arg(va, _QWORD);
  varsB0 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a1);
  va_copy(va1, va);
  return dl_debug_vdprintf(2, 0, a1, (__int64)va1);
}

//----- (000000000041C580) ----------------------------------------------------
void __noreturn dl_fatal_printf(unsigned __int8 *a1, ...)
{
  gcc_va_list va1; // [xsp+10h] [xbp+10h] BYREF
  gcc_va_list va; // [xsp+30h] [xbp+30h] BYREF
  __int64 vars88; // [xsp+D8h] [xbp+D8h]
  __int64 vars90; // [xsp+E0h] [xbp+E0h]
  __int64 vars98; // [xsp+E8h] [xbp+E8h]
  __int64 varsA0; // [xsp+F0h] [xbp+F0h]
  __int64 varsA8; // [xsp+F8h] [xbp+F8h]
  __int64 varsB0; // [xsp+100h] [xbp+100h]

  va_start(va, a1);
  vars88 = va_arg(va, _QWORD);
  vars90 = va_arg(va, _QWORD);
  vars98 = va_arg(va, _QWORD);
  varsA0 = va_arg(va, _QWORD);
  varsA8 = va_arg(va, _QWORD);
  varsB0 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a1);
  va_copy(va1, va);
  dl_debug_vdprintf(2, 0, a1, (__int64)va1);
  exit(127);
}

//----- (000000000041C600) ----------------------------------------------------
__int64 __fastcall dl_setup_hash(__int64 result)
{
  __int64 v1; // x1
  unsigned int *v2; // x2
  unsigned int v3; // w1
  unsigned int v4; // w3
  unsigned int v5; // w5
  _DWORD *v6; // x4
  __int64 v7; // x2
  __int64 v8; // x1
  int *v9; // x1
  _DWORD *v10; // x1
  int v11; // t1

  v1 = *(_QWORD *)(result + 744);
  if ( v1 )
  {
    v2 = *(unsigned int **)(v1 + 8);
    if ( (*(_BYTE *)(result + 870) & 0x20) != 0 )
      v2 = (unsigned int *)((char *)v2 + *(_QWORD *)result);
    v3 = *v2;
    *(_DWORD *)(result + 828) = *v2;
    v4 = v2[2];
    if ( ((v4 - 1) & v4) != 0 )
      _libc_assert_fail(
        (__int64)"(bitmask_nwords & (bitmask_nwords - 1)) == 0",
        (__int64)"dl-setup_hash.c",
        0x24u,
        (__int64)"_dl_setup_hash");
    v5 = v2[1];
    *(_DWORD *)(result + 832) = v4 - 1;
    v6 = v2 + 4;
    *(_DWORD *)(result + 836) = v2[3];
    v7 = (__int64)&v2[2 * (v4 & 0x7FFFFFFF) + 4];
    *(_QWORD *)(result + 840) = v6;
    *(_QWORD *)(result + 848) = v7;
    *(_QWORD *)(result + 856) = v7 + 4 * (v3 - (unsigned __int64)v5);
  }
  else
  {
    v8 = *(_QWORD *)(result + 96);
    if ( v8 )
    {
      v9 = *(int **)(v8 + 8);
      if ( (*(_BYTE *)(result + 870) & 0x20) != 0 )
        v9 = (int *)((char *)v9 + *(_QWORD *)result);
      v11 = *v9;
      v10 = v9 + 2;
      *(_DWORD *)(result + 828) = v11;
      *(_QWORD *)(result + 856) = v10;
      *(_QWORD *)(result + 848) = &v10[v11];
    }
  }
  return result;
}
// 41C6E0: using guessed type __int64 dl_allocate_tls_init_part_0(void);

//----- (000000000041C6E0) ----------------------------------------------------
__int64 __fastcall dl_allocate_tls_init_part_0(
        void **a1,
        unsigned __int8 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        void *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  _QWORD *v15; // x26
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  unsigned __int64 v24; // x3
  unsigned __int64 v25; // x28
  unsigned __int64 *v26; // x22
  __int128 v27; // q31
  unsigned __int64 v28; // x4
  unsigned __int64 v29; // x27
  unsigned __int64 v30; // x21
  unsigned __int64 *v31; // x20
  unsigned __int64 v32; // x19
  unsigned __int64 v33; // x0
  __int64 v34; // x1
  __int64 v35; // x0
  __int64 result; // x0
  __int64 v38; // x2
  void *v39; // x4
  void *v40; // x5
  void *v41; // x6
  __int64 v42; // x7
  double v43; // d0
  double v44; // d1
  double v45; // d2
  double v46; // d3
  double v47; // d4
  double v48; // d5
  double v49; // d6
  double v50; // d7
  _QWORD *v51; // x26
  char *v52; // x3
  char *v53; // x25
  int v55; // [xsp+6Ch] [xbp+6Ch]
  char *v56; // [xsp+70h] [xbp+70h]
  unsigned __int64 v57; // [xsp+78h] [xbp+78h]

  v15 = *a1;
  v55 = a2;
  pthread_mutex_lock(dl_load_tls_lock, a8, a9, a10, a11, a12, a13, a14, a15, a2, a3, a4, a5, a6, a7);
  v24 = dl_tls_max_dtv_idx;
  if ( *(v15 - 2) >= (unsigned __int64)dl_tls_max_dtv_idx )
    goto LABEL_2;
  v56 = (char *)dl_tls_max_dtv_idx;
  _aarch64_ldadd4_relax();
  if ( v15 == (_QWORD *)&unk_492218 )
  {
    v51 = (_QWORD *)malloc(
                      16LL * (_QWORD)(v56 + 16),
                      (__int64)&unk_492218,
                      v38,
                      v56,
                      v39,
                      v40,
                      v41,
                      v42,
                      v43,
                      v44,
                      v45,
                      v46,
                      v47,
                      v48,
                      v49,
                      v50);
    if ( v51 )
    {
      j_memcpy();
      v52 = v56;
      goto LABEL_30;
    }
LABEL_36:
    dl_fatal_printf("cannot allocate memory for thread-local data: ABORT\n");
  }
  v51 = (_QWORD *)realloc(
                    (unsigned __int64)(v15 - 2),
                    16LL * (_QWORD)(v56 + 16),
                    v38,
                    v56,
                    v39,
                    v40,
                    v41,
                    v42,
                    v43,
                    v44,
                    v45,
                    v46,
                    v47,
                    v48,
                    v49,
                    v50);
  if ( !v51 )
    goto LABEL_36;
  v52 = v56;
LABEL_30:
  v53 = v52 + 14;
  _aarch64_ldadd4_relax();
  *v51 = v53;
  memset();
  v15 = v51 + 2;
  v24 = dl_tls_max_dtv_idx;
  *a1 = v15;
LABEL_2:
  v25 = 0LL;
  v57 = 0LL;
  v26 = (unsigned __int64 *)dl_tls_dtv_slotinfo_list;
  v27 = xmmword_45B770;
  while ( 1 )
  {
    v28 = *v26;
    v29 = v57 == 0;
    if ( v29 < *v26 )
      break;
LABEL_22:
    v57 += v29;
    if ( v57 > v24 )
      goto LABEL_26;
    v26 = (unsigned __int64 *)v26[1];
    if ( !v26 )
      _libc_assert_fail((__int64)"listp != NULL", (__int64)"dl-tls.c", 0x2B1u, (__int64)"_dl_allocate_tls_init");
  }
  v30 = v57 + v29;
  v31 = &v26[2 * v29];
  while ( v24 >= v30 )
  {
    v32 = v31[3];
    if ( v32 )
    {
      v33 = v31[2];
      if ( v33 > dl_tls_generation )
        _libc_assert_fail(
          (__int64)"listp->slotinfo[cnt].gen <= GL(dl_tls_generation)",
          (__int64)"dl-tls.c",
          0x282u,
          (__int64)"_dl_allocate_tls_init");
      v34 = *(_QWORD *)(v32 + 1176);
      if ( v25 < v33 )
        v25 = v31[2];
      v35 = *(_QWORD *)(v32 + 1168);
      *(_OWORD *)&v15[2 * v34] = v27;
      if ( (unsigned __int64)(v35 + 1) <= 1 )
        goto LABEL_25;
      if ( v34 != v30 )
        _libc_assert_fail(
          (__int64)"map->l_tls_modid == total + cnt",
          (__int64)"dl-tls.c",
          0x28Cu,
          (__int64)"_dl_allocate_tls_init");
      if ( *(_QWORD *)(v32 + 1144) < *(_QWORD *)(v32 + 1136) )
        _libc_assert_fail(
          (__int64)"map->l_tls_blocksize >= map->l_tls_initimage_size",
          (__int64)"dl-tls.c",
          0x28Du,
          (__int64)"_dl_allocate_tls_init");
      v15[2 * v34] = (char *)a1 + v35;
      if ( !*(_QWORD *)(v32 + 48) || v55 == 0 )
      {
        j_memcpy();
        memset();
        v24 = dl_tls_max_dtv_idx;
        v27 = xmmword_45B770;
        if ( (v55 & 1) != 0 )
          *(_WORD *)(v32 + 868) &= ~0x8000u;
        v28 = *v26;
      }
      else
      {
LABEL_25:
        v24 = dl_tls_max_dtv_idx;
      }
    }
    ++v29;
    ++v30;
    v31 += 2;
    if ( v29 >= v28 )
      goto LABEL_22;
  }
LABEL_26:
  result = pthread_mutex_unlock(dl_load_tls_lock, v16, v17, v18, v19, v20, v21, v22, v23);
  *v15 = v25;
  return result;
}
// 41C8A4: variable 'v16' is possibly undefined
// 41C8A4: variable 'v17' is possibly undefined
// 41C8A4: variable 'v18' is possibly undefined
// 41C8A4: variable 'v19' is possibly undefined
// 41C8A4: variable 'v20' is possibly undefined
// 41C8A4: variable 'v21' is possibly undefined
// 41C8A4: variable 'v22' is possibly undefined
// 41C8A4: variable 'v23' is possibly undefined
// 41C908: variable 'v38' is possibly undefined
// 41C908: variable 'v39' is possibly undefined
// 41C908: variable 'v40' is possibly undefined
// 41C908: variable 'v41' is possibly undefined
// 41C908: variable 'v42' is possibly undefined
// 41C908: variable 'v43' is possibly undefined
// 41C908: variable 'v44' is possibly undefined
// 41C908: variable 'v45' is possibly undefined
// 41C908: variable 'v46' is possibly undefined
// 41C908: variable 'v47' is possibly undefined
// 41C908: variable 'v48' is possibly undefined
// 41C908: variable 'v49' is possibly undefined
// 41C908: variable 'v50' is possibly undefined
// 45B770: using guessed type __int128 xmmword_45B770;
// 490F30: using guessed type int dl_load_tls_lock[12];
// 4921E0: using guessed type __int64 dl_tls_max_dtv_idx;
// 4921E8: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 492608: using guessed type __int64 dl_tls_generation;

//----- (000000000041C9F0) ----------------------------------------------------
__int64 __fastcall dl_tls_static_surplus_init(unsigned __int64 a1)
{
  char *v2; // x19
  _BOOL8 v3; // x19
  __int64 result; // x0
  char *v5; // [xsp+38h] [xbp+38h] BYREF

  _tunable_get_val(32LL, &v5, 0LL);
  v2 = v5;
  _tunable_get_val(33LL, &v5, 0LL);
  v3 = v2 != 0LL;
  if ( !v3 < a1 )
    dl_fatal_printf("Failed loading %lu audit modules, %lu are supported.\n", a1, !v3);
  dl_tls_static_optional = (__int64)v5;
  result = (int)v5 + 144 * ((int)v3 + (int)a1 - 1 + (int)v3 + (int)a1) + 144;
  dl_tls_static_surplus = result;
  return result;
}
// 492610: using guessed type __int64 dl_tls_static_optional;
// 492618: using guessed type __int64 dl_tls_static_surplus;

//----- (000000000041CAA0) ----------------------------------------------------
unsigned __int64 __fastcall dl_assign_tls_modid(unsigned __int64 result)
{
  unsigned __int64 v1; // x9
  unsigned __int64 v2; // x1
  __int64 v3; // x6
  unsigned __int64 *v4; // x2
  unsigned __int64 v5; // x5
  __int64 v6; // x4
  unsigned __int64 *v7; // x4

  if ( (dl_tls_dtv_gaps & 1) != 0 )
  {
    v1 = dl_tls_max_dtv_idx;
    v2 = dl_tls_static_nelem + 1;
    if ( dl_tls_static_nelem + 1 > (unsigned __int64)dl_tls_max_dtv_idx )
      goto LABEL_13;
    v3 = 0LL;
    v4 = (unsigned __int64 *)dl_tls_dtv_slotinfo_list;
    v5 = *(_QWORD *)dl_tls_dtv_slotinfo_list;
    while ( 1 )
    {
      while ( 1 )
      {
        v6 = v2 - v3;
        if ( v2 - v3 < v5 )
          break;
        v4 = (unsigned __int64 *)v4[1];
        if ( !v4 )
          goto LABEL_12;
        v3 += v5;
        v5 = *v4;
      }
      if ( !v4[2 * v6 + 3] )
        break;
      if ( dl_tls_max_dtv_idx + 1 < ++v2 )
        _libc_assert_fail(
          (__int64)"result <= GL(dl_tls_max_dtv_idx) + 1",
          (__int64)"dl-tls.c",
          0xB2u,
          (__int64)"_dl_assign_tls_modid");
    }
    v7 = &v4[2 * v6];
    v7[3] = result;
    v7[2] = 0LL;
    v1 = dl_tls_max_dtv_idx;
LABEL_12:
    if ( v2 > v1 )
    {
LABEL_13:
      if ( v1 + 1 != v2 )
        _libc_assert_fail(
          (__int64)"result == GL(dl_tls_max_dtv_idx) + 1",
          (__int64)"dl-tls.c",
          0xC5u,
          (__int64)"_dl_assign_tls_modid");
      dl_tls_dtv_gaps = 0;
      v2 = ++dl_tls_max_dtv_idx;
    }
    *(_QWORD *)(result + 1176) = v2;
  }
  else
  {
    *(_QWORD *)(result + 1176) = ++dl_tls_max_dtv_idx;
  }
  return result;
}
// 4921E0: using guessed type __int64 dl_tls_max_dtv_idx;
// 4921E8: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 4921F0: using guessed type __int64 dl_tls_static_nelem;
// 492628: using guessed type char dl_tls_dtv_gaps;

//----- (000000000041CBD0) ----------------------------------------------------
__int64 dl_count_modids()
{
  __int64 result; // x0
  _QWORD *v1; // x5
  __int64 v2; // x1
  __int64 v3; // x2

  if ( (dl_tls_dtv_gaps & 1) == 0 )
    return dl_tls_max_dtv_idx;
  v1 = (_QWORD *)dl_tls_dtv_slotinfo_list;
  result = 0LL;
  if ( dl_tls_dtv_slotinfo_list )
  {
    do
    {
      v2 = 0LL;
      if ( *v1 )
      {
        do
        {
          v3 = 2 * v2++;
          if ( v1[v3 + 3] )
            ++result;
        }
        while ( *v1 != v2 );
      }
      v1 = (_QWORD *)v1[1];
    }
    while ( v1 );
  }
  return result;
}
// 4921E0: using guessed type __int64 dl_tls_max_dtv_idx;
// 4921E8: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 492628: using guessed type char dl_tls_dtv_gaps;

//----- (000000000041CC48) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 *dl_determine_tlsoffset()
{
  unsigned __int64 v0; // x19
  __int64 *v1; // x3
  unsigned __int64 v2; // x4
  unsigned __int64 v3; // x5
  unsigned __int64 v4; // x20
  unsigned __int64 v5; // x2
  unsigned __int64 v6; // x1
  unsigned __int64 v7; // x0
  unsigned __int64 v8; // x2
  unsigned __int64 v9; // x1
  unsigned __int64 v10; // x0
  unsigned __int64 v11; // x7
  unsigned __int64 v12; // x2
  unsigned __int64 v13; // x21
  __int64 v14; // x0
  unsigned __int64 v15; // x0
  __int64 *result; // x0
  int v17; // [xsp+3Ch] [xbp+3Ch] BYREF

  v0 = 16LL;
  v1 = dl_ns;
  if ( dl_ns )
  {
    v2 = 0LL;
    v3 = 0LL;
    v4 = 32LL;
    while ( 1 )
    {
      while ( 1 )
      {
        v8 = v1[143];
        if ( v8 )
          break;
LABEL_8:
        v1 = (__int64 *)v1[3];
        if ( !v1 )
          goto LABEL_17;
      }
      v9 = v1[144];
      if ( v4 < v9 )
        v4 = v1[144];
      v10 = -v1[145] & (v9 - 1);
      v11 = v8 - v10;
      if ( v8 > v3 - v2 )
        goto LABEL_3;
      v12 = (v2 - 1 + v9) / v9 * v9;
      if ( v12 - v2 < v10 )
        v12 += v9;
      if ( v12 + v11 > v3 )
      {
LABEL_3:
        v5 = (v0 - 1 + v9) / v9 * v9;
        v6 = v5 + v9;
        if ( v5 - v0 < v10 )
          v5 = v6;
        v7 = v5 - v10;
        v1[146] = v7;
        if ( v3 - v2 < v7 - v0 )
        {
          v2 = v0;
          v3 = v7;
        }
        v0 = v5 + v11;
        goto LABEL_8;
      }
      v1[146] = v12 - v10;
      v1 = (__int64 *)v1[3];
      v2 = v12 + v11;
      if ( !v1 )
        goto LABEL_17;
    }
  }
  v4 = 32LL;
LABEL_17:
  _tunable_get_val(26LL, (char **)&v17, 0LL);
  v13 = 32LL;
  if ( v17 )
  {
    if ( (unsigned int)rseq_size >= 0x20 )
      v14 = (unsigned int)rseq_size;
    else
      v14 = 32LL;
    v13 = (v14 + rseq_align - 1) / (unsigned __int64)rseq_align * rseq_align;
  }
  _tunable_get_val(26LL, (char **)&v17, 0LL);
  if ( !v17 )
  {
    v15 = 32LL;
    if ( v4 < 0x20 )
      v4 = 32LL;
LABEL_25:
    v0 = (v0 - 1 + v15) / v15 * v15;
    goto LABEL_26;
  }
  v15 = rseq_align;
  if ( rseq_align >= v4 )
    v4 = rseq_align;
  if ( rseq_align )
    goto LABEL_25;
LABEL_26:
  rseq_offset[0] = (__int64 *)v0;
  dl_tls_static_used = v13 + v0;
  dl_tls_static_size = (dl_tls_static_surplus + 31 + v13 + v0) & 0xFFFFFFFFFFFFFFE0LL;
  result = &dl_tls_static_align;
  dl_tls_static_align = v4;
  return result;
}
// 41CDC4: write access to const memory at 48F790 has been detected
// 48F788: using guessed type int rseq_size;
// 48F790: using guessed type __int64 *rseq_offset[6];
// 4914A8: using guessed type __int64 *dl_ns;
// 4921F8: using guessed type __int64 dl_tls_static_align;
// 492200: using guessed type __int64 dl_tls_static_size;
// 492618: using guessed type __int64 dl_tls_static_surplus;
// 492620: using guessed type __int64 dl_tls_static_used;
// 496BB0: using guessed type __int64 rseq_align;

//----- (000000000041CE30) ----------------------------------------------------
__int64 __fastcall dl_get_tls_static_info(_QWORD *a1, _QWORD *a2)
{
  __int64 result; // x0

  *a1 = dl_tls_static_size;
  result = dl_tls_static_align;
  *a2 = dl_tls_static_align;
  return result;
}
// 4921F8: using guessed type __int64 dl_tls_static_align;
// 492200: using guessed type __int64 dl_tls_static_size;

//----- (000000000041CE60) ----------------------------------------------------
unsigned __int64 dl_allocate_tls_storage()
{
  __int64 v0; // x19
  unsigned __int64 v1; // x21
  __int64 v2; // x1
  __int64 v3; // x2
  void *v4; // x3
  void *v5; // x4
  void *v6; // x5
  void *v7; // x6
  __int64 v8; // x7
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  unsigned __int64 v17; // x0
  unsigned __int64 v18; // x20
  unsigned __int64 v19; // x19
  __int64 v20; // x21
  __int64 v21; // x2
  void *v22; // x3
  __int64 v23; // x4
  void *v24; // x5
  __int64 v25; // x6
  __int64 v26; // x7
  double v27; // d0
  double v28; // d1
  double v29; // d2
  double v30; // d3
  double v31; // d4
  double v32; // d5
  double v33; // d6
  double v34; // d7
  int8x16_t *(__fastcall *v35)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  double v36; // d0
  double v37; // d1
  double v38; // d2
  double v39; // d3
  double v40; // d4
  double v41; // d5
  double v42; // d6
  double v43; // d7

  v0 = dl_tls_static_size;
  _aarch64_ldadd4_relax();
  v1 = dl_tls_static_align;
  v17 = malloc(dl_tls_static_align + v0 + 1832, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16);
  if ( v17 )
  {
    v18 = v17;
    v19 = (v17 + v1 + 1831) / v1 * v1;
    memset();
    *(_QWORD *)(v19 - 1832) = v18;
    v20 = dl_tls_max_dtv_idx;
    v35 = calloc(dl_tls_max_dtv_idx + 16, 0x10uLL, v21, v22, v27, v28, v29, v30, v31, v32, v33, v34, v23, v24, v25, v26);
    if ( v35 )
    {
      *(_QWORD *)v35 = v20 + 14;
      *(_QWORD *)v19 = (char *)v35 + 16;
    }
    else
    {
      v19 = 0LL;
      free(v18, v36, v37, v38, v39, v40, v41, v42, v43);
    }
    _aarch64_ldadd4_relax();
    return v19;
  }
  else
  {
    _aarch64_ldadd4_relax();
    return 0LL;
  }
}
// 41CEA4: variable 'v2' is possibly undefined
// 41CEA4: variable 'v3' is possibly undefined
// 41CEA4: variable 'v4' is possibly undefined
// 41CEA4: variable 'v5' is possibly undefined
// 41CEA4: variable 'v6' is possibly undefined
// 41CEA4: variable 'v7' is possibly undefined
// 41CEA4: variable 'v8' is possibly undefined
// 41CEA4: variable 'v9' is possibly undefined
// 41CEA4: variable 'v10' is possibly undefined
// 41CEA4: variable 'v11' is possibly undefined
// 41CEA4: variable 'v12' is possibly undefined
// 41CEA4: variable 'v13' is possibly undefined
// 41CEA4: variable 'v14' is possibly undefined
// 41CEA4: variable 'v15' is possibly undefined
// 41CEA4: variable 'v16' is possibly undefined
// 41CEF0: variable 'v21' is possibly undefined
// 41CEF0: variable 'v22' is possibly undefined
// 41CEF0: variable 'v27' is possibly undefined
// 41CEF0: variable 'v28' is possibly undefined
// 41CEF0: variable 'v29' is possibly undefined
// 41CEF0: variable 'v30' is possibly undefined
// 41CEF0: variable 'v31' is possibly undefined
// 41CEF0: variable 'v32' is possibly undefined
// 41CEF0: variable 'v33' is possibly undefined
// 41CEF0: variable 'v34' is possibly undefined
// 41CEF0: variable 'v23' is possibly undefined
// 41CEF0: variable 'v24' is possibly undefined
// 41CEF0: variable 'v25' is possibly undefined
// 41CEF0: variable 'v26' is possibly undefined
// 41CF2C: variable 'v36' is possibly undefined
// 41CF2C: variable 'v37' is possibly undefined
// 41CF2C: variable 'v38' is possibly undefined
// 41CF2C: variable 'v39' is possibly undefined
// 41CF2C: variable 'v40' is possibly undefined
// 41CF2C: variable 'v41' is possibly undefined
// 41CF2C: variable 'v42' is possibly undefined
// 41CF2C: variable 'v43' is possibly undefined
// 4921E0: using guessed type __int64 dl_tls_max_dtv_idx;
// 4921F8: using guessed type __int64 dl_tls_static_align;
// 492200: using guessed type __int64 dl_tls_static_size;

//----- (000000000041CF60) ----------------------------------------------------
void **__fastcall dl_allocate_tls_init(
        void **result,
        unsigned __int8 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        void *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  void **v15; // [xsp+18h] [xbp+18h]

  if ( result )
  {
    v15 = result;
    dl_allocate_tls_init_part_0(result, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
    return v15;
  }
  return result;
}

//----- (000000000041CF88) ----------------------------------------------------
void **__fastcall dl_allocate_tls(
        void **a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        void *a12,
        __int64 a13,
        void *a14,
        __int64 a15,
        __int64 a16)
{
  void **tls_storage; // x19
  __int64 v17; // x20
  int8x16_t *(__fastcall *v18)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  __int64 v19; // x2
  __int64 v20; // x3
  __int64 v21; // x4
  void *v22; // x5
  void *v23; // x6
  double v24; // d0
  double v25; // d1
  double v26; // d2
  double v27; // d3
  double v28; // d4
  double v29; // d5
  double v30; // d6
  double v31; // d7

  if ( a1 )
  {
    tls_storage = a1;
    v17 = dl_tls_max_dtv_idx;
    v18 = calloc(dl_tls_max_dtv_idx + 16, 0x10uLL, a11, a12, a2, a3, a4, a5, a6, a7, a8, a9, a13, a14, a15, a16);
    if ( v18 )
    {
      *(_QWORD *)v18 = v17 + 14;
      *tls_storage = (char *)v18 + 16;
LABEL_4:
      dl_allocate_tls_init_part_0(tls_storage, 0, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31);
      return tls_storage;
    }
  }
  else
  {
    tls_storage = (void **)dl_allocate_tls_storage();
    if ( tls_storage )
      goto LABEL_4;
  }
  return 0LL;
}
// 41CFCC: variable 'v19' is possibly undefined
// 41CFCC: variable 'v20' is possibly undefined
// 41CFCC: variable 'v21' is possibly undefined
// 41CFCC: variable 'v22' is possibly undefined
// 41CFCC: variable 'v23' is possibly undefined
// 41CFCC: variable 'v24' is possibly undefined
// 41CFCC: variable 'v25' is possibly undefined
// 41CFCC: variable 'v26' is possibly undefined
// 41CFCC: variable 'v27' is possibly undefined
// 41CFCC: variable 'v28' is possibly undefined
// 41CFCC: variable 'v29' is possibly undefined
// 41CFCC: variable 'v30' is possibly undefined
// 41CFCC: variable 'v31' is possibly undefined
// 4921E0: using guessed type __int64 dl_tls_max_dtv_idx;

//----- (000000000041D000) ----------------------------------------------------
void __fastcall dl_deallocate_tls(
        void **a1,
        char a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  _QWORD *v11; // x20
  unsigned __int64 v13; // x19

  v11 = *a1;
  if ( *((_QWORD *)*a1 - 2) )
  {
    v13 = 0LL;
    do
    {
      ++v13;
      free(v11[2 * v13 + 1], a3, a4, a5, a6, a7, a8, a9, a10);
    }
    while ( v13 < *(v11 - 2) );
  }
  if ( v11 != (_QWORD *)&unk_492218 )
    free((unsigned __int64)(v11 - 2), a3, a4, a5, a6, a7, a8, a9, a10);
  if ( (a2 & 1) != 0 )
    free((unsigned __int64)*(a1 - 229), a3, a4, a5, a6, a7, a8, a9, a10);
}
// 41D03C: variable 'a3' is possibly undefined
// 41D03C: variable 'a4' is possibly undefined
// 41D03C: variable 'a5' is possibly undefined
// 41D03C: variable 'a6' is possibly undefined
// 41D03C: variable 'a7' is possibly undefined
// 41D03C: variable 'a8' is possibly undefined
// 41D03C: variable 'a9' is possibly undefined
// 41D03C: variable 'a10' is possibly undefined

//----- (000000000041D0A0) ----------------------------------------------------
__int64 __fastcall dl_tls_get_addr_soft(__int64 a1)
{
  unsigned __int64 v1; // x0
  _QWORD *v2; // x1
  __int64 result; // x0
  unsigned __int64 *v4; // x3
  unsigned __int64 v5; // x2
  unsigned __int64 i; // x4

  v1 = *(_QWORD *)(a1 + 1176);
  if ( !v1 )
    return 0LL;
  v2 = *(_QWORD **)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( *v2 != dl_tls_generation )
  {
    if ( *(v2 - 2) <= v1 )
      return 0LL;
    v4 = (unsigned __int64 *)dl_tls_dtv_slotinfo_list;
    v5 = v1;
    for ( i = *(_QWORD *)dl_tls_dtv_slotinfo_list; *v4 <= v5; i = *v4 )
    {
      v4 = (unsigned __int64 *)v4[1];
      v5 -= i;
    }
    if ( *v2 < v4[2 * v5 + 2] )
      return 0LL;
  }
  result = v2[2 * v1];
  if ( result == -1 )
    return 0LL;
  return result;
}
// 4921E8: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 492608: using guessed type __int64 dl_tls_generation;

//----- (000000000041D130) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 dl_tls_initial_modid_limit_setup()
{
  __int64 result; // x0
  __int64 v1; // x1

  result = 1LL;
  if ( *(_QWORD *)dl_tls_dtv_slotinfo_list > 1uLL )
  {
    do
    {
      v1 = *(_QWORD *)(dl_tls_dtv_slotinfo_list + 24 + 16 * result);
      if ( !v1 )
        break;
      if ( (*(_WORD *)(v1 + 868) & 2) != 0 )
        break;
      ++result;
    }
    while ( result != *(_QWORD *)dl_tls_dtv_slotinfo_list );
  }
  dl_tls_initial_modid_limit = result;
  return result;
}
// 41D178: write access to const memory at 48E680 has been detected
// 48E680: using guessed type __int64 dl_tls_initial_modid_limit;
// 4921E8: using guessed type __int64 dl_tls_dtv_slotinfo_list;

//----- (000000000041D180) ----------------------------------------------------
__int64 __fastcall dl_add_to_slotinfo(unsigned __int64 a1, char a2)
{
  unsigned __int64 v2; // x5
  char v3; // w6
  unsigned __int64 *v4; // x4
  unsigned __int64 v5; // x3
  unsigned __int64 *v7; // x3
  __int64 v8; // x1
  __int64 v9; // x2
  void *v10; // x3
  void *v11; // x4
  void *v12; // x5
  void *v13; // x6
  __int64 v14; // x7
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  unsigned __int64 *v23; // x7
  unsigned __int64 *v24; // [xsp+10h] [xbp+10h]
  unsigned __int64 *v25; // [xsp+18h] [xbp+18h]
  unsigned __int64 *v26; // [xsp+20h] [xbp+20h]
  unsigned __int64 v27; // [xsp+20h] [xbp+20h]
  unsigned __int64 v28; // [xsp+28h] [xbp+28h]
  char v30; // [xsp+30h] [xbp+30h]

  v2 = a1;
  if ( !*(_QWORD *)(a1 + 1144) || *(char *)(a1 + 870) < 0 )
    return 0LL;
  v3 = a2;
  v4 = (unsigned __int64 *)dl_tls_dtv_slotinfo_list;
  v5 = *(_QWORD *)(a1 + 1176);
  while ( *v4 <= v5 )
  {
    v5 -= *v4;
    if ( !v4[1] )
    {
      if ( v5 )
        _libc_assert_fail((__int64)"idx == 0", (__int64)"dl-tls.c", 0x4A2u, (__int64)"_dl_add_to_slotinfo");
      v26 = v4;
      _aarch64_ldadd4_relax();
      v24 = (unsigned __int64 *)malloc(1008LL, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22);
      _aarch64_ldadd4_relax();
      if ( !v24 )
        dl_signal_error(0xCu, (__int64)"dlopen", 0LL, "cannot create TLS data structures");
      v25 = v26;
      v27 = 0LL;
      v28 = a1;
      v30 = a2;
      *v24 = 62LL;
      v24[1] = 0LL;
      memset();
      v23 = v24;
      atomic_store((unsigned __int64)v24, v25 + 1);
      v3 = v30;
      v5 = v27;
      v2 = v28;
      v4 = v23;
      break;
    }
    v4 = (unsigned __int64 *)v4[1];
  }
  if ( (v3 & 1) != 0 )
  {
    v7 = &v4[2 * v5];
    v7[3] = v2;
    v7[2] = dl_tls_generation + 1;
    *(_BYTE *)(v2 + 870) |= 0x80u;
  }
  return 1LL;
}
// 41D248: variable 'v8' is possibly undefined
// 41D248: variable 'v9' is possibly undefined
// 41D248: variable 'v10' is possibly undefined
// 41D248: variable 'v11' is possibly undefined
// 41D248: variable 'v12' is possibly undefined
// 41D248: variable 'v13' is possibly undefined
// 41D248: variable 'v14' is possibly undefined
// 41D248: variable 'v15' is possibly undefined
// 41D248: variable 'v16' is possibly undefined
// 41D248: variable 'v17' is possibly undefined
// 41D248: variable 'v18' is possibly undefined
// 41D248: variable 'v19' is possibly undefined
// 41D248: variable 'v20' is possibly undefined
// 41D248: variable 'v21' is possibly undefined
// 41D248: variable 'v22' is possibly undefined
// 4921E8: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 492608: using guessed type __int64 dl_tls_generation;

//----- (000000000041D300) ----------------------------------------------------
void dl_init_static_tls()
{
  __int64 v0; // x1
  __int64 v1; // x2
  __int64 v2; // x3
  void *v3; // x4
  void *v4; // x5
  void *v5; // x6
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7
  int v14; // w0
  __int64 *i; // x20
  __int64 *j; // x20
  __int64 v17; // x1
  __int64 v18; // x2
  __int64 v19; // x3
  void *v20; // x4
  void *v21; // x5
  void *v22; // x6
  int v23; // w0

  _aarch64_cas4_acq();
  if ( v14 )
    _lll_lock_wait_private(dl_stack_cache_lock, v6, v7, v8, v9, v10, v11, v12, v13, v0, v1, v2, v3, v4, v5);
  for ( i = (__int64 *)dl_stack_used; i != &dl_stack_used; i = (__int64 *)*i )
  {
    j_memcpy();
    memset();
  }
  for ( j = (__int64 *)dl_stack_user; j != &dl_stack_user; j = (__int64 *)*j )
  {
    j_memcpy();
    memset();
  }
  _aarch64_swp4_rel();
  if ( v23 > 1 )
    _lll_lock_wake_private(dl_stack_cache_lock, v17, v18, v19, v20, v21, v22);
}
// 41D328: variable 'v14' is possibly undefined
// 41D3FC: variable 'v6' is possibly undefined
// 41D3FC: variable 'v7' is possibly undefined
// 41D3FC: variable 'v8' is possibly undefined
// 41D3FC: variable 'v9' is possibly undefined
// 41D3FC: variable 'v10' is possibly undefined
// 41D3FC: variable 'v11' is possibly undefined
// 41D3FC: variable 'v12' is possibly undefined
// 41D3FC: variable 'v13' is possibly undefined
// 41D3FC: variable 'v0' is possibly undefined
// 41D3FC: variable 'v1' is possibly undefined
// 41D3FC: variable 'v2' is possibly undefined
// 41D3FC: variable 'v3' is possibly undefined
// 41D3FC: variable 'v4' is possibly undefined
// 41D3FC: variable 'v5' is possibly undefined
// 41D3E0: variable 'v23' is possibly undefined
// 41D418: variable 'v17' is possibly undefined
// 41D418: variable 'v18' is possibly undefined
// 41D418: variable 'v19' is possibly undefined
// 41D418: variable 'v20' is possibly undefined
// 41D418: variable 'v21' is possibly undefined
// 41D418: variable 'v22' is possibly undefined
// 496C68: using guessed type _DWORD dl_stack_cache_lock[2];
// 496C90: using guessed type __int64 dl_stack_user;
// 496CA0: using guessed type __int64 dl_stack_used;

//----- (000000000041D420) ----------------------------------------------------
__int64 *_tls_pre_init_tp()
{
  __int64 *result; // x0

  dl_stack_used = (__int64)&dl_stack_used;
  *(_QWORD *)algn_496CA8 = &dl_stack_used;
  dl_stack_user = (__int64)&dl_stack_user;
  *(_QWORD *)algn_496C98 = &dl_stack_user;
  result = &dl_stack_cache;
  dl_stack_cache = (__int64)&dl_stack_cache;
  qword_496C88 = (__int64)&dl_stack_cache;
  return result;
}
// 496C80: using guessed type __int64 dl_stack_cache;
// 496C88: using guessed type __int64 qword_496C88;
// 496C90: using guessed type __int64 dl_stack_user;
// 496C98: using guessed type _BYTE[8];
// 496CA0: using guessed type __int64 dl_stack_used;
// 496CA8: using guessed type _BYTE[8];

//----- (000000000041D448) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 __fastcall _tls_init_tp(__int64 a1, __int64 a2, __int64 a3, __int64 a4, void *a5, void *a6, void *a7)
{
  unsigned __int64 StatusReg; // x19
  unsigned __int64 v8; // x3
  _QWORD *v9; // x2
  unsigned __int64 v10; // x20
  signed __int64 v11; // x0
  signed __int64 v12; // x0
  void *v13; // x5
  void *v14; // x6
  char *v15; // x0
  __int64 v16; // x1
  signed __int64 v17; // x0
  __int64 result; // x0
  int v19; // [xsp+2Ch] [xbp+2Ch] BYREF

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v8 = StatusReg - 1536;
  v9 = (_QWORD *)dl_stack_user;
  *(_QWORD *)(v8 + 0xFFFFFFFFFFFFFFA0LL) = dl_stack_user;
  *(_QWORD *)(v8 + 0xFFFFFFFFFFFFFFA0LL + 8) = &dl_stack_user;
  v10 = StatusReg - 1824;
  v9[1] = StatusReg - 1632;
  __dmb(0xBu);
  dl_stack_user = StatusReg - 1632;
  v11 = linux_eabi_syscall(
          __NR_set_tid_address,
          (void *)(StatusReg - 1616),
          (void *)(StatusReg - 1632),
          v9,
          (void *)(StatusReg - 1536),
          a5,
          a6,
          a7);
  *(_DWORD *)(v10 + 0xD0) = v11;
  *(_QWORD *)(v10 + 0x310) = StatusReg - 1552;
  *(_BYTE *)(v10 + 0x412) = 1;
  LOBYTE(v11) = _nptl_initial_report_events;
  *(_QWORD *)(v10 + 0xE8) = -32LL;
  *(_BYTE *)(v10 + 0x411) = v11;
  *(_QWORD *)(v10 + 0xD8) = StatusReg - 1600;
  *(_QWORD *)(v10 + 0xD8 + 8) = StatusReg - 1600;
  v12 = linux_eabi_syscall(
          __NR_set_robust_list,
          (void *)(StatusReg - 1600),
          (void *)0x18,
          v9,
          (void *)(StatusReg - 1536),
          a5,
          a6,
          a7);
  _tunable_get_val(26LL, (char **)&v19, 0LL);
  if ( !v19
    || ((v15 = (char *)rseq_offset[0] + StatusReg,
         *(__int64 *)((char *)rseq_offset[0] + StatusReg) = 0xFFFFFFFF00000000LL,
         (unsigned int)rseq_size < 0x20)
      ? (v16 = 32LL)
      : (v16 = (unsigned int)rseq_size),
        *(__int64 *)((char *)&qword_497268 + (_QWORD)v15) = 0LL,
        *(int *)((char *)&nl_current_LC_CTYPE + (_QWORD)v15) = 0,
        v17 = linux_eabi_syscall(293LL, v15, (void *)v16, 0LL, (void *)0xD428BC00LL, rseq_offset, v13, v14),
        (unsigned int)v17 > 0xFFFFF000) )
  {
    *(_DWORD *)((char *)rseq_offset[0] + StatusReg + (unsigned __int64)&static_TP + 4) = -2;
    rseq_size = 0;
  }
  result = _libc_stack_end;
  *(_QWORD *)(v10 + 0x498) = _libc_stack_end;
  return result;
}
// 41D548: write access to const memory at 48F788 has been detected
// 41D528: variable 'v13' is possibly undefined
// 41D528: variable 'v14' is possibly undefined
// 48F788: using guessed type int rseq_size;
// 48F790: using guessed type __int64 *rseq_offset[6];
// 48F7C8: using guessed type __int64 _libc_stack_end;
// 496BA8: using guessed type char _nptl_initial_report_events;
// 496C90: using guessed type __int64 dl_stack_user;
// 497260: using guessed type __int64 static_TP;
// 497268: using guessed type __int64 qword_497268;
// 497270: using guessed type int nl_current_LC_CTYPE;

//----- (000000000041D580) ----------------------------------------------------
__int64 __fastcall do_tunable_update_val(
        __int64 result,
        unsigned __int64 *a2,
        unsigned __int64 *a3,
        signed __int64 *a4)
{
  unsigned int v4; // w4
  unsigned __int64 v5; // x5
  unsigned __int64 v6; // x1
  signed __int64 v7; // x4
  unsigned __int64 v8; // x6
  unsigned __int64 v9; // x2
  unsigned __int64 v10; // x3
  __int64 v11; // x2
  __int64 v12; // x6
  unsigned __int64 v13; // x3

  v4 = *(_DWORD *)(result + 48);
  if ( v4 > 2 )
  {
    v13 = a2[1];
    *(_QWORD *)(result + 88) = *a2;
    *(_QWORD *)(result + 96) = v13;
    *(_BYTE *)(result + 104) = 1;
    return result;
  }
  if ( v4 )
  {
    v5 = *a2;
    v6 = *(_QWORD *)(result + 56);
    v7 = *(_QWORD *)(result + 64);
    if ( a3 )
    {
      v8 = *a3;
      v9 = *(_QWORD *)(result + 64);
      if ( a4 )
        v9 = *a4;
    }
    else
    {
      if ( a4 )
        v9 = *a4;
      else
        v9 = *(_QWORD *)(result + 64);
      v8 = *(_QWORD *)(result + 56);
    }
    if ( v6 > v8 )
      v10 = *(_QWORD *)(result + 56);
    else
      v10 = v8;
    if ( v9 > v7 )
      v9 = *(_QWORD *)(result + 64);
    if ( v10 <= v9 )
    {
      v6 = v10;
      v7 = v9;
    }
    if ( v5 < v6 || v5 > v7 )
      return result;
LABEL_26:
    *(_QWORD *)(result + 56) = v6;
    *(_QWORD *)(result + 64) = v7;
    *(_QWORD *)(result + 88) = v5;
    *(_BYTE *)(result + 104) = 1;
    return result;
  }
  v5 = *(int *)a2;
  v6 = *(_QWORD *)(result + 56);
  if ( a3 )
  {
    v7 = *(_QWORD *)(result + 64);
    v11 = *a3;
    v12 = v7;
    if ( a4 )
    {
      v12 = *a4;
      if ( *a4 > v7 )
        v12 = *(_QWORD *)(result + 64);
    }
    if ( v11 < (__int64)v6 )
      v11 = *(_QWORD *)(result + 56);
  }
  else
  {
    v7 = *(_QWORD *)(result + 64);
    if ( a4 )
    {
      v12 = *a4;
      v11 = *(_QWORD *)(result + 56);
      if ( *a4 > v7 )
        v12 = *(_QWORD *)(result + 64);
    }
    else
    {
      v12 = *(_QWORD *)(result + 64);
      v11 = *(_QWORD *)(result + 56);
    }
  }
  if ( v12 >= v11 )
  {
    v6 = v11;
    v7 = v12;
  }
  if ( (__int64)v5 >= (__int64)v6 && (__int64)v5 <= v7 )
    goto LABEL_26;
  return result;
}

//----- (000000000041D6A0) ----------------------------------------------------
__int64 __fastcall tunable_initialize(__int64 a1, unsigned __int8 *a2, __int64 a3)
{
  __int64 v3; // x4
  int v4; // w0
  unsigned __int64 v6; // x0
  __int64 v9; // [xsp+28h] [xbp+28h]
  unsigned __int8 *v10; // [xsp+38h] [xbp+38h] BYREF
  unsigned __int64 v11; // [xsp+40h] [xbp+40h] BYREF
  __int64 v12; // [xsp+48h] [xbp+48h]

  v3 = a1;
  v4 = *(_DWORD *)(a1 + 48);
  v11 = 0LL;
  v12 = 0LL;
  if ( v4 == 3 )
  {
    v11 = (unsigned __int64)a2;
    v12 = a3;
LABEL_3:
    do_tunable_update_val(v3, &v11, 0LL, 0LL);
    return 1LL;
  }
  v9 = v3;
  v10 = 0LL;
  v6 = dl_strtoul(a2, &v10);
  v3 = v9;
  if ( v10 == &a2[a3] )
  {
    v11 = v6;
    goto LABEL_3;
  }
  return 0LL;
}

//----- (000000000041D728) ----------------------------------------------------
__int64 __fastcall _tunable_is_initialized(unsigned int a1)
{
  return (unsigned __int8)tunable_list[128 * (unsigned __int64)a1 + 104];
}

//----- (000000000041D740) ----------------------------------------------------
__int64 __fastcall _tunable_set_val(unsigned int a1, unsigned __int64 *a2, unsigned __int64 *a3, signed __int64 *a4)
{
  return do_tunable_update_val((__int64)&tunable_list[128 * (unsigned __int64)a1], a2, a3, a4);
}

//----- (000000000041D760) ----------------------------------------------------
__int64 __fastcall _tunables_init(
        _BYTE **a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  __int64 result; // x0
  int8x16_t *v11; // x21
  _BYTE *v12; // x26
  int v13; // w0
  __int64 v15; // x1
  int v16; // w0
  __int64 v17; // x2
  __int64 v19; // x25
  const char *v20; // x27
  _BYTE *v21; // x1
  char *v22; // x0
  int v23; // w3
  int v24; // t1
  __int64 v26; // x4
  unsigned __int64 v27; // x5
  char *v28; // x3
  int v29; // w1
  _BYTE *v30; // x0
  int v32; // t1
  char *v33; // x5
  __int64 v34; // x1
  __int64 v35; // x0
  __int64 v36; // x19
  __int64 v37; // x22
  unsigned __int8 *v38; // x23
  int8x16_t *v39; // x24
  int v40; // w9
  const char *i; // x10
  int v42; // w0
  const char *v43; // x1
  int v45; // t1
  const char *v47; // x11
  int v48; // w0
  const char *v49; // x6
  int v51; // t1
  const char *v53; // x7
  __int64 v54; // x8
  int v55; // w1
  const char *v56; // x4
  const char *v57; // x2
  int v58; // t1
  const char *v60; // x25
  __int64 v61; // x26
  char *v62; // x27
  const char **v63; // x1
  const char *v64; // x27
  const char *v65; // x25
  __int64 v66; // x26
  unsigned __int64 v67; // x0
  int v68; // w1
  const char *v69; // [xsp+68h] [xbp+68h] BYREF
  __int128 v70; // [xsp+70h] [xbp+70h] BYREF
  _BYTE v71[176]; // [xsp+80h] [xbp+80h] BYREF
  int8x16_t v72[45]; // [xsp+130h] [xbp+130h] BYREF
  const char *v73; // [xsp+400h] [xbp+400h]
  char *v74; // [xsp+408h] [xbp+408h]
  __int64 v75; // [xsp+410h] [xbp+410h]

  result = (unsigned int)_libc_enable_secure;
  if ( _libc_enable_secure )
    return result;
  v11 = (int8x16_t *)&v70;
  v70 = 0u;
  memset(v71, 0, sizeof(v71));
  while ( a1 )
  {
    do
    {
      while ( 1 )
      {
LABEL_4:
        v12 = *a1;
        if ( !*a1 )
          goto LABEL_37;
        v13 = (unsigned __int8)*v12;
        ++a1;
        if ( v13 == 61 || v13 == 0 )
          break;
        v15 = 1LL;
        do
        {
          v16 = (unsigned __int8)v12[v15];
          v17 = v15++;
        }
        while ( v16 != 61 && v16 != 0 );
        if ( v16 )
          goto LABEL_16;
      }
    }
    while ( !*v12 );
    v17 = 0LL;
LABEL_16:
    v19 = v17 + 1;
    v20 = &v12[v17 + 1];
    v21 = v12;
    v22 = "GLIBC_TUNABLES";
    v23 = 71;
    while ( *v21 && (unsigned __int8)*v21 == v23 )
    {
      v24 = (unsigned __int8)*++v22;
      v23 = v24;
      ++v21;
      if ( v22 == "" )
        goto LABEL_23;
    }
    v26 = 0LL;
    if ( v23 )
    {
LABEL_24:
      v27 = 1280LL;
      v28 = (char *)&unk_48EBF1;
      v29 = unk_48EBF1;
      v30 = v12;
      if ( unk_48EBF1 )
        goto LABEL_27;
LABEL_25:
      while ( ++v26 != 8 )
      {
        v27 = (unsigned __int64)tunable_env_alias_list[v26] << 7;
        v28 = &tunable_list[v27 + 105];
        v29 = (unsigned __int8)*v28;
        v30 = v12;
        if ( *v28 )
        {
LABEL_27:
          while ( *v30 && v29 == (unsigned __int8)*v30 )
          {
            v32 = (unsigned __int8)*++v28;
            v29 = v32;
            ++v30;
            if ( !v32 )
            {
              if ( *v30 != 61 )
                goto LABEL_25;
              v33 = &tunable_list[v27];
              v34 = 0LL;
              if ( v12[v19] )
              {
                do
                  ++v34;
                while ( v20[v34] );
              }
              v35 = 24LL * (int)v26;
              *(_QWORD *)&v71[v35 - 8] = v20;
              *(_QWORD *)&v71[v35 - 16] = v33;
              *(_QWORD *)&v71[v35] = v34;
              if ( a1 )
                goto LABEL_4;
              goto LABEL_37;
            }
          }
        }
      }
    }
    else
    {
LABEL_23:
      v26 = 0LL;
      if ( *v21 != 61 )
        goto LABEL_24;
      v39 = v72;
      _memset_generic(v72, 0, 0x330uLL);
      v40 = (unsigned __int8)v12[v19];
      if ( !v12[v19] )
        goto LABEL_82;
      for ( i = v20; ; i = v49 )
      {
        v42 = v40;
        v43 = i;
        if ( v40 != 58 && v40 != 61 )
        {
          while ( v42 )
          {
            v45 = *(unsigned __int8 *)++v43;
            v42 = v45;
            if ( v45 == 61 || v42 == 58 )
              goto LABEL_57;
          }
          goto LABEL_96;
        }
LABEL_57:
        v47 = v43 + 1;
        if ( v42 != 58 )
          break;
        v49 = v43 + 1;
LABEL_80:
        v40 = *(unsigned __int8 *)v49;
      }
      v48 = *((unsigned __int8 *)v43 + 1);
      v49 = v43 + 1;
      if ( v48 == 61 || v48 == 58 )
      {
LABEL_68:
        if ( v48 != 61 )
        {
          v48 = 58;
          goto LABEL_70;
        }
LABEL_96:
        dl_error_printf("WARNING: ld.so: invalid GLIBC_TUNABLES `%s': ignored.\n", v20);
        continue;
      }
      while ( v48 )
      {
        v51 = *(unsigned __int8 *)++v49;
        v48 = v51;
        if ( v51 == 61 || v48 == 58 )
          goto LABEL_68;
      }
LABEL_70:
      v53 = "glibc.cpu.aarch64_gcs";
      v54 = 0LL;
      while ( 2 )
      {
        v55 = *(unsigned __int8 *)v53;
        v56 = v53;
        v57 = i;
        if ( *v53 )
        {
          while ( *v57 && *(unsigned __int8 *)v57 == v55 )
          {
            v58 = *(unsigned __int8 *)++v56;
            v55 = v58;
            ++v57;
            if ( !v58 )
            {
              v68 = *(unsigned __int8 *)v57;
              goto LABEL_86;
            }
          }
LABEL_78:
          ++v54;
          v53 += 128;
          if ( v54 == 34 )
          {
            if ( v48 )
              goto LABEL_80;
            goto LABEL_88;
          }
          continue;
        }
        break;
      }
      v68 = v40;
LABEL_86:
      if ( v68 != 61 )
        goto LABEL_78;
      v63 = (const char **)v72 + 3 * (unsigned int)v54;
      *v63 = v53;
      v63[1] = v47;
      v63[2] = (const char *)(v49 - v47);
      if ( v48 )
        goto LABEL_80;
LABEL_88:
      v64 = v73;
      if ( !v73 )
        goto LABEL_99;
      v65 = v74;
      v66 = v75;
      v69 = 0LL;
      v67 = dl_strtoul((unsigned __int8 *)v74, &v69);
      if ( v69 != &v65[v66] )
      {
        dl_error_printf(
          "WARNING: ld.so: invalid GLIBC_TUNABLES value `%.*s' for option `%s': ignored.\n",
          v66,
          v65,
          v64);
        goto LABEL_82;
      }
      if ( v67 == 1 )
      {
        _libc_enable_secure = 1;
      }
      else
      {
LABEL_99:
        do
        {
LABEL_82:
          v60 = (const char *)v39->n128_u64[0];
          if ( v39->n128_u64[0] )
          {
            v62 = (char *)v39->n128_u64[1];
            v61 = v39[1].n128_i64[0];
            if ( (tunable_initialize(v39->n128_u64[0], (unsigned __int8 *)v62, v61) & 1) == 0 )
              dl_error_printf(
                "WARNING: ld.so: invalid GLIBC_TUNABLES value `%.*s' for option `%s': ignored.\n",
                v61,
                v62,
                v60);
          }
          v39 = (int8x16_t *)((char *)v39 + 24);
        }
        while ( &a9 != (char *)v39 );
      }
    }
  }
LABEL_37:
  result = (unsigned int)_libc_enable_secure;
  if ( !_libc_enable_secure )
  {
    do
    {
      while ( 1 )
      {
        v36 = v11->n128_u64[0];
        if ( v11->n128_u64[0] )
        {
          result = *(unsigned __int8 *)(v36 + 104);
          if ( (result & 1) == 0 )
          {
            v38 = (unsigned __int8 *)v11->n128_u64[1];
            v37 = v11[1].n128_i64[0];
            result = tunable_initialize(v11->n128_u64[0], v38, v37);
            if ( (result & 1) == 0 )
              break;
          }
        }
        v11 = (int8x16_t *)((char *)v11 + 24);
        if ( v72 == v11 )
          return result;
      }
      v11 = (int8x16_t *)((char *)v11 + 24);
      result = dl_error_printf(
                 "WARNING: ld.so: invalid GLIBC_TUNABLES value `%.*s' for option `%s': ignored.\n",
                 v37,
                 (const char *)v38,
                 (const char *)v36);
    }
    while ( v72 != v11 );
  }
  return result;
}
// 45B9E0: using guessed type unsigned int tunable_env_alias_list[8];
// 491570: using guessed type int _libc_enable_secure;

//----- (000000000041DB90) ----------------------------------------------------
ssize_t _tunables_print()
{
  const char *v0; // x19
  ssize_t result; // x0
  unsigned int v2; // w0
  const char *v3; // x2
  int v4; // w1

  v0 = "glibc.cpu.aarch64_gcs";
  do
  {
    while ( 1 )
    {
      if ( *((_DWORD *)v0 + 12) == 3 && !*((_QWORD *)v0 + 11) )
      {
        result = dl_printf("%s:\n", v0);
        goto LABEL_4;
      }
      dl_printf("%s: ", v0);
      v2 = *((_DWORD *)v0 + 12);
      if ( v2 != 2 )
        break;
      result = dl_printf(
                 "0x%zx (min: 0x%zx, max: 0x%zx)\n",
                 *((_QWORD *)v0 + 11),
                 *((_QWORD *)v0 + 7),
                 *((_QWORD *)v0 + 8));
LABEL_4:
      v0 += 128;
      if ( v0 == (const char *)&rseq_size )
        return result;
    }
    if ( v2 <= 2 )
    {
      if ( v2 )
        result = dl_printf(
                   "0x%lx (min: 0x%lx, max: 0x%lx)\n",
                   *((_QWORD *)v0 + 11),
                   *((_QWORD *)v0 + 7),
                   *((_QWORD *)v0 + 8));
      else
        result = dl_printf("%d (min: %d, max: %d)\n", *((_DWORD *)v0 + 22), *((_DWORD *)v0 + 14), *((_DWORD *)v0 + 16));
      goto LABEL_4;
    }
    v3 = (const char *)*((_QWORD *)v0 + 11);
    v4 = *((_DWORD *)v0 + 24);
    v0 += 128;
    result = dl_printf("%.*s\n", v4, v3);
  }
  while ( v0 != (const char *)&rseq_size );
  return result;
}
// 48F788: using guessed type int rseq_size;

//----- (000000000041DC90) ----------------------------------------------------
char *__fastcall _tunable_get_default(unsigned int a1, char **a2)
{
  char *v2; // x2
  unsigned int v3; // w4
  char *result; // x0

  v2 = &tunable_list[128 * (unsigned __int64)a1];
  v3 = *((_DWORD *)v2 + 12);
  if ( v3 > 2 )
  {
    result = &tunable_list[128 * (unsigned __int64)a1 + 72];
    *a2 = result;
  }
  else
  {
    result = (char *)*((_QWORD *)v2 + 9);
    if ( v3 )
      *a2 = result;
    else
      *(_DWORD *)a2 = (_DWORD)result;
  }
  return result;
}

//----- (000000000041DCE0) ----------------------------------------------------
__int64 __fastcall _tunable_get_val(__int64 result, char **a2, __int64 (__fastcall *a3)(char *))
{
  char *v3; // x4
  unsigned int v4; // w6
  char *v5; // x4

  v3 = &tunable_list[128 * (unsigned __int64)(unsigned int)result];
  v4 = *((_DWORD *)v3 + 12);
  if ( v4 > 2 )
  {
    v5 = &tunable_list[128 * (unsigned __int64)(unsigned int)result + 88];
LABEL_3:
    *a2 = v5;
    if ( ((a3 != 0LL) & (unsigned __int8)tunable_list[128 * (unsigned __int64)(unsigned int)result + 104]) == 0 )
      return result;
    return a3(&tunable_list[128 * (unsigned __int64)(unsigned int)result + 88]);
  }
  v5 = (char *)*((_QWORD *)v3 + 11);
  if ( v4 )
    goto LABEL_3;
  *(_DWORD *)a2 = (_DWORD)v5;
  if ( ((a3 != 0LL) & (unsigned __int8)tunable_list[128 * (unsigned __int64)(unsigned int)result + 104]) != 0 )
    return a3(&tunable_list[128 * (unsigned __int64)(unsigned int)result + 88]);
  return result;
}

//----- (000000000041DD80) ----------------------------------------------------
__int64 __fastcall dl_cache_libcmp(_BYTE *a1, unsigned __int8 *a2)
{
  int v2; // w4
  int v3; // w5
  int v4; // w3
  int v5; // w2
  unsigned int v6; // w6
  int v8; // w5
  int v9; // w3
  int v10; // t1
  int v11; // w5
  int v12; // w2
  int v13; // t1

  while ( 1 )
  {
    v2 = (unsigned __int8)*a1;
    if ( !*a1 )
      return (unsigned int)-*a2;
    while ( 1 )
    {
      v3 = *a2;
      v4 = v2 - 48;
      v5 = v3 - 48;
      v6 = (unsigned __int8)(v3 - 48);
      if ( (unsigned __int8)(v2 - 48) <= 9u )
        break;
      if ( v6 <= 9 )
        return 0xFFFFFFFFLL;
      if ( v2 != v3 )
        return (unsigned int)(v2 - v3);
      v2 = (unsigned __int8)*++a1;
      ++a2;
      if ( !v2 )
        return (unsigned int)-*a2;
    }
    if ( v6 > 9 )
      break;
    v8 = (unsigned __int8)*++a1;
    if ( (unsigned __int8)(v8 - 48) <= 9u )
    {
      do
      {
        v9 = v8 + 10 * v4;
        v10 = (unsigned __int8)*++a1;
        v8 = v10;
        v4 = v9 - 48;
      }
      while ( (unsigned __int8)(v10 - 48) <= 9u );
    }
    v11 = *++a2;
    if ( (unsigned __int8)(v11 - 48) <= 9u )
    {
      do
      {
        v12 = v11 + 10 * v5;
        v13 = *++a2;
        v11 = v13;
        v5 = v12 - 48;
      }
      while ( (unsigned __int8)(v13 - 48) <= 9u );
    }
    if ( v4 != v5 )
      return (unsigned int)(v4 - v5);
  }
  return 1LL;
}

//----- (000000000041DE88) ----------------------------------------------------
__int64 __fastcall search_cache(__int64 a1, unsigned int a2, __int64 a3, int a4, unsigned int a5, _BYTE *a6)
{
  int v6; // w11
  __int64 v7; // x14
  _BYTE *v8; // x15
  unsigned int v10; // w12
  __int64 v11; // x13
  int v12; // w10
  unsigned int v14; // w1
  int v15; // w0
  int v16; // w8
  __int64 v17; // x9
  int v19; // w10
  unsigned int *v20; // x9
  __int64 v21; // x9
  unsigned int v22; // w1
  unsigned int v23; // w0

  v6 = a4 - 1;
  if ( a4 - 1 < 0 )
    return 0LL;
  v7 = a5;
  v8 = a6;
  v10 = a2;
  v11 = a1;
  v12 = 0;
  while ( 1 )
  {
    v14 = *(_DWORD *)(a3 + (v6 + v12) / 2 * v7 + 4);
    if ( v14 >= v10 )
      break;
    v15 = dl_cache_libcmp(v8, (unsigned __int8 *)(v11 + v14));
    if ( !v15 )
    {
      v19 = v16;
      v20 = (unsigned int *)(a3 + 4 + (v17 - 1) * v7);
      while ( v19 > 0 && v10 > *v20 && !(unsigned int)dl_cache_libcmp(v8, (unsigned __int8 *)(v11 + *v20)) )
        --v19;
      v21 = a3 + v19 * v7;
      while ( 1 )
      {
        if ( v19 > v16 )
        {
          v22 = *(_DWORD *)(v21 + 4);
          if ( v22 >= v10 || (unsigned int)dl_cache_libcmp(v8, (unsigned __int8 *)(v11 + v22)) )
            break;
        }
        if ( *(_DWORD *)v21 == 2563 )
        {
          v23 = *(_DWORD *)(v21 + 8);
          if ( v23 < v10 && (a5 != 24 || !*(_QWORD *)(v21 + 16)) )
            return v11 + v23;
        }
        ++v19;
        v21 += v7;
        if ( v6 < v19 )
          return 0LL;
      }
      return 0LL;
    }
    if ( v15 < 0 )
    {
      v12 = v16 + 1;
      if ( v6 < v16 + 1 )
        return 0LL;
    }
    else
    {
      v6 = v16 - 1;
      if ( v16 - 1 < v12 )
        return 0LL;
    }
  }
  return 0LL;
}
// 41DEBC: variable 'v16' is possibly undefined
// 41DEC4: variable 'v12' is possibly undefined
// 41DEC8: variable 'v6' is possibly undefined
// 41DED8: variable 'v7' is possibly undefined
// 41DEE4: variable 'v10' is possibly undefined
// 41DEF0: variable 'v8' is possibly undefined
// 41DEE8: variable 'v11' is possibly undefined
// 41DF18: variable 'v17' is possibly undefined
// 41DF2C: variable 'v20' is possibly undefined
// 41DF4C: variable 'v19' is possibly undefined
// 41DF68: variable 'v21' is possibly undefined

//----- (000000000041DFE0) ----------------------------------------------------
__int64 (__fastcall *__fastcall dl_load_cache_lookup(_BYTE *a1))(__int64 result, __int64 *a2, unsigned __int64 a3)
{
  _BYTE *v1; // x5
  int *v2; // x6
  const char *v3; // x1
  int8x16_t *whole_file; // x0
  uint32x4_t v6; // q30
  unsigned __int64 v7; // x0
  unsigned __int64 v8; // x0
  char *v9; // x2
  uint32x4_t v10; // q28
  _BYTE *v11; // [xsp+20h] [xbp+20h]

  v1 = a1;
  if ( (dl_debug_mask & 1) != 0 )
  {
    dl_debug_printf(" search cache=%s\n", "/etc/ld.so.cache");
    v1 = a1;
  }
  v2 = (int *)cache;
  if ( cache )
    goto LABEL_4;
  v11 = v1;
  whole_file = (int8x16_t *)dl_sysdep_read_whole_file("/etc/ld.so.cache", (size_t *)&cachesize, 1);
  v2 = (int *)whole_file;
  if ( whole_file == (int8x16_t *)-1LL )
  {
LABEL_15:
    cache = -1LL;
    return 0LL;
  }
  v1 = v11;
  if ( (unsigned __int64)cachesize <= 0x30 )
  {
    if ( (unsigned __int64)cachesize <= 0x10 )
    {
LABEL_14:
      munmap(v2, cachesize);
      goto LABEL_15;
    }
LABEL_13:
    if ( whole_file->n128_u64[0] == 0x2E312D6F732E646CLL
      && whole_file->n128_u16[4] == 11831
      && whole_file->n128_u8[10] == 48 )
    {
      v7 = whole_file->n128_u32[3];
      if ( v7 <= (cachesize - 16) / 0xCuLL )
      {
        cache = (__int64)v2;
        v8 = (12LL * (unsigned int)v7 + 23) & 0xFFFFFFFFFFFFFFF8LL;
        v9 = (char *)v2 + v8;
        cache_new = (__int64)v2 + v8;
        if ( cachesize >= v8 + 48 )
        {
          v10 = veorq_s8(*(int8x16_t *)((char *)v2 + v8), (int8x16_t)xmmword_45B790);
          if ( !vpmaxq_u32(v10, v10).n128_u64[0] && *((_DWORD *)v9 + 4) == 825110885 )
          {
            if ( !v9[28] || (v9[28] & 3) == 2 )
              goto LABEL_5;
            cache = -1LL;
            cache_new = -1LL;
            munmap(v2, cachesize);
            v1 = v11;
            v2 = (int *)cache;
            if ( !cache )
              _libc_assert_fail(
                (__int64)"cache != NULL",
                (__int64)"dl-cache.c",
                0x1CAu,
                (__int64)"_dl_load_cache_lookup");
LABEL_4:
            if ( v2 != (int *)-1LL )
              goto LABEL_5;
            return 0LL;
          }
        }
        cache_new = -1LL;
LABEL_5:
        if ( cache_new == -1 )
          v3 = (const char *)search_cache(
                               (__int64)&v2[3 * v2[3] + 4],
                               (int)cachesize - (12 * v2[3] + 16),
                               (__int64)(v2 + 4),
                               v2[3],
                               0xCu,
                               v1);
        else
          v3 = (const char *)search_cache(cache_new, cachesize, cache_new + 48, *(_DWORD *)(cache_new + 20), 0x18u, v1);
        if ( (dl_debug_mask & 1) != 0 )
        {
          if ( v3 )
          {
            dl_debug_printf("  trying file=%s\n", v3);
            goto LABEL_9;
          }
        }
        else if ( v3 )
        {
LABEL_9:
          strlen();
          j_memcpy();
          return strdup();
        }
        return 0LL;
      }
    }
    goto LABEL_14;
  }
  v6 = veorq_s8(*whole_file, (int8x16_t)xmmword_45B790);
  if ( vpmaxq_u32(v6, v6).n128_u64[0]
    || whole_file[1].n128_u32[0] != 825110885
    || cachesize / 0x18uLL - 2 < whole_file[1].n128_u32[1] )
  {
    goto LABEL_13;
  }
  if ( !whole_file[1].n128_u8[12] || (whole_file[1].n128_u8[12] & 3) == 2 )
  {
    cache = (__int64)whole_file;
    cache_new = (__int64)whole_file;
    goto LABEL_5;
  }
  munmap(whole_file, cachesize);
  cache = -1LL;
  cache_new = -1LL;
  return 0LL;
}
// 45B790: using guessed type __int128 xmmword_45B790;
// 496BB8: using guessed type __int64 cache;
// 496BC0: using guessed type __int64 cachesize;
// 496BC8: using guessed type __int64 cache_new;
// 496C20: using guessed type __int64 dl_debug_mask;

//----- (000000000041E30C) ----------------------------------------------------
unsigned __int64 dl_unload_cache()
{
  unsigned __int64 result; // x0

  result = cache;
  if ( (unsigned __int64)(cache - 1) <= 0xFFFFFFFFFFFFFFFDLL )
  {
    result = munmap((void *)cache, cachesize);
    cache = 0LL;
  }
  return result;
}
// 496BB8: using guessed type __int64 cache;
// 496BC0: using guessed type __int64 cachesize;

//----- (000000000041E360) ----------------------------------------------------
void __fastcall __noreturn bti_failed_isra_0(const char *a1, const char *a2)
{
  if ( a2 )
    dl_fatal_printf("%s: %s: failed to turn on BTI protection\n", a2, a1);
  dl_signal_error(0, (__int64)a1, "dlopen", "failed to turn on BTI protection");
}

//----- (000000000041E3A0) ----------------------------------------------------
unsigned __int64 __fastcall dl_bti_protect(__int64 a1, int a2)
{
  unsigned __int64 v3; // x3
  unsigned int v4; // w5
  unsigned __int64 result; // x0
  unsigned __int64 v6; // x19
  __int64 v8; // x20
  __int64 v9; // x23
  int v10; // w6
  __int64 v11; // x2
  void *v12; // x0
  size_t v13; // x1
  int v14; // w2
  __int64 v15; // x5
  unsigned __int64 v16; // x0

  v3 = *(_QWORD *)(a1 + 752);
  v4 = *(unsigned __int16 *)(a1 + 768);
  result = v3 + 56LL * *(unsigned __int16 *)(a1 + 768);
  if ( v3 < result )
  {
    result = (unsigned __int64)&dl_pagesize;
    v6 = v3;
    v8 = dl_pagesize - 1;
    v9 = -dl_pagesize;
    while ( 1 )
    {
      if ( *(_DWORD *)v6 != 1 )
        goto LABEL_3;
      v10 = *(_DWORD *)(v6 + 4);
      if ( (v10 & 1) == 0 )
        goto LABEL_3;
      v11 = *(_QWORD *)(v6 + 16);
      v12 = (void *)((v11 & v9) + *(_QWORD *)a1);
      v13 = ((v11 + *(_QWORD *)(v6 + 32) + v8) & v9) - (v11 & v9);
      v14 = ((*(_DWORD *)(v6 + 4) >> 2) & 1) + 20;
      if ( (v10 & 2) != 0 )
        v14 |= 2u;
      if ( a2 == -1 )
      {
        result = mprotect(v12, v13, v14);
        v3 = *(_QWORD *)(a1 + 752);
        v4 = *(unsigned __int16 *)(a1 + 768);
LABEL_3:
        v6 += 56LL;
        if ( v6 >= v3 + 56LL * v4 )
          return result;
      }
      else
      {
        v15 = *(_QWORD *)(v6 + 8);
        v6 += 56LL;
        v16 = mmap64(v12, v13, v14, 2066, a2, v9 & v15);
        v3 = *(_QWORD *)(a1 + 752);
        v4 = *(unsigned __int16 *)(a1 + 768);
        result = v16 == -1LL;
        *(_BYTE *)(a1 + 1088) = result;
        if ( v6 >= v3 + 56LL * v4 )
          return result;
      }
    }
  }
  return result;
}
// 490F10: using guessed type __int64 dl_pagesize;

//----- (000000000041E4B0) ----------------------------------------------------
__int64 __fastcall dl_bti_check(__int64 result, const char *a2)
{
  unsigned int v2; // w4
  __int64 v3; // x4

  if ( (byte_496CD4 & 1) != 0 )
  {
    if ( (*(_BYTE *)(result + 1088) & 1) != 0 )
      bti_failed_isra_0(*(const char **)(result + 8), a2);
    v2 = *(_DWORD *)(result + 784);
    if ( v2 )
    {
      result = *(_QWORD *)(result + 776);
      v3 = result + 8LL * v2;
      do
      {
        if ( (*(_BYTE *)(*(_QWORD *)result + 1088LL) & 1) != 0 )
          bti_failed_isra_0(*(const char **)(*(_QWORD *)result + 8LL), a2);
        result += 8LL;
      }
      while ( v3 != result );
    }
  }
  return result;
}
// 496CD4: using guessed type char byte_496CD4;

//----- (000000000041E520) ----------------------------------------------------
void __fastcall __noreturn fail(__int64 a1, const char *a2)
{
  if ( a2 )
  {
    if ( *a2 )
      dl_fatal_printf("%s: %s: %s\n", a2, *(const char **)(a1 + 8), "not GCS compatible");
    dl_fatal_printf((unsigned __int8 *)"%s\n", "not GCS compatible");
  }
  dl_signal_error(0, *(_QWORD *)(a1 + 8), "dlopen", "not GCS compatible");
}

//----- (000000000041E580) ----------------------------------------------------
__int64 *__fastcall check_gcs_depends(__int64 *result, const char *a2, char a3)
{
  const char *v3; // x5
  int v4; // w4
  __int64 **v5; // x1
  __int64 **v6; // x4

  v3 = a2;
  if ( (*((_BYTE *)result + 1089) & 1) == 0 )
  {
    if ( a2 && (a3 & 1) == 0 )
    {
LABEL_4:
      result = &dl_aarch64_gcs;
      dl_aarch64_gcs = 0LL;
      return result;
    }
LABEL_12:
    fail((__int64)result, a2);
  }
  v4 = *((_DWORD *)result + 196);
  if ( v4 )
  {
    v5 = (__int64 **)result[97];
    v6 = &v5[v4];
    while ( 1 )
    {
      result = *v5;
      if ( (*((_BYTE *)*v5 + 1089) & 1) == 0 )
        break;
      if ( v6 == ++v5 )
        return result;
    }
    if ( !v3 )
      fail((__int64)result, 0LL);
    if ( (a3 & 1) == 0 )
      goto LABEL_4;
    a2 = v3;
    goto LABEL_12;
  }
  return result;
}
// 496CE0: using guessed type __int64 dl_aarch64_gcs;

//----- (000000000041E600) ----------------------------------------------------
__int64 *__fastcall dl_gcs_check(__int64 *result, const char *a2)
{
  char v2; // w2

  if ( dl_aarch64_gcs == 2 )
  {
    v2 = 0;
    return check_gcs_depends(result, a2, v2);
  }
  if ( (unsigned __int64)dl_aarch64_gcs > 2 )
  {
    if ( dl_aarch64_gcs != 3 )
      dl_fatal_printf((unsigned __int8 *)"%s\n", "unsupported GCS policy");
  }
  else if ( dl_aarch64_gcs )
  {
    v2 = 1;
    return check_gcs_depends(result, a2, v2);
  }
  return result;
}
// 496CE0: using guessed type __int64 dl_aarch64_gcs;

//----- (000000000041E660) ----------------------------------------------------
void __fastcall __noreturn dl_gcs_enable_failed(int a1)
{
  dl_fatal_printf("failed to enable GCS: %d\n", -a1);
}

//----- (000000000041E680) ----------------------------------------------------
void *__fastcall dl_early_allocate(__int64 a1)
{
  size_t v1; // x1
  __int64 v2; // x0
  signed __int64 v3; // x2
  void *v5; // x0

  v1 = a1;
  if ( _curbrk )
  {
    v2 = sbrk(a1);
    v1 = a1;
    v3 = v2;
    if ( v2 == -1 )
      goto LABEL_6;
  }
  else
  {
    v3 = linux_eabi_syscall(__NR_brk, 0LL);
    if ( v3 == linux_eabi_syscall(__NR_brk, (void *)(v3 + v1)) )
      goto LABEL_6;
  }
  if ( v3 )
    return (void *)v3;
LABEL_6:
  v5 = linux_eabi_syscall(__NR_mmap, 0LL, v1, 3, 34, -1, 0LL);
  if ( (unsigned __int64)v5 > 0xFFFFFFFFFFFFF000LL )
    return 0LL;
  else
    return v5;
}
// 496B60: using guessed type __int64 _curbrk;

//----- (000000000041E720) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int64 *__fastcall dl_aux_init(__int64 a1)
{
  unsigned __int64 *v1; // x19
  int8x16_t *v2; // x3
  unsigned __int64 v3; // x1
  __int64 v4; // x2
  unsigned __int64 v5; // t1
  __int64 v6; // x1
  int v7; // w4
  __int64 *result; // x0
  int v9; // w1
  __int64 v10; // x1
  int8x16_t v11; // [xsp+20h] [xbp+20h] BYREF
  __int64 v12; // [xsp+38h] [xbp+38h]
  __int64 v13; // [xsp+48h] [xbp+48h]
  __int64 v14; // [xsp+50h] [xbp+50h]
  __int64 v15; // [xsp+98h] [xbp+98h]
  __int64 v16; // [xsp+A0h] [xbp+A0h]
  __int64 v17; // [xsp+A8h] [xbp+A8h]
  int v18; // [xsp+B0h] [xbp+B0h]
  __int64 v19; // [xsp+D8h] [xbp+D8h]
  void *v20; // [xsp+E8h] [xbp+E8h]
  __int64 v21; // [xsp+F0h] [xbp+F0h]
  unsigned __int64 v22; // [xsp+F8h] [xbp+F8h]
  unsigned __int64 v23; // [xsp+100h] [xbp+100h]
  __int64 v24; // [xsp+108h] [xbp+108h]
  __int64 v25; // [xsp+110h] [xbp+110h]
  __int64 v26; // [xsp+128h] [xbp+128h]
  __int64 v27; // [xsp+1B8h] [xbp+1B8h]

  v1 = (unsigned __int64 *)a1;
  dl_auxv = a1;
  v2 = _memset_generic(&v11, 0, 0x1A0uLL);
  v3 = *v1;
  v4 = 0x10000LL;
  v14 = 0x10000LL;
  v27 = 5120LL;
  if ( v3 )
  {
    do
    {
      if ( v3 <= 0x33 )
        v2->n128_u64[v3] = v1[1];
      v5 = v1[2];
      v1 += 2;
      v3 = v5;
    }
    while ( v5 );
    v4 = v14;
    v6 = v27;
    v7 = v18;
  }
  else
  {
    v6 = 5120LL;
    v7 = 0;
  }
  dl_pagesize = v4;
  _libc_enable_secure = v19;
  result = &dl_auxv;
  dl_platform = v15;
  dl_hwcap = v16;
  dl_fpu_control = v7;
  dl_hwcap2 = v21;
  dl_hwcap3 = v24;
  dl_minsigstacksize = v6;
  dl_hwcap4 = v25;
  dl_sysinfo_dso = v26;
  v9 = v22;
  dl_clktck = v17;
  dl_random = v20;
  if ( v22 < 0x14 )
    v9 = 20;
  rseq_size = v9;
  v10 = v23;
  if ( v23 < 0x20 )
    v10 = 32LL;
  rseq_align = v10;
  dl_phdr = v12;
  dl_phnum = v13;
  if ( !v12 )
  {
    dl_phdr = (__int64)&dword_400040;
    dl_phnum = 7LL;
  }
  return result;
}
// 41E7F0: write access to const memory at 48F798 has been detected
// 41E800: write access to const memory at 48F788 has been detected
// 400040: using guessed type int dword_400040;
// 41E888: using guessed type __int64 dl_non_dynamic_init(void);
// 48F788: using guessed type int rseq_size;
// 48F798: using guessed type _UNKNOWN *dl_random;
// 490F10: using guessed type __int64 dl_pagesize;
// 490F18: using guessed type __int64 dl_minsigstacksize;
// 491570: using guessed type int _libc_enable_secure;
// 496BB0: using guessed type __int64 rseq_align;
// 496BD0: using guessed type __int64 dl_auxv;
// 496BD8: using guessed type __int64 dl_platform;
// 496BE0: using guessed type __int64 dl_hwcap;
// 496BE8: using guessed type __int64 dl_hwcap2;
// 496BF0: using guessed type __int64 dl_hwcap3;
// 496BF8: using guessed type __int64 dl_hwcap4;
// 496C00: using guessed type int dl_clktck;
// 496C04: using guessed type int dl_fpu_control;
// 496C08: using guessed type __int64 dl_sysinfo_dso;
// 496C10: using guessed type __int64 dl_phdr;
// 496C18: using guessed type __int64 dl_phnum;

//----- (000000000041E888) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
unsigned __int64 __fastcall dl_non_dynamic_init(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        void *a5,
        __int64 a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  int v16; // w20
  __int64 v17; // x22
  __int64 v18; // x23
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7
  int8x16_t *(__fastcall *v27)(int8x16_t *, unsigned __int8, unsigned __int64); // x19
  __int64 v28; // x4
  int v29; // w2
  __int64 v30; // x0
  __int64 v31; // x2
  int v32; // w1
  unsigned __int64 v33; // x1
  char v34; // w3
  __int64 v35; // x0
  __int64 v36; // x2
  __int64 v37; // x0
  __int64 v38; // x1
  unsigned __int64 v39; // x0
  unsigned __int64 v40; // t1
  __int64 v41; // x1
  __int64 v42; // x0
  __int64 v43; // x0
  __int64 v44; // x1
  __int64 v45; // x0
  __int64 v46; // x0
  __int64 v47; // x2
  __int64 v48; // x3
  __int64 v49; // x4
  void *v50; // x5
  void *v51; // x6
  double v52; // d0
  double v53; // d1
  double v54; // d2
  double v55; // d3
  double v56; // d4
  double v57; // d5
  double v58; // d6
  double v59; // d7
  __int16 v60; // w0
  __int64 v61; // x0
  __int64 v62; // x0
  __int64 v63; // x0
  __int64 v64; // x1
  __int64 v65; // x0
  __int64 (__fastcall **v66)(); // x25
  __int64 *v67; // x0
  double v68; // d0
  double v69; // d1
  double v70; // d2
  double v71; // d3
  double v72; // d4
  double v73; // d5
  double v74; // d6
  double v75; // d7
  __int64 v76; // x2
  bool v77; // zf
  __int64 (*v78)(void); // x2
  __int64 *v79; // x0
  double v80; // d0
  double v81; // d1
  double v82; // d2
  double v83; // d3
  double v84; // d4
  double v85; // d5
  double v86; // d6
  double v87; // d7
  __int64 v88; // x2
  bool v89; // zf
  __int64 v90; // x2
  __int64 *v91; // x0
  double v92; // d0
  double v93; // d1
  double v94; // d2
  double v95; // d3
  double v96; // d4
  double v97; // d5
  double v98; // d6
  double v99; // d7
  __int64 v100; // x2
  bool v101; // zf
  __int64 v102; // x2
  __int64 *v103; // x0
  __int64 v104; // x1
  bool v105; // zf
  __int64 (__fastcall *v106)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD); // x1
  char *v107; // x19
  char *v108; // x0
  char *v109; // x0
  void *v110; // x4
  void *v111; // x5
  void *v112; // x6
  __int64 v113; // x7
  double v114; // d0
  double v115; // d1
  double v116; // d2
  double v117; // d3
  double v118; // d4
  double v119; // d5
  double v120; // d6
  double v121; // d7
  char *v122; // x0
  _BOOL4 v123; // w1
  char *v124; // x0
  _BOOL4 v125; // w1
  char *v126; // x0
  _BOOL4 v127; // w1
  int v128; // w6
  int v129; // w5
  unsigned __int64 v130; // x0
  unsigned __int64 v131; // x2
  __int64 (__fastcall **v132)(); // x25
  __int64 v134; // x1
  unsigned __int64 v135; // x1
  __int64 v136; // x0
  __int64 v137; // x0
  __int64 v138; // x0
  __int64 v139; // x0
  __int64 v140; // x1
  __int64 v141; // x1
  __int64 v142; // x1
  __int64 v143; // x3
  __int64 v144; // x0
  __int64 *v145; // [xsp+60h] [xbp+60h] BYREF
  __int64 v146; // [xsp+68h] [xbp+68h] BYREF
  __int64 v147; // [xsp+70h] [xbp+70h]
  __int64 v148; // [xsp+78h] [xbp+78h]

  qword_491360 = dl_get_origin(a9, a10, a11, a12, a13, a14, a15, a16, a1, a2, a3, a4, a5, a6, a7, a8);
  qword_4912C0 = dl_phdr;
  word_4912D0 = dl_phnum;
  if ( dl_sysinfo_dso )
  {
    v27 = dl_new_object((char *)&qword_454610, (__int64)&qword_454610, 1, 0LL, 0, 0LL);
    if ( v27 )
    {
      v28 = dl_sysinfo_dso;
      v29 = *(unsigned __int16 *)(dl_sysinfo_dso + 56);
      v30 = v28 + *(_QWORD *)(v28 + 32);
      *((_QWORD *)v27 + 94) = v30;
      *((_WORD *)v27 + 384) = v29;
      if ( v29 )
      {
        v31 = v30 + 56 + 56LL * (unsigned int)(v29 - 1);
        do
        {
          while ( 1 )
          {
            v32 = *(_DWORD *)v30;
            if ( *(_DWORD *)v30 != 2 )
              break;
            *((_QWORD *)v27 + 2) = *(_QWORD *)(v30 + 16);
            v33 = *(_QWORD *)(v30 + 40);
            v30 += 56LL;
            v34 = *((_BYTE *)v27 + 870);
            *((_WORD *)v27 + 385) = v33 >> 4;
            *((_BYTE *)v27 + 870) = v34 & 0xDF | (32 * ((*(_DWORD *)(v30 - 52) & 2) == 0));
            if ( v30 == v31 )
              goto LABEL_10;
          }
          if ( v32 == 1 )
          {
            v134 = *(_QWORD *)(v30 + 16);
            if ( !*(_QWORD *)v27 )
              *(_QWORD *)v27 = v134;
            v135 = v134 + *(_QWORD *)(v30 + 40);
            if ( v135 >= *((_QWORD *)v27 + 116) )
              *((_QWORD *)v27 + 116) = v135;
          }
          else if ( v32 == 7 )
          {
            _libc_assert_fail((__int64)"ph->p_type != PT_TLS", (__int64)"setup-vdso.h", 0x39u, (__int64)"setup_vdso");
          }
          v30 += 56LL;
        }
        while ( v30 != v31 );
      }
LABEL_10:
      v35 = *(_QWORD *)v27;
      *((_QWORD *)v27 + 115) = v28;
      v36 = v28 - v35;
      *(_QWORD *)v27 = v28 - v35;
      *((_QWORD *)v27 + 116) += v28 - v35;
      v37 = *((_QWORD *)v27 + 2);
      v38 = v37 + v36;
      *((_QWORD *)v27 + 2) = v37 + v36;
      if ( !(v37 + v36) )
        goto LABEL_39;
      v39 = *(_QWORD *)(v37 + v36);
      if ( v39 )
      {
        do
        {
          if ( v39 > 0x25 )
          {
            if ( v39 - 1879048192 > 5 )
            {
              if ( 1879048191 - v39 > 0xF )
              {
                if ( (unsigned int)(2 * v39) <= 0xFFFFFFF8 )
                {
                  if ( 1879047679 - v39 <= 0xB )
                  {
                    LODWORD(v39) = 1879047742 - v39;
                  }
                  else
                  {
                    if ( 1879047935 - v39 > 0xA )
                      goto LABEL_16;
                    LODWORD(v39) = 1879048010 - v39;
                  }
                }
                else
                {
                  LODWORD(v39) = 59 - ((2 * (int)v39) >> 1);
                }
              }
              else
              {
                LODWORD(v39) = 1879048235 - v39;
              }
            }
            else
            {
              LODWORD(v39) = v39 - 1879048154;
            }
          }
          *((_QWORD *)v27 + (unsigned int)v39 + 8) = v38;
LABEL_16:
          v40 = *(_QWORD *)(v38 + 16);
          v38 += 16LL;
          v39 = v40;
        }
        while ( v40 );
      }
      if ( !v36 || (*((_BYTE *)v27 + 870) & 0x20) != 0 )
      {
        v41 = *((_QWORD *)v27 + 28);
        if ( !v41 )
          goto LABEL_20;
      }
      else
      {
        v136 = *((_QWORD *)v27 + 12);
        if ( v136 )
          *(_QWORD *)(v136 + 8) += v36;
        v137 = *((_QWORD *)v27 + 11);
        if ( v137 )
          *(_QWORD *)(v137 + 8) += v36;
        v138 = *((_QWORD *)v27 + 13);
        if ( v138 )
          *(_QWORD *)(v138 + 8) += v36;
        v139 = *((_QWORD *)v27 + 14);
        if ( v139 )
          *(_QWORD *)(v139 + 8) += v36;
        v42 = *((_QWORD *)v27 + 44);
        if ( v42 )
          *(_QWORD *)(v42 + 8) += v36;
        v140 = *((_QWORD *)v27 + 31);
        if ( v140 )
          *(_QWORD *)(v140 + 8) += v36;
        v141 = *((_QWORD *)v27 + 67);
        if ( v141 )
          *(_QWORD *)(v141 + 8) += v36;
        v142 = *((_QWORD *)v27 + 93);
        if ( v142 )
          *(_QWORD *)(v142 + 8) += v36;
        v143 = *((_QWORD *)v27 + 15);
        v41 = *((_QWORD *)v27 + 28);
        if ( v143 )
        {
          v144 = *(_QWORD *)(v143 + 8);
          if ( v144 )
            *(_QWORD *)(v143 + 8) = v36 + v144;
          if ( !v41 )
            goto LABEL_21;
        }
        else if ( !v41 )
        {
          goto LABEL_23;
        }
      }
      if ( *(_QWORD *)(v41 + 8) != 7LL )
        _libc_assert_fail(
          (__int64)"info[DT_PLTREL]->d_un.d_val == DT_RELA",
          (__int64)"get-dynamic-info.h",
          0x73u,
          (__int64)"elf_get_dynamic_info");
LABEL_20:
      if ( !*((_QWORD *)v27 + 15) )
      {
LABEL_22:
        v42 = *((_QWORD *)v27 + 44);
LABEL_23:
        if ( v42 && *(_QWORD *)(*((_QWORD *)v27 + 45) + 8LL) != 8LL )
          _libc_assert_fail(
            (__int64)"info[DT_RELRENT]->d_un.d_val == sizeof (ElfW(Relr))",
            (__int64)"get-dynamic-info.h",
            0x82u,
            (__int64)"elf_get_dynamic_info");
        v43 = *((_QWORD *)v27 + 38);
        if ( v43 )
        {
          v44 = *(_QWORD *)(v43 + 8);
          *((_DWORD *)v27 + 266) = v44;
          if ( (v44 & 2) != 0 )
            *((_QWORD *)v27 + 24) = v43;
          if ( (v44 & 4) != 0 )
            *((_QWORD *)v27 + 30) = v43;
          if ( (v44 & 8) != 0 )
            *((_QWORD *)v27 + 32) = v43;
        }
        v45 = *((_QWORD *)v27 + 56);
        if ( !v45 )
          goto LABEL_37;
        v46 = *(_QWORD *)(v45 + 8);
        *((_DWORD *)v27 + 265) = v46;
        if ( (v46 & 8) != 0 )
          *((_BYTE *)v27 + 872) = 1;
        if ( (dl_debug_mask & 0x40) != 0 && (v46 & 0xF7FFF716) != 0 )
        {
          dl_debug_printf("\nWARNING: Unsupported flag value(s) of 0x%x in DT_FLAGS_1.\n", v46 & 0xF7FFF716);
          if ( (*((_DWORD *)v27 + 265) & 1) == 0 )
          {
LABEL_37:
            if ( *((_QWORD *)v27 + 37) )
              *((_QWORD *)v27 + 23) = 0LL;
LABEL_39:
            dl_setup_hash((__int64)v27);
            v60 = *((_WORD *)v27 + 434);
            *((_DWORD *)v27 + 263) = 1;
            *((_WORD *)v27 + 434) = v60 | 8;
            v61 = *((_QWORD *)v27 + 123);
            *(_DWORD *)(v61 + 8) = 1;
            *(_QWORD *)v61 = (char *)v27 + 40;
            v62 = *((_QWORD *)v27 + 22);
            if ( v62 )
            {
              v48 = *((unsigned __int8 *)v27 + 870);
              v63 = *(_QWORD *)(v62 + 8);
              v47 = *(_QWORD *)(*((_QWORD *)v27 + 13) + 8LL);
              v64 = 0LL;
              if ( (v48 & 0x20) != 0 )
                v64 = *(_QWORD *)v27;
              v65 = v63 + v47 + v64;
              **((_QWORD **)v27 + 7) = v65;
              *((_QWORD *)v27 + 1) = v65;
            }
            dl_add_to_namespace_list(
              (__int64 *)v27,
              0LL,
              v47,
              v48,
              v49,
              v50,
              v51,
              v52,
              v53,
              v54,
              v55,
              v56,
              v57,
              v58,
              v59);
            v66 = off_490000;
            dl_nns = 1LL;
            dl_sysinfo_map = (__int64)v27;
            goto LABEL_44;
          }
        }
        else if ( (v46 & 1) == 0 )
        {
          goto LABEL_37;
        }
        *((_QWORD *)v27 + 32) = *((_QWORD *)v27 + 56);
        goto LABEL_37;
      }
LABEL_21:
      if ( *(_QWORD *)(*((_QWORD *)v27 + 17) + 8LL) != 24LL )
        _libc_assert_fail(
          (__int64)"info[DT_RELAENT]->d_un.d_val == sizeof (ElfW(Rela))",
          (__int64)"get-dynamic-info.h",
          0x7Bu,
          (__int64)"elf_get_dynamic_info");
      goto LABEL_22;
    }
  }
  v66 = off_490000;
  v27 = (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))dl_sysinfo_map;
  if ( !dl_sysinfo_map )
  {
    dl_vdso_clock_gettime64 = 0LL;
    dl_vdso_gettimeofday = 0LL;
LABEL_146:
    v106 = 0LL;
    dl_vdso_clock_getres_time64 = 0LL;
    goto LABEL_75;
  }
LABEL_44:
  v146 = 0x2000000000LL;
  v147 = 0LL;
  v145 = &v146;
  v148 = 0LL;
  v67 = (__int64 *)dl_lookup_symbol_x(
                     "__kernel_clock_gettime",
                     (__int64)v27,
                     (__int64 *)&v145,
                     (void ***)v27 + 123,
                     (const char **)&rfv_0,
                     0,
                     0,
                     0LL,
                     v19,
                     v20,
                     v21,
                     v22,
                     v23,
                     v24,
                     v25,
                     v26);
  if ( v145 )
  {
    v76 = 0LL;
    if ( v67 )
      v77 = *((unsigned __int16 *)v145 + 3) == 65521;
    else
      v77 = 1;
    if ( !v77 )
      v76 = *v67;
    v78 = (__int64 (*)(void))(v76 + v145[1]);
  }
  else
  {
    v78 = 0LL;
  }
  dl_vdso_clock_gettime64 = v78;
  if ( !dl_sysinfo_map )
  {
    dl_vdso_gettimeofday = 0LL;
    goto LABEL_146;
  }
  v146 = 0x2000000000LL;
  v147 = 0LL;
  v145 = &v146;
  v148 = 0LL;
  v79 = (__int64 *)dl_lookup_symbol_x(
                     "__kernel_gettimeofday",
                     dl_sysinfo_map,
                     (__int64 *)&v145,
                     (void ***)(dl_sysinfo_map + 984),
                     (const char **)&rfv_0,
                     0,
                     0,
                     0LL,
                     v68,
                     v69,
                     v70,
                     v71,
                     v72,
                     v73,
                     v74,
                     v75);
  if ( v145 )
  {
    v88 = 0LL;
    if ( v79 )
      v89 = *((unsigned __int16 *)v145 + 3) == 65521;
    else
      v89 = 1;
    if ( !v89 )
      v88 = *v79;
    v90 = v88 + v145[1];
  }
  else
  {
    v90 = 0LL;
  }
  dl_vdso_gettimeofday = v90;
  if ( !dl_sysinfo_map )
    goto LABEL_146;
  v146 = 0x2000000000LL;
  v147 = 0LL;
  v145 = &v146;
  v148 = 0LL;
  v91 = (__int64 *)dl_lookup_symbol_x(
                     "__kernel_clock_getres",
                     dl_sysinfo_map,
                     (__int64 *)&v145,
                     (void ***)(dl_sysinfo_map + 984),
                     (const char **)&rfv_0,
                     0,
                     0,
                     0LL,
                     v80,
                     v81,
                     v82,
                     v83,
                     v84,
                     v85,
                     v86,
                     v87);
  if ( v145 )
  {
    v100 = 0LL;
    if ( v91 )
      v101 = *((unsigned __int16 *)v145 + 3) == 65521;
    else
      v101 = 1;
    if ( !v101 )
      v100 = *v91;
    v102 = v100 + v145[1];
  }
  else
  {
    v102 = 0LL;
  }
  dl_vdso_clock_getres_time64 = v102;
  if ( dl_sysinfo_map
    && (v146 = 0x2000000000LL,
        v147 = 0LL,
        v145 = &v146,
        v148 = 0LL,
        v103 = (__int64 *)dl_lookup_symbol_x(
                            "__kernel_getrandom",
                            dl_sysinfo_map,
                            (__int64 *)&v145,
                            (void ***)(dl_sysinfo_map + 984),
                            (const char **)&rfv_0,
                            0,
                            0,
                            0LL,
                            v92,
                            v93,
                            v94,
                            v95,
                            v96,
                            v97,
                            v98,
                            v99),
        v145) )
  {
    v104 = 0LL;
    if ( v103 )
      v105 = *((unsigned __int16 *)v145 + 3) == 65521;
    else
      v105 = 1;
    if ( !v105 )
      v104 = *v103;
    v106 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD))(v104 + v145[1]);
  }
  else
  {
    v106 = 0LL;
  }
LABEL_75:
  dl_vdso_getrandom = v106;
  if ( _libc_enable_secure )
  {
    v107 = "GCONV_PATH";
    do
    {
      unsetenv(v107);
      v107 = (char *)strlen() + (_QWORD)v107 + 1;
    }
    while ( v107 < "fp" );
  }
  v108 = getenv("LD_WARN");
  if ( v108 )
    LODWORD(v108) = *v108 != 0;
  LODWORD(dl_verbose) = (_DWORD)v108;
  v109 = getenv("LD_LIBRARY_PATH");
  dl_init_paths(
    v109,
    (__int64)"LD_LIBRARY_PATH",
    0LL,
    0LL,
    v110,
    v111,
    v112,
    v113,
    v114,
    v115,
    v116,
    v117,
    v118,
    v119,
    v120,
    v121);
  dl_init_all_dirs = dl_all_dirs;
  v122 = getenv("LD_BIND_NOW");
  v123 = 1;
  if ( v122 )
    v123 = *v122 == 0;
  dl_lazy = v123;
  v124 = getenv("LD_BIND_NOT");
  v125 = 0;
  if ( v124 )
    v125 = *v124 != 0;
  dl_bind_not = v125;
  v126 = getenv("LD_DYNAMIC_WEAK");
  v127 = 1;
  if ( v126 )
    v127 = *v126 == 0;
  dl_dynamic_weak = v127;
  if ( dl_platform )
  {
    if ( *(_BYTE *)dl_platform )
      dl_platformlen = (__int64)strlen();
    else
      dl_platform = 0LL;
  }
  v128 = 0;
  v129 = 0;
  v130 = dl_phdr;
  v131 = dl_phdr + 56 * dl_phnum;
  if ( dl_phdr < v131 )
  {
    do
    {
      while ( *(_DWORD *)v130 == 1685382481 )
      {
        v16 = *(_DWORD *)(v130 + 4);
        v130 += 56LL;
        v129 = 1;
        if ( v130 >= v131 )
          goto LABEL_96;
      }
      if ( *(_DWORD *)v130 == 1685382482 )
      {
        v17 = *(_QWORD *)(v130 + 16);
        v128 = 1;
        v18 = *(_QWORD *)(v130 + 40);
      }
      v130 += 56LL;
    }
    while ( v130 < v131 );
LABEL_96:
    if ( v128 )
    {
      qword_491478 = v17;
      qword_491480 = v18;
    }
    v132 = v66 + 482;
    if ( !v129 )
    {
      if ( ((_DWORD)v132[3] & 1) == 0 )
        goto LABEL_101;
      goto LABEL_138;
    }
    *((_DWORD *)v132 + 6) = v16;
  }
  else
  {
    v16 = *((_DWORD *)v66 + 970);
  }
  if ( (v16 & 1) == 0 )
    goto LABEL_101;
LABEL_138:
  _tunable_get_val(31LL, (char **)&v146, 0LL);
  if ( !(_DWORD)v146 )
    dl_fatal_printf("Fatal glibc error: executable stack is not allowed\n");
LABEL_101:
  if ( dl_find_object_init )
    dl_find_object_init();
  return dl_protect_relro((unsigned __int64)&dl_main_map);
}
// 41EBB8: write access to const memory at 48F7A0 has been detected
// 41F0C4: write access to const memory at 48F7A0 has been detected
// 41F0C4: write access to const memory at 48F7A8 has been detected
// 41ED1C: write access to const memory at 48F7B8 has been detected
// 41ECA8: write access to const memory at 48F7B0 has been detected
// 41F0D0: write access to const memory at 48F7B0 has been detected
// 41EC30: write access to const memory at 48F7A8 has been detected
// 41F140: write access to const memory at 48F7A8 has been detected
// 41EB18: variable 'v47' is possibly undefined
// 41EB18: variable 'v48' is possibly undefined
// 41EB18: variable 'v49' is possibly undefined
// 41EB18: variable 'v50' is possibly undefined
// 41EB18: variable 'v51' is possibly undefined
// 41EB18: variable 'v52' is possibly undefined
// 41EB18: variable 'v53' is possibly undefined
// 41EB18: variable 'v54' is possibly undefined
// 41EB18: variable 'v55' is possibly undefined
// 41EB18: variable 'v56' is possibly undefined
// 41EB18: variable 'v57' is possibly undefined
// 41EB18: variable 'v58' is possibly undefined
// 41EB18: variable 'v59' is possibly undefined
// 41EB78: variable 'v19' is possibly undefined
// 41EB78: variable 'v20' is possibly undefined
// 41EB78: variable 'v21' is possibly undefined
// 41EB78: variable 'v22' is possibly undefined
// 41EB78: variable 'v23' is possibly undefined
// 41EB78: variable 'v24' is possibly undefined
// 41EB78: variable 'v25' is possibly undefined
// 41EB78: variable 'v26' is possibly undefined
// 41EBF4: variable 'v68' is possibly undefined
// 41EBF4: variable 'v69' is possibly undefined
// 41EBF4: variable 'v70' is possibly undefined
// 41EBF4: variable 'v71' is possibly undefined
// 41EBF4: variable 'v72' is possibly undefined
// 41EBF4: variable 'v73' is possibly undefined
// 41EBF4: variable 'v74' is possibly undefined
// 41EBF4: variable 'v75' is possibly undefined
// 41EC6C: variable 'v80' is possibly undefined
// 41EC6C: variable 'v81' is possibly undefined
// 41EC6C: variable 'v82' is possibly undefined
// 41EC6C: variable 'v83' is possibly undefined
// 41EC6C: variable 'v84' is possibly undefined
// 41EC6C: variable 'v85' is possibly undefined
// 41EC6C: variable 'v86' is possibly undefined
// 41EC6C: variable 'v87' is possibly undefined
// 41ECE4: variable 'v92' is possibly undefined
// 41ECE4: variable 'v93' is possibly undefined
// 41ECE4: variable 'v94' is possibly undefined
// 41ECE4: variable 'v95' is possibly undefined
// 41ECE4: variable 'v96' is possibly undefined
// 41ECE4: variable 'v97' is possibly undefined
// 41ECE4: variable 'v98' is possibly undefined
// 41ECE4: variable 'v99' is possibly undefined
// 41ED9C: variable 'v110' is possibly undefined
// 41ED9C: variable 'v111' is possibly undefined
// 41ED9C: variable 'v112' is possibly undefined
// 41ED9C: variable 'v113' is possibly undefined
// 41ED9C: variable 'v114' is possibly undefined
// 41ED9C: variable 'v115' is possibly undefined
// 41ED9C: variable 'v116' is possibly undefined
// 41ED9C: variable 'v117' is possibly undefined
// 41ED9C: variable 'v118' is possibly undefined
// 41ED9C: variable 'v119' is possibly undefined
// 41ED9C: variable 'v120' is possibly undefined
// 41ED9C: variable 'v121' is possibly undefined
// 41EEB4: variable 'v17' is possibly undefined
// 41EEB8: variable 'v18' is possibly undefined
// 41EEC4: variable 'v16' is possibly undefined
// 454610: using guessed type __int64 qword_454610;
// 48C9B0: using guessed type char *rfv_0;
// 48F7A0: using guessed type __int64 (*dl_vdso_clock_gettime64)(void);
// 48F7A8: using guessed type __int64 dl_vdso_gettimeofday;
// 48F7B0: using guessed type __int64 dl_vdso_clock_getres_time64;
// 48F7B8: using guessed type __int64 (__fastcall *dl_vdso_getrandom)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 490000: using guessed type __int64 (__fastcall *off_490000[5])();
// 490F20: using guessed type __int64 dl_nns;
// 490FD0: using guessed type __int64 dl_main_map;
// 4912C0: using guessed type __int64 qword_4912C0;
// 4912D0: using guessed type __int16 word_4912D0;
// 491360: using guessed type __int64 qword_491360;
// 491478: using guessed type __int64 qword_491478;
// 491480: using guessed type __int64 qword_491480;
// 491570: using guessed type int _libc_enable_secure;
// 496BD8: using guessed type __int64 dl_platform;
// 496C08: using guessed type __int64 dl_sysinfo_dso;
// 496C10: using guessed type __int64 dl_phdr;
// 496C18: using guessed type __int64 dl_phnum;
// 496C20: using guessed type __int64 dl_debug_mask;
// 496C28: using guessed type __int64 dl_sysinfo_map;
// 496C30: using guessed type __int64 dl_verbose;
// 496C38: using guessed type __int64 dl_init_all_dirs;
// 496C40: using guessed type __int64 dl_all_dirs;
// 496C48: using guessed type int dl_lazy;
// 496C4C: using guessed type int dl_bind_not;
// 496C50: using guessed type int dl_dynamic_weak;
// 496C58: using guessed type __int64 dl_platformlen;

//----- (000000000041F1CC) ----------------------------------------------------
__int64 *dl_get_dl_main_map()
{
  return &dl_main_map;
}
// 490FD0: using guessed type __int64 dl_main_map;

//----- (000000000041F200) ----------------------------------------------------
__int64 __fastcall _libc_early_init(unsigned int a1)
{
  int v2; // w0
  rlim64_t rlim_cur; // x3
  unsigned __int64 v4; // x1
  struct rlimit64 v6; // [xsp+20h] [xbp+20h] BYREF

  _ctype_init();
  _libc_single_threaded = a1;
  v2 = getrlimit64(RLIMIT_STACK, &v6);
  rlim_cur = 0x200000LL;
  if ( !v2 && v6.rlim_cur != -1LL )
  {
    rlim_cur = 0x20000LL;
    if ( v6.rlim_cur >= 0x20000 )
      rlim_cur = v6.rlim_cur;
  }
  v4 = dl_pagesize
     + 2048
     + (dl_tls_static_align + dl_tls_static_size - 1) / (unsigned __int64)dl_tls_static_align * dl_tls_static_align;
  if ( v4 < rlim_cur )
    v4 = rlim_cur;
  v6.rlim_cur = (v4 + dl_pagesize - 1) & -dl_pagesize;
  qword_496FB0 = dl_pagesize;
  qword_496FC0 = v6.rlim_cur;
  _pthread_tunables_init();
  return _getrandom_early_init(a1);
}
// 490F08: using guessed type char _libc_single_threaded;
// 490F10: using guessed type __int64 dl_pagesize;
// 4921F8: using guessed type __int64 dl_tls_static_align;
// 492200: using guessed type __int64 dl_tls_static_size;
// 496FB0: using guessed type __int64 qword_496FB0;
// 496FC0: using guessed type __int64 qword_496FC0;

//----- (000000000041F2C0) ----------------------------------------------------
unsigned __int64 __fastcall check_one_fd(
        int a1,
        int a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  unsigned __int64 result; // x0
  const char *v11; // x0
  __int64 v12; // x21
  int v13; // w0
  char v14; // [xsp+0h] [xbp+0h]
  char v15; // [xsp+30h] [xbp+30h] BYREF
  int v16; // [xsp+40h] [xbp+40h]
  unsigned __int64 v17; // [xsp+50h] [xbp+50h]

  result = _fcntl64_nocancel(a1, 1, a3, a4, a5, a6, a7, a8, v14);
  if ( (_DWORD)result == -1 )
  {
    result = *(unsigned int *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
    if ( (_DWORD)result == 9 )
    {
      if ( a2 == 0x8000 )
      {
        v11 = "/dev/null";
        v12 = 259LL;
      }
      else
      {
        v12 = 263LL;
        v11 = "/dev/full";
      }
      v13 = _open_nocancel(v11, a2);
      if ( a1 != v13
        || (unsigned int)fstat64(v13, (struct stat *)&v15)
        || (v16 & 0xF000) != 0x2000
        || (result = v17, v17 != v12) )
      {
        while ( 1 )
        {
          __break(0x3E8u);
          __break(0x3E8u);
        }
      }
    }
  }
  return result;
}
// 41F2D8: variable 'v14' is possibly undefined

//----- (000000000041F380) ----------------------------------------------------
unsigned __int64 __fastcall _libc_check_standard_fds(
        __int64 a1,
        __int64 a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  void *v8; // x2
  __int64 v9; // x3
  __int64 v10; // x4
  __int64 v11; // x5
  __int64 v12; // x6
  __int64 v13; // x7
  void *v14; // x2
  __int64 v15; // x3
  __int64 v16; // x4
  __int64 v17; // x5
  __int64 v18; // x6
  __int64 v19; // x7

  check_one_fd(0, 32769, a3, a4, a5, a6, a7, a8);
  check_one_fd(1, 0x8000, v8, v9, v10, v11, v12, v13);
  return check_one_fd(2, 0x8000, v14, v15, v16, v17, v18, v19);
}
// 41F39C: variable 'v8' is possibly undefined
// 41F39C: variable 'v9' is possibly undefined
// 41F39C: variable 'v10' is possibly undefined
// 41F39C: variable 'v11' is possibly undefined
// 41F39C: variable 'v12' is possibly undefined
// 41F39C: variable 'v13' is possibly undefined
// 41F3AC: variable 'v14' is possibly undefined
// 41F3AC: variable 'v15' is possibly undefined
// 41F3AC: variable 'v16' is possibly undefined
// 41F3AC: variable 'v17' is possibly undefined
// 41F3AC: variable 'v18' is possibly undefined
// 41F3AC: variable 'v19' is possibly undefined

//----- (000000000041F3C0) ----------------------------------------------------
void __fastcall _libc_init_first(
        __int64 a1,
        __int64 *a2,
        char **a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        void *a15,
        __int64 a16)
{
  __int64 v16; // x3
  __int64 v17; // x4
  __int64 v18; // x5
  unsigned __int64 v19; // x6
  unsigned int v22; // [xsp+2Ch] [xbp+2Ch]

  _libc_argc = a1;
  _libc_argv = (__int64)a2;
  v22 = a1;
  environ = a3;
  dl_non_dynamic_init(
    a1,
    (__int64)a2,
    (__int64)a3,
    (__int64)&environ,
    &_libc_argc,
    a14,
    a15,
    a16,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11);
  _init_misc(v22, a2, (__int64)a3, v16, v17, v18, v19);
}
// 41F3FC: variable 'v16' is possibly undefined
// 41F3FC: variable 'v17' is possibly undefined
// 41F3FC: variable 'v18' is possibly undefined
// 41F3FC: variable 'v19' is possibly undefined
// 496D08: using guessed type int _libc_argc;
// 496D10: using guessed type __int64 _libc_argv;

//----- (000000000041F400) ----------------------------------------------------
__int64 __fastcall _syscall_error(int a1)
{
  *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -a1;
  return -1LL;
}

//----- (000000000041F420) ----------------------------------------------------
unsigned __int64 __fastcall _gconv_alias_compare(unsigned __int64 **a1, unsigned __int64 *a2)
{
  return strcmp(*a1, *a2);
}

//----- (000000000041F42C) ----------------------------------------------------
void __fastcall free_derivation(
        unsigned __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  unsigned __int64 v10; // x3
  __int64 v11; // x19
  __int64 v12; // x1
  unsigned __int64 i; // x20
  void (*v14)(void); // x2
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  double v23; // d0
  double v24; // d1
  double v25; // d2
  double v26; // d3
  double v27; // d4
  double v28; // d5
  double v29; // d6
  double v30; // d7

  v10 = *(_QWORD *)(a1 + 24);
  if ( v10 )
  {
    v11 = 0LL;
    v12 = *(_QWORD *)(a1 + 16);
    for ( i = 0LL; i < v10; ++i )
    {
      if ( *(int *)(v12 + v11 + 16) > 0 )
      {
        if ( *(_QWORD *)(v12 + v11) )
        {
          v14 = (void (*)(void))(*(_QWORD *)(v12 + v11 + 64) ^ _pointer_chk_guard_local);
          if ( v14 )
          {
            v14();
            v12 = *(_QWORD *)(a1 + 16);
            v10 = *(_QWORD *)(a1 + 24);
          }
        }
      }
      v11 += 104LL;
    }
  }
  else
  {
    v12 = *(_QWORD *)(a1 + 16);
  }
  if ( v12 )
  {
    free(*(_QWORD *)(v12 + 24), a2, a3, a4, a5, a6, a7, a8, a9);
    free(*(_QWORD *)(*(_QWORD *)(a1 + 16) + 104LL * *(_QWORD *)(a1 + 24) - 72), v15, v16, v17, v18, v19, v20, v21, v22);
    free(*(_QWORD *)(a1 + 16), v23, v24, v25, v26, v27, v28, v29, v30);
  }
  free(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}
// 41F4AC: variable 'a2' is possibly undefined
// 41F4AC: variable 'a3' is possibly undefined
// 41F4AC: variable 'a4' is possibly undefined
// 41F4AC: variable 'a5' is possibly undefined
// 41F4AC: variable 'a6' is possibly undefined
// 41F4AC: variable 'a7' is possibly undefined
// 41F4AC: variable 'a8' is possibly undefined
// 41F4AC: variable 'a9' is possibly undefined
// 41F4C4: variable 'v15' is possibly undefined
// 41F4C4: variable 'v16' is possibly undefined
// 41F4C4: variable 'v17' is possibly undefined
// 41F4C4: variable 'v18' is possibly undefined
// 41F4C4: variable 'v19' is possibly undefined
// 41F4C4: variable 'v20' is possibly undefined
// 41F4C4: variable 'v21' is possibly undefined
// 41F4C4: variable 'v22' is possibly undefined
// 41F4CC: variable 'v23' is possibly undefined
// 41F4CC: variable 'v24' is possibly undefined
// 41F4CC: variable 'v25' is possibly undefined
// 41F4CC: variable 'v26' is possibly undefined
// 41F4CC: variable 'v27' is possibly undefined
// 41F4CC: variable 'v28' is possibly undefined
// 41F4CC: variable 'v29' is possibly undefined
// 41F4CC: variable 'v30' is possibly undefined
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (000000000041F4E8) ----------------------------------------------------
void __fastcall free_modules_db(
        _QWORD *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  _QWORD *v9; // x19
  _BYTE *v10; // x1
  unsigned __int64 v11; // x0

  v9 = a1;
  if ( a1[4] )
    free_modules_db();
  if ( v9[6] )
    free_modules_db();
  do
  {
    while ( 1 )
    {
      v10 = (_BYTE *)v9[3];
      v11 = (unsigned __int64)v9;
      v9 = (_QWORD *)v9[5];
      if ( *v10 == 47 )
        break;
      if ( !v9 )
        return;
    }
    free(v11, a2, a3, a4, a5, a6, a7, a8, a9);
  }
  while ( v9 );
}
// 41F538: variable 'a2' is possibly undefined
// 41F538: variable 'a3' is possibly undefined
// 41F538: variable 'a4' is possibly undefined
// 41F538: variable 'a5' is possibly undefined
// 41F538: variable 'a6' is possibly undefined
// 41F538: variable 'a7' is possibly undefined
// 41F538: variable 'a8' is possibly undefined
// 41F538: variable 'a9' is possibly undefined

//----- (000000000041F544) ----------------------------------------------------
unsigned __int64 __fastcall derivation_compare(unsigned __int64 **a1, unsigned __int64 *a2)
{
  unsigned __int64 result; // x0

  result = strcmp(*a1, *a2);
  if ( !(_DWORD)result )
    return strcmp(a1[1], a2[1]);
  return result;
}

//----- (000000000041F588) ----------------------------------------------------
__int64 _gconv_get_modules_db()
{
  return _gconv_modules_db;
}
// 496D18: using guessed type __int64 _gconv_modules_db;

//----- (000000000041F5A0) ----------------------------------------------------
__int64 _gconv_get_alias_db()
{
  return _gconv_alias_db;
}
// 496D20: using guessed type __int64 _gconv_alias_db;

//----- (000000000041F5AC) ----------------------------------------------------
__int64 __fastcall _gconv_release_step(__int64 result)
{
  _QWORD *v1; // x1
  __int64 v2; // x3
  int v3; // w2
  void (*v4)(void); // x2
  __int64 *v5; // [xsp+18h] [xbp+18h]
  _QWORD *v6; // [xsp+18h] [xbp+18h]

  v1 = (_QWORD *)result;
  v2 = *(_QWORD *)result;
  if ( *(_QWORD *)result )
  {
    v3 = *(_DWORD *)(result + 16) - 1;
    *(_DWORD *)(result + 16) = v3;
    if ( !v3 )
    {
      v4 = (void (*)(void))(*(_QWORD *)(result + 64) ^ _pointer_chk_guard_local);
      if ( v4 )
      {
        v5 = (__int64 *)result;
        v4();
        v1 = v5;
        v2 = *v5;
      }
      v6 = v1;
      result = _gconv_release_shlib(v2);
      *v6 = 0LL;
    }
  }
  else
  {
    result = *(_QWORD *)(result + 64);
    if ( result )
      _libc_assert_fail(
        (__int64)"step->__end_fct == NULL",
        (__int64)"gconv_db.c",
        0xDDu,
        (__int64)"__gconv_release_step");
  }
  return result;
}
// 41F640: using guessed type __int64 find_derivation(void);
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (000000000041F640) ----------------------------------------------------
__int64 __fastcall find_derivation(
        unsigned __int64 a1,
        unsigned __int64 *a2,
        __int64 a3,
        __int64 a4,
        unsigned __int64 *a5,
        unsigned __int64 *a6)
{
  __int64 v6; // x20
  unsigned __int64 **v9; // x0
  unsigned __int64 **v10; // x22
  unsigned __int64 *v11; // x0
  unsigned __int64 v12; // x21
  unsigned __int64 v13; // x22
  unsigned __int64 v14; // x20
  __int64 i; // x19
  int v16; // w0
  __int64 v17; // x0
  _QWORD *shlib; // x0
  __int64 v19; // x0
  __int64 v20; // x1
  __int64 v21; // x0
  void (__fastcall *v22)(__int64); // x1
  unsigned int v23; // w3
  __int64 v24; // x1
  __int64 v25; // x2
  void *v26; // x3
  void *v27; // x4
  void *v28; // x5
  void *v29; // x6
  __int64 v30; // x7
  double v31; // d0
  double v32; // d1
  double v33; // d2
  double v34; // d3
  double v35; // d4
  double v36; // d5
  double v37; // d6
  double v38; // d7
  int32x2_t *v39; // x23
  int v40; // w25
  int v41; // w21
  int v42; // w26
  __int64 v43; // x19
  unsigned __int64 *v44; // x20
  int v45; // w0
  unsigned __int64 *v46; // x0
  __int64 v47; // x0
  unsigned __int64 v48; // x26
  unsigned __int64 v49; // x27
  unsigned __int64 v50; // x0
  unsigned __int64 v51; // x20
  unsigned __int64 v52; // x21
  unsigned __int64 v53; // x19
  __int64 v54; // x25
  unsigned __int64 *v55; // x0
  __int64 (__fastcall *v56)(__int64, __int64 *, unsigned __int64); // x0
  double v57; // d0
  double v58; // d1
  double v59; // d2
  double v60; // d3
  double v61; // d4
  double v62; // d5
  double v63; // d6
  double v64; // d7
  unsigned __int64 v65; // x22
  int v66; // w3
  double v67; // d0
  double v68; // d1
  double v69; // d2
  double v70; // d3
  double v71; // d4
  double v72; // d5
  double v73; // d6
  double v74; // d7
  double v75; // d0
  double v76; // d1
  double v77; // d2
  double v78; // d3
  double v79; // d4
  double v80; // d5
  double v81; // d6
  double v82; // d7
  unsigned __int64 *v83; // x0
  unsigned __int64 *v84; // x20
  bool v85; // cc
  int v86; // w0
  int v87; // w21
  int v88; // w24
  unsigned __int64 *v89; // x27
  int v90; // w0
  int32x2_t *v92; // x27
  unsigned __int64 (__fastcall *v93)(__int64); // x0
  int v94; // w0
  int32x2_t *v95; // x0
  int32x2_t v96; // d31
  int32x2_t *j; // x0
  int32x2_t v98; // d30
  unsigned __int64 **v99; // x0
  unsigned __int64 *v101; // x3
  __int64 *v102; // x0
  __int64 v103; // x1
  __int64 v104; // x0
  __int64 v105; // x1
  __int64 v106; // x0
  __int64 (__fastcall *v107)(__int64); // x1
  double v108; // d0
  double v109; // d1
  double v110; // d2
  double v111; // d3
  double v112; // d4
  double v113; // d5
  double v114; // d6
  double v115; // d7
  unsigned __int64 v116; // x22
  int v117; // w3
  char *v118; // x21
  unsigned __int64 (__fastcall *v119)(__int64); // x0
  __int64 v120; // x1
  __int64 v121; // x2
  void *v122; // x3
  void *v123; // x4
  void *v124; // x5
  void *v125; // x6
  __int64 v126; // x7
  double v127; // d0
  double v128; // d1
  double v129; // d2
  double v130; // d3
  double v131; // d4
  double v132; // d5
  double v133; // d6
  double v134; // d7
  _QWORD *v135; // x0
  _QWORD *v136; // x19
  void *v137; // x3
  void *v138; // x4
  void *v139; // x5
  __int64 *v140; // x6
  __int64 v141; // x7
  double v142; // d0
  double v143; // d1
  double v144; // d2
  double v145; // d3
  double v146; // d4
  double v147; // d5
  double v148; // d6
  double v149; // d7
  _QWORD *v150; // x0
  double v151; // d0
  double v152; // d1
  double v153; // d2
  double v154; // d3
  double v155; // d4
  double v156; // d5
  double v157; // d6
  double v158; // d7
  __int64 (__fastcall *v160)(__int64, __int64 *, unsigned __int64); // x0
  unsigned __int64 v161; // x0
  __int64 v162; // x23
  double v163; // d0
  double v164; // d1
  double v165; // d2
  double v166; // d3
  double v167; // d4
  double v168; // d5
  double v169; // d6
  double v170; // d7
  double v171; // d0
  double v172; // d1
  double v173; // d2
  double v174; // d3
  double v175; // d4
  double v176; // d5
  double v177; // d6
  double v178; // d7
  double v179; // d0
  double v180; // d1
  double v181; // d2
  double v182; // d3
  double v183; // d4
  double v184; // d5
  double v185; // d6
  double v186; // d7
  unsigned __int64 *v187; // x0
  unsigned __int64 *v188; // x0
  unsigned __int64 v189; // x23
  __int64 v190; // x19
  double v191; // d0
  double v192; // d1
  double v193; // d2
  double v194; // d3
  double v195; // d4
  double v196; // d5
  double v197; // d6
  double v198; // d7
  double v199; // d0
  double v200; // d1
  double v201; // d2
  double v202; // d3
  double v203; // d4
  double v204; // d5
  double v205; // d6
  double v206; // d7
  unsigned __int64 *v207; // x0
  unsigned __int64 *v208; // [xsp+0h] [xbp-90h] BYREF
  unsigned __int64 (__fastcall *v209)(__int64); // [xsp+8h] [xbp-88h]
  int v210; // [xsp+10h] [xbp-80h]
  int v211; // [xsp+14h] [xbp-7Ch]
  __int64 v212; // [xsp+18h] [xbp-78h]
  int32x2_t *v213; // [xsp+20h] [xbp-70h]
  unsigned __int64 **v214; // [xsp+28h] [xbp-68h] BYREF
  _QWORD v215[5]; // [xsp+30h] [xbp-60h] BYREF
  __int64 v216; // [xsp+58h] [xbp-38h] BYREF
  __int64 v217; // [xsp+60h] [xbp-30h] BYREF
  unsigned __int64 (__fastcall *v218)(__int64); // [xsp+68h] [xbp-28h]
  __int64 v219; // [xsp+70h] [xbp-20h]
  __int64 v220; // [xsp+78h] [xbp-18h]
  __int64 v221; // [xsp+80h] [xbp-10h]
  _QWORD v222[15]; // [xsp+88h] [xbp-8h] BYREF
  unsigned __int64 *v223; // [xsp+100h] [xbp+70h]
  unsigned __int64 ***v224; // [xsp+108h] [xbp+78h]
  __int64 v225; // [xsp+110h] [xbp+80h]
  int32x2_t *v226; // [xsp+118h] [xbp+88h]
  unsigned __int64 *v227; // [xsp+120h] [xbp+90h]
  unsigned __int64 *v228; // [xsp+128h] [xbp+98h]
  _QWORD v229[4]; // [xsp+130h] [xbp+A0h] BYREF

  v6 = a3;
  if ( a4 )
    a3 = a4;
  v227 = (unsigned __int64 *)a1;
  v228 = a2;
  if ( a2 )
    a1 = (unsigned __int64)a2;
  v222[14] = a1;
  v229[0] = a3;
  v229[1] = a1;
  v223 = a5;
  v225 = a3;
  v229[2] = 0LL;
  v229[3] = 0LL;
  v9 = (unsigned __int64 **)tfind(
                              (__int64)v229,
                              (unsigned __int64 *)&known_derivations,
                              (__int64 (__fastcall *)(__int64, _QWORD))derivation_compare);
  v10 = v9;
  if ( v9 )
  {
    v11 = *v9;
    v13 = v11[2];
    v12 = v11[3];
    *v223 = v13;
    *a6 = v12;
    if ( !v12 )
      return 0;
    v14 = v12 - 1;
    for ( i = v13 + 104 * v12 - 104; ; i -= 104LL )
    {
      v16 = *(_DWORD *)(i + 16);
      *(_DWORD *)(i + 16) = v16 + 1;
      if ( !v16 )
      {
        v17 = *(_QWORD *)(i + 8);
        if ( v17 )
        {
          shlib = (_QWORD *)_gconv_find_shlib(v17);
          *(_QWORD *)i = shlib;
          if ( !shlib )
          {
            v189 = v14 + 1;
            --*(_DWORD *)(i + 16);
            if ( v12 > v14 + 1 )
            {
              v190 = v13 + 104 + 104 * v14;
              do
              {
                ++v189;
                _gconv_release_step(v190);
                v190 += 104LL;
              }
              while ( v12 > v189 );
            }
            return 1;
          }
          *(_QWORD *)(i + 40) = shlib[3];
          v20 = shlib[4];
          v19 = shlib[5];
          *(_QWORD *)(i + 48) = 0LL;
          *(_QWORD *)(i + 56) = v20;
          *(_QWORD *)(i + 64) = v19;
          v21 = _pointer_chk_guard_local;
          v22 = (void (__fastcall *)(__int64))(v20 ^ _pointer_chk_guard_local);
          if ( v22 )
          {
            v22(i);
            v21 = *(_QWORD *)(i + 48) ^ _pointer_chk_guard_local;
          }
          *(_QWORD *)(i + 48) = v21;
        }
      }
      if ( --v14 == -1LL )
        return 0;
    }
  }
  v226 = (int32x2_t *)&v217;
  if ( a4 )
  {
    v217 = a4;
    v218 = strlen();
    v219 = 0LL;
    v220 = 0LL;
    v221 = 0LL;
    v215[0] = v6;
    v215[1] = strlen();
    memset(&v215[2], 0, 24);
    v216 = 0LL;
    v222[0] = v215;
    v224 = (unsigned __int64 ***)&v216;
  }
  else
  {
    v217 = v6;
    v218 = strlen();
    v219 = 0LL;
    v220 = 0LL;
    v221 = 0LL;
    v222[0] = 0LL;
    v224 = (unsigned __int64 ***)v222;
  }
  v39 = v226;
  v40 = 0x7FFFFFFF;
  v41 = 0;
  v42 = 0x7FFFFFFF;
  while ( 1 )
  {
    if ( v42 >= v41 && (v42 != v41 || (signed __int32)v39[2].n64_u32[0] < v40) )
    {
      v43 = _gconv_modules_db;
      if ( _gconv_modules_db )
        break;
    }
LABEL_20:
    v39 = (int32x2_t *)v39[5].n64_u64[0];
    if ( !v39 )
      goto LABEL_30;
LABEL_21:
    v41 = v39[2].n64_i32[1];
  }
  v44 = (unsigned __int64 *)v39->n64_u64[0];
  do
  {
    while ( 1 )
    {
      v45 = strcmp(v44, *(_QWORD *)v43);
      if ( !v45 )
      {
        while ( 1 )
        {
          v84 = *(unsigned __int64 **)(v43 + 8);
          v86 = *(unsigned __int8 *)v84 - 45;
          if ( *(_BYTE *)v84 == 45 )
            v86 = *((unsigned __int8 *)v84 + 1);
          v87 = v41 + *(_DWORD *)(v43 + 16);
          v88 = *(_DWORD *)(v43 + 20) + v39[2].n64_u32[0];
          if ( v86 )
          {
            if ( !(unsigned int)strcmp(*(unsigned __int64 **)(v43 + 8), (unsigned __int64)v227)
              || v228 && !(unsigned int)strcmp(v84, (unsigned __int64)v228) )
            {
              goto LABEL_68;
            }
          }
          else
          {
            if ( !v228 )
            {
              v84 = v227;
              v89 = (unsigned __int64 *)v10;
              if ( !v10 )
                goto LABEL_110;
LABEL_71:
              while ( (unsigned int)strcmp(v84, *v89) )
              {
                v89 = (unsigned __int64 *)v89[5];
                if ( !v89 )
                  goto LABEL_110;
              }
              v90 = *((_DWORD *)v89 + 5);
              if ( v90 > v87 || v90 == v87 && *((_DWORD *)v89 + 4) > v88 )
              {
                *((_DWORD *)v89 + 4) = v88;
                *((_DWORD *)v89 + 5) = v87;
                v89[3] = v43;
                v89[4] = (unsigned __int64)v39;
              }
LABEL_74:
              if ( v42 > v87 )
              {
                v40 = v88;
                v42 = v87;
              }
              else if ( v42 == v87 && v40 > v88 )
              {
                v40 = v88;
              }
              goto LABEL_60;
            }
            v84 = v228;
            if ( !(unsigned int)strcmp(v228, (unsigned __int64)v227) )
            {
              v84 = v228;
LABEL_68:
              v89 = (unsigned __int64 *)v10;
              if ( v10 )
                goto LABEL_71;
LABEL_110:
              v208 = v84;
              v209 = strlen();
              v210 = v88;
              v211 = v87;
              v212 = v43;
              v213 = v39;
              v214 = v10;
              v10 = &v208;
              goto LABEL_74;
            }
            if ( !(unsigned int)strcmp(v84, (unsigned __int64)v228) )
              goto LABEL_68;
          }
          if ( v42 > v87 || (v42 == v87 ? (v85 = v40 <= v88) : (v85 = 1), !v85) )
          {
            v92 = v226;
            while ( (unsigned int)strcmp(v84, v92->n64_u64[0]) )
            {
              v92 = (int32x2_t *)v92[5].n64_u64[0];
              if ( !v92 )
              {
                v208 = v84;
                v93 = strlen();
                v210 = v88;
                v211 = v87;
                v212 = v43;
                v213 = v39;
                v209 = v93;
                v214 = 0LL;
                *v224 = &v208;
                v224 = &v214;
                goto LABEL_60;
              }
            }
            v94 = v92[2].n64_i32[1];
            if ( v94 > v87 || v94 == v87 && (signed __int32)v92[2].n64_u32[0] > v88 )
            {
              v92[3].n64_u64[0] = v43;
              v92[4].n64_u64[0] = (unsigned __int64)v39;
              v25 = (__int64)v226;
              do
              {
                while ( 1 )
                {
                  v95 = *(int32x2_t **)(v25 + 24);
                  if ( v95 )
                    break;
                  v25 = *(_QWORD *)(v25 + 40);
                  if ( !v25 )
                    goto LABEL_96;
                }
                v24 = *(_QWORD *)(v25 + 32);
                v96.n64_u64[0] = v95[2].n64_u64[0];
                for ( j = *(int32x2_t **)(v24 + 24); j; v96.n64_u64[0] = vadd_s32(v96, v98).n64_u64[0] )
                {
                  v24 = *(_QWORD *)(v24 + 32);
                  v98.n64_u64[0] = j[2].n64_u64[0];
                  j = *(int32x2_t **)(v24 + 24);
                }
                *(int32x2_t *)(v25 + 16) = vrev64_s32(v96);
                v25 = *(_QWORD *)(v25 + 40);
              }
              while ( v25 );
LABEL_96:
              if ( v10 )
              {
                v99 = v10;
                do
                {
                  v101 = v99[3];
                  v27 = (void *)*((unsigned int *)v101 + 4);
                  v26 = (void *)*((unsigned int *)v101 + 5);
                  v24 = (unsigned int)(*((_DWORD *)v99[4] + 5) + (_DWORD)v27);
                  v25 = (unsigned int)(*((_DWORD *)v99[4] + 4) + (_DWORD)v26);
                  *((_DWORD *)v99 + 4) = v25;
                  *((_DWORD *)v99 + 5) = v24;
                  if ( (int)v24 >= v42 )
                  {
                    if ( (_DWORD)v24 == v42 && (int)v25 < v40 )
                      v40 = v25;
                  }
                  else
                  {
                    v40 = v25;
                    v42 = v24;
                  }
                  v99 = (unsigned __int64 **)v99[5];
                }
                while ( v99 );
              }
            }
          }
LABEL_60:
          v43 = *(_QWORD *)(v43 + 40);
          if ( !v43 )
            goto LABEL_20;
          v41 = v39[2].n64_i32[1];
        }
      }
      if ( v45 < 0 )
        break;
      v43 = *(_QWORD *)(v43 + 48);
      if ( !v43 )
        goto LABEL_29;
    }
    v43 = *(_QWORD *)(v43 + 32);
  }
  while ( v43 );
LABEL_29:
  v39 = (int32x2_t *)v39[5].n64_u64[0];
  if ( v39 )
    goto LABEL_21;
LABEL_30:
  if ( !v10 )
  {
    *v223 = 0LL;
    *a6 = 0LL;
    goto LABEL_131;
  }
  v46 = v10[5];
  if ( v46 )
  {
    v25 = *((unsigned int *)v46 + 5);
    v24 = *((unsigned int *)v10 + 5);
    if ( (int)v25 < (int)v24 )
    {
      v10 = (unsigned __int64 **)v10[5];
      v47 = v46[4];
      if ( v47 )
        goto LABEL_37;
LABEL_134:
      v51 = malloc(v47, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38);
      if ( v51 )
      {
        *a6 = 0LL;
LABEL_137:
        v116 = 0LL;
LABEL_118:
        v117 = 0;
        *v223 = v51;
        goto LABEL_119;
      }
LABEL_135:
      v188 = v223;
      *a6 = 0LL;
      v116 = 0LL;
      v117 = 3;
      *v188 = 0LL;
      goto LABEL_119;
    }
    if ( (_DWORD)v25 == (_DWORD)v24 )
    {
      v24 = *((unsigned int *)v10 + 4);
      v25 = *((unsigned int *)v46 + 4);
      if ( (int)v25 < (int)v24 )
        v10 = (unsigned __int64 **)v10[5];
    }
  }
  v47 = (__int64)v10[4];
  if ( !v47 )
    goto LABEL_134;
LABEL_37:
  v48 = 0LL;
  do
  {
    v47 = *(_QWORD *)(v47 + 32);
    v49 = v48++;
  }
  while ( v47 );
  v50 = malloc(104 * v48, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38);
  v51 = v50;
  if ( !v50 )
    goto LABEL_135;
  *a6 = v48;
  if ( !v48 )
    goto LABEL_137;
  v52 = 0LL;
  v53 = 0LL;
  v54 = v50 + 104 * v49;
  if ( !v49 )
    goto LABEL_48;
LABEL_42:
  *(_QWORD *)(v54 + 24) = *v10[4];
  while ( 1 )
  {
    if ( *a6 == v48 )
    {
      v160 = strdup();
      *(_QWORD *)(v54 + 32) = v160;
      v52 = (unsigned __int64)v160;
      if ( !v160 )
        goto LABEL_49;
    }
    else
    {
      *(_QWORD *)(v54 + 32) = *(_QWORD *)(v51 + 104 * v48 + 24);
    }
    v55 = (unsigned __int64 *)v10[3][3];
    *(_DWORD *)(v54 + 16) = 1;
    *(_QWORD *)(v54 + 96) = 0LL;
    if ( *(_BYTE *)v55 == 47 )
      break;
    v48 = v49;
    _gconv_get_builtin_trans(v55, v54);
    v54 -= 104LL;
    v10 = (unsigned __int64 **)v10[4];
    if ( !v49 )
      goto LABEL_117;
LABEL_47:
    if ( --v49 )
      goto LABEL_42;
LABEL_48:
    v56 = strdup();
    *(_QWORD *)(v51 + 24) = v56;
    v53 = (unsigned __int64)v56;
    if ( !v56 )
    {
LABEL_49:
      v65 = v49 + 1;
      v66 = 0;
      if ( v49 + 1 >= *a6 )
      {
        free(v51, v57, v58, v59, v60, v61, v62, v63, v64);
        free(v53, v67, v68, v69, v70, v71, v72, v73, v74);
        free(v52, v75, v76, v77, v78, v79, v80, v81, v82);
        v83 = v223;
        *a6 = 0LL;
        *v83 = 0LL;
        goto LABEL_131;
      }
      goto LABEL_126;
    }
  }
  v102 = (__int64 *)_gconv_find_shlib((__int64)v55);
  if ( !v102 )
    goto LABEL_49;
  v103 = *v102;
  *(_QWORD *)v54 = v102;
  *(_QWORD *)(v54 + 8) = v103;
  *(_QWORD *)(v54 + 40) = v102[3];
  v105 = v102[4];
  v104 = v102[5];
  *(_QWORD *)(v54 + 48) = 0LL;
  *(_QWORD *)(v54 + 56) = v105;
  *(_QWORD *)(v54 + 64) = v104;
  v106 = _pointer_chk_guard_local;
  v107 = (__int64 (__fastcall *)(__int64))(v105 ^ _pointer_chk_guard_local);
  if ( !v107 )
  {
LABEL_116:
    *(_QWORD *)(v54 + 48) = v106;
    v48 = v49;
    v10 = (unsigned __int64 **)v10[4];
    v54 -= 104LL;
    if ( !v49 )
    {
LABEL_117:
      v116 = *a6;
      goto LABEL_118;
    }
    goto LABEL_47;
  }
  v66 = v107(v54);
  if ( !v66 )
  {
    v106 = *(_QWORD *)(v54 + 48) ^ _pointer_chk_guard_local;
    goto LABEL_116;
  }
  v161 = *a6;
  v65 = v48 - 1;
  *(_QWORD *)(v54 + 64) = _pointer_chk_guard_local;
  v49 = v48 - 2;
  if ( v48 - 1 >= v161 )
  {
    LODWORD(v228) = v66;
    free(v51, v108, v109, v110, v111, v112, v113, v114, v115);
    v51 = 0LL;
    free(v53, v191, v192, v193, v194, v195, v196, v197, v198);
    free(v52, v199, v200, v201, v202, v203, v204, v205, v206);
    v207 = v223;
    *a6 = 0LL;
    v117 = (int)v228;
    v116 = 0LL;
    *v207 = 0LL;
    goto LABEL_119;
  }
LABEL_126:
  v162 = v51 + 104 + 104 * v49;
  do
  {
    LODWORD(v228) = v66;
    _gconv_release_step(v162);
    ++v65;
    v162 += 104LL;
    v66 = (int)v228;
  }
  while ( v65 < *a6 );
  free(v51, v163, v164, v165, v166, v167, v168, v169, v170);
  v51 = 0LL;
  free(v53, v171, v172, v173, v174, v175, v176, v177, v178);
  free(v52, v179, v180, v181, v182, v183, v184, v185, v186);
  v187 = v223;
  *a6 = 0LL;
  v117 = (int)v228;
  v116 = 0LL;
  *v187 = 0LL;
  if ( !v117 )
  {
LABEL_131:
    v51 = 0LL;
    v116 = 0LL;
    v117 = 1;
  }
LABEL_119:
  LODWORD(v228) = v117;
  v118 = (char *)strlen() + 1;
  v119 = strlen();
  v135 = (_QWORD *)malloc(
                     (__int64)v119 + (_QWORD)v118 + 33,
                     v120,
                     v121,
                     v122,
                     v123,
                     v124,
                     v125,
                     v126,
                     v127,
                     v128,
                     v129,
                     v130,
                     v131,
                     v132,
                     v133,
                     v134);
  v23 = (unsigned int)v228;
  v136 = v135;
  if ( v135 )
  {
    *v135 = v135 + 4;
    LODWORD(v228) = v23;
    j_memcpy();
    v136[1] = j_memcpy();
    v136[2] = v51;
    v136[3] = v116;
    v150 = tsearch(
             (__int64)v136,
             &known_derivations,
             (__int64 (__fastcall *)(__int64, _QWORD))derivation_compare,
             v137,
             v138,
             v139,
             v140,
             v141,
             v142,
             v143,
             v144,
             v145,
             v146,
             v147,
             v148,
             v149);
    v23 = (unsigned int)v228;
    if ( !v150 )
    {
      free((unsigned __int64)v136, v151, v152, v153, v154, v155, v156, v157, v158);
      return (unsigned int)v228;
    }
  }
  return v23;
}
// 41F86C: variable 'v24' is possibly undefined
// 41F86C: variable 'v25' is possibly undefined
// 41F86C: variable 'v26' is possibly undefined
// 41F86C: variable 'v27' is possibly undefined
// 41F86C: variable 'v28' is possibly undefined
// 41F86C: variable 'v29' is possibly undefined
// 41F86C: variable 'v30' is possibly undefined
// 41F86C: variable 'v31' is possibly undefined
// 41F86C: variable 'v32' is possibly undefined
// 41F86C: variable 'v33' is possibly undefined
// 41F86C: variable 'v34' is possibly undefined
// 41F86C: variable 'v35' is possibly undefined
// 41F86C: variable 'v36' is possibly undefined
// 41F86C: variable 'v37' is possibly undefined
// 41F86C: variable 'v38' is possibly undefined
// 41F934: variable 'v57' is possibly undefined
// 41F934: variable 'v58' is possibly undefined
// 41F934: variable 'v59' is possibly undefined
// 41F934: variable 'v60' is possibly undefined
// 41F934: variable 'v61' is possibly undefined
// 41F934: variable 'v62' is possibly undefined
// 41F934: variable 'v63' is possibly undefined
// 41F934: variable 'v64' is possibly undefined
// 41F93C: variable 'v67' is possibly undefined
// 41F93C: variable 'v68' is possibly undefined
// 41F93C: variable 'v69' is possibly undefined
// 41F93C: variable 'v70' is possibly undefined
// 41F93C: variable 'v71' is possibly undefined
// 41F93C: variable 'v72' is possibly undefined
// 41F93C: variable 'v73' is possibly undefined
// 41F93C: variable 'v74' is possibly undefined
// 41F944: variable 'v75' is possibly undefined
// 41F944: variable 'v76' is possibly undefined
// 41F944: variable 'v77' is possibly undefined
// 41F944: variable 'v78' is possibly undefined
// 41F944: variable 'v79' is possibly undefined
// 41F944: variable 'v80' is possibly undefined
// 41F944: variable 'v81' is possibly undefined
// 41F944: variable 'v82' is possibly undefined
// 41FC4C: variable 'v120' is possibly undefined
// 41FC4C: variable 'v121' is possibly undefined
// 41FC4C: variable 'v122' is possibly undefined
// 41FC4C: variable 'v123' is possibly undefined
// 41FC4C: variable 'v124' is possibly undefined
// 41FC4C: variable 'v125' is possibly undefined
// 41FC4C: variable 'v126' is possibly undefined
// 41FC4C: variable 'v127' is possibly undefined
// 41FC4C: variable 'v128' is possibly undefined
// 41FC4C: variable 'v129' is possibly undefined
// 41FC4C: variable 'v130' is possibly undefined
// 41FC4C: variable 'v131' is possibly undefined
// 41FC4C: variable 'v132' is possibly undefined
// 41FC4C: variable 'v133' is possibly undefined
// 41FC4C: variable 'v134' is possibly undefined
// 41FCA4: variable 'v137' is possibly undefined
// 41FCA4: variable 'v138' is possibly undefined
// 41FCA4: variable 'v139' is possibly undefined
// 41FCA4: variable 'v140' is possibly undefined
// 41FCA4: variable 'v141' is possibly undefined
// 41FCA4: variable 'v142' is possibly undefined
// 41FCA4: variable 'v143' is possibly undefined
// 41FCA4: variable 'v144' is possibly undefined
// 41FCA4: variable 'v145' is possibly undefined
// 41FCA4: variable 'v146' is possibly undefined
// 41FCA4: variable 'v147' is possibly undefined
// 41FCA4: variable 'v148' is possibly undefined
// 41FCA4: variable 'v149' is possibly undefined
// 41FDF8: variable 'v151' is possibly undefined
// 41FDF8: variable 'v152' is possibly undefined
// 41FDF8: variable 'v153' is possibly undefined
// 41FDF8: variable 'v154' is possibly undefined
// 41FDF8: variable 'v155' is possibly undefined
// 41FDF8: variable 'v156' is possibly undefined
// 41FDF8: variable 'v157' is possibly undefined
// 41FDF8: variable 'v158' is possibly undefined
// 41FD40: variable 'v163' is possibly undefined
// 41FD40: variable 'v164' is possibly undefined
// 41FD40: variable 'v165' is possibly undefined
// 41FD40: variable 'v166' is possibly undefined
// 41FD40: variable 'v167' is possibly undefined
// 41FD40: variable 'v168' is possibly undefined
// 41FD40: variable 'v169' is possibly undefined
// 41FD40: variable 'v170' is possibly undefined
// 41FD4C: variable 'v171' is possibly undefined
// 41FD4C: variable 'v172' is possibly undefined
// 41FD4C: variable 'v173' is possibly undefined
// 41FD4C: variable 'v174' is possibly undefined
// 41FD4C: variable 'v175' is possibly undefined
// 41FD4C: variable 'v176' is possibly undefined
// 41FD4C: variable 'v177' is possibly undefined
// 41FD4C: variable 'v178' is possibly undefined
// 41FD54: variable 'v179' is possibly undefined
// 41FD54: variable 'v180' is possibly undefined
// 41FD54: variable 'v181' is possibly undefined
// 41FD54: variable 'v182' is possibly undefined
// 41FD54: variable 'v183' is possibly undefined
// 41FD54: variable 'v184' is possibly undefined
// 41FD54: variable 'v185' is possibly undefined
// 41FD54: variable 'v186' is possibly undefined
// 41FE60: variable 'v108' is possibly undefined
// 41FE60: variable 'v109' is possibly undefined
// 41FE60: variable 'v110' is possibly undefined
// 41FE60: variable 'v111' is possibly undefined
// 41FE60: variable 'v112' is possibly undefined
// 41FE60: variable 'v113' is possibly undefined
// 41FE60: variable 'v114' is possibly undefined
// 41FE60: variable 'v115' is possibly undefined
// 41FE6C: variable 'v191' is possibly undefined
// 41FE6C: variable 'v192' is possibly undefined
// 41FE6C: variable 'v193' is possibly undefined
// 41FE6C: variable 'v194' is possibly undefined
// 41FE6C: variable 'v195' is possibly undefined
// 41FE6C: variable 'v196' is possibly undefined
// 41FE6C: variable 'v197' is possibly undefined
// 41FE6C: variable 'v198' is possibly undefined
// 41FE74: variable 'v199' is possibly undefined
// 41FE74: variable 'v200' is possibly undefined
// 41FE74: variable 'v201' is possibly undefined
// 41FE74: variable 'v202' is possibly undefined
// 41FE74: variable 'v203' is possibly undefined
// 41FE74: variable 'v204' is possibly undefined
// 41FE74: variable 'v205' is possibly undefined
// 41FE74: variable 'v206' is possibly undefined
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;
// 496D18: using guessed type __int64 _gconv_modules_db;
// 496D28: using guessed type __int64 known_derivations;

//----- (000000000041FE90) ----------------------------------------------------
unsigned __int64 __fastcall _gconv_compare_alias(unsigned __int64 *a1, unsigned __int8 *a2)
{
  _QWORD *v5; // x0
  unsigned __int64 *v6; // x4
  _QWORD *v7; // x0
  unsigned __int64 v8; // x1
  unsigned __int64 *v9; // [xsp+28h] [xbp+28h]
  unsigned int v10; // [xsp+3Ch] [xbp+3Ch] BYREF
  _QWORD v11[2]; // [xsp+40h] [xbp+40h] BYREF

  _gconv_load_conf();
  if ( !(unsigned int)_gconv_compare_alias_cache(a1, a2, &v10) )
    return v10;
  v11[0] = a1;
  v5 = tfind(
         (__int64)v11,
         (unsigned __int64 *)&_gconv_alias_db,
         (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare);
  if ( v5 )
  {
    v6 = *(unsigned __int64 **)(*v5 + 8LL);
    if ( !v6 )
      v6 = a1;
  }
  else
  {
    v6 = a1;
  }
  v9 = v6;
  v11[0] = a2;
  v7 = tfind(
         (__int64)v11,
         (unsigned __int64 *)&_gconv_alias_db,
         (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare);
  if ( v7 )
  {
    v8 = *(_QWORD *)(*v7 + 8LL);
    if ( !v8 )
      v8 = (unsigned __int64)a2;
  }
  else
  {
    v8 = (unsigned __int64)a2;
  }
  return strcmp(v9, v8);
}
// 496D20: using guessed type __int64 _gconv_alias_db;

//----- (000000000041FF6C) ----------------------------------------------------
__int64 __fastcall _gconv_find_transform(
        unsigned __int8 *a1,
        unsigned __int8 *a2,
        unsigned __int64 *a3,
        __int64 *a4,
        unsigned __int8 a5)
{
  __int64 v10; // x1
  __int64 v11; // x2
  __int64 v12; // x3
  void *v13; // x4
  void *v14; // x5
  void *v15; // x6
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  int v24; // w0
  unsigned int derivation; // w20
  _QWORD *v26; // x0
  unsigned __int64 v27; // x26
  unsigned __int64 *v28; // x0
  unsigned __int64 *v29; // x20
  __int64 v30; // x1
  __int64 v31; // x2
  __int64 v32; // x3
  void *v33; // x4
  void *v34; // x5
  void *v35; // x6
  int v36; // w0
  __int64 v38; // x1
  __int64 v39; // x2
  __int64 v40; // x3
  void *v41; // x4
  void *v42; // x5
  void *v43; // x6
  int v44; // w0
  __int64 v45; // x1
  __int64 v46; // x2
  __int64 v47; // x3
  void *v48; // x4
  void *v49; // x5
  void *v50; // x6
  int v51; // w0
  __int64 v52; // x1
  __int64 v53; // x2
  __int64 v54; // x3
  void *v55; // x4
  void *v56; // x5
  void *v57; // x6
  int v58; // w0
  _QWORD v59[2]; // [xsp+50h] [xbp+50h] BYREF

  _gconv_load_conf();
  _aarch64_cas4_acq();
  if ( v24 )
    _lll_lock_wait_private(_gconv_lock, v16, v17, v18, v19, v20, v21, v22, v23, v10, v11, v12, v13, v14, v15);
  derivation = _gconv_lookup_cache(a1, a2, a3, a4, a5);
  if ( derivation != 2 )
  {
    _aarch64_swp4_rel();
    if ( v44 > 1 )
      _lll_lock_wake_private(_gconv_lock, v38, v39, v40, v41, v42, v43);
    return derivation;
  }
  if ( _gconv_modules_db )
  {
    v59[0] = a2;
    v26 = tfind(
            (__int64)v59,
            (unsigned __int64 *)&_gconv_alias_db,
            (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare);
    v27 = (unsigned __int64)v26;
    if ( v26 )
      v27 = *(_QWORD *)(*v26 + 8LL);
    v59[0] = a1;
    v28 = tfind(
            (__int64)v59,
            (unsigned __int64 *)&_gconv_alias_db,
            (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare);
    v29 = v28;
    if ( v28 )
      v29 = *(unsigned __int64 **)(*v28 + 8);
    if ( (a5 & 1) != 0
      && (!(unsigned int)strcmp((unsigned __int64 *)a1, (unsigned __int64)a2)
       || v29 && !(unsigned int)strcmp(v29, (unsigned __int64)a2)
       || v27 && (!(unsigned int)strcmp((unsigned __int64 *)a1, v27) || v29 && !(unsigned int)strcmp(v29, v27))) )
    {
      _aarch64_swp4_rel();
      derivation = -1;
      if ( v51 > 1 )
        _lll_lock_wake_private(_gconv_lock, v45, v46, v47, v48, v49, v50);
      return derivation;
    }
    derivation = find_derivation((unsigned __int64)a1, v29, (__int64)a2, v27, a3, (unsigned __int64 *)a4);
    _aarch64_swp4_rel();
    if ( v36 > 1 )
    {
      _lll_lock_wake_private(_gconv_lock, v30, v31, v32, v33, v34, v35);
      if ( derivation )
        return derivation;
    }
    else if ( derivation )
    {
      return derivation;
    }
    return *a3 == 0;
  }
  _aarch64_swp4_rel();
  if ( v58 > 1 )
    _lll_lock_wake_private(_gconv_lock, v52, v53, v54, v55, v56, v57);
  return 1LL;
}
// 41FFB4: variable 'v24' is possibly undefined
// 420184: variable 'v16' is possibly undefined
// 420184: variable 'v17' is possibly undefined
// 420184: variable 'v18' is possibly undefined
// 420184: variable 'v19' is possibly undefined
// 420184: variable 'v20' is possibly undefined
// 420184: variable 'v21' is possibly undefined
// 420184: variable 'v22' is possibly undefined
// 420184: variable 'v23' is possibly undefined
// 420184: variable 'v10' is possibly undefined
// 420184: variable 'v11' is possibly undefined
// 420184: variable 'v12' is possibly undefined
// 420184: variable 'v13' is possibly undefined
// 420184: variable 'v14' is possibly undefined
// 420184: variable 'v15' is possibly undefined
// 420074: variable 'v36' is possibly undefined
// 4200B8: variable 'v44' is possibly undefined
// 4200C0: variable 'v38' is possibly undefined
// 4200C0: variable 'v39' is possibly undefined
// 4200C0: variable 'v40' is possibly undefined
// 4200C0: variable 'v41' is possibly undefined
// 4200C0: variable 'v42' is possibly undefined
// 4200C0: variable 'v43' is possibly undefined
// 420104: variable 'v51' is possibly undefined
// 420114: variable 'v30' is possibly undefined
// 420114: variable 'v31' is possibly undefined
// 420114: variable 'v32' is possibly undefined
// 420114: variable 'v33' is possibly undefined
// 420114: variable 'v34' is possibly undefined
// 420114: variable 'v35' is possibly undefined
// 42015C: variable 'v58' is possibly undefined
// 420194: variable 'v52' is possibly undefined
// 420194: variable 'v53' is possibly undefined
// 420194: variable 'v54' is possibly undefined
// 420194: variable 'v55' is possibly undefined
// 420194: variable 'v56' is possibly undefined
// 420194: variable 'v57' is possibly undefined
// 4201A4: variable 'v45' is possibly undefined
// 4201A4: variable 'v46' is possibly undefined
// 4201A4: variable 'v47' is possibly undefined
// 4201A4: variable 'v48' is possibly undefined
// 4201A4: variable 'v49' is possibly undefined
// 4201A4: variable 'v50' is possibly undefined
// 496D18: using guessed type __int64 _gconv_modules_db;
// 496D20: using guessed type __int64 _gconv_alias_db;
// 496D30: using guessed type _DWORD _gconv_lock[2];

//----- (00000000004201AC) ----------------------------------------------------
__int64 __fastcall _gconv_close_transform(unsigned __int64 a1, __int64 a2)
{
  __int64 v4; // x1
  __int64 v5; // x2
  __int64 v6; // x3
  void *v7; // x4
  void *v8; // x5
  void *v9; // x6
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7
  int v18; // w0
  __int64 v19; // x20
  __int64 v20; // x19
  int v21; // w1
  void (__fastcall *v22)(__int64); // x1
  __int64 v23; // x0
  __int64 v24; // x1
  __int64 v25; // x2
  __int64 v26; // x3
  void *v27; // x4
  void *v28; // x5
  void *v29; // x6
  int v30; // w0

  _aarch64_cas4_acq();
  if ( v18 )
    _lll_lock_wait_private(_gconv_lock, v10, v11, v12, v13, v14, v15, v16, v17, v4, v5, v6, v7, v8, v9);
  if ( a2 )
  {
    v19 = a2 - 1;
    v20 = a1 - 104 + 104 * a2;
    do
    {
      v23 = *(_QWORD *)v20;
      if ( *(_QWORD *)v20 )
      {
        v21 = *(_DWORD *)(v20 + 16) - 1;
        *(_DWORD *)(v20 + 16) = v21;
        if ( !v21 )
        {
          v22 = (void (__fastcall *)(__int64))(*(_QWORD *)(v20 + 64) ^ _pointer_chk_guard_local);
          if ( v22 )
          {
            v22(v20);
            v23 = *(_QWORD *)v20;
          }
          _gconv_release_shlib(v23);
          *(_QWORD *)v20 = 0LL;
        }
      }
      else if ( *(_QWORD *)(v20 + 64) )
      {
        _libc_assert_fail(
          (__int64)"step->__end_fct == NULL",
          (__int64)"gconv_db.c",
          0xDDu,
          (__int64)"__gconv_release_step");
      }
      --v19;
      v20 -= 104LL;
    }
    while ( v19 != -1 );
  }
  _gconv_release_cache(a1, v10, v11, v12, v13, v14, v15, v16, v17);
  _aarch64_swp4_rel();
  if ( v30 > 1 )
    _lll_lock_wake_private(_gconv_lock, v24, v25, v26, v27, v28, v29);
  return 0LL;
}
// 4201E0: variable 'v18' is possibly undefined
// 4202B8: variable 'v10' is possibly undefined
// 4202B8: variable 'v11' is possibly undefined
// 4202B8: variable 'v12' is possibly undefined
// 4202B8: variable 'v13' is possibly undefined
// 4202B8: variable 'v14' is possibly undefined
// 4202B8: variable 'v15' is possibly undefined
// 4202B8: variable 'v16' is possibly undefined
// 4202B8: variable 'v17' is possibly undefined
// 4202B8: variable 'v4' is possibly undefined
// 4202B8: variable 'v5' is possibly undefined
// 4202B8: variable 'v6' is possibly undefined
// 4202B8: variable 'v7' is possibly undefined
// 4202B8: variable 'v8' is possibly undefined
// 4202B8: variable 'v9' is possibly undefined
// 420298: variable 'v30' is possibly undefined
// 4202C4: variable 'v24' is possibly undefined
// 4202C4: variable 'v25' is possibly undefined
// 4202C4: variable 'v26' is possibly undefined
// 4202C4: variable 'v27' is possibly undefined
// 4202C4: variable 'v28' is possibly undefined
// 4202C4: variable 'v29' is possibly undefined
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;
// 496D30: using guessed type _DWORD _gconv_lock[2];

//----- (00000000004202E0) ----------------------------------------------------
void __fastcall _gconv_db_freemem(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7

  nl_locale_subfreeres(a1, a2, a3, a4, a5, a6, a7, a8);
  nl_finddomain_subfreeres(v8, v9, v10, v11, v12, v13, v14, v15);
  if ( _gconv_alias_db )
    tdestroy((_QWORD *)_gconv_alias_db, (void (__fastcall *)(_QWORD))free);
  if ( _gconv_modules_db )
    free_modules_db((_QWORD *)_gconv_modules_db, v16, v17, v18, v19, v20, v21, v22, v23);
  if ( known_derivations )
    tdestroy((_QWORD *)known_derivations, (void (__fastcall *)(_QWORD))free_derivation);
}
// 4202F0: variable 'v8' is possibly undefined
// 4202F0: variable 'v9' is possibly undefined
// 4202F0: variable 'v10' is possibly undefined
// 4202F0: variable 'v11' is possibly undefined
// 4202F0: variable 'v12' is possibly undefined
// 4202F0: variable 'v13' is possibly undefined
// 4202F0: variable 'v14' is possibly undefined
// 4202F0: variable 'v15' is possibly undefined
// 420318: variable 'v16' is possibly undefined
// 420318: variable 'v17' is possibly undefined
// 420318: variable 'v18' is possibly undefined
// 420318: variable 'v19' is possibly undefined
// 420318: variable 'v20' is possibly undefined
// 420318: variable 'v21' is possibly undefined
// 420318: variable 'v22' is possibly undefined
// 420318: variable 'v23' is possibly undefined
// 496D18: using guessed type __int64 _gconv_modules_db;
// 496D20: using guessed type __int64 _gconv_alias_db;
// 496D28: using guessed type __int64 known_derivations;

//----- (0000000000420360) ----------------------------------------------------
void _gconv_get_path()
{
  __int64 v0; // x23
  __int64 v1; // x22
  unsigned __int64 (__fastcall *v2)(__int64); // x19
  __int64 v3; // x24
  void *v4; // x3
  void *v5; // x4
  void *v6; // x5
  void *v7; // x6
  __int64 v8; // x7
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  char *v17; // x21
  unsigned __int64 (__fastcall *v18)(__int64); // x20
  __int64 v19; // x25
  void *v20; // x3
  void *v21; // x4
  void *v22; // x5
  void *v23; // x6
  __int64 v24; // x7
  __int64 v25; // x19
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7
  int v34; // w26
  __int64 v35; // x0
  __int64 v36; // x19
  __int64 v37; // x2
  __int64 v38; // x1
  double v39; // d0
  double v40; // d1
  double v41; // d2
  double v42; // d3
  double v43; // d4
  double v44; // d5
  double v45; // d6
  double v46; // d7
  _BYTE *v47; // x27
  _QWORD *v48; // x28
  unsigned int v49; // w21
  _QWORD *v50; // x19
  __int64 (__fastcall *v51)(__int64, __int64 *, unsigned __int64); // x0
  char *v52; // x19
  unsigned __int64 v53; // x1
  unsigned __int64 v54; // x0
  _QWORD *v55; // x0
  char v56[16]; // [xsp+0h] [xbp-10h] BYREF
  __int64 v57; // [xsp+10h] [xbp+0h] BYREF
  _QWORD *v58; // [xsp+78h] [xbp+68h]
  char *v59; // [xsp+88h] [xbp+78h] BYREF

  v0 = _gconv_path_elem;
  if ( _gconv_path_elem )
    _libc_assert_fail((__int64)"result == NULL", (__int64)"gconv_conf.c", 0x16Au, (__int64)"__gconv_get_path");
  v1 = _gconv_path_envvar;
  if ( !_gconv_path_envvar )
  {
    v19 = 1LL;
    v17 = v56;
    v18 = 0LL;
    strcpy(v56, "/lib/gconv");
    v3 = 11LL;
    v59 = v56;
    v25 = strchr((__int64)v56, 0x3Au);
    if ( v25 )
      goto LABEL_6;
LABEL_26:
    v38 = 0LL;
    v36 = 1LL;
    v37 = 32LL;
    goto LABEL_12;
  }
  v2 = strlen();
  v3 = (__int64)v2 + 12;
  v59 = (char *)&v57;
  strcpy((char *)v2 + (_QWORD)j_memcpy(), ":/lib/gconv");
  v1 = getcwd(0LL, 0LL, *(__int64 *)"/lib/gconv", v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16);
  v17 = v59;
  if ( v1 )
  {
    v18 = strlen();
    v19 = (__int64)v18 + 1;
  }
  else
  {
    v19 = 1LL;
    v18 = 0LL;
  }
  v25 = strchr((__int64)v17, 0x3Au);
  if ( !v25 )
    goto LABEL_26;
LABEL_6:
  v34 = 1;
  while ( 1 )
  {
    if ( v25 != v0 + 1 )
      ++v34;
    v0 = v25;
    v35 = strchr(v25 + 1, 0x3Au);
    if ( !v35 )
      break;
    v25 = v35;
  }
  v36 = v34;
  v37 = 16LL * (unsigned int)(v34 + 1);
  v38 = (v34 - 1) * v19;
LABEL_12:
  v58 = (_QWORD *)malloc(
                    v37 + v36 + v3 + v38,
                    v38,
                    v37 + v36,
                    v20,
                    v21,
                    v22,
                    v23,
                    v24,
                    v26,
                    v27,
                    v28,
                    v29,
                    v30,
                    v31,
                    v32,
                    v33);
  if ( v58 )
  {
    _gconv_max_path_elem_len = 0LL;
    v47 = strtok_r(v17, ":", &v59);
    if ( !v47 )
      _libc_assert_fail((__int64)"elem != NULL", (__int64)"gconv_conf.c", 0x1A8u, (__int64)"__gconv_get_path");
    v48 = v58;
    v49 = 0;
    v50 = &v58[2 * (unsigned int)(v36 + 1)];
    do
    {
      *v48 = v50;
      if ( *v47 != 47 )
      {
        if ( !v1 )
          _libc_assert_fail((__int64)"cwd != NULL", (__int64)"gconv_conf.c", 0x1AEu, (__int64)"__gconv_get_path");
        v51 = j_memcpy();
        *((_BYTE *)v18 + (_QWORD)v51) = 47;
        v50 = (_QWORD *)((char *)v18 + (_QWORD)v51 + 1);
      }
      v52 = stpcpy(v50, (unsigned __int64)v47);
      if ( *(v52 - 1) != 47 )
        *v52++ = 47;
      v53 = _gconv_max_path_elem_len;
      v54 = (unsigned __int64)&v52[-*v48];
      v48[1] = v54;
      if ( v54 > v53 )
        _gconv_max_path_elem_len = v54;
      *v52 = 0;
      v50 = v52 + 1;
      ++v49;
      v48 += 2;
      v47 = strtok_r(0LL, ":", &v59);
    }
    while ( v47 );
    v55 = &v58[2 * v49];
    *v55 = 0LL;
    v55[1] = 0LL;
  }
  else
  {
    v58 = &empty_path_elem;
  }
  _gconv_path_elem = (__int64)v58;
  free(v1, v39, v40, v41, v42, v43, v44, v45, v46);
}
// 4203F4: variable 'v4' is possibly undefined
// 4203F4: variable 'v5' is possibly undefined
// 4203F4: variable 'v6' is possibly undefined
// 4203F4: variable 'v7' is possibly undefined
// 4203F4: variable 'v8' is possibly undefined
// 4203F4: variable 'v9' is possibly undefined
// 4203F4: variable 'v10' is possibly undefined
// 4203F4: variable 'v11' is possibly undefined
// 4203F4: variable 'v12' is possibly undefined
// 4203F4: variable 'v13' is possibly undefined
// 4203F4: variable 'v14' is possibly undefined
// 4203F4: variable 'v15' is possibly undefined
// 4203F4: variable 'v16' is possibly undefined
// 420474: variable 'v20' is possibly undefined
// 420474: variable 'v21' is possibly undefined
// 420474: variable 'v22' is possibly undefined
// 420474: variable 'v23' is possibly undefined
// 420474: variable 'v24' is possibly undefined
// 420474: variable 'v26' is possibly undefined
// 420474: variable 'v27' is possibly undefined
// 420474: variable 'v28' is possibly undefined
// 420474: variable 'v29' is possibly undefined
// 420474: variable 'v30' is possibly undefined
// 420474: variable 'v31' is possibly undefined
// 420474: variable 'v32' is possibly undefined
// 420474: variable 'v33' is possibly undefined
// 420574: variable 'v39' is possibly undefined
// 420574: variable 'v40' is possibly undefined
// 420574: variable 'v41' is possibly undefined
// 420574: variable 'v42' is possibly undefined
// 420574: variable 'v43' is possibly undefined
// 420574: variable 'v44' is possibly undefined
// 420574: variable 'v45' is possibly undefined
// 420574: variable 'v46' is possibly undefined
// 496D38: using guessed type __int64 _gconv_path_elem;
// 496D40: using guessed type __int64 _gconv_path_envvar;
// 496D48: using guessed type __int64 _gconv_max_path_elem_len;

//----- (0000000000420668) ----------------------------------------------------
void __fastcall insert_module(unsigned __int64 a1, int a2)
{
  unsigned __int64 *v2; // x19
  unsigned __int64 **v5; // x20
  unsigned __int64 *v6; // x21
  int i; // w0
  unsigned __int64 v8; // x2
  unsigned __int64 *v9; // x23
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7
  int v18; // w0
  int v19; // w1
  __int128 v20; // q31
  unsigned __int64 v21; // x0

  v2 = (unsigned __int64 *)_gconv_modules_db;
  if ( !_gconv_modules_db )
  {
    v5 = (unsigned __int64 **)&_gconv_modules_db;
LABEL_12:
    *v5 = (unsigned __int64 *)a1;
    return;
  }
  v5 = (unsigned __int64 **)&_gconv_modules_db;
  v6 = *(unsigned __int64 **)a1;
  for ( i = strcmp(*(unsigned __int64 **)a1, *(_QWORD *)_gconv_modules_db); i; i = strcmp(v6, **v5) )
  {
    if ( i < 0 )
    {
      v8 = v2[4];
      v5 = (unsigned __int64 **)(v2 + 4);
    }
    else
    {
      v8 = v2[6];
      v5 = (unsigned __int64 **)(v2 + 6);
    }
    if ( !v8 )
      goto LABEL_12;
    v2 = *v5;
  }
  v9 = *(unsigned __int64 **)(a1 + 8);
  while ( (unsigned int)strcmp(v9, v2[1]) )
  {
    v5 = (unsigned __int64 **)(v2 + 5);
    v2 = (unsigned __int64 *)v2[5];
    if ( !v2 )
      goto LABEL_12;
    while ( (unsigned int)strcmp(v6, *v2) )
    {
      v5 = (unsigned __int64 **)(v2 + 5);
      v2 = (unsigned __int64 *)v2[5];
      if ( !v2 )
        goto LABEL_12;
    }
  }
  v18 = *((_DWORD *)v2 + 4);
  v19 = *(_DWORD *)(a1 + 16);
  if ( v19 < v18 || v19 == v18 && *(_DWORD *)(a1 + 20) < *((_DWORD *)v2 + 5) )
  {
    v20 = *((_OWORD *)v2 + 2);
    *(_QWORD *)(a1 + 48) = v2[6];
    v21 = (unsigned __int64)v2;
    *(_OWORD *)(a1 + 32) = v20;
    *v5 = (unsigned __int64 *)a1;
LABEL_21:
    free(v21, v10, v11, v12, v13, v14, v15, v16, v17);
    return;
  }
  if ( a2 )
  {
    v21 = a1;
    goto LABEL_21;
  }
}
// 420784: variable 'v10' is possibly undefined
// 420784: variable 'v11' is possibly undefined
// 420784: variable 'v12' is possibly undefined
// 420784: variable 'v13' is possibly undefined
// 420784: variable 'v14' is possibly undefined
// 420784: variable 'v15' is possibly undefined
// 420784: variable 'v16' is possibly undefined
// 420784: variable 'v17' is possibly undefined
// 496D18: using guessed type __int64 _gconv_modules_db;

//----- (00000000004207A0) ----------------------------------------------------
void __fastcall add_module(unsigned __int8 *a1, __int64 a2, __int64 a3, unsigned __int32 a4)
{
  __int64 v4; // x9
  __int64 v6; // x6
  unsigned int v7; // t1
  unsigned int v8; // w4
  _BYTE *v9; // x7
  unsigned int v10; // w4
  unsigned int v11; // t1
  int8x16_t *v12; // x11
  __int64 v13; // x8
  int8x16_t *v14; // x4
  unsigned int v15; // w6
  unsigned int v16; // t1
  _BYTE *v17; // x10
  unsigned int v18; // w6
  unsigned int v19; // t1
  int8x16_t *v20; // x8
  int v21; // w6
  int v22; // t1
  __int64 v23; // x12
  _BYTE *v24; // x1
  int v25; // t1
  int v26; // w22
  int v27; // w0
  int8x16_t *v28; // x3
  int v29; // w0
  __int64 v30; // x19
  __int64 v31; // x25
  int v32; // w23
  _BYTE *v33; // x20
  _QWORD *v34; // x0
  __int64 v35; // x2
  __int64 v36; // x4
  void *v37; // x5
  __int64 v38; // x6
  double v39; // d0
  double v40; // d1
  double v41; // d2
  double v42; // d3
  double v43; // d4
  double v44; // d5
  double v45; // d6
  double v46; // d7
  _BYTE *v47; // x3
  __int64 v48; // x7
  int8x16_t *(__fastcall *v49)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  __int64 (__fastcall *v50)(__int64, __int64 *, unsigned __int64); // x0
  int8x16_t *v51; // x3
  _BYTE *v52; // x10
  _BYTE *v53; // x7
  __int64 (__fastcall *v54)(__int64, __int64 *, unsigned __int64); // x0
  int8x16_t *v55; // x2
  int8x16_t *v56; // x3
  int8x16_t *v57; // x8
  __int64 (__fastcall *v58)(__int64, __int64 *, unsigned __int64); // x0
  unsigned __int64 v59; // x3
  char *v60; // x0
  __int64 v61; // [xsp+0h] [xbp+0h]
  __int64 v62; // [xsp+50h] [xbp+50h]
  __int64 v63; // [xsp+58h] [xbp+58h]
  int8x16_t *v64; // [xsp+60h] [xbp+60h]
  _BYTE *v65; // [xsp+68h] [xbp+68h]
  int8x16_t *v66; // [xsp+70h] [xbp+70h]
  _BYTE *v67; // [xsp+78h] [xbp+78h]
  int8x16_t *v68; // [xsp+80h] [xbp+80h]
  int8x16_t *v69; // [xsp+88h] [xbp+88h]
  int8x16_t *v70[2]; // [xsp+90h] [xbp+90h] BYREF

  v4 = (__int64)a1;
  v6 = *a1;
  if ( (word_45EA40[v6] & 0x2000) != 0 )
  {
    do
    {
      v7 = *(unsigned __int8 *)++v4;
      v6 = v7;
      v8 = v7;
    }
    while ( (word_45EA40[(unsigned __int8)v7] & 0x2000) != 0 );
  }
  else
  {
    v8 = v6;
  }
  if ( v8 )
  {
    v9 = (_BYTE *)v4;
    while ( (word_45EA40[v6] & 0x2000) == 0 )
    {
      *v9 = dword_45E140[v6];
      v11 = (unsigned __int8)*++v9;
      v10 = v11;
      if ( !v11 )
        return;
      v6 = v10;
    }
    *v9 = 0;
    v12 = (int8x16_t *)(v9 + 1);
    v13 = (unsigned __int8)v9[1];
    v14 = (int8x16_t *)(v9 + 1);
    v15 = (unsigned __int8)v9[1];
    if ( (word_45EA40[v13] & 0x2000) != 0 )
    {
      do
      {
        v16 = v14->n128_u8[1];
        v14 = (int8x16_t *)((char *)v14 + 1);
        v13 = v16;
        v15 = v16;
      }
      while ( (word_45EA40[(unsigned __int8)v16] & 0x2000) != 0 );
    }
    v17 = v9 + 1;
    if ( v15 )
    {
      while ( (word_45EA40[v13] & 0x2000) == 0 )
      {
        *v17++ = dword_45E140[v13];
        v19 = v14->n128_u8[1];
        v14 = (int8x16_t *)((char *)v14 + 1);
        v18 = v19;
        if ( !v19 )
          return;
        v13 = v18;
      }
      *v17 = 0;
      v20 = (int8x16_t *)(v17 + 1);
      do
      {
        v22 = v14->n128_u8[1];
        v14 = (int8x16_t *)((char *)v14 + 1);
        v21 = v22;
      }
      while ( (word_45EA40[(unsigned __int8)v22] & 0x2000) != 0 );
      v23 = a3;
      v24 = v17 + 1;
      if ( v21 )
      {
        while ( 1 )
        {
          *v24++ = v21;
          v25 = v14->n128_u8[1];
          v14 = (int8x16_t *)((char *)v14 + 1);
          LOBYTE(v21) = v25;
          if ( !v25 )
            break;
          if ( (word_45EA40[(unsigned __int8)v21] & 0x2000) != 0 )
          {
            v26 = 1;
            *v24 = 0;
            v62 = a3;
            v63 = v4;
            v64 = (int8x16_t *)(v17 + 1);
            v65 = v17;
            v66 = (int8x16_t *)(v9 + 1);
            v67 = v9;
            v68 = (int8x16_t *)(v24 + 1);
            v69 = v14;
            v27 = _isoc23_strtoll(v14, v70, 10);
            v28 = v68;
            v23 = v62;
            v4 = v63;
            v20 = v64;
            v17 = v65;
            v12 = v66;
            v9 = v67;
            if ( v70[0] == v69 )
              goto LABEL_27;
            if ( v27 <= 0 )
              v26 = 1;
            else
              v26 = v27;
            v29 = (unsigned __int8)v65[1];
            if ( v65[1] )
              goto LABEL_28;
            return;
          }
        }
      }
      v26 = 1;
      *v24 = 0;
      v28 = (int8x16_t *)(v24 + 1);
LABEL_27:
      v29 = (unsigned __int8)v17[1];
      if ( v17[1] )
      {
LABEL_28:
        if ( v29 == 47 )
          v30 = 0LL;
        else
          v30 = v23;
        v31 = (char *)v28 - (char *)v20;
        v32 = 3;
        if ( (char *)v28 - (char *)v20 > 3 )
        {
          if ( v28[-1].n128_u32[3] == 7303982 )
            v32 = 0;
          else
            v32 = 3;
        }
        v33 = (char *)v12 - v4;
        v64 = v20;
        v65 = v17;
        v66 = (int8x16_t *)v9;
        v67 = v28;
        v68 = v12;
        v69 = (int8x16_t *)v4;
        *((_BYTE *)&v61 + strnlen(v4, (unsigned __int64)v12->n128_u64 - v4)) = 0;
        v70[0] = (int8x16_t *)j_memcpy();
        v34 = tfind(
                (__int64)v70,
                (unsigned __int64 *)&_gconv_alias_db,
                (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare);
        v48 = (__int64)v66;
        v47 = v67;
        if ( !v34 )
        {
          v66 = v68;
          v67 = (_BYTE *)v48;
          v68 = v69;
          v49 = calloc(
                  1uLL,
                  v47 - (_BYTE *)v69 + 56 + v30 + v32,
                  v35,
                  v47,
                  v39,
                  v40,
                  v41,
                  v42,
                  v43,
                  v44,
                  v45,
                  v46,
                  v36,
                  v37,
                  v38,
                  v48);
          if ( v49 )
          {
            *(_QWORD *)v49 = (char *)v49 + 56;
            v69 = (int8x16_t *)v49;
            v50 = j_memcpy();
            v51 = v69;
            v52 = v65;
            v53 = v67;
            v69->n128_u64[1] = (unsigned __int64)&v33[(_QWORD)v50];
            v68 = v51;
            v69 = (int8x16_t *)(v52 - v53);
            v54 = j_memcpy();
            v56 = v68;
            v55 = v69;
            v68[1].n128_u32[0] = v26;
            v56[1].n128_u32[1] = a4;
            v57 = v64;
            v56[1].n128_u64[1] = (unsigned __int64)v55->n128_u64 + (_QWORD)v54;
            if ( v30 )
            {
              v68 = v56;
              v69 = v57;
              j_memcpy();
              v56 = v68;
            }
            v69 = v56;
            v58 = j_memcpy();
            v59 = (unsigned __int64)v69;
            v60 = (char *)v58 + v31;
            if ( v32 )
              *(_DWORD *)(v60 - 1) = 7303982;
            insert_module(v59, 1);
          }
        }
      }
    }
  }
}
// 4208AC: conditional instruction was optimized away because w3.4==0
// 4209F4: variable 'v35' is possibly undefined
// 4209F4: variable 'v39' is possibly undefined
// 4209F4: variable 'v40' is possibly undefined
// 4209F4: variable 'v41' is possibly undefined
// 4209F4: variable 'v42' is possibly undefined
// 4209F4: variable 'v43' is possibly undefined
// 4209F4: variable 'v44' is possibly undefined
// 4209F4: variable 'v45' is possibly undefined
// 4209F4: variable 'v46' is possibly undefined
// 4209F4: variable 'v36' is possibly undefined
// 4209F4: variable 'v37' is possibly undefined
// 4209F4: variable 'v38' is possibly undefined
// 45E140: using guessed type int dword_45E140[256];
// 45EA40: using guessed type _WORD word_45EA40[256];
// 496D20: using guessed type __int64 _gconv_alias_db;

//----- (0000000000420AC4) ----------------------------------------------------
void __fastcall add_alias2_part_0(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  unsigned __int64 v18; // x0
  _QWORD *v19; // x19
  __int64 (__fastcall *v20)(__int64, __int64 *, unsigned __int64); // x0
  void *v21; // x3
  void *v22; // x4
  void *v23; // x5
  __int64 *v24; // x6
  __int64 v25; // x7
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7
  _QWORD *v34; // x0
  double v35; // d0
  double v36; // d1
  double v37; // d2
  double v38; // d3
  double v39; // d4
  double v40; // d5
  double v41; // d6
  double v42; // d7

  v18 = malloc(a3 - a1 + 16, a2, a3 - a1, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
  if ( v18 )
  {
    v19 = (_QWORD *)v18;
    v20 = j_memcpy();
    *v19 = v20;
    v19[1] = (char *)v20 + a2 - a1;
    v34 = tsearch(
            (__int64)v19,
            &_gconv_alias_db,
            (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare,
            v21,
            v22,
            v23,
            v24,
            v25,
            v26,
            v27,
            v28,
            v29,
            v30,
            v31,
            v32,
            v33);
    if ( !v34 || v19 != (_QWORD *)*v34 )
      free((unsigned __int64)v19, v35, v36, v37, v38, v39, v40, v41, v42);
  }
}
// 420B24: variable 'v21' is possibly undefined
// 420B24: variable 'v22' is possibly undefined
// 420B24: variable 'v23' is possibly undefined
// 420B24: variable 'v24' is possibly undefined
// 420B24: variable 'v25' is possibly undefined
// 420B24: variable 'v26' is possibly undefined
// 420B24: variable 'v27' is possibly undefined
// 420B24: variable 'v28' is possibly undefined
// 420B24: variable 'v29' is possibly undefined
// 420B24: variable 'v30' is possibly undefined
// 420B24: variable 'v31' is possibly undefined
// 420B24: variable 'v32' is possibly undefined
// 420B24: variable 'v33' is possibly undefined
// 420B48: variable 'v35' is possibly undefined
// 420B48: variable 'v36' is possibly undefined
// 420B48: variable 'v37' is possibly undefined
// 420B48: variable 'v38' is possibly undefined
// 420B48: variable 'v39' is possibly undefined
// 420B48: variable 'v40' is possibly undefined
// 420B48: variable 'v41' is possibly undefined
// 420B48: variable 'v42' is possibly undefined
// 496D20: using guessed type __int64 _gconv_alias_db;

//----- (0000000000420B60) ----------------------------------------------------
__int64 *__fastcall read_conf_file_isra_0(
        char *a1,
        __int64 a2,
        __int64 a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  __int64 *result; // x0
  unsigned __int64 v17; // x4
  int *v18; // x5
  void *v19; // x6
  __int64 v20; // x7
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  __int64 *v29; // x19
  int v30; // w0
  __int64 v31; // x0
  unsigned __int64 *v32; // x26
  __int64 v33; // x27
  unsigned __int64 *v34; // x0
  _WORD *v35; // x3
  int v36; // t1
  unsigned __int8 v37; // w1
  unsigned __int64 *v38; // x27
  int v39; // t1
  __int64 v40; // x1
  __int64 v41; // x2
  __int64 v42; // x3
  void *v43; // x4
  void *v44; // x5
  void *v45; // x6
  __int64 v46; // x7
  double v47; // d0
  double v48; // d1
  double v49; // d2
  double v50; // d3
  double v51; // d4
  double v52; // d5
  double v53; // d6
  double v54; // d7
  __int64 v55; // x27
  __int64 v56; // x1
  unsigned int v57; // w0
  unsigned int v58; // t1
  unsigned __int64 *v59; // x2
  unsigned int v60; // w0
  unsigned __int8 *v61; // x1
  unsigned int v62; // t1
  _BYTE *v63; // x26
  unsigned int v64; // w0
  unsigned int v65; // t1
  unsigned __int64 *v66; // x28
  int v67; // w0
  unsigned __int32 v68; // w3
  __int64 v71; // [xsp+78h] [xbp+78h]
  __int64 v72; // [xsp+80h] [xbp+80h] BYREF
  __int64 v73; // [xsp+88h] [xbp+88h] BYREF

  result = (__int64 *)fopen64(a1, "rce", a9, a10, a11, a12, a13, a14, a15, a16, a3, a4, a5, a6, a7, a8);
  v72 = 0LL;
  v73 = 0LL;
  if ( result )
  {
    v29 = result;
    v30 = *(_DWORD *)result;
    *(_DWORD *)v29 = v30 | 0x8000;
    if ( (v30 & 0x10) != 0 )
    {
      v32 = 0LL;
    }
    else
    {
      while ( 1 )
      {
        v31 = getdelim(
                (unsigned __int64 *)&v72,
                (__int64)&v73,
                10LL,
                v29,
                (void *)v17,
                v18,
                v19,
                v20,
                v21,
                v22,
                v23,
                v24,
                v25,
                v26,
                v27,
                v28);
        v32 = (unsigned __int64 *)v72;
        v33 = v31;
        if ( v31 < 0 )
          break;
        v34 = (unsigned __int64 *)strchr(v72, 0x23u);
        if ( v34 )
        {
          *(_BYTE *)v34 = 0;
        }
        else
        {
          v55 = v33 - 1;
          if ( *((_BYTE *)v32 + v55) == 10 )
            *((_BYTE *)v32 + v55) = 0;
        }
        v35 = word_45EA40;
        if ( (word_45EA40[*(unsigned __int8 *)v32] & 0x2000) != 0 )
        {
          do
          {
            v36 = *((unsigned __int8 *)v32 + 1);
            v32 = (unsigned __int64 *)((char *)v32 + 1);
          }
          while ( (word_45EA40[v36] & 0x2000) != 0 );
        }
        if ( v34 != v32 )
        {
          v37 = *(_BYTE *)v32;
          v38 = v32;
          if ( *(_BYTE *)v32 )
          {
            do
            {
              if ( (word_45EA40[v37] & 0x2000) != 0 )
                break;
              v39 = *((unsigned __int8 *)v38 + 1);
              v38 = (unsigned __int64 *)((char *)v38 + 1);
              v37 = v39;
            }
            while ( v39 );
            if ( (char *)v38 - (char *)v32 == 5 )
            {
              if ( *(_DWORD *)v32 == 1634298977 && *((_BYTE *)v32 + 4) == 115 )
              {
                v56 = *(unsigned __int8 *)v38;
                v57 = *(unsigned __int8 *)v38;
                if ( (word_45EA40[v56] & 0x2000) != 0 )
                {
                  do
                  {
                    v58 = *((unsigned __int8 *)v38 + 1);
                    v38 = (unsigned __int64 *)((char *)v38 + 1);
                    v56 = v58;
                    v57 = v58;
                  }
                  while ( (word_45EA40[(unsigned __int8)v58] & 0x2000) != 0 );
                }
                if ( v57 )
                {
                  v59 = v38;
                  v18 = dword_45E140;
                  while ( (word_45EA40[v56] & 0x2000) == 0 )
                  {
                    *(_BYTE *)v59 = dword_45E140[v56];
                    v59 = (unsigned __int64 *)((char *)v59 + 1);
                    if ( !*(_BYTE *)v59 )
                      goto LABEL_16;
                    v56 = *(unsigned __int8 *)v59;
                  }
                  *(_BYTE *)v59 = 0;
                  v19 = (char *)v59 + 1;
                  v17 = *((unsigned __int8 *)v59 + 1);
                  v71 = (__int64)v59 + 1;
                  v60 = *((unsigned __int8 *)v59 + 1);
                  v61 = (unsigned __int8 *)v59 + 1;
                  if ( (word_45EA40[v17] & 0x2000) != 0 )
                  {
                    do
                    {
                      v62 = *++v61;
                      v17 = v62;
                      v60 = v62;
                    }
                    while ( (word_45EA40[(unsigned __int8)v62] & 0x2000) != 0 );
                  }
                  v63 = (char *)v59 + 1;
                  if ( v60 )
                  {
                    while ( (word_45EA40[v17] & 0x2000) == 0 )
                    {
                      *v63++ = dword_45E140[v17];
                      v65 = *++v61;
                      v64 = v65;
                      if ( !v65 )
                        break;
                      v17 = v64;
                    }
                    if ( (_BYTE *)v71 != v63 )
                    {
                      *v63 = 0;
                      v66 = (unsigned __int64 *)_gconv_modules_db;
LABEL_40:
                      if ( v66 )
                      {
                        while ( 1 )
                        {
                          v67 = strcmp(v38, *v66);
                          if ( !v67 )
                            break;
                          if ( v67 < 0 )
                          {
                            v66 = (unsigned __int64 *)v66[4];
                            goto LABEL_40;
                          }
                          v66 = (unsigned __int64 *)v66[6];
                          if ( !v66 )
                            goto LABEL_44;
                        }
                      }
                      else
                      {
LABEL_44:
                        add_alias2_part_0(
                          (__int64)v38,
                          v71,
                          (__int64)(v63 + 1),
                          v35,
                          (void *)v17,
                          v18,
                          v19,
                          v20,
                          v21,
                          v22,
                          v23,
                          v24,
                          v25,
                          v26,
                          v27,
                          v28);
                      }
                    }
                  }
                }
              }
            }
            else if ( (char *)v38 - (char *)v32 == 6 && *(_DWORD *)v32 == 1969516397 && *((_WORD *)v32 + 2) == 25964 )
            {
              v68 = modcounter_0++;
              add_module((unsigned __int8 *)v38, a2, a3, v68);
            }
          }
        }
LABEL_16:
        if ( (*(_DWORD *)v29 & 0x10) != 0 )
        {
          v32 = (unsigned __int64 *)v72;
          break;
        }
      }
    }
    free((unsigned __int64)v32, v21, v22, v23, v24, v25, v26, v27, v28);
    return (__int64 *)fclose(v29, v47, v48, v49, v50, v51, v52, v53, v54, v40, v41, v42, v43, v44, v45, v46);
  }
  return result;
}
// 420BD0: variable 'v17' is possibly undefined
// 420BD0: variable 'v18' is possibly undefined
// 420BD0: variable 'v19' is possibly undefined
// 420BD0: variable 'v20' is possibly undefined
// 420BD0: variable 'v21' is possibly undefined
// 420BD0: variable 'v22' is possibly undefined
// 420BD0: variable 'v23' is possibly undefined
// 420BD0: variable 'v24' is possibly undefined
// 420BD0: variable 'v25' is possibly undefined
// 420BD0: variable 'v26' is possibly undefined
// 420BD0: variable 'v27' is possibly undefined
// 420BD0: variable 'v28' is possibly undefined
// 420C84: variable 'v47' is possibly undefined
// 420C84: variable 'v48' is possibly undefined
// 420C84: variable 'v49' is possibly undefined
// 420C84: variable 'v50' is possibly undefined
// 420C84: variable 'v51' is possibly undefined
// 420C84: variable 'v52' is possibly undefined
// 420C84: variable 'v53' is possibly undefined
// 420C84: variable 'v54' is possibly undefined
// 420C84: variable 'v40' is possibly undefined
// 420C84: variable 'v41' is possibly undefined
// 420C84: variable 'v42' is possibly undefined
// 420C84: variable 'v43' is possibly undefined
// 420C84: variable 'v44' is possibly undefined
// 420C84: variable 'v45' is possibly undefined
// 420C84: variable 'v46' is possibly undefined
// 420DC8: variable 'v35' is possibly undefined
// 45E140: using guessed type int dword_45E140[256];
// 45EA40: using guessed type _WORD word_45EA40[256];
// 496D18: using guessed type __int64 _gconv_modules_db;
// 496D50: using guessed type int modcounter_0;

//----- (0000000000420E24) ----------------------------------------------------
unsigned __int64 _gconv_read_conf()
{
  unsigned __int64 result; // x0
  __int64 v1; // x2
  void *v2; // x3
  void *v3; // x4
  void *v4; // x5
  void *v5; // x6
  __int64 v6; // x7
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  __int64 v15; // x1
  __int64 v16; // x24
  __int64 i; // x23
  __int64 v18; // x21
  char *v19; // x22
  char *v20; // x19
  void *v21; // x3
  void *v22; // x4
  void *v23; // x5
  void *v24; // x6
  __int64 v25; // x7
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7
  int *v34; // x20
  double v35; // d0
  double v36; // d1
  double v37; // d2
  double v38; // d3
  double v39; // d4
  double v40; // d5
  double v41; // d6
  double v42; // d7
  __int64 v43; // x27
  double v44; // d0
  double v45; // d1
  double v46; // d2
  double v47; // d3
  double v48; // d4
  double v49; // d5
  double v50; // d6
  double v51; // d7
  unsigned __int64 (__fastcall *v52)(__int64); // x0
  void *v53; // x3
  void *v54; // x4
  void *v55; // x5
  void *v56; // x6
  __int64 v57; // x7
  double v58; // d0
  double v59; // d1
  double v60; // d2
  double v61; // d3
  double v62; // d4
  double v63; // d5
  double v64; // d6
  double v65; // d7
  _UNKNOWN **v66; // x19
  unsigned __int64 v67; // x0
  unsigned __int64 *v68; // x20
  __int64 j; // x0
  __int64 v70; // x21
  unsigned __int64 (__fastcall *v71)(__int64); // x0
  void *v72; // x3
  void *v73; // x4
  void *v74; // x5
  void *v75; // x6
  __int64 v76; // x7
  double v77; // d0
  double v78; // d1
  double v79; // d2
  double v80; // d3
  double v81; // d4
  double v82; // d5
  double v83; // d6
  double v84; // d7
  unsigned __int64 *v85; // x19
  char *v86; // x24
  __int64 v87; // x23
  int v88; // w0
  int v89; // [xsp+6Ch] [xbp+6Ch]
  unsigned __int64 StatusReg; // [xsp+70h] [xbp+70h]
  char *v91; // [xsp+88h] [xbp+88h] BYREF
  _QWORD v92[2]; // [xsp+90h] [xbp+90h] BYREF
  int v93; // [xsp+A0h] [xbp+A0h]

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v89 = *(_DWORD *)(StatusReg + 40);
  if ( (unsigned int)_gconv_load_cache() )
  {
    _gconv_get_path();
    v15 = _gconv_path_elem;
    v16 = 16LL;
    for ( i = *(_QWORD *)_gconv_path_elem; i; v16 += 16LL )
    {
      v18 = *(_QWORD *)(v15 + 8);
      v19 = (char *)malloc(v18 + 16, v15, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);
      if ( v19 )
      {
        v20 = (char *)j_memcpy() + v18;
        strcpy(v20, "gconv-modules");
        read_conf_file_isra_0(v19, i, v18, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32, v33);
        strcpy(v20 + 13, ".d");
        v34 = (int *)opendir(v19);
        if ( v34 )
        {
          while ( 1 )
          {
            v43 = readdir64((__int64)v34);
            if ( !v43 )
              break;
            while ( (*(_BYTE *)(v43 + 18) & 0xF7) == 0 )
            {
              v52 = strlen();
              if ( (unsigned __int64)v52 <= 5
                || (unsigned int)strcmp((unsigned __int64 *)((char *)v52 + v43 + 14), (unsigned __int64)".conf")
                || (asprintf((unsigned __int64 *)&v91, (__int64)"%s/%s", v19, (const char *)(v43 + 19)) & 0x80000000) != 0 )
              {
                break;
              }
              if ( *(_BYTE *)(v43 + 18)
                || (unsigned int)lstat64(v91, (struct stat *)v92) != -1 && (v93 & 0xF000) == 0x8000 )
              {
                read_conf_file_isra_0(v91, i, v18, v53, v54, v55, v56, v57, v58, v59, v60, v61, v62, v63, v64, v65);
              }
              free((unsigned __int64)v91, v58, v59, v60, v61, v62, v63, v64, v65);
              v43 = readdir64((__int64)v34);
              if ( !v43 )
                goto LABEL_15;
            }
          }
LABEL_15:
          closedir(v34, v44, v45, v46, v47, v48, v49, v50, v51);
        }
        free((unsigned __int64)v19, v35, v36, v37, v38, v39, v40, v41, v42);
      }
      v15 = _gconv_path_elem + v16;
      i = *(_QWORD *)(_gconv_path_elem + v16);
    }
    v66 = &builtin_modules;
    do
    {
      while ( 1 )
      {
        v92[0] = *v66;
        if ( !tfind(
                (__int64)v92,
                (unsigned __int64 *)&_gconv_alias_db,
                (__int64 (__fastcall *)(__int64, _QWORD))_gconv_alias_compare) )
          break;
        v66 += 7;
        if ( v66 == (_UNKNOWN **)&unk_491818 )
          goto LABEL_22;
      }
      v67 = (unsigned __int64)v66;
      v66 += 7;
      insert_module(v67, 0);
    }
    while ( v66 != (_UNKNOWN **)&unk_491818 );
LABEL_22:
    v68 = (unsigned __int64 *)"UCS4//";
    for ( j = 6LL; ; j = (__int64)strlen() )
    {
      v70 = (__int64)v68 + j + 1;
      v71 = strlen();
      v85 = (unsigned __int64 *)_gconv_modules_db;
      v86 = (char *)v71 + v70;
      v87 = (__int64)v71 + v70 + 1;
LABEL_24:
      if ( v85 )
      {
        while ( 1 )
        {
          v88 = strcmp(v68, *v85);
          if ( !v88 )
            break;
          if ( v88 < 0 )
          {
            v85 = (unsigned __int64 *)v85[4];
            goto LABEL_24;
          }
          v85 = (unsigned __int64 *)v85[6];
          if ( !v85 )
            goto LABEL_28;
        }
      }
      else
      {
LABEL_28:
        add_alias2_part_0((__int64)v68, v70, v87, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82, v83, v84);
      }
      if ( !v86[1] )
        break;
      v68 = (unsigned __int64 *)v87;
    }
    result = StatusReg;
    *(_DWORD *)(StatusReg + 40) = v89;
  }
  else
  {
    result = StatusReg;
    *(_DWORD *)(StatusReg + 40) = v89;
  }
  return result;
}
// 420EAC: variable 'v1' is possibly undefined
// 420EAC: variable 'v2' is possibly undefined
// 420EAC: variable 'v3' is possibly undefined
// 420EAC: variable 'v4' is possibly undefined
// 420EAC: variable 'v5' is possibly undefined
// 420EAC: variable 'v6' is possibly undefined
// 420EAC: variable 'v7' is possibly undefined
// 420EAC: variable 'v8' is possibly undefined
// 420EAC: variable 'v9' is possibly undefined
// 420EAC: variable 'v10' is possibly undefined
// 420EAC: variable 'v11' is possibly undefined
// 420EAC: variable 'v12' is possibly undefined
// 420EAC: variable 'v13' is possibly undefined
// 420EAC: variable 'v14' is possibly undefined
// 420EE4: variable 'v21' is possibly undefined
// 420EE4: variable 'v22' is possibly undefined
// 420EE4: variable 'v23' is possibly undefined
// 420EE4: variable 'v24' is possibly undefined
// 420EE4: variable 'v25' is possibly undefined
// 420EE4: variable 'v26' is possibly undefined
// 420EE4: variable 'v27' is possibly undefined
// 420EE4: variable 'v28' is possibly undefined
// 420EE4: variable 'v29' is possibly undefined
// 420EE4: variable 'v30' is possibly undefined
// 420EE4: variable 'v31' is possibly undefined
// 420EE4: variable 'v32' is possibly undefined
// 420EE4: variable 'v33' is possibly undefined
// 420F98: variable 'v58' is possibly undefined
// 420F98: variable 'v59' is possibly undefined
// 420F98: variable 'v60' is possibly undefined
// 420F98: variable 'v61' is possibly undefined
// 420F98: variable 'v62' is possibly undefined
// 420F98: variable 'v63' is possibly undefined
// 420F98: variable 'v64' is possibly undefined
// 420F98: variable 'v65' is possibly undefined
// 420FB0: variable 'v44' is possibly undefined
// 420FB0: variable 'v45' is possibly undefined
// 420FB0: variable 'v46' is possibly undefined
// 420FB0: variable 'v47' is possibly undefined
// 420FB0: variable 'v48' is possibly undefined
// 420FB0: variable 'v49' is possibly undefined
// 420FB0: variable 'v50' is possibly undefined
// 420FB0: variable 'v51' is possibly undefined
// 420FB8: variable 'v35' is possibly undefined
// 420FB8: variable 'v36' is possibly undefined
// 420FB8: variable 'v37' is possibly undefined
// 420FB8: variable 'v38' is possibly undefined
// 420FB8: variable 'v39' is possibly undefined
// 420FB8: variable 'v40' is possibly undefined
// 420FB8: variable 'v41' is possibly undefined
// 420FB8: variable 'v42' is possibly undefined
// 421090: variable 'v72' is possibly undefined
// 421090: variable 'v73' is possibly undefined
// 421090: variable 'v74' is possibly undefined
// 421090: variable 'v75' is possibly undefined
// 421090: variable 'v76' is possibly undefined
// 421090: variable 'v77' is possibly undefined
// 421090: variable 'v78' is possibly undefined
// 421090: variable 'v79' is possibly undefined
// 421090: variable 'v80' is possibly undefined
// 421090: variable 'v81' is possibly undefined
// 421090: variable 'v82' is possibly undefined
// 421090: variable 'v83' is possibly undefined
// 421090: variable 'v84' is possibly undefined
// 4210B8: variable 'v53' is possibly undefined
// 4210B8: variable 'v54' is possibly undefined
// 4210B8: variable 'v55' is possibly undefined
// 4210B8: variable 'v56' is possibly undefined
// 4210B8: variable 'v57' is possibly undefined
// 491578: using guessed type _UNKNOWN *builtin_modules;
// 496D18: using guessed type __int64 _gconv_modules_db;
// 496D20: using guessed type __int64 _gconv_alias_db;
// 496D38: using guessed type __int64 _gconv_path_elem;

//----- (00000000004210EC) ----------------------------------------------------
__int64 _gconv_load_conf()
{
  return pthread_once(&once, _gconv_read_conf);
}
// 496D54: using guessed type unsigned int once;

//----- (0000000000421104) ----------------------------------------------------
void __fastcall _gconv_conf_freemem(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  bool v8; // zf

  if ( _gconv_path_elem )
    v8 = _gconv_path_elem == (_QWORD)&empty_path_elem;
  else
    v8 = 1;
  if ( !v8 )
    free(_gconv_path_elem, a1, a2, a3, a4, a5, a6, a7, a8);
}
// 496D38: using guessed type __int64 _gconv_path_elem;

//----- (0000000000421140) ----------------------------------------------------
__int64 __fastcall _gconv_get_builtin_trans(unsigned __int64 *a1, __int64 a2)
{
  __int64 v4; // x19
  char **v5; // x19
  __int128 v6; // q31
  int v7; // w0
  int v8; // w1
  __int64 result; // x0
  int v10; // w1

  v4 = 0LL;
  while ( (unsigned int)strcmp(a1, (unsigned __int64)(&map)[4 * (unsigned int)v4]) )
  {
    if ( ++v4 == 12 )
      _libc_assert_fail(
        (__int64)"cnt < sizeof (map) / sizeof (map[0])",
        (__int64)"gconv_builtin.c",
        0x45u,
        (__int64)"__gconv_get_builtin_trans");
  }
  v5 = &(&map)[4 * v4];
  v6 = *(_OWORD *)(v5 + 1);
  *(_DWORD *)(a2 + 88) = 0;
  v7 = *((char *)v5 + 24);
  v8 = *((char *)v5 + 25);
  *(_OWORD *)(a2 + 40) = v6;
  *(_DWORD *)(a2 + 72) = v7;
  *(_DWORD *)(a2 + 76) = v8;
  result = (unsigned int)*((char *)v5 + 26);
  v10 = *((char *)v5 + 27);
  *(_DWORD *)(a2 + 80) = result;
  *(_DWORD *)(a2 + 84) = v10;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  return result;
}
// 48F7D0: using guessed type char *map;

//----- (0000000000421200) ----------------------------------------------------
__int64 __fastcall _gconv_btwoc_ascii(__int64 a1, unsigned __int8 a2)
{
  if ( (a2 & 0x80) != 0 )
    return 0xFFFFFFFFLL;
  else
    return a2;
}

//----- (0000000000421210) ----------------------------------------------------
__int64 __fastcall _gconv_transform_internal_ucs4(
        __int64 a1,
        __int64 a2,
        __int64 *a3,
        unsigned __int64 a4,
        unsigned __int64 *a5,
        __int64 *a6,
        unsigned int a7,
        unsigned int a8)
{
  __int64 v8; // x14
  unsigned __int64 v9; // x13
  __int64 v12; // x1
  unsigned __int64 *v14; // x0
  unsigned __int64 v15; // x12
  unsigned __int64 v16; // x23
  unsigned __int64 v17; // x0
  __int64 v19; // x27
  __int64 *v20; // x20
  unsigned __int64 v21; // x25
  _BYTE *v23; // x23
  unsigned __int64 v24; // x19
  __int64 v25; // x26
  signed __int64 v26; // x0
  __int64 v27; // x2
  __int64 v28; // x0
  __int64 v29; // x1
  unsigned __int64 v30; // x3
  __int64 v31; // x1
  unsigned int v32; // w21
  int v33; // w1
  unsigned int v34; // w0
  unsigned __int64 v35; // x4
  unsigned int v36; // w7
  int v37; // w19
  unsigned __int64 *v38; // x25
  __int64 *v39; // x26
  _BYTE *v40; // x27
  unsigned int v41; // w20
  bool v42; // zf
  int *v44; // x3
  int v45; // w6
  unsigned __int64 v46; // x0
  _BYTE *v47; // x2
  __int64 v50; // x1
  signed __int64 v51; // x1
  __int64 v52; // x3
  __int64 v53; // x1
  __int64 v54; // x6
  __int64 v55; // x2
  unsigned __int64 v56; // x0
  __int64 i; // x1
  __int64 v58; // x2
  char v59; // w3
  unsigned int *v60; // x1
  unsigned int v61; // w0
  unsigned int v62; // w2
  __int64 v63; // [xsp+68h] [xbp+68h]
  unsigned __int64 v64; // [xsp+70h] [xbp+70h]
  __int64 v65; // [xsp+80h] [xbp+80h]
  __int64 (__fastcall *v66)(__int64, __int64, unsigned __int64 *, unsigned __int64, _QWORD, __int64 *, _QWORD, _QWORD); // [xsp+88h] [xbp+88h]
  __int64 v67; // [xsp+90h] [xbp+90h]
  unsigned __int64 v69; // [xsp+A8h] [xbp+A8h] BYREF

  v8 = a1 + 104;
  v9 = 0LL;
  v12 = a2 + 48;
  if ( (*(_DWORD *)(a2 + 16) & 1) == 0 )
  {
    v9 = *(_QWORD *)(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v9 ^= _pointer_chk_guard_local;
  }
  if ( !a7 )
  {
    if ( a5 )
      v14 = a5;
    else
      v14 = (unsigned __int64 *)a2;
    v15 = *(_QWORD *)(a2 + 8);
    v16 = *v14;
    if ( !a8 || (v44 = *(int **)(a2 + 32), v45 = *v44, LODWORD(v46) = *v44 & 7, !(_DWORD)v46) )
    {
LABEL_9:
      v65 = v12;
      v17 = a4;
      v19 = a2;
      v20 = a3;
      v21 = v16;
      v23 = (_BYTE *)v17;
      v24 = v15;
      v66 = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64 *, unsigned __int64, _QWORD, __int64 *, _QWORD, _QWORD))v9;
      v67 = v8;
      while ( 1 )
      {
        v63 = 0LL;
        v25 = *v20;
        if ( a6 )
          v63 = *a6;
        v26 = v24 - v21;
        if ( (__int64)(v24 - v21) > (__int64)&v23[-v25] )
          v26 = (signed __int64)&v23[-v25];
        v27 = v26 / 4;
        if ( v26 / 4 )
        {
          v28 = 0LL;
          do
          {
            *(_DWORD *)(v21 + 4 * v28) = bswap32(*(_DWORD *)(v25 + 4 * v28));
            v29 = v28++;
          }
          while ( v27 != v28 );
          v30 = v21 + 4 + 4 * v29;
          v31 = v25 + 4 + 4 * v29;
        }
        else
        {
          v30 = v21;
          v31 = *v20;
        }
        *v20 = v31;
        v32 = 4;
        if ( v23 != (_BYTE *)v31 )
        {
          if ( v24 < v30 + 4 )
            v32 = 5;
          else
            v32 = 7;
        }
        if ( a5 )
        {
          *a5 = v30;
          return v32;
        }
        v33 = *(_DWORD *)(v19 + 16);
        ++*(_DWORD *)(v19 + 20);
        if ( (v33 & 1) != 0 )
        {
          v38 = (unsigned __int64 *)v19;
          v39 = v20;
          v36 = a8;
          v37 = 0;
          v41 = v32;
          v40 = v23;
          *v38 = v30;
          goto LABEL_31;
        }
        if ( v21 >= v30 )
          goto LABEL_30;
        v69 = *(_QWORD *)v19;
        v64 = v30;
        v34 = v66(v67, v65, &v69, v30, 0LL, a6, 0LL, a8);
        if ( v34 == 4 )
        {
          if ( v32 != 5 )
          {
LABEL_30:
            v36 = a8;
            v37 = 0;
            v38 = (unsigned __int64 *)v19;
            v39 = v20;
            v40 = v23;
            v41 = v32;
            goto LABEL_31;
          }
        }
        else
        {
          v35 = v69;
          if ( v69 == v64 )
            goto LABEL_27;
          v50 = 0LL;
          if ( a6 )
            v50 = *a6;
          if ( v50 == v63 )
          {
            *v20 -= v64 - v69;
            if ( v34 )
            {
LABEL_75:
              v38 = (unsigned __int64 *)v19;
              v39 = v20;
              v36 = a8;
              v37 = 0;
              v40 = v23;
              v41 = v34;
LABEL_31:
              if ( v36 )
                v42 = v41 == 7;
              else
                v42 = 0;
              if ( !v42 )
                return v41;
              v56 = (unsigned __int64)&v40[-*v39];
              if ( v56 > 4 )
                _libc_assert_fail(
                  (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
                  (__int64)"../iconv/skeleton.c",
                  0x287u,
                  (__int64)"__gconv_transform_internal_ucs4");
              if ( v56 )
              {
                *(_BYTE *)(v38[4] + 4) = *(_BYTE *)*v39;
                for ( i = 1LL; v56 != i; *(_BYTE *)(v58 + 4) = v59 )
                {
                  v58 = v38[4] + i;
                  v59 = *(_BYTE *)(*v39 + i++);
                }
                v37 = v56;
              }
              v60 = (unsigned int *)v38[4];
              v61 = *v60;
              *v39 = (__int64)v40;
              *v60 = v61 & 0xFFFFFFF8 | v37;
              return 7;
            }
          }
          else
          {
            v51 = v69 - v21;
            if ( (__int64)(v69 - v21) > (__int64)&v23[-v25] )
              v51 = (signed __int64)&v23[-v25];
            v52 = v51 / 4;
            if ( v51 / 4 )
            {
              v53 = 0LL;
              do
              {
                v54 = v53;
                *(_DWORD *)(v21 + 4 * v53) = bswap32(*(_DWORD *)(v25 + 4 * v53));
                ++v53;
              }
              while ( v52 != v53 );
              v55 = v21 + 4 + 4 * v54;
              v25 += 4 + 4 * v54;
            }
            else
            {
              v55 = v21;
            }
            *v20 = v25;
            if ( v23 == (_BYTE *)v25 || v35 >= v55 + 4 )
            {
              if ( v35 == v55 )
                _libc_assert_fail(
                  (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                  (__int64)"../iconv/skeleton.c",
                  0x253u,
                  (__int64)"__gconv_transform_internal_ucs4");
LABEL_86:
              _libc_assert_fail(
                (__int64)"outbuf == outerr",
                (__int64)"../iconv/skeleton.c",
                0x252u,
                (__int64)"__gconv_transform_internal_ucs4");
            }
            if ( v35 != v55 )
              goto LABEL_86;
            if ( v21 != v35 )
            {
LABEL_27:
              if ( v34 )
                goto LABEL_75;
              goto LABEL_28;
            }
            --*(_DWORD *)(v19 + 20);
            if ( v34 )
              goto LABEL_75;
          }
        }
LABEL_28:
        v21 = *(_QWORD *)v19;
      }
    }
    if ( !a5 )
    {
      v47 = (_BYTE *)*a3;
      v46 = (int)v46;
      if ( (v45 & 4) == 0 && (unsigned __int64)v47 < a4 )
      {
        do
        {
          ++v46;
          *a3 = (__int64)(v47 + 1);
          *((_BYTE *)v44 + v46 + 3) = *v47;
          v47 = (_BYTE *)*a3;
        }
        while ( a4 > *a3 && v46 != 4 );
      }
      if ( v46 <= 3 )
      {
        *v44 = v45 & 0xFFFFFFF8 | v46;
        return 7;
      }
      v16 += 4LL;
      *(_BYTE *)(v16 - 4) = *((_BYTE *)v44 + 7);
      *(_BYTE *)(v16 - 3) = *((_BYTE *)v44 + 6);
      *(_BYTE *)(v16 - 2) = *((_BYTE *)v44 + 5);
      *(_BYTE *)(v16 - 1) = *((_BYTE *)v44 + 4);
      *v44 &= 0xFFFFFFF8;
      goto LABEL_9;
    }
    v62 = 467;
LABEL_88:
    _libc_assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      v62,
      (__int64)"__gconv_transform_internal_ucs4");
  }
  if ( a5 )
  {
    v62 = 350;
    goto LABEL_88;
  }
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_DWORD *)(a2 + 16) & 1) != 0 )
    return 0;
  return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, __int64 *, _QWORD))v9)(
           v8,
           v12,
           0LL,
           0LL,
           0LL,
           a6,
           a7);
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000421720) ----------------------------------------------------
__int64 __fastcall _gconv_transform_ucs4_internal(
        __int64 a1,
        __int64 a2,
        unsigned __int64 *a3,
        unsigned __int64 a4,
        _QWORD *a5,
        __int64 *a6,
        int a7,
        unsigned int a8)
{
  __int64 v8; // x15
  unsigned __int64 v9; // x13
  __int64 v12; // x1
  int v16; // w2
  _QWORD *v17; // x0
  __int64 *v18; // x11
  unsigned __int64 v19; // x24
  _DWORD *v20; // x28
  unsigned int *v21; // x5
  unsigned int v22; // w4
  unsigned __int64 v23; // x0
  _BYTE *v24; // x18
  __int64 v25; // x9
  __int64 *v28; // x0
  unsigned __int64 *v29; // x23
  unsigned int *v30; // x27
  __int64 v31; // x26
  __int64 *v32; // x28
  unsigned int **v33; // x25
  __int64 *v34; // x21
  __int64 v35; // x22
  unsigned int *v36; // x19
  _BYTE *v37; // x1
  _BYTE *v38; // x4
  _BYTE *v39; // x0
  unsigned int v40; // w0
  unsigned int v41; // w14
  int v42; // w1
  unsigned int v43; // w0
  unsigned __int64 v44; // x2
  _BYTE *v45; // x9
  int v46; // w0
  int v48; // w6
  unsigned int v49; // w7
  unsigned int **v50; // x25
  unsigned int v51; // w22
  unsigned __int64 *v52; // x26
  bool v53; // zf
  __int64 v54; // x0
  __int64 v55; // x1
  __int64 v56; // x1
  int v57; // w6
  unsigned int *v58; // x4
  _BYTE *v59; // x8
  unsigned int v60; // w1
  int v61; // w0
  unsigned __int64 v62; // x0
  __int64 i; // x1
  __int64 v64; // x2
  char v65; // w3
  unsigned int *v66; // x1
  unsigned int v67; // w0
  unsigned int v68; // w2
  unsigned int v69; // [xsp+64h] [xbp+64h]
  __int64 v70; // [xsp+80h] [xbp+80h]
  __int64 (__fastcall *v71)(__int64, __int64, unsigned int **, unsigned int *, _QWORD, __int64 *, _QWORD, _QWORD); // [xsp+88h] [xbp+88h]
  __int64 v72; // [xsp+90h] [xbp+90h]
  __int64 v74; // [xsp+A0h] [xbp+A0h] BYREF
  unsigned int *v75; // [xsp+A8h] [xbp+A8h] BYREF

  v8 = a1 + 104;
  v9 = 0LL;
  v12 = a2 + 48;
  v16 = *(_DWORD *)(a2 + 16);
  if ( (v16 & 1) == 0 )
  {
    v9 = *(_QWORD *)(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v9 ^= _pointer_chk_guard_local;
  }
  if ( a7 )
  {
    if ( !a5 )
    {
      **(_QWORD **)(a2 + 32) = 0LL;
      if ( (*(_DWORD *)(a2 + 16) & 1) != 0 )
        return 0;
      return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, __int64 *))v9)(
               v8,
               v12,
               0LL,
               0LL,
               0LL,
               a6);
    }
    v68 = 350;
    goto LABEL_104;
  }
  if ( a5 )
    v17 = a5;
  else
    v17 = (_QWORD *)a2;
  v18 = &v74;
  v19 = *(_QWORD *)(a2 + 8);
  if ( !a6 )
    v18 = 0LL;
  v20 = (_DWORD *)*v17;
  v74 = 0LL;
  if ( a8 )
  {
    v21 = *(unsigned int **)(a2 + 32);
    v22 = *v21;
    LODWORD(v23) = *v21 & 7;
    if ( (_DWORD)v23 )
    {
      if ( !a5 )
      {
        v24 = (_BYTE *)*a3;
        v25 = (int)v23;
        v23 = (int)v23;
        if ( (v22 & 4) == 0 && (unsigned __int64)v24 < a4 )
        {
          do
          {
            ++v23;
            *a3 = (unsigned __int64)(v24 + 1);
            *((_BYTE *)v21 + v23 + 3) = *v24;
            v24 = (_BYTE *)*a3;
          }
          while ( a4 > *a3 && v23 != 4 );
        }
        if ( v23 <= 3 )
        {
          v51 = 7;
          *v21 = v22 & 0xFFFFFFF8 | v23;
          return v51;
        }
        if ( *((unsigned __int8 *)v21 + 4) > 0x80u )
        {
          if ( (v16 & 2) == 0 )
          {
            v51 = 6;
            *a3 = (unsigned __int64)&v24[v25 - v23];
            *(_DWORD *)(a2 + 16) |= 0x40000000u;
            return v51;
          }
        }
        else
        {
          *((_BYTE *)++v20 - 4) = *((_BYTE *)v21 + 7);
          *((_BYTE *)v20 - 3) = *((_BYTE *)v21 + 6);
          *((_BYTE *)v20 - 2) = *((_BYTE *)v21 + 5);
          *((_BYTE *)v20 - 1) = *((_BYTE *)v21 + 4);
          v24 = (_BYTE *)*a3;
          v22 = *v21;
        }
        *v21 = v22 & 0xFFFFFFF8;
        v16 = *(_DWORD *)(a2 + 16);
        goto LABEL_27;
      }
      v68 = 467;
LABEL_104:
      _libc_assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        v68,
        (__int64)"__gconv_transform_ucs4_internal");
    }
  }
  v24 = (_BYTE *)*a3;
LABEL_27:
  v70 = v12;
  v28 = a6;
  v29 = a3;
  v30 = v20;
  v31 = a2;
  v32 = v28;
  v33 = (unsigned int **)a5;
  v34 = v18;
  v35 = 0LL;
  v71 = (__int64 (__fastcall *)(__int64, __int64, unsigned int **, unsigned int *, _QWORD, __int64 *, _QWORD, _QWORD))v9;
  v72 = v8;
  while ( 1 )
  {
    if ( v32 )
      v35 += *v32;
    v36 = v30;
    v37 = v24 + 4;
    v38 = v24;
    if ( (unsigned __int64)(v24 + 4) <= a4 )
    {
      while ( 1 )
      {
        v38 = v37 - 4;
        if ( v19 < (unsigned __int64)(v36 + 1) )
          break;
        v40 = bswap32(*((_DWORD *)v37 - 1));
        if ( (v40 & 0x80000000) != 0 )
        {
          if ( !v34 )
          {
            v36 = v30;
            v41 = 6;
            *(_DWORD *)(v31 + 16) |= 0x40000000u;
            goto LABEL_44;
          }
          if ( (v16 & 2) == 0 )
          {
            v46 = *(_DWORD *)(v31 + 16);
            v41 = 6;
            *v29 = (unsigned __int64)v38;
            *(_DWORD *)(v31 + 16) = v46 | 0x40000000;
            if ( v33 )
            {
LABEL_52:
              *v33 = v36;
              return v41;
            }
            goto LABEL_45;
          }
          ++*v34;
          v39 = v37 + 4;
          if ( a4 < (unsigned __int64)(v37 + 4) )
          {
LABEL_39:
            v38 = v37;
            break;
          }
        }
        else
        {
          *v36 = v40;
          v39 = v37 + 4;
          ++v36;
          if ( a4 < (unsigned __int64)(v37 + 4) )
            goto LABEL_39;
        }
        v37 = v39;
      }
    }
    *v29 = (unsigned __int64)v38;
    v41 = 4;
    if ( (_BYTE *)a4 != v38 )
    {
      if ( v19 < (unsigned __int64)(v36 + 1) )
        v41 = 5;
      else
        v41 = 7;
    }
LABEL_44:
    if ( v33 )
      goto LABEL_52;
LABEL_45:
    v42 = *(_DWORD *)(v31 + 16);
    ++*(_DWORD *)(v31 + 20);
    if ( (v42 & 1) != 0 )
    {
      v50 = (unsigned int **)v31;
      v51 = v41;
      v54 = *v32;
      v52 = v29;
      v55 = v74;
      v49 = a8;
      v48 = 0;
      *v50 = v36;
      *v32 = v54 + v55;
      goto LABEL_55;
    }
    if ( v30 >= v36 )
      goto LABEL_54;
    v75 = *(unsigned int **)v31;
    v69 = v41;
    v43 = v71(v72, v70, &v75, v36, 0LL, v32, 0LL, a8);
    v41 = v69;
    if ( v43 != 4 )
      break;
    if ( v69 != 5 )
    {
LABEL_54:
      v49 = a8;
      v48 = 0;
      v50 = (unsigned int **)v31;
      v51 = v41;
      v52 = v29;
      goto LABEL_55;
    }
LABEL_50:
    v24 = (_BYTE *)*v29;
    v30 = *(unsigned int **)v31;
    v35 = v74;
    v16 = *(_DWORD *)(v31 + 16);
  }
  v44 = (unsigned __int64)v75;
  v45 = v24 + 4;
  if ( v75 != v36 )
  {
    v56 = 0LL;
    if ( v32 )
      v56 = *v32;
    if ( v56 + v74 == v35 )
    {
      *v29 -= (char *)v36 - (char *)v75;
    }
    else
    {
      *v29 = (unsigned __int64)v24;
      if ( (unsigned __int64)(v24 + 4) > a4 )
      {
        v58 = v30;
        v45 = v24;
LABEL_86:
        *v29 = (unsigned __int64)v45;
        if ( (_BYTE *)a4 == v45 || v44 >= (unsigned __int64)(v58 + 1) )
          goto LABEL_74;
      }
      else
      {
        v57 = *(_DWORD *)(v31 + 16);
        v58 = v30;
        while ( 1 )
        {
          v59 = v45 - 4;
          if ( v44 < (unsigned __int64)(v58 + 1) )
            break;
          v60 = bswap32(*((_DWORD *)v45 - 1));
          if ( (v60 & 0x80000000) != 0 )
          {
            if ( !v34 )
            {
              *(_DWORD *)(v31 + 16) |= 0x40000000u;
              if ( (unsigned int *)v44 != v30 )
LABEL_102:
                _libc_assert_fail(
                  (__int64)"outbuf == outerr",
                  (__int64)"../iconv/skeleton.c",
                  0x252u,
                  (__int64)"__gconv_transform_ucs4_internal");
LABEL_75:
              _libc_assert_fail(
                (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                (__int64)"../iconv/skeleton.c",
                0x253u,
                (__int64)"__gconv_transform_ucs4_internal");
            }
            if ( (v57 & 2) == 0 )
            {
              v61 = *(_DWORD *)(v31 + 16);
              *v29 = (unsigned __int64)v59;
              *(_DWORD *)(v31 + 16) = v61 | 0x40000000;
              goto LABEL_74;
            }
            ++*v34;
          }
          else
          {
            *v58++ = v60;
          }
          if ( a4 < (unsigned __int64)(v45 + 4) )
            goto LABEL_86;
          v45 += 4;
        }
        *v29 = (unsigned __int64)v59;
        if ( (_BYTE *)a4 == v59 )
        {
LABEL_74:
          if ( (unsigned int *)v44 != v58 )
            goto LABEL_102;
          goto LABEL_75;
        }
      }
      if ( (unsigned int *)v44 != v58 )
        goto LABEL_102;
      if ( (unsigned int *)v44 == v30 )
        --*(_DWORD *)(v31 + 20);
    }
  }
  if ( !v43 )
    goto LABEL_50;
  v50 = (unsigned int **)v31;
  v51 = v43;
  v49 = a8;
  v48 = 0;
  v52 = v29;
LABEL_55:
  if ( v49 )
    v53 = v51 == 7;
  else
    v53 = 0;
  if ( v53 )
  {
    v62 = a4 - *v52;
    if ( v62 > 4 )
      _libc_assert_fail(
        (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
        (__int64)"../iconv/skeleton.c",
        0x287u,
        (__int64)"__gconv_transform_ucs4_internal");
    if ( v62 )
    {
      *((_BYTE *)v50[4] + 4) = *(_BYTE *)*v52;
      for ( i = 1LL; v62 != i; *(_BYTE *)(v64 + 4) = v65 )
      {
        v64 = (__int64)v50[4] + i;
        v65 = *(_BYTE *)(*v52 + i++);
      }
      v48 = v62;
    }
    v66 = v50[4];
    v67 = *v66;
    *v52 = a4;
    *v66 = v67 & 0xFFFFFFF8 | v48;
  }
  return v51;
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000421D24) ----------------------------------------------------
__int64 __fastcall _gconv_transform_internal_ucs4le(
        __int64 a1,
        __int64 a2,
        _BYTE **a3,
        _BYTE *a4,
        char **a5,
        __int64 *a6,
        unsigned int a7,
        unsigned int a8)
{
  __int64 v8; // x11
  unsigned __int64 v9; // x10
  __int64 v12; // x1
  char **v15; // x0
  unsigned __int64 v16; // x21
  char *v17; // x28
  __int64 v18; // x0
  char *v19; // x26
  __int64 v20; // x28
  _BYTE *v21; // x19
  __int64 v22; // x0
  unsigned int v23; // w22
  __int64 v24; // x2
  char *v25; // x24
  int v26; // w1
  unsigned int v27; // w6
  unsigned __int64 v28; // x22
  unsigned int v29; // w7
  int v30; // w20
  __int64 v31; // x26
  bool v32; // zf
  int *v34; // x6
  int v35; // w9
  unsigned __int64 v36; // x0
  _BYTE *v37; // x2
  __int64 v40; // x0
  __int64 v41; // x0
  __int64 v42; // x20
  unsigned __int64 v43; // x20
  char *v44; // x0
  unsigned __int64 v45; // x2
  __int64 i; // x0
  __int64 v47; // x1
  char v48; // w3
  unsigned int *v49; // x1
  unsigned int v50; // w0
  unsigned int v51; // w2
  __int64 v52; // [xsp+68h] [xbp+68h]
  unsigned int v53; // [xsp+68h] [xbp+68h]
  __int64 v55; // [xsp+80h] [xbp+80h]
  __int64 (__fastcall *v56)(__int64, __int64, unsigned __int64 *, char *, _QWORD, __int64 *, _QWORD, _QWORD); // [xsp+88h] [xbp+88h]
  __int64 v57; // [xsp+90h] [xbp+90h]
  unsigned __int64 v59; // [xsp+A8h] [xbp+A8h] BYREF

  v8 = a1 + 104;
  v9 = 0LL;
  v12 = a2 + 48;
  if ( (*(_DWORD *)(a2 + 16) & 1) == 0 )
  {
    v9 = *(_QWORD *)(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v9 ^= _pointer_chk_guard_local;
  }
  if ( a7 )
  {
    if ( !a5 )
    {
      **(_QWORD **)(a2 + 32) = 0LL;
      if ( (*(_DWORD *)(a2 + 16) & 1) != 0 )
        return 0;
      return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, __int64 *, _QWORD))v9)(
               v8,
               v12,
               0LL,
               0LL,
               0LL,
               a6,
               a7);
    }
    v51 = 350;
    goto LABEL_80;
  }
  if ( a5 )
    v15 = a5;
  else
    v15 = (char **)a2;
  v16 = *(_QWORD *)(a2 + 8);
  v17 = *v15;
  if ( a8 )
  {
    v34 = *(int **)(a2 + 32);
    v35 = *v34;
    LODWORD(v36) = *v34 & 7;
    if ( (_DWORD)v36 )
    {
      if ( !a5 )
      {
        v37 = *a3;
        v36 = (int)v36;
        if ( (v35 & 4) == 0 && v37 < a4 )
        {
          do
          {
            ++v36;
            *a3 = v37 + 1;
            *((_BYTE *)v34 + v36 + 3) = *v37;
            v37 = *a3;
          }
          while ( a4 > *a3 && v36 != 4 );
        }
        if ( v36 <= 3 )
        {
          v23 = 7;
          *v34 = v35 & 0xFFFFFFF8 | v36;
          return v23;
        }
        v17 += 4;
        *(v17 - 4) = *((_BYTE *)v34 + 4);
        *(v17 - 3) = *((_BYTE *)v34 + 5);
        *(v17 - 2) = *((_BYTE *)v34 + 6);
        *(v17 - 1) = *((_BYTE *)v34 + 7);
        *v34 &= 0xFFFFFFF8;
        goto LABEL_9;
      }
      v51 = 467;
LABEL_80:
      _libc_assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        v51,
        (__int64)"__gconv_transform_internal_ucs4le");
    }
  }
LABEL_9:
  v18 = a2;
  v19 = v17;
  v20 = v18;
  v55 = v12;
  v56 = (__int64 (__fastcall *)(__int64, __int64, unsigned __int64 *, char *, _QWORD, __int64 *, _QWORD, _QWORD))v9;
  v57 = v8;
  while ( 1 )
  {
    v52 = 0LL;
    v21 = *a3;
    if ( a6 )
      v52 = *a6;
    v22 = v16 - (_QWORD)v19;
    if ( (__int64)(v16 - (_QWORD)v19) > a4 - v21 )
      v22 = a4 - v21;
    v23 = 4;
    v24 = v22 + 3;
    if ( v22 >= 0 )
      v24 = v22;
    *a3 = &v21[v24 & 0xFFFFFFFFFFFFFFFCLL];
    v25 = (char *)j_memcpy() + (v24 & 0xFFFFFFFFFFFFFFFCLL);
    if ( a4 != *a3 )
    {
      if ( v16 >= (unsigned __int64)(v25 + 4) )
        v23 = 7;
      else
        v23 = 5;
    }
    if ( a5 )
    {
      *a5 = v25;
      return v23;
    }
    v26 = *(_DWORD *)(v20 + 16);
    ++*(_DWORD *)(v20 + 20);
    if ( (v26 & 1) != 0 )
    {
      v29 = a8;
      v30 = 0;
      v31 = v20;
      *(_QWORD *)v20 = v25;
      goto LABEL_29;
    }
    if ( v25 <= v19 )
      goto LABEL_28;
    v59 = *(_QWORD *)v20;
    v27 = v56(v57, v55, &v59, v25, 0LL, a6, 0LL, a8);
    if ( v27 == 4 )
    {
      if ( v23 != 5 )
      {
LABEL_28:
        v29 = a8;
        v30 = 0;
        v31 = v20;
        goto LABEL_29;
      }
      goto LABEL_26;
    }
    v28 = v59;
    if ( (char *)v59 == v25 )
      goto LABEL_25;
    v40 = 0LL;
    if ( a6 )
      v40 = *a6;
    if ( v40 == v52 )
      break;
    v41 = v59 - (_QWORD)v19;
    v53 = v27;
    if ( (__int64)(v59 - (_QWORD)v19) > a4 - v21 )
      v41 = a4 - v21;
    v42 = v41 + 3;
    if ( v41 >= 0 )
      v42 = v41;
    v43 = v42 & 0xFFFFFFFFFFFFFFFCLL;
    *a3 = &v21[v43];
    v44 = (char *)j_memcpy() + v43;
    if ( a4 == *a3 || v28 >= (unsigned __int64)(v44 + 4) )
    {
      if ( v44 == (char *)v59 )
        _libc_assert_fail(
          (__int64)"nstatus == __GCONV_FULL_OUTPUT",
          (__int64)"../iconv/skeleton.c",
          0x253u,
          (__int64)"__gconv_transform_internal_ucs4le");
LABEL_81:
      _libc_assert_fail(
        (__int64)"outbuf == outerr",
        (__int64)"../iconv/skeleton.c",
        0x252u,
        (__int64)"__gconv_transform_internal_ucs4le");
    }
    v27 = v53;
    if ( v44 != (char *)v59 )
      goto LABEL_81;
    if ( v19 != v44 )
    {
LABEL_25:
      if ( v27 )
        goto LABEL_70;
      goto LABEL_26;
    }
    --*(_DWORD *)(v20 + 20);
    if ( v53 )
      goto LABEL_70;
LABEL_26:
    v19 = *(char **)v20;
  }
  *a3 -= (unsigned __int64)&v25[-v59];
  if ( !v27 )
    goto LABEL_26;
LABEL_70:
  v29 = a8;
  v30 = 0;
  v31 = v20;
  v23 = v27;
LABEL_29:
  if ( v29 )
    v32 = v23 == 7;
  else
    v32 = 0;
  if ( v32 )
  {
    v45 = a4 - *a3;
    if ( v45 > 4 )
      _libc_assert_fail(
        (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
        (__int64)"../iconv/skeleton.c",
        0x287u,
        (__int64)"__gconv_transform_internal_ucs4le");
    if ( v45 )
    {
      *(_BYTE *)(*(_QWORD *)(v31 + 32) + 4LL) = **a3;
      for ( i = 1LL; v45 != i; *(_BYTE *)(v47 + 4) = v48 )
      {
        v47 = *(_QWORD *)(v31 + 32) + i;
        v48 = (*a3)[i++];
      }
      v30 = v45;
    }
    v49 = *(unsigned int **)(v31 + 32);
    v23 = 7;
    v50 = *v49;
    *a3 = a4;
    *v49 = v50 & 0xFFFFFFF8 | v30;
  }
  return v23;
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (00000000004221C4) ----------------------------------------------------
__int64 __fastcall _gconv_transform_ucs4le_internal(
        __int64 a1,
        __int64 a2,
        unsigned __int64 *a3,
        unsigned __int64 a4,
        _QWORD *a5,
        _QWORD *a6,
        int a7,
        unsigned int a8)
{
  __int64 v8; // x16
  unsigned __int64 v9; // x15
  __int64 v11; // x1
  int v16; // w2
  _QWORD *v17; // x0
  __int64 *v18; // x12
  unsigned __int64 v19; // x25
  _DWORD *v20; // x23
  _BYTE *v21; // x21
  _QWORD *v22; // x5
  char **v23; // x28
  __int64 v24; // x22
  char *v25; // x20
  unsigned __int64 *v26; // x23
  __int64 *v27; // x27
  _BYTE *v28; // x26
  __int64 v29; // x21
  char *v30; // x19
  unsigned __int64 v31; // x0
  unsigned __int64 v32; // x1
  unsigned __int64 v33; // x4
  int v34; // w3
  int v35; // w1
  unsigned int v36; // w0
  unsigned __int64 v37; // x2
  int v38; // w0
  unsigned int v40; // w4
  __int64 v41; // x20
  int v42; // w6
  unsigned int v43; // w7
  unsigned __int64 *v44; // x27
  bool v45; // zf
  unsigned int *v46; // x5
  unsigned int v47; // w4
  unsigned __int64 v48; // x0
  __int64 v51; // x0
  __int64 v52; // x1
  __int64 v53; // x1
  int v54; // w10
  unsigned __int64 v55; // x1
  char *v56; // x3
  unsigned __int64 v57; // x8
  unsigned __int64 v58; // x7
  int v59; // w6
  int v60; // w0
  int v61; // w0
  unsigned __int64 *v62; // x27
  unsigned __int64 v64; // x0
  __int64 i; // x1
  __int64 v66; // x2
  char v67; // w3
  unsigned int *v68; // x1
  unsigned int v69; // w0
  unsigned int v70; // w2
  unsigned int v71; // [xsp+6Ch] [xbp+6Ch]
  _QWORD *v72; // [xsp+70h] [xbp+70h]
  _BYTE *v73; // [xsp+80h] [xbp+80h]
  __int64 v74; // [xsp+90h] [xbp+90h]
  __int64 (__fastcall *v75)(__int64, __int64, char **, char *, _QWORD, _QWORD *, _QWORD, _QWORD); // [xsp+98h] [xbp+98h]
  __int64 v76; // [xsp+A0h] [xbp+A0h]
  __int64 v78; // [xsp+B0h] [xbp+B0h] BYREF
  char *v79; // [xsp+B8h] [xbp+B8h] BYREF

  v8 = a1 + 104;
  v9 = 0LL;
  v11 = a2 + 48;
  v16 = *(_DWORD *)(a2 + 16);
  if ( (v16 & 1) == 0 )
  {
    v9 = *(_QWORD *)(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v9 ^= _pointer_chk_guard_local;
  }
  if ( a7 )
  {
    if ( !a5 )
    {
      **(_QWORD **)(a2 + 32) = 0LL;
      if ( (*(_DWORD *)(a2 + 16) & 1) != 0 )
        return 0;
      return ((__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, _QWORD *))v9)(
               v8,
               v11,
               0LL,
               0LL,
               0LL,
               a6);
    }
    v70 = 350;
    goto LABEL_113;
  }
  if ( a5 )
    v17 = a5;
  else
    v17 = (_QWORD *)a2;
  v18 = &v78;
  v19 = *(_QWORD *)(a2 + 8);
  if ( !a6 )
    v18 = 0LL;
  v20 = (_DWORD *)*v17;
  v78 = 0LL;
  if ( a8 )
  {
    v46 = *(unsigned int **)(a2 + 32);
    v47 = *v46;
    LODWORD(v48) = *v46 & 7;
    if ( (_DWORD)v48 )
    {
      if ( !a5 )
      {
        v21 = (_BYTE *)*a3;
        v48 = (int)v48;
        if ( (v47 & 4) == 0 && (unsigned __int64)v21 < a4 )
        {
          do
          {
            ++v48;
            *a3 = (unsigned __int64)(v21 + 1);
            *((_BYTE *)v46 + v48 + 3) = *v21;
            v21 = (_BYTE *)*a3;
          }
          while ( a4 > *a3 && v48 != 4 );
        }
        if ( v48 <= 3 )
        {
          *v46 = v47 & 0xFFFFFFF8 | v48;
          return 7;
        }
        if ( *((unsigned __int8 *)v46 + 7) > 0x80u )
        {
          if ( (v16 & 2) == 0 )
          {
            v40 = 6;
            *(_DWORD *)(a2 + 16) |= 0x40000000u;
            return v40;
          }
        }
        else
        {
          *((_BYTE *)++v20 - 4) = *((_BYTE *)v46 + 4);
          *((_BYTE *)v20 - 3) = *((_BYTE *)v46 + 5);
          *((_BYTE *)v20 - 2) = *((_BYTE *)v46 + 6);
          *((_BYTE *)v20 - 1) = *((_BYTE *)v46 + 7);
          v21 = (_BYTE *)*a3;
          v47 = *v46;
        }
        *v46 = v47 & 0xFFFFFFF8;
        v16 = *(_DWORD *)(a2 + 16);
        goto LABEL_12;
      }
      v70 = 467;
LABEL_113:
      _libc_assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        v70,
        (__int64)"__gconv_transform_ucs4le_internal");
    }
  }
  v21 = (_BYTE *)*a3;
LABEL_12:
  v22 = a6;
  v23 = (char **)a5;
  v24 = a2;
  v25 = (char *)v20;
  v26 = a3;
  v27 = v18;
  v28 = v21;
  v29 = 0LL;
  v74 = v11;
  v75 = (__int64 (__fastcall *)(__int64, __int64, char **, char *, _QWORD, _QWORD *, _QWORD, _QWORD))v9;
  v76 = v8;
  while ( 1 )
  {
    v73 = v28;
    if ( v22 )
      v29 += *v22;
    v30 = v25;
    v31 = (unsigned __int64)(v28 + 4);
    if ( (unsigned __int64)(v28 + 4) <= a4 )
    {
      while ( 1 )
      {
        v33 = v31 - 4;
        if ( v19 < (unsigned __int64)(v30 + 4) )
          goto LABEL_25;
        v34 = *(_DWORD *)(v31 - 4);
        if ( v34 < 0 )
        {
          if ( !v27 )
          {
            v30 = v25;
            *(_DWORD *)(v24 + 16) |= 0x40000000u;
            v71 = 6;
            goto LABEL_29;
          }
          if ( (v16 & 2) == 0 )
          {
            v38 = *(_DWORD *)(v24 + 16);
            *v26 = v33;
            *(_DWORD *)(v24 + 16) = v38 | 0x40000000;
            v71 = 6;
            if ( v23 )
            {
LABEL_37:
              *v23 = v30;
              return v71;
            }
            goto LABEL_30;
          }
          ++*v27;
          v32 = v31 + 4;
          if ( a4 < v31 + 4 )
          {
LABEL_24:
            v33 = v31;
            v31 = v32;
LABEL_25:
            *v26 = v33;
            if ( a4 == v33 )
            {
              v71 = 4;
            }
            else if ( a4 < v31 )
            {
              v71 = 7;
            }
            else
            {
              if ( v19 >= (unsigned __int64)(v30 + 4) )
                _libc_assert_fail(
                  (__int64)"*outptrp + 4 > outend",
                  (__int64)"gconv_simple.c",
                  0x1E4u,
                  (__int64)"ucs4le_internal_loop");
              v71 = 5;
            }
            goto LABEL_29;
          }
        }
        else
        {
          *(_DWORD *)v30 = v34;
          v30 += 4;
          v32 = v31 + 4;
          if ( a4 < v31 + 4 )
            goto LABEL_24;
        }
        v31 = v32;
      }
    }
    if ( (_BYTE *)a4 == v28 )
      v61 = 4;
    else
      v61 = 7;
    *v26 = (unsigned __int64)v28;
    v71 = v61;
LABEL_29:
    if ( v23 )
      goto LABEL_37;
LABEL_30:
    v35 = *(_DWORD *)(v24 + 16);
    ++*(_DWORD *)(v24 + 20);
    if ( (v35 & 1) != 0 )
    {
      v51 = *v22;
      v41 = v24;
      v52 = v78;
      v44 = v26;
      v43 = a8;
      v42 = 0;
      *(_QWORD *)v24 = v30;
      v40 = v71;
      *v22 = v51 + v52;
      goto LABEL_40;
    }
    if ( v25 >= v30 )
      goto LABEL_39;
    v79 = *(char **)v24;
    v72 = v22;
    v36 = v75(v76, v74, &v79, v30, 0LL, v22, 0LL, a8);
    v22 = v72;
    if ( v36 != 4 )
      break;
    if ( v71 != 5 )
    {
LABEL_39:
      v40 = v71;
      v41 = v24;
      v43 = a8;
      v42 = 0;
      v44 = v26;
      goto LABEL_40;
    }
LABEL_35:
    v25 = *(char **)v24;
    v28 = (_BYTE *)*v26;
    v29 = v78;
    v16 = *(_DWORD *)(v24 + 16);
  }
  v37 = (unsigned __int64)v79;
  if ( v79 != v30 )
  {
    v53 = 0LL;
    if ( v72 )
      v53 = *v72;
    if ( v53 + v78 == v29 )
    {
      *v26 -= v30 - v79;
    }
    else
    {
      *v26 = (unsigned __int64)v28;
      if ( (unsigned __int64)(v28 + 4) > a4 )
      {
        v62 = v26;
        v56 = v25;
LABEL_91:
        *v62 = (unsigned __int64)v73;
LABEL_75:
        if ( (char *)v37 != v56 )
          goto LABEL_110;
        goto LABEL_76;
      }
      v54 = *(_DWORD *)(v24 + 16);
      v55 = (unsigned __int64)(v28 + 4);
      v56 = v25;
      while ( 1 )
      {
        v57 = v55 - 4;
        v58 = v55;
        if ( v37 < (unsigned __int64)(v56 + 4) )
          break;
        v59 = *(_DWORD *)(v55 - 4);
        if ( v59 < 0 )
        {
          if ( !v27 )
          {
            *(_DWORD *)(v24 + 16) |= 0x40000000u;
            if ( (char *)v37 != v25 )
LABEL_110:
              _libc_assert_fail(
                (__int64)"outbuf == outerr",
                (__int64)"../iconv/skeleton.c",
                0x252u,
                (__int64)"__gconv_transform_ucs4le_internal");
LABEL_76:
            _libc_assert_fail(
              (__int64)"nstatus == __GCONV_FULL_OUTPUT",
              (__int64)"../iconv/skeleton.c",
              0x253u,
              (__int64)"__gconv_transform_ucs4le_internal");
          }
          if ( (v54 & 2) == 0 )
          {
            v60 = *(_DWORD *)(v24 + 16);
            *v26 = v57;
            *(_DWORD *)(v24 + 16) = v60 | 0x40000000;
            goto LABEL_75;
          }
          ++*v27;
        }
        else
        {
          *(_DWORD *)v56 = v59;
          v56 += 4;
        }
        v55 += 4LL;
        if ( a4 < v55 )
        {
          v62 = v26;
          v73 = (_BYTE *)v58;
          goto LABEL_91;
        }
      }
      *v26 = v57;
      if ( a4 == v57 || a4 < v55 )
        goto LABEL_75;
      if ( v56 != (char *)v37 )
        goto LABEL_110;
      if ( v56 == v25 )
        --*(_DWORD *)(v24 + 20);
    }
  }
  if ( !v36 )
    goto LABEL_35;
  v43 = a8;
  v42 = 0;
  v41 = v24;
  v44 = v26;
  v40 = v36;
LABEL_40:
  if ( v43 )
    v45 = v40 == 7;
  else
    v45 = 0;
  if ( v45 )
  {
    v64 = a4 - *v44;
    if ( v64 > 4 )
      _libc_assert_fail(
        (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
        (__int64)"../iconv/skeleton.c",
        0x287u,
        (__int64)"__gconv_transform_ucs4le_internal");
    if ( v64 )
    {
      *(_BYTE *)(*(_QWORD *)(v41 + 32) + 4LL) = *(_BYTE *)*v44;
      for ( i = 1LL; v64 != i; *(_BYTE *)(v66 + 4) = v67 )
      {
        v66 = *(_QWORD *)(v41 + 32) + i;
        v67 = *(_BYTE *)(*v44 + i++);
      }
      v42 = v64;
    }
    v68 = *(unsigned int **)(v41 + 32);
    v69 = *v68;
    *v44 = a4;
    *v68 = v69 & 0xFFFFFFF8 | v42;
  }
  return v40;
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000422820) ----------------------------------------------------
__int64 __fastcall _gconv_transform_ascii_internal(
        __int64 a1,
        __int64 a2,
        __int64 *a3,
        __int64 a4,
        _QWORD *a5,
        __int64 *a6,
        int a7,
        unsigned int a8)
{
  int v13; // w4
  _QWORD *v14; // x0
  __int64 *v15; // x12
  __int64 v16; // x27
  _DWORD *v17; // x28
  unsigned __int64 v18; // x26
  __int64 v19; // x10
  __int64 v20; // x0
  _DWORD *v21; // x19
  unsigned int v22; // w24
  int v23; // w6
  __int64 v24; // x7
  __int64 v25; // x1
  int v26; // w2
  unsigned int v27; // w0
  unsigned __int64 v28; // x1
  __int64 v30; // x2
  int v31; // w9
  __int64 v32; // x2
  _DWORD *v33; // x3
  int v34; // w6
  __int64 v35; // x7
  __int64 v36; // x0
  __int64 *v37; // [xsp+60h] [xbp+60h]
  __int64 v38; // [xsp+68h] [xbp+68h]
  __int64 (__fastcall *v39)(__int64, __int64, _QWORD, _QWORD, _QWORD, __int64 *); // [xsp+70h] [xbp+70h]
  __int64 v40; // [xsp+78h] [xbp+78h]
  __int64 v41; // [xsp+80h] [xbp+80h]
  __int64 v43; // [xsp+90h] [xbp+90h] BYREF
  _DWORD *v44; // [xsp+98h] [xbp+98h] BYREF

  v13 = *(_DWORD *)(a2 + 16);
  v39 = 0LL;
  v40 = a2 + 48;
  v41 = a1 + 104;
  if ( (v13 & 1) == 0 )
  {
    v39 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD, _QWORD, __int64 *))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v39 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD, __int64 *))(*(_QWORD *)(a1 + 144) ^ _pointer_chk_guard_local);
  }
  if ( !a7 )
  {
    if ( a5 )
      v14 = a5;
    else
      v14 = (_QWORD *)a2;
    v15 = &v43;
    v16 = *a3;
    if ( !a6 )
      v15 = 0LL;
    v17 = (_DWORD *)*v14;
    v43 = 0LL;
    v18 = *(_QWORD *)(a2 + 8);
    v19 = 0LL;
    if ( a6 )
LABEL_11:
      v19 += *a6;
    if ( v16 == a4 )
    {
      v25 = v16;
      v21 = v17;
      v22 = 4;
    }
    else
    {
LABEL_13:
      v20 = v16 + 1;
      v21 = v17;
      v22 = 4;
      while ( 1 )
      {
        while ( 1 )
        {
          v25 = v20 - 1;
          if ( v18 < (unsigned __int64)(v21 + 1) )
          {
            v22 = 5;
            goto LABEL_18;
          }
          v23 = *(unsigned __int8 *)(v20 - 1);
          v24 = v20;
          if ( (v23 & 0x80) != 0 )
            break;
          *v21 = v23;
          ++v20;
          ++v21;
          if ( a4 == v24 )
            goto LABEL_31;
        }
        *(_DWORD *)(a2 + 16) |= 0x40000000u;
        if ( !v15 || (v13 & 2) == 0 )
          break;
        ++v20;
        v22 = 6;
        ++*v15;
        if ( a4 == v24 )
        {
LABEL_31:
          *a3 = a4;
          if ( a5 )
            goto LABEL_32;
          goto LABEL_19;
        }
      }
      v22 = 6;
    }
LABEL_18:
    *a3 = v25;
    if ( a5 )
    {
LABEL_32:
      *a5 = v21;
      return v22;
    }
LABEL_19:
    v26 = *(_DWORD *)(a2 + 16);
    while ( 1 )
    {
      ++*(_DWORD *)(a2 + 20);
      if ( (v26 & 1) != 0 )
      {
        v36 = *a6;
        *(_QWORD *)a2 = v21;
        *a6 = v36 + v43;
        return v22;
      }
      if ( v21 <= v17 )
        return v22;
      v44 = *(_DWORD **)a2;
      v37 = v15;
      v38 = v19;
      v27 = ((__int64 (__fastcall *)(__int64, __int64, _DWORD **, _DWORD *, _QWORD, __int64 *, _QWORD, _QWORD))v39)(
              v41,
              v40,
              &v44,
              v21,
              0LL,
              a6,
              0LL,
              a8);
      v15 = v37;
      if ( v27 == 4 )
      {
        if ( v22 != 5 )
          return v22;
      }
      else
      {
        v28 = (unsigned __int64)v44;
        if ( v21 != v44 )
        {
          v30 = 0LL;
          if ( a6 )
            v30 = *a6;
          if ( v30 + v43 == v38 )
          {
            *a3 -= v21 - v44;
          }
          else
          {
            *a3 = v16;
            if ( v16 == a4 )
            {
              v33 = v17;
              goto LABEL_56;
            }
            v31 = *(_DWORD *)(a2 + 16);
            v32 = v16 + 1;
            v33 = v17;
            while ( 1 )
            {
              v16 = v32 - 1;
              if ( v28 < (unsigned __int64)(v33 + 1) )
                break;
              v34 = *(unsigned __int8 *)(v32 - 1);
              v35 = v32;
              if ( (v34 & 0x80) != 0 )
              {
                *(_DWORD *)(a2 + 16) |= 0x40000000u;
                if ( !v37 || (v31 & 2) == 0 )
                  goto LABEL_56;
                ++*v37;
              }
              else
              {
                *v33++ = v34;
              }
              ++v32;
              if ( a4 == v35 )
              {
                v16 = a4;
LABEL_56:
                *a3 = v16;
                if ( (_DWORD *)v28 == v33 )
                  _libc_assert_fail(
                    (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                    (__int64)"../iconv/skeleton.c",
                    0x253u,
                    (__int64)"__gconv_transform_ascii_internal");
LABEL_64:
                _libc_assert_fail(
                  (__int64)"outbuf == outerr",
                  (__int64)"../iconv/skeleton.c",
                  0x252u,
                  (__int64)"__gconv_transform_ascii_internal");
              }
            }
            *a3 = v16;
            if ( (_DWORD *)v28 != v33 )
              goto LABEL_64;
            if ( (_DWORD *)v28 == v17 )
              --*(_DWORD *)(a2 + 20);
          }
        }
        if ( v27 )
          return v27;
      }
      v26 = *(_DWORD *)(a2 + 16);
      v17 = *(_DWORD **)a2;
      LOBYTE(v13) = v26;
      v16 = *a3;
      v19 = v43;
      if ( a6 )
        goto LABEL_11;
      if ( a4 != v16 )
        goto LABEL_13;
      v21 = *(_DWORD **)a2;
      v22 = 4;
    }
  }
  if ( a5 )
    _libc_assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      0x15Eu,
      (__int64)"__gconv_transform_ascii_internal");
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_DWORD *)(a2 + 16) & 1) != 0 )
    return 0;
  return v39(v41, v40, 0LL, 0LL, 0LL, a6);
}
// 422C2C: using guessed type __int64 _gconv_transform_internal_ascii(void);
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000422C2C) ----------------------------------------------------
__int64 __fastcall _gconv_transform_internal_ascii(
        _QWORD *a1,
        __int64 a2,
        __int64 *a3,
        unsigned __int64 a4,
        _QWORD *a5,
        __int64 *a6,
        unsigned int a7,
        unsigned int a8)
{
  int v13; // w7
  _BYTE **v14; // x0
  unsigned __int64 v15; // x26
  _BYTE *v16; // x21
  __int64 *v17; // x0
  unsigned int *v18; // x8
  int v19; // w0
  __int64 v20; // x2
  _DWORD *v21; // x18
  unsigned int *v22; // x1
  unsigned __int64 v23; // x28
  unsigned __int64 v24; // x3
  unsigned int *v25; // x0
  _BYTE *v26; // x22
  bool v27; // cc
  unsigned int *v28; // x0
  __int64 v29; // x0
  unsigned int v30; // w1
  __int64 v31; // x14
  unsigned int *v32; // x28
  _BYTE *v33; // x22
  unsigned int *v34; // x8
  unsigned int v35; // w24
  unsigned int *v36; // x1
  unsigned int v37; // w0
  unsigned int v38; // w7
  _BYTE *v39; // x24
  int v41; // w0
  bool v42; // zf
  __int64 v43; // x0
  bool v44; // zf
  unsigned int v45; // w0
  __int64 v46; // x0
  int v47; // w22
  _BYTE *v48; // x0
  unsigned int *v49; // x2
  unsigned int v50; // w1
  _BYTE *v51; // x1
  unsigned __int64 v52; // x2
  __int64 i; // x0
  __int64 v54; // x1
  char v55; // w3
  unsigned int *v56; // x1
  unsigned int v57; // w0
  unsigned int v58; // w0
  unsigned int *v59; // x14
  int v60; // w1
  unsigned __int64 v61; // x1
  unsigned __int64 v62; // x3
  unsigned int *v63; // x0
  int v64; // w3
  _BYTE *v65; // x1
  signed int v66; // w0
  unsigned __int64 v67; // x0
  unsigned int v68; // w2
  __int64 (__fastcall *v70)(_QWORD *, __int64, _BYTE **, _BYTE *, _QWORD, __int64 *, _QWORD, _QWORD); // [xsp+68h] [xbp+68h]
  __int64 v71; // [xsp+70h] [xbp+70h]
  __int64 v72; // [xsp+70h] [xbp+70h]
  unsigned int *v73; // [xsp+70h] [xbp+70h]
  unsigned int v74; // [xsp+70h] [xbp+70h]
  _QWORD *v75; // [xsp+78h] [xbp+78h]
  __int64 v76; // [xsp+80h] [xbp+80h]
  __int64 *v77; // [xsp+88h] [xbp+88h]
  int v79; // [xsp+98h] [xbp+98h]
  int v80; // [xsp+A0h] [xbp+A0h]
  char v81; // [xsp+A4h] [xbp+A4h]
  _DWORD *v82; // [xsp+A8h] [xbp+A8h]
  unsigned int v83; // [xsp+B8h] [xbp+B8h] BYREF
  _BYTE v84[4]; // [xsp+BCh] [xbp+BCh] BYREF
  __int64 v85; // [xsp+C0h] [xbp+C0h] BYREF
  _BYTE *v86; // [xsp+C8h] [xbp+C8h] BYREF
  unsigned int *v87; // [xsp+D0h] [xbp+D0h] BYREF
  _BYTE *v88; // [xsp+D8h] [xbp+D8h] BYREF

  v75 = a1 + 13;
  v76 = a2 + 48;
  v13 = *(_DWORD *)(a2 + 16);
  v70 = 0LL;
  v80 = a7;
  if ( (v13 & 1) == 0 )
  {
    v70 = (__int64 (__fastcall *)(_QWORD *, __int64, _BYTE **, _BYTE *, _QWORD, __int64 *, _QWORD, _QWORD))a1[18];
    if ( a1[13] )
      v70 = (__int64 (__fastcall *)(_QWORD *, __int64, _BYTE **, _BYTE *, _QWORD, __int64 *, _QWORD, _QWORD))(a1[18] ^ _pointer_chk_guard_local);
  }
  if ( !a7 )
  {
    if ( a5 )
      v14 = (_BYTE **)a5;
    else
      v14 = (_BYTE **)a2;
    v15 = *(_QWORD *)(a2 + 8);
    v16 = *v14;
    if ( a6 )
      v17 = &v85;
    else
      v17 = 0LL;
    v77 = v17;
    v85 = 0LL;
    if ( !a8 || (v18 = *(unsigned int **)(a2 + 32), (v19 = *v18 & 7) == 0) )
    {
      v32 = (unsigned int *)*a3;
      v31 = 0LL;
LABEL_29:
      if ( a6 )
LABEL_30:
        v31 += *a6;
      v87 = v32;
      v88 = v16;
      if ( (unsigned int *)a4 != v32 )
      {
LABEL_32:
        v33 = v16;
        v34 = v32;
        v35 = 4;
        while ( 1 )
        {
          v36 = v34 + 1;
          if ( a4 < (unsigned __int64)(v34 + 1) )
          {
            *a3 = (__int64)v87;
            v35 = 7;
            if ( !a5 )
              goto LABEL_39;
            goto LABEL_51;
          }
          if ( v15 <= (unsigned __int64)v33 )
          {
            v34 = v87;
            v35 = 5;
            goto LABEL_38;
          }
          v37 = *v34;
          if ( *v34 <= 0x7F )
          {
            v88 = v33 + 1;
            *v33 = v37;
            v33 = v88;
            v34 = ++v87;
            goto LABEL_37;
          }
          if ( v37 >> 7 == 7168 )
          {
            ++v34;
            v87 = v36;
            goto LABEL_37;
          }
          v41 = *(_DWORD *)(a2 + 16);
          if ( !v77 )
          {
            v34 = v87;
            v35 = 6;
            *(_DWORD *)(a2 + 16) = v41 | 0x40000000;
            goto LABEL_38;
          }
          if ( (v41 & 8) != 0 )
          {
            v72 = v31;
            v79 = v13;
            v45 = _gconv_transliterate(a1, a2, *a3, &v87, a4, &v88, v77);
            v31 = v72;
            v35 = v45;
            v33 = v88;
            v13 = v79;
            if ( v45 != 6 )
            {
              v34 = v87;
              if ( v45 == 5 )
                goto LABEL_38;
              goto LABEL_37;
            }
          }
          else
          {
            *(_DWORD *)(a2 + 16) = v41 | 0x40000000;
          }
          v34 = v87;
          if ( (v13 & 2) == 0 )
          {
            v35 = 6;
            goto LABEL_38;
          }
          v34 = v87 + 1;
          v35 = 6;
          ++v87;
          ++*v77;
LABEL_37:
          if ( (unsigned int *)a4 == v34 )
            goto LABEL_38;
        }
      }
      v33 = v16;
      v34 = (unsigned int *)a4;
      v35 = 4;
LABEL_38:
      *a3 = (__int64)v34;
      if ( a5 )
      {
LABEL_51:
        *a5 = v33;
        return v35;
      }
LABEL_39:
      v13 = *(_DWORD *)(a2 + 16);
      while ( 1 )
      {
        ++*(_DWORD *)(a2 + 20);
        if ( (v13 & 1) != 0 )
          break;
        if ( v16 >= v33 )
          goto LABEL_45;
        v86 = *(_BYTE **)a2;
        v71 = v31;
        v38 = v70(v75, v76, &v86, v33, 0LL, a6, 0LL, a8);
        if ( v38 == 4 )
        {
          if ( v35 != 5 && v35 )
            goto LABEL_61;
        }
        else
        {
          v39 = v86;
          if ( v86 == v33 )
            goto LABEL_44;
          v46 = 0LL;
          if ( a6 )
            v46 = *a6;
          if ( v46 + v85 != v71 )
          {
            v47 = *(_DWORD *)(a2 + 16);
            v48 = v16;
            *a3 = (__int64)v32;
            v87 = v32;
            v88 = v16;
            if ( (unsigned int *)a4 == v32 )
            {
LABEL_97:
              *a3 = (__int64)v32;
              if ( v39 != v48 )
                goto LABEL_115;
LABEL_98:
              _libc_assert_fail(
                (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                (__int64)"../iconv/skeleton.c",
                0x253u,
                (__int64)"__gconv_transform_internal_ascii");
            }
            while ( 2 )
            {
              v49 = v32 + 1;
              if ( a4 < (unsigned __int64)(v32 + 1) )
                goto LABEL_96;
              if ( v39 <= v48 )
              {
                *a3 = (__int64)v87;
                if ( v86 != v48 )
                  goto LABEL_115;
                goto LABEL_88;
              }
              v50 = *v32;
              if ( *v32 <= 0x7F )
              {
                v88 = v48 + 1;
                *v48 = v50;
                v48 = v88;
                v32 = ++v87;
                goto LABEL_85;
              }
              if ( v50 >> 7 == 7168 )
              {
                ++v32;
                v87 = v49;
              }
              else
              {
                v60 = *(_DWORD *)(a2 + 16);
                if ( !v77 )
                {
                  *(_DWORD *)(a2 + 16) = v60 | 0x40000000;
LABEL_96:
                  v39 = v86;
                  v32 = v87;
                  goto LABEL_97;
                }
                if ( (v60 & 8) == 0 )
                {
                  *(_DWORD *)(a2 + 16) = v60 | 0x40000000;
                  goto LABEL_120;
                }
                v74 = v38;
                v64 = _gconv_transliterate(a1, a2, *a3, &v87, a4, &v88, v77);
                v38 = v74;
                v48 = v88;
                if ( v64 == 6 )
                {
LABEL_120:
                  v32 = v87;
                  if ( (v47 & 2) == 0 )
                  {
                    v39 = v86;
                    goto LABEL_97;
                  }
                  v32 = ++v87;
                  ++*v77;
                }
                else
                {
                  v32 = v87;
                  if ( v64 == 5 )
                  {
                    v65 = v86;
                    *a3 = (__int64)v87;
                    if ( v65 != v48 )
LABEL_115:
                      _libc_assert_fail(
                        (__int64)"outbuf == outerr",
                        (__int64)"../iconv/skeleton.c",
                        0x252u,
                        (__int64)"__gconv_transform_internal_ascii");
LABEL_88:
                    if ( v16 == v48 )
                    {
                      v35 = v38;
                      --*(_DWORD *)(a2 + 20);
                      goto LABEL_45;
                    }
LABEL_44:
                    v35 = v38;
                    goto LABEL_45;
                  }
                }
              }
LABEL_85:
              if ( (unsigned int *)a4 == v32 )
              {
                v51 = v86;
                *a3 = a4;
                if ( v51 != v48 )
                  goto LABEL_115;
                goto LABEL_98;
              }
              continue;
            }
          }
          v35 = v38;
          *a3 -= 4 * (v33 - v86);
LABEL_45:
          if ( v35 )
          {
LABEL_61:
            if ( a8 )
              v42 = v35 == 7;
            else
              v42 = 0;
            if ( !v42 )
              return v35;
            goto LABEL_102;
          }
        }
        v16 = *(_BYTE **)a2;
        v32 = (unsigned int *)*a3;
        v31 = v85;
        v13 = *(_DWORD *)(a2 + 16);
        if ( a6 )
          goto LABEL_30;
        v87 = (unsigned int *)*a3;
        v88 = v16;
        if ( (unsigned int *)a4 != v32 )
          goto LABEL_32;
        v33 = v16;
        v35 = 4;
      }
      v43 = *a6;
      *(_QWORD *)a2 = v33;
      *a6 = v43 + v85;
      if ( a8 )
        v44 = v35 == 7;
      else
        v44 = 0;
      if ( !v44 )
        return v35;
LABEL_102:
      v52 = a4 - *a3;
      if ( v52 > 4 )
        _libc_assert_fail(
          (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
          (__int64)"../iconv/skeleton.c",
          0x287u,
          (__int64)"__gconv_transform_internal_ascii");
      if ( v52 )
      {
        *(_BYTE *)(*(_QWORD *)(a2 + 32) + 4LL) = *(_BYTE *)*a3;
        for ( i = 1LL; v52 != i; *(_BYTE *)(v54 + 4) = v55 )
        {
          v54 = *(_QWORD *)(a2 + 32) + i;
          v55 = *(_BYTE *)(*a3 + i++);
        }
        v80 = v52;
      }
      v56 = *(unsigned int **)(a2 + 32);
      v57 = *v56;
      *a3 = a4;
      *v56 = v57 & 0xFFFFFFF8 | v80;
      return v35;
    }
    if ( !a5 )
    {
      v20 = *a3;
      v87 = (unsigned int *)*a3;
      v88 = v16;
      if ( v19 > 4 )
        _libc_assert_fail(
          (__int64)"(state->__count & 7) <= sizeof (state->__value)",
          (__int64)"../iconv/loop.c",
          0x137u,
          (__int64)"internal_ascii_loop_single");
      v21 = v18 + 1;
      v22 = &v83;
      v23 = 0LL;
      do
      {
        v24 = v23;
        *(_BYTE *)v22 = *((_BYTE *)v21 + v23);
        v22 = (unsigned int *)((char *)v22 + 1);
        ++v23;
      }
      while ( v23 < (*v18 & 7) );
      if ( a4 < v20 - v23 + 4 )
      {
        *a3 = a4;
        v61 = a4 - v20 + v23;
        if ( v61 > 4 )
          _libc_assert_fail(
            (__int64)"inlen_after <= sizeof (state->__value.__wchb)",
            (__int64)"../iconv/loop.c",
            0x154u,
            (__int64)"internal_ascii_loop_single");
        if ( v23 < v61 )
        {
          v87 = (unsigned int *)(v20 + 1);
          v62 = v24 + 2;
          *((_BYTE *)v18 + v23 + 4) = *(_BYTE *)v20;
          if ( v61 > v62 )
          {
            do
            {
              v63 = v87;
              v87 = (unsigned int *)((char *)v87 + 1);
              *((_BYTE *)v21 + v62++) = *(_BYTE *)v63;
            }
            while ( v61 != v62 );
          }
        }
        return 7;
      }
      if ( (unsigned __int64)v16 < v15 )
      {
        v25 = (unsigned int *)v20;
        do
        {
          v25 = (unsigned int *)((char *)v25 + 1);
          v26 = &v84[++v23 - 4];
          v87 = v25;
          v27 = v23 != 4 && a4 > (unsigned __int64)v25;
          *(v26 - 1) = *((_BYTE *)v25 - 1);
        }
        while ( v27 );
        v87 = &v83;
        if ( v83 <= 0x7F )
        {
          v88 = v16 + 1;
          *v16 = v83;
          v28 = v87 + 1;
          v87 = v28;
          if ( v28 != &v83 )
          {
LABEL_26:
            v29 = (char *)v28 - (char *)&v83;
LABEL_27:
            v30 = *v18;
            if ( (*v18 & 7LL) >= v29 )
              _libc_assert_fail(
                (__int64)"inptr - bytebuf > (state->__count & 7)",
                (__int64)"../iconv/loop.c",
                0x183u,
                (__int64)"internal_ascii_loop_single");
            v31 = v85;
            v32 = (unsigned int *)(*a3 + v29 - (v30 & 7));
            *a3 = (__int64)v32;
            v16 = v88;
            *v18 = v30 & 0xFFFFFFF8;
            v13 = *(_DWORD *)(a2 + 16);
            goto LABEL_29;
          }
          goto LABEL_113;
        }
        if ( v83 >> 7 == 7168 )
        {
          v87 = (unsigned int *)v84;
          v29 = 4LL;
          goto LABEL_27;
        }
        if ( v77 )
        {
          if ( (v13 & 8) == 0 )
          {
            *(_DWORD *)(a2 + 16) = v13 | 0x40000000;
            if ( (v13 & 2) != 0 )
            {
              ++*v77;
              v28 = (unsigned int *)v84;
              v87 = (unsigned int *)v84;
              goto LABEL_26;
            }
            return 6;
          }
          v73 = v18;
          v81 = v13;
          v82 = v18 + 1;
          v58 = _gconv_transliterate(a1, a2, v20, &v87, (unsigned __int64)&v84[v23 - 4], &v88, v77);
          v18 = v73;
          v35 = v58;
          v59 = &v83;
          v42 = v58 == 6;
          v28 = v87;
          if ( !v42 )
          {
            if ( v35 != 5 )
            {
              if ( v87 != &v83 )
                goto LABEL_26;
              if ( v35 != 7 )
              {
                if ( !v35 )
                {
LABEL_113:
                  v32 = (unsigned int *)*a3;
                  v31 = v85;
                  v13 = *(_DWORD *)(a2 + 16);
                  goto LABEL_29;
                }
                return v35;
              }
              if ( v23 == 4 )
                _libc_assert_fail(
                  (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
                  (__int64)"../iconv/loop.c",
                  0x195u,
                  (__int64)"internal_ascii_loop_single");
              v66 = *v73 & 0xFFFFFFF8;
              *a3 += v23 - (*v73 & 7LL);
              if ( (__int64)v23 <= v66 )
                _libc_assert_fail(
                  (__int64)"inend - inptr > (state->__count & ~7)",
                  (__int64)"../iconv/loop.c",
                  0x19Fu,
                  (__int64)"internal_ascii_loop_single");
              if ( v23 > 4 )
                _libc_assert_fail(
                  (__int64)"inend - inptr <= sizeof (state->__value.__wchb)",
                  (__int64)"../iconv/loop.c",
                  0x1A0u,
                  (__int64)"internal_ascii_loop_single");
              *v73 = v66 | v23;
              v67 = 0LL;
              do
              {
                *((_BYTE *)v82 + v67) = *((_BYTE *)v59 + v67);
                ++v67;
                v59 = v87;
              }
              while ( v67 < v26 - (_BYTE *)v87 );
              return 7;
            }
            if ( v87 != &v83 )
              goto LABEL_26;
            return 5;
          }
          if ( (v81 & 2) != 0 )
          {
            v28 = ++v87;
            ++*v77;
          }
          if ( v28 != &v83 )
            goto LABEL_26;
        }
        else
        {
          *(_DWORD *)(a2 + 16) = v13 | 0x40000000;
        }
        return 6;
      }
      return 5;
    }
    v68 = 467;
LABEL_157:
    _libc_assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      v68,
      (__int64)"__gconv_transform_internal_ascii");
  }
  if ( a5 )
  {
    v68 = 350;
    goto LABEL_157;
  }
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_DWORD *)(a2 + 16) & 1) != 0 )
    return 0;
  return v70(v75, v76, 0LL, 0LL, 0LL, a6, a7, a8);
}
// 4230D8: conditional instruction was optimized away because w3.4!=5
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000423610) ----------------------------------------------------
__int64 __fastcall _gconv_transform_internal_utf8(
        _QWORD *a1,
        __int64 a2,
        __int64 *a3,
        unsigned __int64 a4,
        _QWORD *a5,
        __int64 *a6,
        unsigned int a7,
        unsigned int a8)
{
  int v13; // w7
  _BYTE **v14; // x0
  unsigned __int64 v15; // x20
  _BYTE *v16; // x25
  __int64 *v17; // x0
  unsigned int *v18; // x28
  _BYTE *v19; // x21
  unsigned int *v20; // x0
  unsigned int v21; // w24
  unsigned int v22; // w0
  unsigned int v23; // w7
  _BYTE *v24; // x24
  __int64 v27; // x1
  char v28; // w2
  bool v29; // zf
  unsigned int *v30; // x14
  int v31; // w0
  unsigned int *v32; // x2
  _DWORD *v33; // x18
  _BYTE *v34; // x1
  unsigned __int64 v35; // x28
  unsigned __int64 v36; // x3
  unsigned int *v37; // x0
  char *v38; // x4
  bool v39; // cc
  unsigned int v40; // w0
  unsigned int *v41; // x0
  unsigned int v42; // w1
  __int64 v43; // x0
  __int64 v44; // x0
  int v45; // w21
  _BYTE *v46; // x1
  int v47; // w4
  unsigned int v48; // w0
  _BYTE *v49; // x0
  int v50; // w0
  __int64 v52; // x2
  char v53; // w3
  unsigned __int64 v54; // x1
  unsigned __int64 v55; // x3
  unsigned int *v56; // x0
  __int64 v58; // x1
  char v59; // w2
  unsigned __int64 v60; // x2
  __int64 i; // x0
  __int64 v62; // x1
  char v63; // w3
  unsigned int *v64; // x1
  unsigned int v65; // w0
  unsigned int *v66; // x1
  int v67; // w0
  int v68; // w0
  _BYTE *v69; // x0
  signed int v70; // w0
  unsigned int *v71; // x15
  unsigned __int64 v72; // x0
  unsigned int v73; // w2
  __int64 (__fastcall *v75)(_QWORD *, __int64, _BYTE **, _BYTE *, _QWORD, __int64 *, _QWORD, _QWORD); // [xsp+68h] [xbp+68h]
  _QWORD *v76; // [xsp+70h] [xbp+70h]
  __int64 v77; // [xsp+78h] [xbp+78h]
  __int64 *v78; // [xsp+80h] [xbp+80h]
  int v80; // [xsp+90h] [xbp+90h]
  unsigned int v81; // [xsp+90h] [xbp+90h]
  unsigned int *v82; // [xsp+98h] [xbp+98h]
  _DWORD *v83; // [xsp+A0h] [xbp+A0h]
  int v84; // [xsp+A8h] [xbp+A8h]
  char v85; // [xsp+ACh] [xbp+ACh]
  _DWORD v86[2]; // [xsp+B8h] [xbp+B8h] BYREF
  __int64 v87; // [xsp+C0h] [xbp+C0h] BYREF
  _BYTE *v88; // [xsp+C8h] [xbp+C8h] BYREF
  unsigned int *v89; // [xsp+D0h] [xbp+D0h] BYREF
  _BYTE *v90; // [xsp+D8h] [xbp+D8h] BYREF

  v75 = 0LL;
  v76 = a1 + 13;
  v13 = *(_DWORD *)(a2 + 16);
  v77 = a2 + 48;
  v84 = a7;
  if ( (v13 & 1) == 0 )
  {
    v75 = (__int64 (__fastcall *)(_QWORD *, __int64, _BYTE **, _BYTE *, _QWORD, __int64 *, _QWORD, _QWORD))a1[18];
    if ( a1[13] )
      v75 = (__int64 (__fastcall *)(_QWORD *, __int64, _BYTE **, _BYTE *, _QWORD, __int64 *, _QWORD, _QWORD))(a1[18] ^ _pointer_chk_guard_local);
  }
  if ( a7 )
  {
    if ( !a5 )
    {
      **(_QWORD **)(a2 + 32) = 0LL;
      if ( (*(_DWORD *)(a2 + 16) & 1) != 0 )
        return 0;
      return v75(v76, v77, 0LL, 0LL, 0LL, a6, a7, a8);
    }
    v73 = 350;
    goto LABEL_183;
  }
  if ( a5 )
    v14 = (_BYTE **)a5;
  else
    v14 = (_BYTE **)a2;
  v15 = *(_QWORD *)(a2 + 8);
  v16 = *v14;
  if ( a6 )
    v17 = &v87;
  else
    v17 = 0LL;
  v78 = v17;
  v87 = 0LL;
  if ( a8 )
  {
    v30 = *(unsigned int **)(a2 + 32);
    v31 = *v30 & 7;
    if ( v31 )
    {
      if ( !a5 )
      {
        v32 = (unsigned int *)*a3;
        v89 = (unsigned int *)*a3;
        v90 = v16;
        if ( v31 > 4 )
          _libc_assert_fail(
            (__int64)"(state->__count & 7) <= sizeof (state->__value)",
            (__int64)"../iconv/loop.c",
            0x137u,
            (__int64)"internal_utf8_loop_single");
        v33 = v30 + 1;
        v34 = v86;
        v35 = 0LL;
        do
        {
          v36 = v35;
          *v34++ = *((_BYTE *)v33 + v35++);
        }
        while ( v35 < (*v30 & 7) );
        if ( a4 < (unsigned __int64)v32 - v35 + 4 )
        {
          *a3 = a4;
          v54 = a4 - (_QWORD)v32 + v35;
          if ( v54 > 4 )
            _libc_assert_fail(
              (__int64)"inlen_after <= sizeof (state->__value.__wchb)",
              (__int64)"../iconv/loop.c",
              0x154u,
              (__int64)"internal_utf8_loop_single");
          if ( v35 < v54 )
          {
            v89 = (unsigned int *)((char *)v32 + 1);
            v55 = v36 + 2;
            *((_BYTE *)v30 + v35 + 4) = *(_BYTE *)v32;
            if ( v55 < v54 )
            {
              do
              {
                v56 = v89;
                v89 = (unsigned int *)((char *)v89 + 1);
                *((_BYTE *)v33 + v55++) = *(_BYTE *)v56;
              }
              while ( v54 != v55 );
            }
          }
          return 7;
        }
        if ( (unsigned __int64)v16 >= v15 )
          return 5;
        v37 = v32;
        do
        {
          v37 = (unsigned int *)((char *)v37 + 1);
          ++v35;
          v38 = (char *)v86 + v35;
          v89 = v37;
          v39 = v35 != 4 && a4 > (unsigned __int64)v37;
          *(v38 - 1) = *((_BYTE *)v37 - 1);
        }
        while ( v39 );
        v40 = v86[0];
        v89 = v86;
        if ( v86[0] <= 0x7Fu )
        {
          v90 = v16 + 1;
          goto LABEL_67;
        }
        if ( (unsigned int)(v86[0] - 55296) > 0x7FF && v86[0] >= 0 )
        {
          if ( v86[0] <= 0x7FFu )
          {
            v58 = 2LL;
          }
          else if ( v86[0] <= 0xFFFFu )
          {
            v58 = 3LL;
          }
          else if ( v86[0] <= 0x1FFFFFu )
          {
            v58 = 4LL;
          }
          else
          {
            v58 = (v86[0] > 0x3FFFFFFu) + 5LL;
          }
          if ( v15 >= (unsigned __int64)&v16[v58] )
          {
            *v16 = -256 >> v58;
            v90 += v58;
            do
            {
              --v58;
              v59 = v40 & 0x3F | 0x80;
              v40 >>= 6;
              v16[v58] = v59;
            }
            while ( v58 != 1 );
            LOBYTE(v40) = v40 | *v16;
LABEL_67:
            *v16 = v40;
            v41 = v89 + 1;
            v89 = v41;
            if ( v41 != v86 )
            {
LABEL_68:
              v42 = *v30;
              v43 = (char *)v41 - (char *)v86;
              if ( v43 <= (*v30 & 7LL) )
                _libc_assert_fail(
                  (__int64)"inptr - bytebuf > (state->__count & 7)",
                  (__int64)"../iconv/loop.c",
                  0x183u,
                  (__int64)"internal_utf8_loop_single");
              v16 = v90;
              v18 = (unsigned int *)(*a3 + v43 - (v42 & 7));
              *a3 = (__int64)v18;
              *v30 = v42 & 0xFFFFFFF8;
              v13 = *(_DWORD *)(a2 + 16);
              goto LABEL_13;
            }
            goto LABEL_148;
          }
          return 5;
        }
        if ( !v78 )
        {
          v21 = 6;
          *(_DWORD *)(a2 + 16) = v13 | 0x40000000;
          return v21;
        }
        if ( (v13 & 8) != 0 )
        {
          v82 = v30;
          v83 = v30 + 1;
          v85 = v13;
          v21 = _gconv_transliterate(a1, a2, (__int64)v32, &v89, (unsigned __int64)v38, &v90, v78);
          v41 = v89;
          v66 = v89;
          v30 = v82;
          if ( v21 != 6 )
          {
            if ( v21 != 5 )
            {
              if ( v89 != v86 )
                goto LABEL_68;
              if ( v21 == 7 )
              {
                if ( v35 == 4 )
                  _libc_assert_fail(
                    (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
                    (__int64)"../iconv/loop.c",
                    0x195u,
                    (__int64)"internal_utf8_loop_single");
                v70 = *v82 & 0xFFFFFFF8;
                *a3 += v35 - (*v82 & 7LL);
                if ( (__int64)v35 <= v70 )
                  _libc_assert_fail(
                    (__int64)"inend - inptr > (state->__count & ~7)",
                    (__int64)"../iconv/loop.c",
                    0x19Fu,
                    (__int64)"internal_utf8_loop_single");
                if ( v35 > 4 )
                  _libc_assert_fail(
                    (__int64)"inend - inptr <= sizeof (state->__value.__wchb)",
                    (__int64)"../iconv/loop.c",
                    0x1A0u,
                    (__int64)"internal_utf8_loop_single");
                v71 = v86;
                *v82 = v70 | v35;
                v72 = 0LL;
                do
                {
                  *((_BYTE *)v83 + v72) = *((_BYTE *)v71 + v72);
                  ++v72;
                  v71 = v89;
                }
                while ( v72 < (char *)v86 + v35 - (char *)v89 );
                return 7;
              }
              if ( v21 )
                return v21;
LABEL_148:
              v18 = (unsigned int *)*a3;
              v13 = *(_DWORD *)(a2 + 16);
              goto LABEL_13;
            }
            if ( v89 != v86 )
              goto LABEL_68;
            return 5;
          }
          if ( (v85 & 2) == 0 )
          {
            if ( v89 == v86 )
              return 6;
            goto LABEL_68;
          }
        }
        else
        {
          *(_DWORD *)(a2 + 16) = v13 | 0x40000000;
          if ( (v13 & 2) == 0 )
            return 6;
          v66 = v86;
        }
        ++*v78;
        v41 = v66 + 1;
        v89 = v66 + 1;
        if ( v66 + 1 != v86 )
          goto LABEL_68;
        return 6;
      }
      v73 = 467;
LABEL_183:
      _libc_assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        v73,
        (__int64)"__gconv_transform_internal_utf8");
    }
  }
  v18 = (unsigned int *)*a3;
LABEL_13:
  v89 = v18;
  v90 = v16;
  if ( v18 == (unsigned int *)a4 )
  {
    v19 = v16;
    v20 = v18;
    v21 = 4;
    goto LABEL_21;
  }
LABEL_14:
  v19 = v16;
  v20 = v18;
  v21 = 4;
  while ( 1 )
  {
    if ( a4 < (unsigned __int64)(v20 + 1) )
    {
      *a3 = (__int64)v89;
      v21 = 7;
      if ( !a5 )
        goto LABEL_22;
LABEL_32:
      *a5 = v19;
      return v21;
    }
    if ( v15 <= (unsigned __int64)v19 )
      goto LABEL_33;
    v22 = *v20;
    if ( v22 <= 0x7F )
    {
      v90 = v19 + 1;
LABEL_19:
      *v19 = v22;
      v19 = v90;
      v20 = ++v89;
      goto LABEL_20;
    }
    if ( v22 - 55296 > 0x7FF && (v22 & 0x80000000) == 0 )
    {
      if ( v22 <= 0x7FF )
      {
        v27 = 2LL;
      }
      else if ( v22 <= 0xFFFF )
      {
        v27 = 3LL;
      }
      else if ( v22 <= 0x1FFFFF )
      {
        v27 = 4LL;
      }
      else
      {
        v27 = (v22 > 0x3FFFFFF) + 5LL;
      }
      if ( v15 < (unsigned __int64)&v19[v27] )
      {
LABEL_33:
        v20 = v89;
        v21 = 5;
        goto LABEL_21;
      }
      *v19 = -256 >> v27;
      v90 += v27;
      do
      {
        --v27;
        v28 = v22 & 0x3F | 0x80;
        v22 >>= 6;
        v19[v27] = v28;
      }
      while ( v27 != 1 );
      LOBYTE(v22) = v22 | *v19;
      goto LABEL_19;
    }
    v50 = *(_DWORD *)(a2 + 16);
    if ( !v78 )
      break;
    if ( (v50 & 8) != 0 )
    {
      v80 = v13;
      v21 = _gconv_transliterate(a1, a2, *a3, &v89, a4, &v90, v78);
      v19 = v90;
      v13 = v80;
      if ( v21 != 6 )
      {
        v20 = v89;
        if ( v21 == 5 )
          goto LABEL_21;
        goto LABEL_20;
      }
    }
    else
    {
      *(_DWORD *)(a2 + 16) = v50 | 0x40000000;
    }
    v20 = v89;
    if ( (v13 & 2) == 0 )
    {
      v21 = 6;
      goto LABEL_21;
    }
    v20 = v89 + 1;
    v21 = 6;
    ++v89;
    ++*v78;
LABEL_20:
    if ( (unsigned int *)a4 == v20 )
      goto LABEL_21;
  }
  v21 = 6;
  *(_DWORD *)(a2 + 16) = v50 | 0x40000000;
  v20 = v89;
LABEL_21:
  *a3 = (__int64)v20;
  if ( a5 )
    goto LABEL_32;
LABEL_22:
  v13 = *(_DWORD *)(a2 + 16);
  while ( 1 )
  {
    ++*(_DWORD *)(a2 + 20);
    if ( (v13 & 1) != 0 )
    {
      v44 = *a6;
      *(_QWORD *)a2 = v19;
      *a6 = v44 + v87;
      goto LABEL_48;
    }
    if ( v16 >= v19 )
      goto LABEL_28;
    v88 = *(_BYTE **)a2;
    v23 = v75(v76, v77, &v88, v19, 0LL, a6, 0LL, a8);
    if ( v23 == 4 )
      break;
    v24 = v88;
    if ( v88 == v19 )
      goto LABEL_27;
    v45 = *(_DWORD *)(a2 + 16);
    v46 = v16;
    *a3 = (__int64)v18;
    v89 = v18;
    v90 = v16;
    if ( (unsigned int *)a4 == v18 )
      goto LABEL_92;
    v47 = 4;
    while ( 1 )
    {
      if ( a4 < (unsigned __int64)(v18 + 1) )
        goto LABEL_91;
      if ( v24 <= v46 )
        goto LABEL_94;
      v48 = *v18;
      if ( *v18 <= 0x7F )
      {
        v90 = v46 + 1;
LABEL_77:
        *v46 = v48;
        v46 = v90;
        v18 = ++v89;
        goto LABEL_78;
      }
      if ( v48 - 55296 > 0x7FF && (v48 & 0x80000000) == 0 )
      {
        if ( v48 <= 0x7FF )
        {
          v52 = 2LL;
        }
        else if ( v48 <= 0xFFFF )
        {
          v52 = 3LL;
        }
        else if ( v48 <= 0x1FFFFF )
        {
          v52 = 4LL;
        }
        else
        {
          v52 = (v48 > 0x3FFFFFF) + 5LL;
        }
        if ( v24 < &v46[v52] )
        {
LABEL_94:
          *a3 = (__int64)v89;
          if ( v46 == v88 )
            goto LABEL_95;
LABEL_93:
          _libc_assert_fail(
            (__int64)"outbuf == outerr",
            (__int64)"../iconv/skeleton.c",
            0x252u,
            (__int64)"__gconv_transform_internal_utf8");
        }
        *v46 = -256 >> v52;
        v90 += v52;
        do
        {
          --v52;
          v53 = v48 & 0x3F | 0x80;
          v48 >>= 6;
          v46[v52] = v53;
        }
        while ( v52 != 1 );
        LOBYTE(v48) = v48 | *v46;
        goto LABEL_77;
      }
      v67 = *(_DWORD *)(a2 + 16);
      if ( !v78 )
      {
        *(_DWORD *)(a2 + 16) = v67 | 0x40000000;
LABEL_91:
        v24 = v88;
        v18 = v89;
        goto LABEL_92;
      }
      if ( (v67 & 8) != 0 )
        break;
      *(_DWORD *)(a2 + 16) = v67 | 0x40000000;
LABEL_152:
      v18 = v89;
      if ( (v45 & 2) == 0 )
      {
        v24 = v88;
LABEL_92:
        *a3 = (__int64)v18;
        if ( v24 != v46 )
          goto LABEL_93;
LABEL_81:
        _libc_assert_fail(
          (__int64)"nstatus == __GCONV_FULL_OUTPUT",
          (__int64)"../iconv/skeleton.c",
          0x253u,
          (__int64)"__gconv_transform_internal_utf8");
      }
      v18 = v89 + 1;
      v47 = 6;
      ++v89;
      ++*v78;
LABEL_78:
      if ( (unsigned int *)a4 == v18 )
      {
        v49 = v88;
        *a3 = a4;
        if ( v49 != v46 )
          goto LABEL_93;
        if ( v47 == 5 )
          goto LABEL_95;
        goto LABEL_81;
      }
    }
    v81 = v23;
    v68 = _gconv_transliterate(a1, a2, *a3, &v89, a4, &v90, v78);
    v47 = v68;
    v46 = v90;
    v23 = v81;
    if ( v68 == 6 )
      goto LABEL_152;
    v18 = v89;
    if ( v68 != 5 )
      goto LABEL_78;
    v69 = v88;
    *a3 = (__int64)v89;
    if ( v46 != v69 )
      goto LABEL_93;
LABEL_95:
    if ( v16 != v46 )
    {
LABEL_27:
      v21 = v23;
      goto LABEL_28;
    }
    v21 = v23;
    --*(_DWORD *)(a2 + 20);
LABEL_28:
    if ( v21 )
      goto LABEL_48;
LABEL_29:
    v18 = (unsigned int *)*a3;
    v16 = *(_BYTE **)a2;
    v13 = *(_DWORD *)(a2 + 16);
    v89 = v18;
    v90 = v16;
    if ( (unsigned int *)a4 != v18 )
      goto LABEL_14;
    v19 = v16;
    v21 = 4;
  }
  if ( v21 == 5 || !v21 )
    goto LABEL_29;
LABEL_48:
  if ( a8 )
    v29 = v21 == 7;
  else
    v29 = 0;
  if ( v29 )
  {
    v60 = a4 - *a3;
    if ( v60 > 4 )
      _libc_assert_fail(
        (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
        (__int64)"../iconv/skeleton.c",
        0x287u,
        (__int64)"__gconv_transform_internal_utf8");
    if ( v60 )
    {
      *(_BYTE *)(*(_QWORD *)(a2 + 32) + 4LL) = *(_BYTE *)*a3;
      for ( i = 1LL; v60 != i; *(_BYTE *)(v62 + 4) = v63 )
      {
        v62 = *(_QWORD *)(a2 + 32) + i;
        v63 = *(_BYTE *)(*a3 + i++);
      }
      v84 = v60;
    }
    v64 = *(unsigned int **)(a2 + 32);
    v65 = *v64;
    *a3 = a4;
    *v64 = v65 & 0xFFFFFFF8 | v84;
  }
  return v21;
}
// 424108: using guessed type __int64 _gconv_transform_utf8_internal(void);
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000424108) ----------------------------------------------------
__int64 __fastcall _gconv_transform_utf8_internal(
        __int64 a1,
        __int64 a2,
        unsigned __int8 **a3,
        unsigned __int64 a4,
        unsigned int **a5,
        _QWORD *a6,
        int a7,
        unsigned int a8)
{
  int v12; // w7
  unsigned int **v13; // x0
  __int64 *v14; // x20
  unsigned int *v15; // x22
  unsigned __int64 v16; // x27
  unsigned __int8 *v17; // x28
  unsigned __int8 *v18; // x6
  unsigned int *v19; // x19
  unsigned int v20; // w23
  unsigned int v21; // w0
  unsigned __int8 *v22; // x8
  int v23; // w1
  unsigned int v24; // w0
  unsigned __int64 v25; // x1
  __int64 v26; // x2
  unsigned int v27; // w3
  unsigned __int8 *v28; // x14
  __int64 v29; // x9
  unsigned __int8 v30; // w8
  unsigned int i; // w4
  __int64 v32; // x0
  bool v34; // zf
  int *v35; // x8
  int v36; // w9
  unsigned __int64 v37; // x0
  unsigned __int64 v38; // x1
  unsigned int v39; // w2
  unsigned __int8 *v40; // x28
  unsigned __int64 v41; // x3
  unsigned int *v42; // x12
  unsigned __int8 *v43; // x1
  char v44; // w6
  char v45; // w1
  __int64 v46; // x0
  __int64 v47; // x1
  __int64 v48; // x0
  int v49; // w14
  unsigned int *v50; // x6
  unsigned int v51; // w2
  unsigned __int8 *v52; // x3
  __int64 v53; // x4
  unsigned int v54; // w12
  unsigned __int8 *v55; // x15
  __int64 v56; // x4
  unsigned __int8 v57; // w3
  unsigned int j; // w9
  unsigned int v59; // w18
  char *v60; // x17
  __int64 v61; // x2
  unsigned int v62; // w15
  unsigned int v63; // w16
  char *v64; // x14
  unsigned int v65; // w3
  unsigned __int8 *v66; // x5
  _DWORD *v67; // x6
  unsigned __int64 v68; // x7
  int v69; // w0
  int v70; // w0
  char v71; // w3
  int v72; // w4
  unsigned __int8 *v73; // x1
  char v74; // t1
  char *v75; // x2
  int v76; // w1
  int v77; // w3
  char v78; // w2
  char v79; // t1
  __int64 v80; // x2
  char *v81; // x0
  unsigned int v82; // w2
  _QWORD *v83; // [xsp+68h] [xbp+68h]
  __int64 (__fastcall *v85)(__int64, __int64, _QWORD, _QWORD, _QWORD); // [xsp+78h] [xbp+78h]
  __int64 v86; // [xsp+80h] [xbp+80h]
  __int64 v87; // [xsp+88h] [xbp+88h]
  __int64 v88; // [xsp+90h] [xbp+90h] BYREF
  unsigned __int64 v89; // [xsp+98h] [xbp+98h] BYREF

  v85 = 0LL;
  v86 = a1 + 104;
  v12 = *(_DWORD *)(a2 + 16);
  v87 = a2 + 48;
  if ( (v12 & 1) == 0 )
  {
    v85 = *(__int64 (__fastcall **)(__int64, __int64, _QWORD, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v85 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 144) ^ _pointer_chk_guard_local);
  }
  if ( !a7 )
  {
    if ( a5 )
      v13 = a5;
    else
      v13 = (unsigned int **)a2;
    v14 = &v88;
    v15 = *v13;
    v88 = 0LL;
    if ( !a6 )
      v14 = 0LL;
    v16 = *(_QWORD *)(a2 + 8);
    if ( !a8 || (v35 = *(int **)(a2 + 32), (v36 = *v35 & 7) == 0) )
    {
      v17 = *a3;
      goto LABEL_12;
    }
    if ( !a5 )
    {
      v37 = (unsigned __int8)*v35;
      v38 = *v35 >> 8;
      v39 = v35[1];
      v40 = *a3;
      LOBYTE(v89) = inmask_9[(int)v38 - 2];
      do
      {
        v41 = v38--;
        if ( v37 > v38 )
          *((_BYTE *)&v89 + v41 - 1) = v39 & 0x3F | 0x80;
        v39 >>= 6;
      }
      while ( v38 > 1 );
      v42 = v15 + 1;
      if ( v16 < (unsigned __int64)(v15 + 1) )
        return 5;
      v43 = v40;
      LOBYTE(v89) = v39 | v89;
      while ( 1 )
      {
        v44 = v37++;
        *((_BYTE *)&v89 + v37 - 1) = *v43;
        if ( v37 == 6 )
          break;
        if ( a4 <= (unsigned __int64)++v43 )
          goto LABEL_73;
      }
      v44 = 5;
LABEL_73:
      v45 = v89;
      if ( (unsigned __int8)v89 <= 0x7Fu )
      {
        v46 = 1LL;
        *v15 = (unsigned __int8)v89;
LABEL_75:
        v47 = *v35 & 7;
        if ( v47 >= v46 )
          _libc_assert_fail(
            (__int64)"inptr - bytebuf > (state->__count & 7)",
            (__int64)"../iconv/loop.c",
            0x183u,
            (__int64)"utf8_internal_loop_single");
        v15 = v42;
        v17 = &v40[v46 - v47];
        *a3 = v17;
        *v35 = 0;
        v12 = *(_DWORD *)(a2 + 16);
LABEL_12:
        v18 = (unsigned __int8 *)a4;
        v19 = v15;
        v20 = 4;
        if ( (unsigned __int8 *)a4 != v17 )
          goto LABEL_13;
LABEL_19:
        *a3 = v18;
        if ( a5 )
          goto LABEL_54;
LABEL_20:
        v23 = *(_DWORD *)(a2 + 16);
        ++*(_DWORD *)(a2 + 20);
        if ( (v23 & 1) != 0 )
        {
          v48 = *a6;
          *(_QWORD *)a2 = v19;
          *a6 = v48 + v88;
          goto LABEL_56;
        }
        if ( v15 < v19 )
        {
          v89 = *(_QWORD *)a2;
          v83 = a6;
          v24 = ((__int64 (__fastcall *)(__int64, __int64, unsigned __int64 *, unsigned int *, _QWORD, _QWORD *, _QWORD, _QWORD))v85)(
                  v86,
                  v87,
                  &v89,
                  v19,
                  0LL,
                  a6,
                  0LL,
                  a8);
          a6 = v83;
          if ( v24 == 4 )
          {
            if ( v20 == 5 )
              goto LABEL_25;
            goto LABEL_56;
          }
          v25 = v89;
          if ( (unsigned int *)v89 == v19 )
            goto LABEL_24;
          *a3 = v17;
          if ( (unsigned __int8 *)a4 == v17 )
          {
            v50 = v15;
LABEL_110:
            *a3 = v17;
            if ( (unsigned int *)v25 == v50 )
              _libc_assert_fail(
                (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                (__int64)"../iconv/skeleton.c",
                0x253u,
                (__int64)"__gconv_transform_utf8_internal");
            goto LABEL_200;
          }
          v49 = *(_DWORD *)(a2 + 16);
          v50 = v15;
          while ( 1 )
          {
            if ( v25 < (unsigned __int64)(v50 + 1) )
            {
              *a3 = v17;
              if ( (unsigned int *)v25 == v50 )
              {
                if ( (unsigned int *)v25 == v15 )
                  --*(_DWORD *)(a2 + 20);
LABEL_24:
                if ( !v24 )
                {
LABEL_25:
                  v17 = *a3;
                  v15 = *(unsigned int **)a2;
                  if ( (unsigned __int8 *)a4 == *a3 )
                  {
                    v19 = *(unsigned int **)a2;
                    v20 = 4;
                    goto LABEL_20;
                  }
                  v12 = *(_DWORD *)(a2 + 16);
LABEL_13:
                  v18 = v17;
                  v19 = v15;
                  v20 = 4;
                  while ( 2 )
                  {
                    if ( v16 < (unsigned __int64)(v19 + 1) )
                    {
                      v20 = 5;
                      goto LABEL_19;
                    }
                    v22 = v18 + 1;
                    v21 = *v18;
                    if ( v21 <= 0x7F )
                    {
LABEL_15:
                      v18 = v22;
                      *v19++ = v21;
LABEL_16:
                      if ( v18 == (unsigned __int8 *)a4 )
                        goto LABEL_19;
                      continue;
                    }
                    break;
                  }
                  if ( v21 - 194 > 0x1D )
                  {
                    if ( (v21 & 0xF0) == 0xE0 )
                    {
                      v28 = v18 + 3;
                      v21 &= 0xFu;
                      v27 = 3;
                      v29 = 1LL;
                      if ( a4 < (unsigned __int64)(v18 + 3) )
                        goto LABEL_48;
LABEL_30:
                      while ( 1 )
                      {
                        v30 = v18[v29];
                        i = v29;
                        if ( (v30 & 0xC0) != 0x80 )
                          break;
                        ++v29;
                        v21 = v30 & 0x3F | (v21 << 6);
                        if ( v27 <= (unsigned int)v29 )
                        {
                          ++i;
                          break;
                        }
                      }
                      if ( i >= v27 && (v27 == 2 || v21 >> (5 * v27 - 4)) && v21 - 55296 > 0x7FF )
                      {
                        v22 = v28;
                        goto LABEL_15;
                      }
                    }
                    else
                    {
                      if ( (v21 & 0xF8) == 0xF0 )
                      {
                        v26 = 4LL;
                        v21 &= 7u;
                        v27 = 4;
                        goto LABEL_29;
                      }
                      if ( (v21 & 0xFC) == 0xF8 )
                      {
                        v26 = 5LL;
                        v21 &= 3u;
                        v27 = 5;
                        goto LABEL_29;
                      }
                      if ( (v21 & 0xFE) == 0xFC )
                      {
                        v26 = 6LL;
                        v21 &= 1u;
                        v27 = 6;
                        goto LABEL_29;
                      }
                      v32 = 1LL;
                      while ( 1 )
                      {
                        i = v32;
                        if ( a4 <= (unsigned __int64)&v18[v32] || (v18[v32] & 0xC0) != 0x80 )
                          break;
                        if ( ++v32 == 6 )
                        {
                          i = 5;
                          break;
                        }
                      }
                    }
                  }
                  else
                  {
                    v26 = 2LL;
                    v21 &= 0x1Fu;
                    v27 = 2;
LABEL_29:
                    v28 = &v18[v26];
                    v29 = 1LL;
                    if ( a4 >= (unsigned __int64)&v18[v26] )
                      goto LABEL_30;
LABEL_48:
                    for ( i = 1; a4 > (unsigned __int64)v22; v22 = &v18[++i] )
                    {
                      if ( (*v22 & 0xC0) != 0x80 )
                        break;
                    }
                    if ( (unsigned __int8 *)a4 == v22 )
                    {
                      *a3 = v18;
                      v20 = 7;
                      if ( a5 )
                      {
LABEL_54:
                        *a5 = v19;
                        return v20;
                      }
                      goto LABEL_20;
                    }
                  }
                  *(_DWORD *)(a2 + 16) |= 0x40000000u;
                  if ( !v14 || (v12 & 2) == 0 )
                  {
                    v20 = 6;
                    goto LABEL_19;
                  }
                  v18 += i;
                  v20 = 6;
                  ++*v14;
                  goto LABEL_16;
                }
                v20 = v24;
                break;
              }
LABEL_200:
              _libc_assert_fail(
                (__int64)"outbuf == outerr",
                (__int64)"../iconv/skeleton.c",
                0x252u,
                (__int64)"__gconv_transform_utf8_internal");
            }
            v52 = v17 + 1;
            v51 = *v17;
            if ( v51 <= 0x7F )
              goto LABEL_81;
            if ( v51 - 194 > 0x1D )
            {
              if ( (v51 & 0xF0) == 0xE0 )
              {
                v53 = 3LL;
                v51 &= 0xFu;
                v54 = 3;
              }
              else if ( (v51 & 0xF8) == 0xF0 )
              {
                v53 = 4LL;
                v51 &= 7u;
                v54 = 4;
              }
              else if ( (v51 & 0xFC) == 0xF8 )
              {
                v53 = 5LL;
                v51 &= 3u;
                v54 = 5;
              }
              else
              {
                if ( (v51 & 0xFE) != 0xFC )
                {
                  v80 = 1LL;
                  while ( 1 )
                  {
                    j = v80;
                    if ( a4 <= (unsigned __int64)&v17[v80] || (v17[v80] & 0xC0) != 0x80 )
                      goto LABEL_108;
                    if ( ++v80 == 6 )
                    {
                      j = 5;
                      goto LABEL_108;
                    }
                  }
                }
                v53 = 6LL;
                v51 &= 1u;
                v54 = 6;
              }
            }
            else
            {
              v53 = 2LL;
              v51 &= 0x1Fu;
              v54 = 2;
            }
            v55 = &v17[v53];
            v56 = 1LL;
            if ( a4 < (unsigned __int64)v55 )
            {
              for ( j = 1; a4 > (unsigned __int64)v52; v52 = &v17[++j] )
              {
                if ( (*v52 & 0xC0) != 0x80 )
                  break;
              }
              if ( (unsigned __int8 *)a4 == v52 )
                goto LABEL_110;
            }
            else
            {
              while ( 1 )
              {
                v57 = v17[v56];
                j = v56;
                if ( (v57 & 0xC0) != 0x80 )
                  break;
                ++v56;
                v51 = v57 & 0x3F | (v51 << 6);
                if ( v54 <= (unsigned int)v56 )
                {
                  ++j;
                  break;
                }
              }
              if ( j >= v54 && (v54 == 2 || v51 >> (5 * v54 - 4)) && v51 - 55296 > 0x7FF )
              {
                v52 = v55;
LABEL_81:
                v17 = v52;
                *v50++ = v51;
                goto LABEL_82;
              }
            }
LABEL_108:
            *(_DWORD *)(a2 + 16) |= 0x40000000u;
            if ( !v14 || (v49 & 2) == 0 )
              goto LABEL_110;
            v17 += j;
            ++*v14;
LABEL_82:
            if ( (unsigned __int8 *)a4 == v17 )
              goto LABEL_110;
          }
        }
LABEL_56:
        if ( a8 )
          v34 = v20 == 7;
        else
          v34 = 0;
        if ( v34 )
        {
          v66 = *a3;
          v67 = *(_DWORD **)(a2 + 32);
          v68 = a4 - (_QWORD)*a3;
          v69 = **a3;
          *v67 = v68;
          if ( (unsigned int)(v69 - 192) <= 1 )
            _libc_assert_fail(
              (__int64)"ch != 0xc0 && ch != 0xc1",
              (__int64)"../iconv/skeleton.c",
              0x282u,
              (__int64)"__gconv_transform_utf8_internal");
          if ( (unsigned int)(v69 - 194) > 0x1D )
          {
            if ( (v69 & 0xF0) == 0xE0 )
            {
              v70 = v69 & 0xF;
              v71 = 2;
              v72 = 768;
            }
            else if ( (v69 & 0xF8) == 0xF0 )
            {
              v70 = v69 & 7;
              v71 = 3;
              v72 = 1024;
            }
            else if ( (v69 & 0xFC) == 0xF8 )
            {
              v70 = v69 & 3;
              v71 = 4;
              v72 = 1280;
            }
            else
            {
              v70 = v69 & 1;
              v71 = 5;
              v72 = 1536;
            }
          }
          else
          {
            v70 = v69 & 0x1F;
            v71 = 1;
            v72 = 512;
          }
          v73 = v66 + 1;
          *a3 = v66 + 1;
          if ( a4 > (unsigned __int64)(v66 + 1) )
          {
            do
            {
              v74 = *v73++;
              *a3 = v73;
              v70 = v74 & 0x3F | (v70 << 6);
            }
            while ( v73 != (unsigned __int8 *)a4 );
            v71 += 1 - (_BYTE)v73 + (_BYTE)v66;
          }
          *v67 = v72 | v68;
          v67[1] = v70 << (6 * v71);
        }
        return v20;
      }
      v59 = (unsigned __int8)v89 - 194;
      v60 = (char *)&v89 + v37;
      if ( v59 > 0x1D )
      {
        if ( (v89 & 0xF0) == 0xE0 )
        {
          v61 = 3LL;
          v62 = v89 & 0xF;
          v63 = 3;
        }
        else if ( (v89 & 0xF8) == 0xF0 )
        {
          v61 = 4LL;
          v62 = v89 & 7;
          v63 = 4;
        }
        else if ( (v89 & 0xFC) == 0xF8 )
        {
          v61 = 5LL;
          v62 = v89 & 3;
          v63 = 5;
        }
        else
        {
          if ( (v89 & 0xFE) != 0xFC )
          {
            v81 = (char *)&v89 + 1;
            v65 = 0;
            do
            {
              ++v65;
              if ( v60 <= v81 )
                break;
              if ( (*v81 & 0xC0) != 0x80 )
                break;
              ++v81;
            }
            while ( v65 != 5 );
            goto LABEL_138;
          }
          v61 = 6LL;
          v62 = v89 & 1;
          v63 = 6;
        }
      }
      else
      {
        v61 = 2LL;
        v62 = v89 & 0x1F;
        v63 = 2;
      }
      v64 = (char *)&v89 + 1;
      v65 = 1;
      if ( v60 >= (char *)&v89 + v61 )
      {
        while ( (*v64 & 0xC0) == 0x80 )
        {
          ++v65;
          v62 = *v64++ & 0x3F | (v62 << 6);
          if ( v63 == v65 )
            goto LABEL_125;
        }
        if ( v63 <= v65 )
        {
LABEL_125:
          if ( (v63 == 2 || v62 >> (5 * v63 - 4)) && v62 - 55296 > 0x7FF )
          {
            v46 = v61;
            *v15 = v62;
            goto LABEL_75;
          }
        }
        goto LABEL_138;
      }
      if ( v60 <= (char *)&v89 + 1 )
      {
        if ( v37 == 1 )
        {
LABEL_154:
          *a3 = &v40[v37 - v36];
          if ( v59 > 0x1D )
          {
            if ( (v45 & 0xF0) == 0xE0 )
            {
              v76 = v45 & 0xF;
              v77 = 768;
              v78 = 2;
            }
            else if ( (v45 & 0xF8) == 0xF0 )
            {
              v76 = v45 & 7;
              v77 = 1024;
              v78 = 3;
            }
            else if ( (v45 & 0xFC) == 0xF8 )
            {
              v76 = v45 & 3;
              v77 = 1280;
              v78 = 4;
            }
            else
            {
              v76 = v45 & 1;
              v77 = 1536;
              v78 = 5;
            }
          }
          else
          {
            v76 = v45 & 0x1F;
            v77 = 512;
            v78 = 1;
          }
          if ( v60 > (char *)&v89 + 1 )
          {
            do
            {
              v79 = *v64++;
              v76 = v79 & 0x3F | (v76 << 6);
            }
            while ( v64 != v60 );
            v78 -= v44;
          }
          v20 = 7;
          *v35 = v37 | v77;
          v35[1] = v76 << (6 * v78);
          return v20;
        }
      }
      else
      {
        v75 = (char *)&v89 + 1;
        do
        {
          if ( (*v75 & 0xC0) != 0x80 )
            break;
          v75 = (char *)&v89 + ++v65;
        }
        while ( v60 > v75 );
        if ( v60 == v75 )
        {
          if ( v37 == 6 )
            _libc_assert_fail(
              (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
              (__int64)"../iconv/loop.c",
              0x195u,
              (__int64)"utf8_internal_loop_single");
          goto LABEL_154;
        }
      }
LABEL_138:
      *(_DWORD *)(a2 + 16) = v12 | 0x40000000;
      if ( v14 )
      {
        if ( (v12 & 2) != 0 )
        {
          v42 = v15;
          ++*v14;
          v46 = v65;
          if ( v65 )
            goto LABEL_75;
        }
      }
      return 6;
    }
    v82 = 467;
LABEL_202:
    _libc_assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      v82,
      (__int64)"__gconv_transform_utf8_internal");
  }
  if ( a5 )
  {
    v82 = 350;
    goto LABEL_202;
  }
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_DWORD *)(a2 + 16) & 1) != 0 )
    return 0;
  return v85(v86, v87, 0LL, 0LL, 0LL);
}
// 4575B0: using guessed type _BYTE inmask_9[8];
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000424C80) ----------------------------------------------------
__int64 __fastcall _gconv_transform_ucs2_internal(
        __int64 a1,
        __int64 a2,
        unsigned __int64 *a3,
        unsigned __int8 *a4,
        char **a5,
        _QWORD *a6,
        unsigned int a7,
        unsigned int a8)
{
  int v12; // w1
  char **v13; // x0
  unsigned __int64 v14; // x22
  char *v15; // x23
  __int64 *v16; // x0
  unsigned int *v17; // x4
  int v18; // w0
  unsigned __int8 *v19; // x28
  bool v20; // zf
  unsigned __int8 *v21; // x0
  unsigned __int64 v22; // x3
  int v23; // w2
  unsigned int v24; // w0
  unsigned __int64 v25; // x28
  __int64 v26; // x21
  char *v27; // x19
  unsigned __int64 v28; // x0
  unsigned int v29; // w24
  _BYTE *v30; // x3
  int v31; // w2
  int v33; // w1
  unsigned int v34; // w0
  unsigned __int64 v35; // x1
  bool v36; // zf
  __int64 v37; // x0
  __int64 v38; // x2
  int v39; // w12
  char *v40; // x3
  _BYTE *v41; // x7
  int v42; // w6
  unsigned __int64 v43; // x0
  unsigned __int8 *v44; // x28
  int *v45; // x4
  unsigned __int64 v46; // x2
  __int64 i; // x0
  __int64 v48; // x1
  char v49; // w3
  unsigned int *v50; // x1
  unsigned int v51; // w0
  unsigned int v52; // w2
  _QWORD *v53; // [xsp+60h] [xbp+60h]
  __int64 (__fastcall *v54)(__int64, __int64, char **, char *, _QWORD, _QWORD *, _QWORD, _QWORD); // [xsp+68h] [xbp+68h]
  __int64 v55; // [xsp+70h] [xbp+70h]
  __int64 v56; // [xsp+78h] [xbp+78h]
  __int64 *v57; // [xsp+80h] [xbp+80h]
  unsigned int v59; // [xsp+8Ch] [xbp+8Ch]
  __int64 v60; // [xsp+90h] [xbp+90h] BYREF
  char *v61; // [xsp+98h] [xbp+98h] BYREF

  v54 = 0LL;
  v55 = a1 + 104;
  v59 = a7;
  v56 = a2 + 48;
  v12 = *(_DWORD *)(a2 + 16);
  LOBYTE(a7) = v12;
  if ( (v12 & 1) == 0 )
  {
    v54 = *(__int64 (__fastcall **)(__int64, __int64, char **, char *, _QWORD, _QWORD *, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v54 = (__int64 (__fastcall *)(__int64, __int64, char **, char *, _QWORD, _QWORD *, _QWORD, _QWORD))(*(_QWORD *)(a1 + 144) ^ _pointer_chk_guard_local);
  }
  if ( v59 )
  {
    if ( !a5 )
    {
      **(_QWORD **)(a2 + 32) = 0LL;
      if ( (*(_DWORD *)(a2 + 16) & 1) != 0 )
        return 0;
      return v54(v55, v56, 0LL, 0LL, 0LL, a6, v59, a8);
    }
    v52 = 350;
    goto LABEL_107;
  }
  if ( a5 )
    v13 = a5;
  else
    v13 = (char **)a2;
  v14 = *(_QWORD *)(a2 + 8);
  v15 = *v13;
  if ( a6 )
    v16 = &v60;
  else
    v16 = 0LL;
  v57 = v16;
  v60 = 0LL;
  if ( a8 )
  {
    v17 = *(unsigned int **)(a2 + 32);
    v18 = *v17 & 7;
    if ( v18 )
    {
      if ( !a5 )
      {
        v19 = (unsigned __int8 *)*a3;
        if ( (*v17 & 7) > 4 )
          _libc_assert_fail(
            (__int64)"(state->__count & 7) <= sizeof (state->__value)",
            (__int64)"../iconv/loop.c",
            0x137u,
            (__int64)"ucs2_internal_loop_single");
        v20 = v18 == 1;
        if ( v18 == 1 )
          v21 = v19 + 1;
        else
          v21 = (unsigned __int8 *)*a3;
        v22 = 2LL;
        if ( v20 )
          v22 = 1LL;
        if ( a4 < v21 )
        {
          *a3 = (unsigned __int64)a4;
          v43 = a4 - v19 + v22;
          if ( v43 > 4 )
            _libc_assert_fail(
              (__int64)"inlen_after <= sizeof (state->__value.__wchb)",
              (__int64)"../iconv/loop.c",
              0x154u,
              (__int64)"ucs2_internal_loop_single");
          v44 = &v19[-v22];
          v45 = (int *)(v17 + 1);
          if ( v43 > v22 )
          {
            do
            {
              *((_BYTE *)v45 + v22) = v44[v22];
              ++v22;
            }
            while ( v43 != v22 );
          }
          return 7;
        }
        if ( v14 < (unsigned __int64)(v15 + 4) )
          return 5;
        v23 = (unsigned __int16)(*((unsigned __int8 *)v17 + 4) | (*v19 << 8));
        if ( (unsigned __int16)(v23 + 10240) <= 0x7FFu )
        {
          *(_DWORD *)(a2 + 16) = v12 | 0x40000000;
          if ( !v57 || (v12 & 2) == 0 )
            return 6;
          ++*v57;
        }
        else
        {
          *(_DWORD *)v15 = v23;
          v15 += 4;
        }
        v24 = *v17;
        if ( (*v17 & 6) != 0 )
          _libc_assert_fail(
            (__int64)"inptr - bytebuf > (state->__count & 7)",
            (__int64)"../iconv/loop.c",
            0x183u,
            (__int64)"ucs2_internal_loop_single");
        v25 = (unsigned __int64)&v19[-(*v17 & 7LL) + 2];
        *a3 = v25;
        *v17 = v24 & 0xFFFFFFF8;
        v26 = v60;
        a7 = *(_DWORD *)(a2 + 16);
        goto LABEL_27;
      }
      v52 = 467;
LABEL_107:
      _libc_assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        v52,
        (__int64)"__gconv_transform_ucs2_internal");
    }
  }
  v25 = *a3;
  v26 = 0LL;
LABEL_27:
  if ( a6 )
    v26 += *a6;
  if ( (unsigned __int8 *)v25 == a4 )
  {
    v27 = v15;
    v30 = (_BYTE *)v25;
    v29 = 4;
LABEL_40:
    *a3 = (unsigned __int64)v30;
    if ( a5 )
      goto LABEL_37;
  }
  else
  {
LABEL_30:
    v27 = v15;
    v28 = v25;
    v29 = 4;
    do
    {
      v30 = (_BYTE *)v28;
      v28 += 2LL;
      if ( (unsigned __int64)a4 < v28 )
      {
        v29 = 7;
        goto LABEL_40;
      }
      if ( v14 < (unsigned __int64)(v27 + 4) )
      {
        v29 = 5;
        goto LABEL_40;
      }
      v31 = *(unsigned __int16 *)(v28 - 2);
      if ( (unsigned __int16)(v31 + 10240) <= 0x7FFu )
      {
        *(_DWORD *)(a2 + 16) |= 0x40000000u;
        if ( !v57 || (a7 & 2) == 0 )
        {
          v29 = 6;
          goto LABEL_40;
        }
        v29 = 6;
        ++*v57;
      }
      else
      {
        *(_DWORD *)v27 = v31;
        v27 += 4;
      }
    }
    while ( a4 != (unsigned __int8 *)v28 );
    *a3 = (unsigned __int64)a4;
    if ( a5 )
    {
LABEL_37:
      *a5 = v27;
      return v29;
    }
  }
  v33 = *(_DWORD *)(a2 + 16);
  while ( 1 )
  {
    ++*(_DWORD *)(a2 + 20);
    if ( (v33 & 1) != 0 )
    {
      v37 = *a6;
      *(_QWORD *)a2 = v27;
      *a6 = v37 + v60;
      goto LABEL_56;
    }
    if ( v27 <= v15 )
      goto LABEL_56;
    v61 = *(char **)a2;
    v53 = a6;
    v34 = v54(v55, v56, &v61, v27, 0LL, a6, 0LL, a8);
    a6 = v53;
    if ( v34 != 4 )
      break;
    if ( v29 != 5 )
      goto LABEL_56;
LABEL_47:
    v33 = *(_DWORD *)(a2 + 16);
    v25 = *a3;
    LOBYTE(a7) = v33;
    v15 = *(char **)a2;
    v26 = v60;
    if ( v53 )
      v26 = v60 + *v53;
    if ( a4 != (unsigned __int8 *)v25 )
      goto LABEL_30;
    v27 = *(char **)a2;
    v29 = 4;
    *a3 = v25;
  }
  v35 = (unsigned __int64)v61;
  if ( v61 != v27 )
  {
    v38 = 0LL;
    if ( v53 )
      v38 = *v53;
    if ( v38 + v60 == v26 )
    {
      *a3 -= (v27 - v61) / 2;
    }
    else
    {
      if ( a4 == (unsigned __int8 *)v25 )
      {
        v40 = v15;
        v41 = a4;
        goto LABEL_74;
      }
      v39 = *(_DWORD *)(a2 + 16);
      v40 = v15;
      while ( 1 )
      {
        v41 = (_BYTE *)v25;
        v25 += 2LL;
        if ( (unsigned __int64)a4 < v25 )
          goto LABEL_74;
        if ( v35 < (unsigned __int64)(v40 + 4) )
          break;
        v42 = *(unsigned __int16 *)(v25 - 2);
        if ( (unsigned __int16)(v42 + 10240) <= 0x7FFu )
        {
          *(_DWORD *)(a2 + 16) |= 0x40000000u;
          if ( !v57 || (v39 & 2) == 0 )
            goto LABEL_74;
          ++*v57;
        }
        else
        {
          *(_DWORD *)v40 = v42;
          v40 += 4;
        }
        if ( a4 == (unsigned __int8 *)v25 )
        {
          v41 = a4;
LABEL_74:
          *a3 = (unsigned __int64)v41;
          if ( (char *)v35 == v40 )
            _libc_assert_fail(
              (__int64)"nstatus == __GCONV_FULL_OUTPUT",
              (__int64)"../iconv/skeleton.c",
              0x253u,
              (__int64)"__gconv_transform_ucs2_internal");
LABEL_111:
          _libc_assert_fail(
            (__int64)"outbuf == outerr",
            (__int64)"../iconv/skeleton.c",
            0x252u,
            (__int64)"__gconv_transform_ucs2_internal");
        }
      }
      *a3 = (unsigned __int64)v41;
      if ( (char *)v35 != v40 )
        goto LABEL_111;
      if ( v15 == (char *)v35 )
        --*(_DWORD *)(a2 + 20);
    }
  }
  if ( !v34 )
    goto LABEL_47;
  v29 = v34;
LABEL_56:
  if ( a8 )
    v36 = v29 == 7;
  else
    v36 = 0;
  if ( v36 )
  {
    v46 = (unsigned __int64)&a4[-*a3];
    if ( v46 > 4 )
      _libc_assert_fail(
        (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
        (__int64)"../iconv/skeleton.c",
        0x287u,
        (__int64)"__gconv_transform_ucs2_internal");
    if ( v46 )
    {
      *(_BYTE *)(*(_QWORD *)(a2 + 32) + 4LL) = *(_BYTE *)*a3;
      for ( i = 1LL; v46 != i; *(_BYTE *)(v48 + 4) = v49 )
      {
        v48 = *(_QWORD *)(a2 + 32) + i;
        v49 = *(_BYTE *)(*a3 + i++);
      }
      v59 = v46;
    }
    v50 = *(unsigned int **)(a2 + 32);
    v51 = *v50;
    *a3 = (unsigned __int64)a4;
    *v50 = v51 & 0xFFFFFFF8 | v59;
  }
  return v29;
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (00000000004252E0) ----------------------------------------------------
__int64 __fastcall _gconv_transform_internal_ucs2(
        _QWORD *a1,
        __int64 a2,
        __int64 *a3,
        unsigned __int64 a4,
        char **a5,
        __int64 *a6,
        unsigned int a7,
        unsigned int a8)
{
  int v13; // w8
  int v14; // w18
  char **v15; // x0
  unsigned __int64 v16; // x26
  __int64 *v17; // x27
  char *v18; // x22
  unsigned int *v19; // x7
  int v20; // w0
  __int64 v21; // x2
  _DWORD *v22; // x13
  unsigned int *v23; // x1
  unsigned __int64 v24; // x21
  unsigned __int64 v25; // x3
  unsigned int *v26; // x0
  _BYTE *v27; // x4
  char v28; // w3
  bool v29; // cc
  __int64 v30; // x0
  unsigned int v31; // w1
  __int64 v32; // x13
  unsigned int *v33; // x21
  char *v34; // x3
  unsigned int *v35; // x0
  unsigned int v36; // w23
  unsigned int *v37; // x1
  char *v38; // x2
  unsigned int v39; // w0
  int v40; // w8
  unsigned int v41; // w7
  unsigned __int64 v42; // x23
  int v44; // w0
  bool v45; // zf
  __int64 v46; // x1
  __int64 v47; // x0
  __int64 v48; // x0
  bool v49; // zf
  unsigned int v50; // w0
  __int64 v51; // x0
  int v52; // w13
  char *v53; // x1
  int v54; // w5
  unsigned int *v55; // x0
  char *v56; // x2
  unsigned int v57; // w3
  char *v58; // x0
  unsigned __int64 v59; // x2
  __int64 i; // x0
  __int64 v61; // x1
  char v62; // w3
  unsigned int *v63; // x1
  unsigned int v64; // w0
  int v65; // w0
  __int64 v66; // x2
  unsigned __int64 v67; // x1
  unsigned __int64 v68; // x3
  unsigned int *v69; // x0
  unsigned int *v70; // x0
  __int64 v71; // x0
  int v72; // w0
  char *v73; // x0
  unsigned int *v74; // x10
  signed int v75; // w0
  unsigned __int64 v76; // x0
  __int64 v77; // x1
  unsigned int *v78; // x0
  unsigned int v79; // w2
  __int64 (__fastcall *v81)(_QWORD *, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD); // [xsp+68h] [xbp+68h]
  char *v82; // [xsp+70h] [xbp+70h]
  __int64 v83; // [xsp+70h] [xbp+70h]
  int v84; // [xsp+70h] [xbp+70h]
  __int64 v85; // [xsp+78h] [xbp+78h]
  unsigned int v86; // [xsp+78h] [xbp+78h]
  unsigned int *v87; // [xsp+78h] [xbp+78h]
  _QWORD *v88; // [xsp+80h] [xbp+80h]
  __int64 v89; // [xsp+88h] [xbp+88h]
  int v91; // [xsp+98h] [xbp+98h]
  char v92; // [xsp+9Ch] [xbp+9Ch]
  _DWORD *v93; // [xsp+A0h] [xbp+A0h]
  unsigned int v94; // [xsp+B8h] [xbp+B8h] BYREF
  _BYTE v95[4]; // [xsp+BCh] [xbp+BCh] BYREF
  __int64 v96; // [xsp+C0h] [xbp+C0h] BYREF
  char *v97; // [xsp+C8h] [xbp+C8h] BYREF
  unsigned int *v98; // [xsp+D0h] [xbp+D0h] BYREF
  char *v99; // [xsp+D8h] [xbp+D8h] BYREF

  v13 = *(_DWORD *)(a2 + 16);
  v81 = 0LL;
  LOBYTE(v14) = v13;
  v88 = a1 + 13;
  v89 = a2 + 48;
  v91 = a7;
  if ( (v13 & 1) == 0 )
  {
    v81 = (__int64 (__fastcall *)(_QWORD *, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD))a1[18];
    if ( a1[13] )
      v81 = (__int64 (__fastcall *)(_QWORD *, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD))(a1[18] ^ _pointer_chk_guard_local);
  }
  if ( !a7 )
  {
    if ( a5 )
      v15 = a5;
    else
      v15 = (char **)a2;
    v16 = *(_QWORD *)(a2 + 8);
    if ( a6 )
      v17 = &v96;
    else
      v17 = 0LL;
    v18 = *v15;
    v96 = 0LL;
    if ( !a8 || (v19 = *(unsigned int **)(a2 + 32), (v20 = *v19 & 7) == 0) )
    {
      v33 = (unsigned int *)*a3;
      v32 = 0LL;
      goto LABEL_30;
    }
    if ( !a5 )
    {
      v21 = *a3;
      v98 = (unsigned int *)*a3;
      v99 = v18;
      if ( v20 > 4 )
        _libc_assert_fail(
          (__int64)"(state->__count & 7) <= sizeof (state->__value)",
          (__int64)"../iconv/loop.c",
          0x137u,
          (__int64)"internal_ucs2_loop_single");
      v22 = v19 + 1;
      v23 = &v94;
      v24 = 0LL;
      do
      {
        v25 = v24;
        *(_BYTE *)v23 = *((_BYTE *)v22 + v24);
        v23 = (unsigned int *)((char *)v23 + 1);
        ++v24;
      }
      while ( v24 < (*v19 & 7) );
      if ( a4 < v21 - v24 + 4 )
      {
        *a3 = a4;
        v67 = a4 - v21 + v24;
        if ( v67 > 4 )
          _libc_assert_fail(
            (__int64)"inlen_after <= sizeof (state->__value.__wchb)",
            (__int64)"../iconv/loop.c",
            0x154u,
            (__int64)"internal_ucs2_loop_single");
        if ( v24 < v67 )
        {
          v98 = (unsigned int *)(v21 + 1);
          v68 = v25 + 2;
          *((_BYTE *)v19 + v24 + 4) = *(_BYTE *)v21;
          if ( v67 > v68 )
          {
            do
            {
              v69 = v98;
              v98 = (unsigned int *)((char *)v98 + 1);
              *((_BYTE *)v22 + v68++) = *(_BYTE *)v69;
            }
            while ( v67 != v68 );
          }
        }
        return 7;
      }
      if ( v16 >= (unsigned __int64)(v18 + 2) )
      {
        v26 = (unsigned int *)(v21 + 1);
        do
        {
          ++v24;
          v98 = v26;
          v27 = &v95[v24 - 4];
          v28 = *((_BYTE *)v26 - 1);
          v29 = v24 != 4 && a4 > (unsigned __int64)v26;
          v26 = (unsigned int *)((char *)v26 + 1);
          *(v27 - 1) = v28;
        }
        while ( v29 );
        v98 = &v94;
        if ( v94 <= 0xFFFF )
        {
          if ( v94 - 55296 > 0x7FF )
          {
            *(_WORD *)v18 = v94;
            v98 = (unsigned int *)v95;
            v99 = v18 + 2;
LABEL_27:
            v30 = 4LL;
LABEL_28:
            v31 = *v19;
            if ( v30 <= (*v19 & 7LL) )
              _libc_assert_fail(
                (__int64)"inptr - bytebuf > (state->__count & 7)",
                (__int64)"../iconv/loop.c",
                0x183u,
                (__int64)"internal_ucs2_loop_single");
            v32 = v96;
            v33 = (unsigned int *)(*a3 + v30 - (v31 & 7));
            *a3 = (__int64)v33;
            v18 = v99;
            *v19 = v31 & 0xFFFFFFF8;
            v14 = *(_DWORD *)(a2 + 16);
            goto LABEL_30;
          }
          *(_DWORD *)(a2 + 16) = v13 | 0x40000000;
          if ( v17 && (v13 & 2) != 0 )
          {
            v98 = (unsigned int *)v95;
            ++*v17;
            goto LABEL_27;
          }
          return 6;
        }
        if ( v94 >> 7 == 7168 )
        {
          v98 = (unsigned int *)v95;
          goto LABEL_27;
        }
        if ( !v17 )
        {
          *(_DWORD *)(a2 + 16) = v13 | 0x40000000;
          return 6;
        }
        if ( (v13 & 8) == 0 )
        {
          *(_DWORD *)(a2 + 16) = v13 | 0x40000000;
          if ( (v13 & 2) != 0 )
          {
            ++*v17;
            v70 = (unsigned int *)v95;
            v98 = (unsigned int *)v95;
            goto LABEL_137;
          }
          return 6;
        }
        v87 = v19;
        v92 = v13;
        v93 = v19 + 1;
        v36 = _gconv_transliterate(a1, a2, v21, &v98, (unsigned __int64)v27, &v99, v17);
        v70 = v98;
        v19 = v87;
        v74 = &v94;
        if ( v36 == 6 )
        {
          if ( (v92 & 2) != 0 )
          {
            v77 = *v17;
            v78 = ++v98;
            *v17 = v77 + 1;
            if ( v78 != &v94 )
            {
              v30 = (char *)v78 - (char *)&v94;
              goto LABEL_28;
            }
          }
          else if ( v98 != &v94 )
          {
            v30 = (char *)v98 - (char *)&v94;
            goto LABEL_28;
          }
          return 6;
        }
        if ( v36 != 5 )
        {
          if ( v98 != &v94 )
            goto LABEL_137;
          if ( v36 == 7 )
          {
            if ( v24 == 4 )
              _libc_assert_fail(
                (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
                (__int64)"../iconv/loop.c",
                0x195u,
                (__int64)"internal_ucs2_loop_single");
            v75 = *v87 & 0xFFFFFFF8;
            *a3 += v24 - (*v87 & 7LL);
            if ( (__int64)v24 <= v75 )
              _libc_assert_fail(
                (__int64)"inend - inptr > (state->__count & ~7)",
                (__int64)"../iconv/loop.c",
                0x19Fu,
                (__int64)"internal_ucs2_loop_single");
            if ( v24 > 4 )
              _libc_assert_fail(
                (__int64)"inend - inptr <= sizeof (state->__value.__wchb)",
                (__int64)"../iconv/loop.c",
                0x1A0u,
                (__int64)"internal_ucs2_loop_single");
            *v87 = v75 | v24;
            v76 = 0LL;
            do
            {
              *((_BYTE *)v93 + v76) = *((_BYTE *)v74 + v76);
              ++v76;
              v74 = v98;
            }
            while ( v76 < &v95[v24 - 4] - (_BYTE *)v98 );
            return 7;
          }
          if ( v36 )
            return v36;
          v33 = (unsigned int *)*a3;
          v32 = v96;
          v14 = *(_DWORD *)(a2 + 16);
LABEL_30:
          if ( a6 )
LABEL_31:
            v32 += *a6;
          v98 = v33;
          v99 = v18;
          if ( (unsigned int *)a4 != v33 )
          {
LABEL_33:
            v34 = v18;
            v35 = v33;
            v36 = 4;
            while ( 1 )
            {
              v37 = v35 + 1;
              if ( a4 < (unsigned __int64)(v35 + 1) )
              {
                *a3 = (__int64)v98;
                v36 = 7;
                if ( !a5 )
                  goto LABEL_41;
                goto LABEL_53;
              }
              v38 = v34 + 2;
              if ( v16 < (unsigned __int64)(v34 + 2) )
              {
                v35 = v98;
                v36 = 5;
                goto LABEL_40;
              }
              v39 = *v35;
              if ( v39 > 0xFFFF )
              {
                if ( v39 >> 7 == 7168 )
                {
                  v35 = v37;
                  v98 = v37;
                  goto LABEL_39;
                }
                v44 = *(_DWORD *)(a2 + 16);
                if ( !v17 )
                {
                  v36 = 6;
                  *(_DWORD *)(a2 + 16) = v44 | 0x40000000;
                  v35 = v98;
                  goto LABEL_40;
                }
                if ( (v44 & 8) != 0 )
                {
                  v83 = v32;
                  v50 = _gconv_transliterate(a1, a2, *a3, &v98, a4, &v99, v17);
                  v32 = v83;
                  v36 = v50;
                  v34 = v99;
                  if ( v50 != 6 )
                  {
                    v35 = v98;
                    if ( v36 == 5 )
                      goto LABEL_40;
                    goto LABEL_39;
                  }
                }
                else
                {
                  *(_DWORD *)(a2 + 16) = v44 | 0x40000000;
                }
                v35 = v98;
                if ( (v14 & 2) == 0 )
                {
                  v36 = 6;
                  goto LABEL_40;
                }
                v46 = *v17;
                v35 = v98 + 1;
                v36 = 6;
                ++v98;
                *v17 = v46 + 1;
              }
              else if ( v39 - 55296 <= 0x7FF )
              {
                *(_DWORD *)(a2 + 16) |= 0x40000000u;
                if ( !v17 || (v14 & 2) == 0 )
                {
                  v35 = v98;
                  v36 = 6;
                  goto LABEL_40;
                }
                v47 = *v17;
                v36 = 6;
                v98 = v37;
                *v17 = v47 + 1;
                v35 = v37;
              }
              else
              {
                *(_WORD *)v34 = v39;
                v34 += 2;
                v35 = v37;
                v98 = v37;
                v99 = v38;
              }
LABEL_39:
              if ( (unsigned int *)a4 == v35 )
                goto LABEL_40;
            }
          }
          v34 = v18;
          v35 = (unsigned int *)a4;
          v36 = 4;
LABEL_40:
          *a3 = (__int64)v35;
          if ( a5 )
          {
LABEL_53:
            *a5 = v34;
            return v36;
          }
LABEL_41:
          v40 = *(_DWORD *)(a2 + 16);
          while ( 1 )
          {
            ++*(_DWORD *)(a2 + 20);
            if ( (v40 & 1) != 0 )
              break;
            if ( v34 <= v18 )
              goto LABEL_47;
            v97 = *(char **)a2;
            v82 = v34;
            v85 = v32;
            v41 = v81(v88, v89, &v97, v34, 0LL, a6, 0LL, a8);
            if ( v41 == 4 )
            {
              if ( v36 != 5 && v36 )
                goto LABEL_66;
            }
            else
            {
              v42 = (unsigned __int64)v97;
              if ( v82 == v97 )
                goto LABEL_46;
              v51 = 0LL;
              if ( a6 )
                v51 = *a6;
              if ( v51 + v96 != v85 )
              {
                v52 = *(_DWORD *)(a2 + 16);
                v53 = v18;
                *a3 = (__int64)v33;
                v98 = v33;
                v99 = v18;
                if ( (unsigned int *)a4 == v33 )
                  goto LABEL_103;
                v54 = 4;
                while ( 2 )
                {
                  v55 = v33 + 1;
                  if ( a4 < (unsigned __int64)(v33 + 1) )
                  {
LABEL_102:
                    v42 = (unsigned __int64)v97;
                    v33 = v98;
LABEL_103:
                    *a3 = (__int64)v33;
                    if ( (char *)v42 != v53 )
                      goto LABEL_116;
                    goto LABEL_104;
                  }
                  v56 = v53 + 2;
                  if ( v42 < (unsigned __int64)(v53 + 2) )
                  {
                    *a3 = (__int64)v98;
                    if ( v97 != v53 )
                      goto LABEL_116;
                    goto LABEL_96;
                  }
                  v57 = *v33;
                  if ( *v33 <= 0xFFFF )
                  {
                    if ( v57 - 55296 <= 0x7FF )
                    {
                      *(_DWORD *)(a2 + 16) |= 0x40000000u;
                      if ( !v17 || (v52 & 2) == 0 )
                        goto LABEL_102;
                      v66 = *v17;
                      ++v33;
                      v54 = 6;
                      v98 = v55;
                      *v17 = v66 + 1;
                    }
                    else
                    {
                      ++v33;
                      *(_WORD *)v53 = v57;
                      v53 += 2;
                      v98 = v55;
                      v99 = v56;
                    }
                    goto LABEL_93;
                  }
                  if ( v57 >> 7 == 7168 )
                  {
                    ++v33;
                    v98 = v55;
                    goto LABEL_93;
                  }
                  v65 = *(_DWORD *)(a2 + 16);
                  if ( !v17 )
                  {
                    v42 = (unsigned __int64)v97;
                    v33 = v98;
                    *(_DWORD *)(a2 + 16) = v65 | 0x40000000;
                    goto LABEL_103;
                  }
                  if ( (v65 & 8) == 0 )
                  {
                    *(_DWORD *)(a2 + 16) = v65 | 0x40000000;
                    goto LABEL_121;
                  }
                  v84 = v52;
                  v86 = v41;
                  v72 = _gconv_transliterate(a1, a2, *a3, &v98, a4, &v99, v17);
                  v53 = v99;
                  v54 = v72;
                  v52 = v84;
                  v41 = v86;
                  if ( v72 == 6 )
                  {
LABEL_121:
                    v33 = v98;
                    if ( (v52 & 2) == 0 )
                    {
                      v42 = (unsigned __int64)v97;
                      goto LABEL_103;
                    }
                    v71 = *v17;
                    v33 = v98 + 1;
                    v54 = 6;
                    ++v98;
                    *v17 = v71 + 1;
                  }
                  else
                  {
                    v33 = v98;
                    if ( v72 == 5 )
                    {
                      v73 = v97;
                      *a3 = (__int64)v98;
                      if ( v73 != v53 )
LABEL_116:
                        _libc_assert_fail(
                          (__int64)"outbuf == outerr",
                          (__int64)"../iconv/skeleton.c",
                          0x252u,
                          (__int64)"__gconv_transform_internal_ucs2");
LABEL_96:
                      if ( v53 == v18 )
                      {
                        v36 = v41;
                        --*(_DWORD *)(a2 + 20);
                        goto LABEL_47;
                      }
LABEL_46:
                      v36 = v41;
                      goto LABEL_47;
                    }
                  }
LABEL_93:
                  if ( (unsigned int *)a4 == v33 )
                  {
                    v58 = v97;
                    *a3 = a4;
                    if ( v58 != v53 )
                      goto LABEL_116;
                    if ( v54 == 5 )
                      goto LABEL_96;
LABEL_104:
                    _libc_assert_fail(
                      (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                      (__int64)"../iconv/skeleton.c",
                      0x253u,
                      (__int64)"__gconv_transform_internal_ucs2");
                  }
                  continue;
                }
              }
              v36 = v41;
              *a3 -= 2 * (v82 - v97);
LABEL_47:
              if ( v36 )
              {
LABEL_66:
                if ( a8 )
                  v45 = v36 == 7;
                else
                  v45 = 0;
                if ( !v45 )
                  return v36;
                goto LABEL_109;
              }
            }
            v40 = *(_DWORD *)(a2 + 16);
            v18 = *(char **)a2;
            LOBYTE(v14) = v40;
            v33 = (unsigned int *)*a3;
            v32 = v96;
            if ( a6 )
              goto LABEL_31;
            v98 = (unsigned int *)*a3;
            v99 = v18;
            if ( (unsigned int *)a4 != v33 )
              goto LABEL_33;
            v34 = v18;
            v36 = 4;
          }
          v48 = *a6;
          *(_QWORD *)a2 = v34;
          *a6 = v48 + v96;
          if ( a8 )
            v49 = v36 == 7;
          else
            v49 = 0;
          if ( !v49 )
            return v36;
LABEL_109:
          v59 = a4 - *a3;
          if ( v59 > 4 )
            _libc_assert_fail(
              (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
              (__int64)"../iconv/skeleton.c",
              0x287u,
              (__int64)"__gconv_transform_internal_ucs2");
          if ( v59 )
          {
            *(_BYTE *)(*(_QWORD *)(a2 + 32) + 4LL) = *(_BYTE *)*a3;
            for ( i = 1LL; v59 != i; *(_BYTE *)(v61 + 4) = v62 )
            {
              v61 = *(_QWORD *)(a2 + 32) + i;
              v62 = *(_BYTE *)(*a3 + i++);
            }
            v91 = v59;
          }
          v63 = *(unsigned int **)(a2 + 32);
          v64 = *v63;
          *a3 = a4;
          *v63 = v64 & 0xFFFFFFF8 | v91;
          return v36;
        }
        if ( v98 != &v94 )
        {
LABEL_137:
          v30 = (char *)v70 - (char *)&v94;
          goto LABEL_28;
        }
      }
      return 5;
    }
    v79 = 467;
LABEL_174:
    _libc_assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      v79,
      (__int64)"__gconv_transform_internal_ucs2");
  }
  if ( a5 )
  {
    v79 = 350;
    goto LABEL_174;
  }
  **(_QWORD **)(a2 + 32) = 0LL;
  if ( (*(_DWORD *)(a2 + 16) & 1) != 0 )
    return 0;
  return v81(v88, v89, 0LL, 0LL, 0LL, a6, a7, a8);
}
// 425D80: using guessed type __int64 _gconv_transform_ucs2reverse_internal(void);
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000425D80) ----------------------------------------------------
__int64 __fastcall _gconv_transform_ucs2reverse_internal(
        __int64 a1,
        __int64 a2,
        unsigned __int8 **a3,
        unsigned __int8 *a4,
        char **a5,
        __int64 *a6,
        unsigned int a7,
        unsigned int a8)
{
  int v13; // w4
  char **v14; // x0
  unsigned __int64 v15; // x28
  char *v16; // x25
  __int64 *v17; // x0
  unsigned int *v18; // x7
  unsigned int v19; // w0
  int v20; // w2
  unsigned __int8 *v21; // x9
  unsigned __int8 *v22; // x6
  unsigned __int64 v23; // x3
  int v24; // w1
  unsigned __int8 *v25; // x21
  __int64 v26; // x22
  char *v27; // x19
  unsigned __int8 *v28; // x0
  unsigned __int8 *v29; // x3
  int v30; // w8
  unsigned int v32; // w0
  unsigned __int64 v33; // x1
  bool v34; // zf
  __int64 v35; // x0
  __int64 v36; // x2
  int v37; // w13
  char *v38; // x4
  unsigned __int8 *v39; // x7
  int v40; // w2
  unsigned __int64 v41; // x0
  unsigned __int8 *v42; // x9
  int *v43; // x7
  unsigned __int64 v44; // x2
  __int64 i; // x0
  __int64 v46; // x1
  unsigned __int8 v47; // w3
  unsigned int *v48; // x1
  unsigned int v49; // w0
  unsigned int v50; // w2
  unsigned int v51; // [xsp+64h] [xbp+64h]
  __int64 (__fastcall *v52)(__int64, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD); // [xsp+68h] [xbp+68h]
  __int64 v53; // [xsp+70h] [xbp+70h]
  __int64 v54; // [xsp+78h] [xbp+78h]
  __int64 *v55; // [xsp+80h] [xbp+80h]
  int v57; // [xsp+8Ch] [xbp+8Ch]
  __int64 v58; // [xsp+90h] [xbp+90h] BYREF
  char *v59; // [xsp+98h] [xbp+98h] BYREF

  v13 = *(_DWORD *)(a2 + 16);
  v52 = 0LL;
  v53 = a1 + 104;
  v54 = a2 + 48;
  v57 = a7;
  if ( (v13 & 1) == 0 )
  {
    v52 = *(__int64 (__fastcall **)(__int64, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD))(a1 + 144);
    if ( *(_QWORD *)(a1 + 104) )
      v52 = (__int64 (__fastcall *)(__int64, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD))(*(_QWORD *)(a1 + 144) ^ _pointer_chk_guard_local);
  }
  if ( a7 )
  {
    if ( !a5 )
    {
      **(_QWORD **)(a2 + 32) = 0LL;
      if ( (*(_DWORD *)(a2 + 16) & 1) != 0 )
        return 0;
      return v52(v53, v54, 0LL, 0LL, 0LL, a6, a7, a8);
    }
    v50 = 350;
LABEL_106:
    _libc_assert_fail(
      (__int64)"outbufstart == NULL",
      (__int64)"../iconv/skeleton.c",
      v50,
      (__int64)"__gconv_transform_ucs2reverse_internal");
  }
  if ( a5 )
    v14 = a5;
  else
    v14 = (char **)a2;
  v15 = *(_QWORD *)(a2 + 8);
  v16 = *v14;
  if ( a6 )
    v17 = &v58;
  else
    v17 = 0LL;
  v55 = v17;
  v58 = 0LL;
  if ( !a8 || (v18 = *(unsigned int **)(a2 + 32), v19 = *v18, (v20 = *v18 & 7) == 0) )
  {
    v25 = *a3;
    v26 = 0LL;
    goto LABEL_26;
  }
  if ( a5 )
  {
    v50 = 467;
    goto LABEL_106;
  }
  v21 = *a3;
  if ( (*v18 & 7) > 4 )
    _libc_assert_fail(
      (__int64)"(state->__count & 7) <= sizeof (state->__value)",
      (__int64)"../iconv/loop.c",
      0x137u,
      (__int64)"ucs2reverse_internal_loop_single");
  if ( v20 == 1 )
    v22 = v21 + 1;
  else
    v22 = *a3;
  v23 = 2LL;
  if ( v20 == 1 )
    v23 = 1LL;
  if ( a4 < v22 )
  {
    *a3 = a4;
    v41 = a4 - v21 + v23;
    if ( v41 > 4 )
      _libc_assert_fail(
        (__int64)"inlen_after <= sizeof (state->__value.__wchb)",
        (__int64)"../iconv/loop.c",
        0x154u,
        (__int64)"ucs2reverse_internal_loop_single");
    v42 = &v21[-v23];
    v43 = (int *)(v18 + 1);
    if ( v41 > v23 )
    {
      do
      {
        *((_BYTE *)v43 + v23) = v42[v23];
        ++v23;
      }
      while ( v41 != v23 );
    }
    return 7;
  }
  if ( v15 < (unsigned __int64)(v16 + 4) )
    return 5;
  v24 = (unsigned __int16)__rev16(*((unsigned __int8 *)v18 + 4) | (*v21 << 8));
  if ( (unsigned __int16)(v24 + 10240) <= 0x7FFu )
  {
    if ( !v55 || (v13 & 2) == 0 )
    {
      *(_DWORD *)(a2 + 16) = v13 | 0x40000000;
      return 6;
    }
    ++*v55;
  }
  else
  {
    *(_DWORD *)v16 = v24;
    v16 += 4;
    v19 = *v18;
    v20 = *v18 & 7;
  }
  if ( v20 > 1 )
    _libc_assert_fail(
      (__int64)"inptr - bytebuf > (state->__count & 7)",
      (__int64)"../iconv/loop.c",
      0x183u,
      (__int64)"ucs2reverse_internal_loop_single");
  v25 = &v21[-v20 + 2];
  *a3 = v25;
  *v18 = v19 & 0xFFFFFFF8;
  v26 = v58;
  v13 = *(_DWORD *)(a2 + 16);
LABEL_26:
  if ( a6 )
    v26 += *a6;
  if ( a4 == v25 )
  {
    v27 = v16;
LABEL_35:
    *a3 = a4;
    v51 = 4;
    if ( !a5 )
      goto LABEL_40;
    goto LABEL_36;
  }
LABEL_29:
  v27 = v16;
  v28 = v25;
  while ( 1 )
  {
    v29 = v28;
    v28 += 2;
    if ( a4 < v28 )
    {
      v51 = 7;
      goto LABEL_39;
    }
    if ( v15 < (unsigned __int64)(v27 + 4) )
    {
      v51 = 5;
      goto LABEL_39;
    }
    v30 = (unsigned __int16)__rev16(*((unsigned __int16 *)v28 - 1));
    if ( (unsigned __int16)(v30 + 10240) <= 0x7FFu )
      break;
    *(_DWORD *)v27 = v30;
    v27 += 4;
LABEL_34:
    if ( a4 == v28 )
      goto LABEL_35;
  }
  if ( v55 && (v13 & 2) != 0 )
  {
    ++*v55;
    goto LABEL_34;
  }
  v51 = 6;
  *(_DWORD *)(a2 + 16) |= 0x40000000u;
LABEL_39:
  *a3 = v29;
  if ( a5 )
  {
LABEL_36:
    *a5 = v27;
    return v51;
  }
LABEL_40:
  v13 = *(_DWORD *)(a2 + 16);
  while ( 1 )
  {
    ++*(_DWORD *)(a2 + 20);
    if ( (v13 & 1) != 0 )
    {
      v35 = *a6;
      *(_QWORD *)a2 = v27;
      *a6 = v35 + v58;
      goto LABEL_55;
    }
    if ( v27 <= v16 )
      goto LABEL_55;
    v59 = *(char **)a2;
    v32 = v52(v53, v54, &v59, v27, 0LL, a6, 0LL, a8);
    if ( v32 != 4 )
      break;
    if ( v51 != 5 )
      goto LABEL_55;
LABEL_46:
    v25 = *a3;
    v16 = *(char **)a2;
    v26 = v58;
    v13 = *(_DWORD *)(a2 + 16);
    if ( a6 )
      v26 = v58 + *a6;
    if ( a4 != v25 )
      goto LABEL_29;
    v27 = *(char **)a2;
    *a3 = v25;
    v51 = 4;
  }
  v33 = (unsigned __int64)v59;
  if ( v27 != v59 )
  {
    v36 = 0LL;
    if ( a6 )
      v36 = *a6;
    if ( v26 == v36 + v58 )
    {
      *a3 -= (v27 - v59) / 2;
    }
    else
    {
      if ( a4 == v25 )
      {
        v38 = v16;
        v39 = a4;
        goto LABEL_73;
      }
      v37 = *(_DWORD *)(a2 + 16);
      v38 = v16;
      while ( 1 )
      {
        v39 = v25;
        v25 += 2;
        if ( a4 < v25 )
          goto LABEL_73;
        if ( v33 < (unsigned __int64)(v38 + 4) )
          break;
        v40 = (unsigned __int16)__rev16(*((unsigned __int16 *)v25 - 1));
        if ( (unsigned __int16)(v40 + 10240) <= 0x7FFu )
        {
          if ( !v55 || (v37 & 2) == 0 )
          {
            *(_DWORD *)(a2 + 16) |= 0x40000000u;
            goto LABEL_73;
          }
          ++*v55;
        }
        else
        {
          *(_DWORD *)v38 = v40;
          v38 += 4;
        }
        if ( a4 == v25 )
        {
          v39 = a4;
LABEL_73:
          *a3 = v39;
          if ( (char *)v33 == v38 )
            _libc_assert_fail(
              (__int64)"nstatus == __GCONV_FULL_OUTPUT",
              (__int64)"../iconv/skeleton.c",
              0x253u,
              (__int64)"__gconv_transform_ucs2reverse_internal");
LABEL_111:
          _libc_assert_fail(
            (__int64)"outbuf == outerr",
            (__int64)"../iconv/skeleton.c",
            0x252u,
            (__int64)"__gconv_transform_ucs2reverse_internal");
        }
      }
      *a3 = v39;
      if ( (char *)v33 != v38 )
        goto LABEL_111;
      if ( (char *)v33 == v16 )
        --*(_DWORD *)(a2 + 20);
    }
  }
  if ( !v32 )
    goto LABEL_46;
  v51 = v32;
LABEL_55:
  if ( a8 )
    v34 = v51 == 7;
  else
    v34 = 0;
  if ( v34 )
  {
    v44 = a4 - *a3;
    if ( v44 > 4 )
      _libc_assert_fail(
        (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
        (__int64)"../iconv/skeleton.c",
        0x287u,
        (__int64)"__gconv_transform_ucs2reverse_internal");
    if ( v44 )
    {
      *(_BYTE *)(*(_QWORD *)(a2 + 32) + 4LL) = **a3;
      for ( i = 1LL; v44 != i; *(_BYTE *)(v46 + 4) = v47 )
      {
        v46 = *(_QWORD *)(a2 + 32) + i;
        v47 = (*a3)[i++];
      }
      v57 = v44;
    }
    v48 = *(unsigned int **)(a2 + 32);
    v49 = *v48;
    *a3 = a4;
    *v48 = v49 & 0xFFFFFFF8 | v57;
  }
  return v51;
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000426420) ----------------------------------------------------
__int64 __fastcall _gconv_transform_internal_ucs2reverse(
        _QWORD *a1,
        __int64 a2,
        __int64 *a3,
        unsigned __int64 a4,
        char **a5,
        __int64 *a6,
        unsigned int a7,
        unsigned int a8)
{
  int v13; // w8
  char **v14; // x0
  unsigned __int64 v15; // x26
  __int64 *v16; // x27
  char *v17; // x22
  unsigned int *v18; // x7
  int v19; // w0
  unsigned int *v20; // x2
  _DWORD *v21; // x18
  unsigned int *v22; // x1
  unsigned __int64 v23; // x21
  unsigned __int64 v24; // x3
  unsigned int *v25; // x0
  _BYTE *v26; // x4
  char v27; // w3
  bool v28; // cc
  __int64 v29; // x0
  unsigned int v30; // w1
  __int64 v31; // x13
  unsigned int *v32; // x21
  char *v33; // x3
  unsigned int *v34; // x0
  unsigned int v35; // w25
  unsigned int *v36; // x1
  char *v37; // x2
  unsigned int v38; // w0
  unsigned int v39; // w7
  unsigned __int64 v40; // x25
  int v42; // w0
  bool v43; // zf
  __int64 v44; // x1
  __int64 v45; // x0
  __int64 v46; // x0
  bool v47; // zf
  unsigned int v48; // w0
  __int64 v49; // x0
  int v50; // w18
  char *v51; // x2
  int v52; // w5
  char *v53; // x3
  unsigned int v54; // w0
  char *v55; // x0
  int v56; // w0
  unsigned __int64 v57; // x2
  __int64 i; // x0
  __int64 v59; // x1
  char v60; // w3
  unsigned int *v61; // x1
  unsigned int v62; // w0
  __int64 v63; // x0
  unsigned __int64 v64; // x1
  unsigned __int64 v65; // x3
  unsigned int *v66; // x0
  unsigned int *v67; // x0
  __int64 v68; // x0
  int v69; // w0
  char *v70; // x0
  unsigned int v71; // w0
  unsigned int *v72; // x13
  signed int v73; // w0
  unsigned __int64 v74; // x0
  __int64 v75; // x1
  unsigned int v76; // w2
  __int64 (__fastcall *v78)(_QWORD *, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD); // [xsp+68h] [xbp+68h]
  char *v79; // [xsp+70h] [xbp+70h]
  __int64 v80; // [xsp+70h] [xbp+70h]
  __int64 v81; // [xsp+78h] [xbp+78h]
  int v82; // [xsp+78h] [xbp+78h]
  unsigned int v83; // [xsp+78h] [xbp+78h]
  unsigned int *v84; // [xsp+78h] [xbp+78h]
  _QWORD *v85; // [xsp+80h] [xbp+80h]
  __int64 v86; // [xsp+88h] [xbp+88h]
  _DWORD *v88; // [xsp+98h] [xbp+98h]
  int v89; // [xsp+A8h] [xbp+A8h]
  char v90; // [xsp+ACh] [xbp+ACh]
  unsigned int v91; // [xsp+B8h] [xbp+B8h] BYREF
  _BYTE v92[4]; // [xsp+BCh] [xbp+BCh] BYREF
  __int64 v93; // [xsp+C0h] [xbp+C0h] BYREF
  char *v94; // [xsp+C8h] [xbp+C8h] BYREF
  unsigned int *v95; // [xsp+D0h] [xbp+D0h] BYREF
  char *v96; // [xsp+D8h] [xbp+D8h] BYREF

  v13 = *(_DWORD *)(a2 + 16);
  v78 = 0LL;
  v85 = a1 + 13;
  v86 = a2 + 48;
  v89 = a7;
  if ( (v13 & 1) == 0 )
  {
    v78 = (__int64 (__fastcall *)(_QWORD *, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD))a1[18];
    if ( a1[13] )
      v78 = (__int64 (__fastcall *)(_QWORD *, __int64, char **, char *, _QWORD, __int64 *, _QWORD, _QWORD))(a1[18] ^ _pointer_chk_guard_local);
  }
  if ( a7 )
  {
    if ( !a5 )
    {
      **(_QWORD **)(a2 + 32) = 0LL;
      if ( (*(_DWORD *)(a2 + 16) & 1) != 0 )
        return 0;
      return v78(v85, v86, 0LL, 0LL, 0LL, a6, a7, a8);
    }
    v76 = 350;
    goto LABEL_179;
  }
  if ( a5 )
    v14 = a5;
  else
    v14 = (char **)a2;
  v15 = *(_QWORD *)(a2 + 8);
  if ( a6 )
    v16 = &v93;
  else
    v16 = 0LL;
  v17 = *v14;
  v93 = 0LL;
  if ( a8 )
  {
    v18 = *(unsigned int **)(a2 + 32);
    v19 = *v18 & 7;
    if ( v19 )
    {
      if ( !a5 )
      {
        v20 = (unsigned int *)*a3;
        v95 = (unsigned int *)*a3;
        v96 = v17;
        if ( v19 > 4 )
          _libc_assert_fail(
            (__int64)"(state->__count & 7) <= sizeof (state->__value)",
            (__int64)"../iconv/loop.c",
            0x137u,
            (__int64)"internal_ucs2reverse_loop_single");
        v21 = v18 + 1;
        v22 = &v91;
        v23 = 0LL;
        do
        {
          v24 = v23;
          *(_BYTE *)v22 = *((_BYTE *)v21 + v23);
          v22 = (unsigned int *)((char *)v22 + 1);
          ++v23;
        }
        while ( v23 < (*v18 & 7) );
        if ( a4 < (unsigned __int64)v20 - v23 + 4 )
        {
          *a3 = a4;
          v64 = a4 - (_QWORD)v20 + v23;
          if ( v64 > 4 )
            _libc_assert_fail(
              (__int64)"inlen_after <= sizeof (state->__value.__wchb)",
              (__int64)"../iconv/loop.c",
              0x154u,
              (__int64)"internal_ucs2reverse_loop_single");
          if ( v23 < v64 )
          {
            v95 = (unsigned int *)((char *)v20 + 1);
            v65 = v24 + 2;
            *((_BYTE *)v18 + v23 + 4) = *(_BYTE *)v20;
            if ( v64 > v65 )
            {
              do
              {
                v66 = v95;
                v95 = (unsigned int *)((char *)v95 + 1);
                *((_BYTE *)v21 + v65++) = *(_BYTE *)v66;
              }
              while ( v64 != v65 );
            }
          }
          return 7;
        }
        if ( v15 >= (unsigned __int64)(v17 + 2) )
        {
          v25 = (unsigned int *)((char *)v20 + 1);
          do
          {
            ++v23;
            v95 = v25;
            v26 = &v92[v23 - 4];
            v27 = *((_BYTE *)v25 - 1);
            v28 = v23 != 4 && a4 > (unsigned __int64)v25;
            v25 = (unsigned int *)((char *)v25 + 1);
            *(v26 - 1) = v27;
          }
          while ( v28 );
          v95 = &v91;
          if ( v91 <= 0xFFFF )
          {
            if ( v91 - 55296 > 0x7FF )
            {
              *(_WORD *)v17 = __rev16(v91);
              v95 = (unsigned int *)v92;
              v96 = v17 + 2;
LABEL_27:
              v29 = 4LL;
LABEL_28:
              v30 = *v18;
              if ( v29 <= (*v18 & 7LL) )
                _libc_assert_fail(
                  (__int64)"inptr - bytebuf > (state->__count & 7)",
                  (__int64)"../iconv/loop.c",
                  0x183u,
                  (__int64)"internal_ucs2reverse_loop_single");
              v31 = v93;
              v32 = (unsigned int *)(*a3 + v29 - (v30 & 7));
              *a3 = (__int64)v32;
              v17 = v96;
              *v18 = v30 & 0xFFFFFFF8;
              v13 = *(_DWORD *)(a2 + 16);
              goto LABEL_30;
            }
            if ( v16 && (v13 & 2) != 0 )
            {
              v95 = (unsigned int *)v92;
              ++*v16;
              goto LABEL_27;
            }
            goto LABEL_142;
          }
          if ( v91 >> 7 == 7168 )
          {
            v95 = (unsigned int *)v92;
            goto LABEL_27;
          }
          if ( !v16 )
          {
LABEL_142:
            *(_DWORD *)(a2 + 16) = v13 | 0x40000000;
            return 6;
          }
          if ( (v13 & 8) == 0 )
          {
            *(_DWORD *)(a2 + 16) = v13 | 0x40000000;
            if ( (v13 & 2) != 0 )
            {
              ++*v16;
              v67 = (unsigned int *)v92;
              v95 = (unsigned int *)v92;
              goto LABEL_141;
            }
            return 6;
          }
          v84 = v18;
          v88 = v18 + 1;
          v90 = v13;
          v71 = _gconv_transliterate(a1, a2, (__int64)v20, &v95, (unsigned __int64)v26, &v96, v16);
          v18 = v84;
          v35 = v71;
          v43 = v71 == 6;
          v67 = v95;
          v72 = &v91;
          if ( v43 )
          {
            if ( (v90 & 2) == 0 )
            {
              if ( v95 != &v91 )
              {
                v29 = (char *)v95 - (char *)&v91;
                goto LABEL_28;
              }
              return 6;
            }
            v75 = *v16;
            v67 = ++v95;
            *v16 = v75 + 1;
            if ( v67 == &v91 )
              return 6;
          }
          else
          {
            if ( v35 != 5 )
            {
              if ( v95 != &v91 )
                goto LABEL_141;
              if ( v35 != 7 )
              {
                if ( v35 )
                  return v35;
                v32 = (unsigned int *)*a3;
                v31 = v93;
                v13 = *(_DWORD *)(a2 + 16);
                goto LABEL_30;
              }
              if ( v23 == 4 )
                _libc_assert_fail(
                  (__int64)"inend != &bytebuf[MAX_NEEDED_INPUT]",
                  (__int64)"../iconv/loop.c",
                  0x195u,
                  (__int64)"internal_ucs2reverse_loop_single");
              v73 = *v84 & 0xFFFFFFF8;
              *a3 += v23 - (*v84 & 7LL);
              if ( (__int64)v23 <= v73 )
                _libc_assert_fail(
                  (__int64)"inend - inptr > (state->__count & ~7)",
                  (__int64)"../iconv/loop.c",
                  0x19Fu,
                  (__int64)"internal_ucs2reverse_loop_single");
              if ( v23 > 4 )
                _libc_assert_fail(
                  (__int64)"inend - inptr <= sizeof (state->__value.__wchb)",
                  (__int64)"../iconv/loop.c",
                  0x1A0u,
                  (__int64)"internal_ucs2reverse_loop_single");
              *v84 = v73 | v23;
              v74 = 0LL;
              do
              {
                *((_BYTE *)v88 + v74) = *((_BYTE *)v72 + v74);
                ++v74;
                v72 = v95;
              }
              while ( v74 < &v92[v23 - 4] - (_BYTE *)v95 );
              return 7;
            }
            if ( v95 == &v91 )
              return 5;
          }
LABEL_141:
          v29 = (char *)v67 - (char *)&v91;
          goto LABEL_28;
        }
        return 5;
      }
      v76 = 467;
LABEL_179:
      _libc_assert_fail(
        (__int64)"outbufstart == NULL",
        (__int64)"../iconv/skeleton.c",
        v76,
        (__int64)"__gconv_transform_internal_ucs2reverse");
    }
  }
  v32 = (unsigned int *)*a3;
  v31 = 0LL;
LABEL_30:
  if ( a6 )
LABEL_31:
    v31 += *a6;
  v95 = v32;
  v96 = v17;
  if ( (unsigned int *)a4 == v32 )
  {
    v33 = v17;
    v34 = (unsigned int *)a4;
    v35 = 4;
    goto LABEL_41;
  }
LABEL_33:
  v33 = v17;
  v34 = v32;
  v35 = 4;
  while ( 1 )
  {
    v36 = v34 + 1;
    if ( a4 < (unsigned __int64)(v34 + 1) )
    {
      *a3 = (__int64)v95;
      v35 = 7;
      if ( !a5 )
        goto LABEL_42;
      goto LABEL_54;
    }
    v37 = v33 + 2;
    if ( v15 < (unsigned __int64)(v33 + 2) )
    {
      v34 = v95;
      v35 = 5;
      goto LABEL_41;
    }
    v38 = *v34;
    if ( v38 <= 0xFFFF )
    {
      if ( v38 - 55296 <= 0x7FF )
      {
        if ( !v16 || (v13 & 2) == 0 )
        {
          v35 = 6;
          v34 = v95;
          *(_DWORD *)(a2 + 16) |= 0x40000000u;
          goto LABEL_41;
        }
        v45 = *v16;
        v95 = v36;
        *v16 = v45 + 1;
      }
      else
      {
        *(_WORD *)v33 = __rev16(v38);
        v33 += 2;
        v95 = v36;
        v96 = v37;
      }
      goto LABEL_39;
    }
    if ( v38 >> 7 == 7168 )
    {
      v95 = v36;
LABEL_39:
      v34 = v36;
      goto LABEL_40;
    }
    v42 = *(_DWORD *)(a2 + 16);
    if ( !v16 )
      break;
    if ( (v42 & 8) != 0 )
    {
      v80 = v31;
      v82 = v13;
      v48 = _gconv_transliterate(a1, a2, *a3, &v95, a4, &v96, v16);
      v31 = v80;
      v35 = v48;
      v33 = v96;
      v13 = v82;
      if ( v48 != 6 )
      {
        v34 = v95;
        if ( v35 == 5 )
          goto LABEL_41;
        goto LABEL_40;
      }
    }
    else
    {
      *(_DWORD *)(a2 + 16) = v42 | 0x40000000;
    }
    v34 = v95;
    if ( (v13 & 2) == 0 )
    {
      v35 = 6;
      goto LABEL_41;
    }
    v44 = *v16;
    v34 = v95 + 1;
    v35 = 6;
    ++v95;
    *v16 = v44 + 1;
LABEL_40:
    if ( (unsigned int *)a4 == v34 )
      goto LABEL_41;
  }
  v35 = 6;
  *(_DWORD *)(a2 + 16) = v42 | 0x40000000;
  v34 = v95;
LABEL_41:
  *a3 = (__int64)v34;
  if ( a5 )
  {
LABEL_54:
    *a5 = v33;
    return v35;
  }
LABEL_42:
  v13 = *(_DWORD *)(a2 + 16);
  while ( 1 )
  {
    ++*(_DWORD *)(a2 + 20);
    if ( (v13 & 1) != 0 )
      break;
    if ( v17 >= v33 )
      goto LABEL_48;
    v94 = *(char **)a2;
    v79 = v33;
    v81 = v31;
    v39 = v78(v85, v86, &v94, v33, 0LL, a6, 0LL, a8);
    if ( v39 == 4 )
    {
      if ( v35 != 5 && v35 )
        goto LABEL_67;
    }
    else
    {
      v40 = (unsigned __int64)v94;
      if ( v94 == v79 )
        goto LABEL_47;
      v49 = 0LL;
      if ( a6 )
        v49 = *a6;
      if ( v49 + v93 != v81 )
      {
        v50 = *(_DWORD *)(a2 + 16);
        v51 = v17;
        *a3 = (__int64)v32;
        v95 = v32;
        v96 = v17;
        if ( (unsigned int *)a4 == v32 )
          goto LABEL_107;
        v52 = 4;
        while ( 1 )
        {
          if ( a4 < (unsigned __int64)(v32 + 1) )
            goto LABEL_106;
          v53 = v51 + 2;
          if ( v40 < (unsigned __int64)(v51 + 2) )
          {
            *a3 = (__int64)v95;
            if ( v94 != v51 )
              goto LABEL_120;
            goto LABEL_98;
          }
          v54 = *v32;
          if ( *v32 <= 0xFFFF )
            break;
          if ( v54 >> 7 == 7168 )
          {
            v95 = v32 + 1;
LABEL_94:
            ++v32;
            goto LABEL_95;
          }
          v56 = *(_DWORD *)(a2 + 16);
          if ( !v16 )
            goto LABEL_105;
          if ( (v56 & 8) == 0 )
          {
            *(_DWORD *)(a2 + 16) = v56 | 0x40000000;
LABEL_125:
            v32 = v95;
            if ( (v50 & 2) == 0 )
            {
              v40 = (unsigned __int64)v94;
              goto LABEL_107;
            }
            v68 = *v16;
            v32 = v95 + 1;
            v52 = 6;
            ++v95;
            *v16 = v68 + 1;
            goto LABEL_95;
          }
          v83 = v39;
          v69 = _gconv_transliterate(a1, a2, *a3, &v95, a4, &v96, v16);
          v51 = v96;
          v52 = v69;
          v39 = v83;
          if ( v69 == 6 )
            goto LABEL_125;
          v32 = v95;
          if ( v69 == 5 )
          {
            v70 = v94;
            *a3 = (__int64)v95;
            if ( v70 != v51 )
              goto LABEL_120;
LABEL_98:
            if ( v17 == v51 )
            {
              v35 = v39;
              --*(_DWORD *)(a2 + 20);
              goto LABEL_48;
            }
LABEL_47:
            v35 = v39;
            goto LABEL_48;
          }
LABEL_95:
          if ( (unsigned int *)a4 == v32 )
          {
            v55 = v94;
            *a3 = a4;
            if ( v55 != v51 )
              goto LABEL_120;
            if ( v52 != 5 )
              goto LABEL_108;
            goto LABEL_98;
          }
        }
        if ( v54 - 55296 <= 0x7FF )
        {
          if ( !v16 || (v50 & 2) == 0 )
          {
            v56 = *(_DWORD *)(a2 + 16);
LABEL_105:
            *(_DWORD *)(a2 + 16) = v56 | 0x40000000;
LABEL_106:
            v40 = (unsigned __int64)v94;
            v32 = v95;
LABEL_107:
            *a3 = (__int64)v32;
            if ( (char *)v40 == v51 )
LABEL_108:
              _libc_assert_fail(
                (__int64)"nstatus == __GCONV_FULL_OUTPUT",
                (__int64)"../iconv/skeleton.c",
                0x253u,
                (__int64)"__gconv_transform_internal_ucs2reverse");
LABEL_120:
            _libc_assert_fail(
              (__int64)"outbuf == outerr",
              (__int64)"../iconv/skeleton.c",
              0x252u,
              (__int64)"__gconv_transform_internal_ucs2reverse");
          }
          v63 = *v16;
          v95 = v32 + 1;
          *v16 = v63 + 1;
        }
        else
        {
          *(_WORD *)v51 = __rev16(v54);
          v51 += 2;
          v95 = v32 + 1;
          v96 = v53;
        }
        goto LABEL_94;
      }
      v35 = v39;
      *a3 -= 2 * (v79 - v94);
LABEL_48:
      if ( v35 )
      {
LABEL_67:
        if ( a8 )
          v43 = v35 == 7;
        else
          v43 = 0;
        if ( !v43 )
          return v35;
        goto LABEL_113;
      }
    }
    v17 = *(char **)a2;
    v32 = (unsigned int *)*a3;
    v31 = v93;
    v13 = *(_DWORD *)(a2 + 16);
    if ( a6 )
      goto LABEL_31;
    v95 = (unsigned int *)*a3;
    v96 = v17;
    if ( (unsigned int *)a4 != v32 )
      goto LABEL_33;
    v33 = v17;
    v35 = 4;
  }
  v46 = *a6;
  *(_QWORD *)a2 = v33;
  *a6 = v46 + v93;
  if ( a8 )
    v47 = v35 == 7;
  else
    v47 = 0;
  if ( !v47 )
    return v35;
LABEL_113:
  v57 = a4 - *a3;
  if ( v57 > 4 )
    _libc_assert_fail(
      (__int64)"cnt_after <= sizeof (data->__statep->__value.__wchb)",
      (__int64)"../iconv/skeleton.c",
      0x287u,
      (__int64)"__gconv_transform_internal_ucs2reverse");
  if ( v57 )
  {
    *(_BYTE *)(*(_QWORD *)(a2 + 32) + 4LL) = *(_BYTE *)*a3;
    for ( i = 1LL; v57 != i; *(_BYTE *)(v59 + 4) = v60 )
    {
      v59 = *(_QWORD *)(a2 + 32) + i;
      v60 = *(_BYTE *)(*a3 + i++);
    }
    v89 = v57;
  }
  v61 = *(unsigned int **)(a2 + 32);
  v62 = *v61;
  *a3 = a4;
  *v61 = v62 & 0xFFFFFFF8 | v89;
  return v35;
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000426EA0) ----------------------------------------------------
__int64 __fastcall _gconv_transliterate(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        unsigned int **a4,
        unsigned __int64 a5,
        _QWORD *a6,
        _QWORD *a7)
{
  _QWORD *v7; // x13
  _QWORD *v9; // x8
  unsigned int **v10; // x22
  unsigned __int64 v11; // x24
  unsigned __int64 v13; // x10
  unsigned int *v14; // x23
  unsigned __int64 StatusReg; // x1
  __int64 *v16; // x0
  __int64 v17; // x5
  __int64 v18; // x19
  _QWORD *v19; // x21
  unsigned int v20; // w25
  __int64 v22; // x24
  unsigned int v23; // w22
  unsigned int v24; // w28
  __int64 v25; // x3
  unsigned int v26; // w26
  unsigned int *v27; // x0
  int v28; // w1
  unsigned int v29; // w2
  unsigned int *v30; // x0
  __int64 *v31; // x0
  int v32; // w2
  int v33; // w0
  _DWORD *v34; // x3
  __int64 result; // x0
  unsigned int v36; // w20
  _DWORD *v37; // x2
  unsigned int v38; // w0
  _DWORD *v39; // x3
  __int64 v40; // x0
  unsigned int *v41; // x0
  unsigned int v42; // w3
  unsigned int *v43; // x4
  __int64 v44; // x0
  __int64 v45; // x0
  __int64 v46; // [xsp+60h] [xbp+60h]
  __int64 (__fastcall *v47)(_QWORD *, __int64, _DWORD **, _DWORD *, __int64 *, _QWORD, _QWORD, _QWORD); // [xsp+68h] [xbp+68h]
  _QWORD *v48; // [xsp+68h] [xbp+68h]
  __int64 v49; // [xsp+70h] [xbp+70h]
  _QWORD *v50; // [xsp+78h] [xbp+78h]
  __int64 v51; // [xsp+90h] [xbp+90h]
  __int64 v52; // [xsp+98h] [xbp+98h]
  unsigned __int64 v55; // [xsp+B8h] [xbp+B8h]
  _DWORD *v56; // [xsp+C0h] [xbp+C0h] BYREF
  __int64 v57; // [xsp+C8h] [xbp+C8h] BYREF

  v7 = a1;
  v9 = a7;
  v10 = a4;
  v11 = a5;
  v13 = a1[5];
  v14 = *a4;
  if ( *a1 )
    v13 ^= _pointer_chk_guard_local;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v16 = *(__int64 **)(StatusReg + 16);
  v17 = *v16;
  if ( !*(_DWORD *)(*v16 + 544) )
  {
    v32 = *(_DWORD *)(v17 + 600);
    if ( !v32 )
    {
LABEL_17:
      v33 = *(_DWORD *)(v17 + 584);
      if ( !v33 )
        goto LABEL_42;
      v34 = *(_DWORD **)(v17 + 592);
      v56 = v34;
      if ( v11 >= (unsigned __int64)(v14 + 1) )
        goto LABEL_53;
      if ( v14 == (unsigned int *)v11 )
        return 4LL;
      else
        return 7LL;
    }
    if ( a5 >= (unsigned __int64)(v14 + 1) )
      goto LABEL_38;
LABEL_22:
    result = 4LL;
    if ( v14 != (unsigned int *)a5 )
      return 7LL;
    return result;
  }
  if ( a5 < (unsigned __int64)(v14 + 1) )
    goto LABEL_22;
  v50 = v7;
  v47 = (__int64 (__fastcall *)(_QWORD *, __int64, _DWORD **, _DWORD *, __int64 *, _QWORD, _QWORD, _QWORD))v13;
  v49 = a2;
  v18 = *(_QWORD *)(v17 + 576);
  v19 = a6;
  v20 = *(_DWORD *)(*v16 + 544);
  v55 = StatusReg;
  v22 = *(_QWORD *)(v17 + 560);
  v51 = *(_QWORD *)(v17 + 552);
  v23 = 0;
  v52 = *(_QWORD *)(v17 + 568);
  while ( 1 )
  {
    v24 = 0;
    v25 = (v23 + v20) >> 1;
    v26 = *(_DWORD *)(v51 + 4 * v25);
    v27 = v14;
    v28 = *(_DWORD *)(v22 + 4LL * v26);
    while ( *v27 == v28 )
    {
      v29 = ++v24 + v26;
      v28 = *(_DWORD *)(v22 + 4LL * (v24 + v26));
      if ( v28 )
      {
        if ( a5 > (unsigned __int64)++v27 )
          continue;
      }
      goto LABEL_27;
    }
    if ( v24 )
      break;
LABEL_11:
    v30 = &v14[v24];
LABEL_12:
    if ( a5 <= (unsigned __int64)v30 || *(_DWORD *)(v22 + 4LL * (v24 + v26)) < *v30 )
      v23 = ((v23 + v20) >> 1) + 1;
    else
      v20 = (v23 + v20) >> 1;
    if ( v23 >= v20 )
    {
      a6 = v19;
      v7 = v50;
      v11 = a5;
      v13 = (unsigned __int64)v47;
      a2 = v49;
      v31 = *(__int64 **)(v55 + 16);
      v10 = a4;
      v9 = a7;
      v17 = *v31;
      v32 = *(_DWORD *)(*v31 + 600);
      if ( !v32 )
        goto LABEL_17;
LABEL_38:
      if ( v32 > 0 )
      {
        v41 = *(unsigned int **)(v17 + 608);
        v42 = **v10;
        v43 = &v41[3 * v32];
        while ( *v41 <= v42 )
        {
          if ( v41[1] >= v42 && !((v42 - *v41) % v41[2]) )
          {
            v45 = *v9;
            ++*v10;
            *v9 = v45 + 1;
            return 0LL;
          }
          v41 += 3;
          if ( v43 == v41 )
            break;
        }
      }
      v33 = *(_DWORD *)(v17 + 584);
      if ( !v33 )
      {
LABEL_42:
        *(_DWORD *)(a2 + 16) |= 0x40000000u;
        return 6LL;
      }
      v34 = *(_DWORD **)(v17 + 592);
      v56 = v34;
LABEL_53:
      v46 = a2;
      v48 = v9;
      v57 = *a6;
      result = ((__int64 (__fastcall *)(_QWORD *, __int64, _DWORD **, _DWORD *, __int64 *, _QWORD, _QWORD, _QWORD))v13)(
                 v7,
                 a2,
                 &v56,
                 &v34[v33],
                 &v57,
                 0LL,
                 0LL,
                 0LL);
      a2 = v46;
      if ( (_DWORD)result == 6 )
        goto LABEL_42;
      if ( (_DWORD)result == 4 )
      {
        ++*v48;
        ++*v10;
        result = 0LL;
      }
LABEL_45:
      *a6 = v57;
      return result;
    }
  }
  v29 = v24 + v26;
LABEL_27:
  if ( *(_DWORD *)(v22 + 4LL * v29) )
  {
    v30 = &v14[v24];
    if ( v30 == (unsigned int *)a5 )
      return 7LL;
    goto LABEL_12;
  }
  v36 = *(_DWORD *)(v52 + 4 * v25);
  v37 = (_DWORD *)(v18 + 4LL * v36);
  if ( !*v37 )
  {
    v39 = (_DWORD *)(v18 + 4LL * v36);
    goto LABEL_33;
  }
  while ( 1 )
  {
    v38 = v36 + 1;
    do
    {
      v36 = v38;
      v39 = (_DWORD *)(v18 + 4LL * v38++);
    }
    while ( *v39 );
LABEL_33:
    v40 = *v19;
    v56 = v37;
    v57 = v40;
    result = v47(v50, v49, &v56, v39, &v57, 0LL, 0LL, 0LL);
    if ( (_DWORD)result != 6 )
      break;
    v37 = (_DWORD *)(v18 + 4LL * ++v36);
    if ( !*v37 )
      goto LABEL_11;
  }
  a6 = v19;
  if ( (_DWORD)result == 4 )
  {
    v44 = *a7;
    *a4 += v24;
    *a7 = v44 + 1;
    result = 0LL;
    goto LABEL_45;
  }
  if ( (_DWORD)result != 5 )
    goto LABEL_45;
  return result;
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (00000000004272C0) ----------------------------------------------------
unsigned __int64 __fastcall find_module_idx(unsigned __int8 *a1, _QWORD *a2)
{
  __int64 v4; // x21
  unsigned int v5; // w25
  __int64 v6; // x22
  unsigned int v7; // w0
  unsigned int v8; // w20
  __int64 v9; // x27
  unsigned int v10; // w19
  unsigned int v11; // w26
  unsigned int v12; // w28
  unsigned __int64 result; // x0
  unsigned __int16 *v14; // x25

  v4 = gconv_cache;
  v5 = *(unsigned __int16 *)(gconv_cache + 6);
  v6 = *(unsigned __int16 *)(gconv_cache + 4);
  v7 = _hash_string(a1);
  v8 = *(unsigned __int16 *)(v4 + 8);
  v9 = v5;
  v10 = v7 % v8;
  v11 = v7 % (v8 - 2) + 1;
  v12 = cache_size - *(unsigned __int16 *)(v4 + 4);
  while ( 1 )
  {
    v14 = (unsigned __int16 *)(v4 + v9 + 4LL * v10);
    if ( !*v14 )
      return 0xFFFFFFFFLL;
    if ( *v14 < v12 )
    {
      result = strcmp((unsigned __int64 *)a1, v4 + v6 + *v14);
      if ( !(_DWORD)result )
        break;
    }
    v10 += v11;
    if ( v8 <= v10 )
      v10 -= v8;
  }
  *a2 = v14[1];
  return result;
}
// 496D58: using guessed type __int64 gconv_cache;
// 496D60: using guessed type __int64 cache_size;

//----- (00000000004273AC) ----------------------------------------------------
__int64 __fastcall find_module_constprop_0(__int64 a1, __int64 a2, _QWORD *a3)
{
  _QWORD *shlib; // x0
  __int64 v5; // x1
  __int64 v6; // x1
  __int64 result; // x0
  __int64 (__fastcall *v8)(_QWORD *); // x1
  __int64 v9; // [xsp+0h] [xbp+0h] BYREF

  strlen();
  strlen();
  j_memcpy();
  j_memcpy();
  shlib = (_QWORD *)_gconv_find_shlib((__int64)&v9);
  *a3 = shlib;
  if ( !shlib )
    return 1LL;
  v5 = shlib[3];
  a3[1] = 0LL;
  a3[5] = v5;
  v6 = shlib[4];
  a3[8] = shlib[5];
  a3[6] = 0LL;
  a3[7] = v6;
  result = 0LL;
  a3[12] = 0LL;
  v8 = (__int64 (__fastcall *)(_QWORD *))(v6 ^ _pointer_chk_guard_local);
  if ( v8 )
  {
    result = v8(a3);
    a3[6] ^= _pointer_chk_guard_local;
  }
  return result;
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (00000000004274A0) ----------------------------------------------------
__int64 _gconv_get_cache()
{
  return gconv_cache;
}
// 496D58: using guessed type __int64 gconv_cache;

//----- (00000000004274AC) ----------------------------------------------------
__int64 _gconv_load_cache()
{
  int v0; // w0
  int v1; // w20
  __int64 v2; // x1
  void *v3; // x3
  void *v4; // x4
  void *v5; // x5
  void *v6; // x6
  __int64 v7; // x7
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  unsigned __int64 v24; // x3
  __int64 result; // x0
  unsigned __int64 v26; // x0
  __int64 v27; // x2
  unsigned __int64 v28; // x22
  __int64 v29; // x0
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  __int64 v38; // [xsp+38h] [xbp+38h]
  char v39; // [xsp+40h] [xbp+40h] BYREF
  size_t v40; // [xsp+70h] [xbp+70h]

  _gconv_path_envvar = (__int64)getenv("GCONV_PATH");
  if ( _gconv_path_envvar )
    return 0xFFFFFFFFLL;
  v0 = _open_nocancel("/lib/gconv/gconv-modules.cache", 0x80000);
  v1 = v0;
  if ( v0 == -1 )
    return 0xFFFFFFFFLL;
  if ( (fstat64(v0, (struct stat *)&v39) & 0x80000000) != 0 || v40 <= 0xF )
    goto LABEL_24;
  cache_size = v40;
  gconv_cache = mmap64(0LL, v40, 1, 1, v1, 0LL);
  if ( gconv_cache != -1 )
    goto LABEL_6;
  v38 = cache_size;
  v26 = malloc(cache_size, v2, cache_size, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
  gconv_cache = v26;
  if ( !v26 )
  {
LABEL_24:
    _close_nocancel(v1);
    return 0xFFFFFFFFLL;
  }
  v27 = v38;
  v28 = 0LL;
  while ( 1 )
  {
    v29 = read(v1, (void *)(v26 + v28), (void *)(v27 - v28));
    if ( v29 == -1 )
    {
      free(gconv_cache, v30, v31, v32, v33, v34, v35, v36, v37);
      gconv_cache = 0LL;
      goto LABEL_24;
    }
    v27 = cache_size;
    v28 += v29;
    if ( cache_size <= v28 )
      break;
    v26 = gconv_cache;
  }
  cache_malloced = 1;
LABEL_6:
  _close_nocancel(v1);
  if ( *(_DWORD *)gconv_cache != 536937252
    || *(unsigned __int16 *)(gconv_cache + 4) >= (unsigned __int64)cache_size
    || (v24 = *(unsigned __int16 *)(gconv_cache + 6), cache_size <= v24)
    || !*(_WORD *)(gconv_cache + 8)
    || cache_size < v24 + 4LL * *(unsigned __int16 *)(gconv_cache + 8)
    || cache_size <= (unsigned __int64)*(unsigned __int16 *)(gconv_cache + 10)
    || (result = 0LL, cache_size < (unsigned __int64)*(unsigned __int16 *)(gconv_cache + 12)) )
  {
    if ( cache_malloced )
    {
      free(gconv_cache, v16, v17, v18, v19, v20, v21, v22, v23);
      cache_malloced = 0;
    }
    else
    {
      munmap((void *)gconv_cache, cache_size);
    }
    gconv_cache = 0LL;
    return 0xFFFFFFFFLL;
  }
  return result;
}
// 4275F0: variable 'v16' is possibly undefined
// 4275F0: variable 'v17' is possibly undefined
// 4275F0: variable 'v18' is possibly undefined
// 4275F0: variable 'v19' is possibly undefined
// 4275F0: variable 'v20' is possibly undefined
// 4275F0: variable 'v21' is possibly undefined
// 4275F0: variable 'v22' is possibly undefined
// 4275F0: variable 'v23' is possibly undefined
// 427608: variable 'v2' is possibly undefined
// 427608: variable 'v3' is possibly undefined
// 427608: variable 'v4' is possibly undefined
// 427608: variable 'v5' is possibly undefined
// 427608: variable 'v6' is possibly undefined
// 427608: variable 'v7' is possibly undefined
// 427608: variable 'v8' is possibly undefined
// 427608: variable 'v9' is possibly undefined
// 427608: variable 'v10' is possibly undefined
// 427608: variable 'v11' is possibly undefined
// 427608: variable 'v12' is possibly undefined
// 427608: variable 'v13' is possibly undefined
// 427608: variable 'v14' is possibly undefined
// 427608: variable 'v15' is possibly undefined
// 427650: variable 'v30' is possibly undefined
// 427650: variable 'v31' is possibly undefined
// 427650: variable 'v32' is possibly undefined
// 427650: variable 'v33' is possibly undefined
// 427650: variable 'v34' is possibly undefined
// 427650: variable 'v35' is possibly undefined
// 427650: variable 'v36' is possibly undefined
// 427650: variable 'v37' is possibly undefined
// 496D40: using guessed type __int64 _gconv_path_envvar;
// 496D58: using guessed type __int64 gconv_cache;
// 496D60: using guessed type __int64 cache_size;
// 496D68: using guessed type int cache_malloced;

//----- (0000000000427688) ----------------------------------------------------
__int64 __fastcall _gconv_compare_alias_cache(unsigned __int64 *a1, unsigned __int8 *a2, _DWORD *a3)
{
  __int64 v7; // [xsp+30h] [xbp+30h] BYREF
  __int64 v8; // [xsp+38h] [xbp+38h] BYREF

  if ( !gconv_cache )
    return 0xFFFFFFFFLL;
  if ( (unsigned int)find_module_idx((unsigned __int8 *)a1, &v7) || (unsigned int)find_module_idx(a2, &v8) )
  {
    *a3 = strcmp(a1, (unsigned __int64)a2);
    return 0LL;
  }
  else
  {
    *a3 = v7 - v8;
    return 0LL;
  }
}
// 496D58: using guessed type __int64 gconv_cache;

//----- (0000000000427720) ----------------------------------------------------
__int64 __fastcall _gconv_lookup_cache(
        unsigned __int8 *a1,
        unsigned __int8 *a2,
        unsigned __int64 *a3,
        __int64 *a4,
        unsigned __int8 a5)
{
  __int64 v5; // x19
  unsigned int v9; // w25
  unsigned int v11; // w26
  unsigned int v12; // w3
  unsigned int module_idx; // w0
  __int64 v15; // x2
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  unsigned __int64 v24; // x3
  void *v25; // x4
  __int64 v26; // x1
  __int64 v27; // x7
  char *v28; // x6
  __int64 v29; // x24
  unsigned __int16 *v30; // x22
  __int64 v31; // x25
  _WORD *v32; // x5
  unsigned __int64 v33; // x0
  unsigned __int64 v34; // x19
  __int64 v35; // x0
  __int64 v36; // x2
  __int64 v37; // x1
  unsigned __int64 *v38; // x0
  unsigned int v39; // w0
  double v40; // d0
  double v41; // d1
  double v42; // d2
  double v43; // d3
  double v44; // d4
  double v45; // d5
  double v46; // d6
  double v47; // d7
  __int64 v48; // x7
  void *v49; // x4
  _BYTE *v50; // x6
  __int64 v51; // x5
  unsigned __int64 v52; // x0
  __int64 v53; // x4
  __int64 v54; // x1
  _BYTE *v55; // x0
  __int64 v56; // x2
  unsigned __int64 *v57; // x0
  unsigned int v58; // w21
  double v59; // d0
  double v60; // d1
  double v61; // d2
  double v62; // d3
  double v63; // d4
  double v64; // d5
  double v65; // d6
  double v66; // d7
  _WORD *v67; // x19
  unsigned int i; // w0
  unsigned __int64 v69; // x0
  unsigned __int64 v70; // x26
  void *v71; // x4
  char *v72; // x6
  _WORD *v73; // x5
  __int64 v74; // x7
  __int64 v75; // x2
  unsigned __int16 *v76; // x10
  int v77; // w21
  char *v78; // x9
  int module_constprop_0; // w0
  double v80; // d0
  double v81; // d1
  double v82; // d2
  double v83; // d3
  double v84; // d4
  double v85; // d5
  double v86; // d6
  double v87; // d7
  unsigned __int16 *v88; // x10
  __int64 v89; // x2
  unsigned int v90; // w0
  __int64 v91; // x11
  __int64 v92; // x1
  __int64 v93; // x9
  unsigned __int64 *v94; // x0
  char *v95; // x9
  void *v96; // [xsp+60h] [xbp+60h]
  void *v97; // [xsp+60h] [xbp+60h]
  unsigned int v98; // [xsp+60h] [xbp+60h]
  void *v99; // [xsp+60h] [xbp+60h]
  __int64 v100; // [xsp+60h] [xbp+60h]
  __int64 v101; // [xsp+60h] [xbp+60h]
  unsigned int v102; // [xsp+60h] [xbp+60h]
  char *v103; // [xsp+68h] [xbp+68h]
  __int64 v104; // [xsp+68h] [xbp+68h]
  int v105; // [xsp+68h] [xbp+68h]
  char *v106; // [xsp+68h] [xbp+68h]
  void *v107; // [xsp+68h] [xbp+68h]
  __int64 v108; // [xsp+70h] [xbp+70h]
  __int64 v109; // [xsp+70h] [xbp+70h]
  __int64 v110; // [xsp+70h] [xbp+70h]
  char *v111; // [xsp+70h] [xbp+70h]
  _WORD *v112; // [xsp+78h] [xbp+78h]
  unsigned int v113; // [xsp+78h] [xbp+78h]
  _WORD *v114; // [xsp+78h] [xbp+78h]
  char *v115; // [xsp+78h] [xbp+78h]
  unsigned int v116; // [xsp+80h] [xbp+80h]
  unsigned int v117; // [xsp+80h] [xbp+80h]
  __int64 v118; // [xsp+80h] [xbp+80h]
  _WORD *v119; // [xsp+88h] [xbp+88h]
  unsigned __int16 *v120; // [xsp+90h] [xbp+90h]
  unsigned int v121; // [xsp+9Ch] [xbp+9Ch]
  void *v122; // [xsp+A0h] [xbp+A0h] BYREF
  void *v123; // [xsp+A8h] [xbp+A8h] BYREF

  v5 = gconv_cache;
  if ( gconv_cache )
  {
    v9 = *(unsigned __int16 *)(gconv_cache + 4);
    v11 = *(unsigned __int16 *)(gconv_cache + 10);
    if ( !(unsigned int)find_module_idx(a2, &v122)
      && (unsigned __int64)*(unsigned __int16 *)(v5 + 10) + 12LL * ((_QWORD)v122 + 1) <= cache_size )
    {
      v96 = v122;
      module_idx = find_module_idx(a1, &v123);
      v24 = module_idx;
      if ( !module_idx )
      {
        v25 = v123;
        v26 = cache_size;
        if ( (unsigned __int64)*(unsigned __int16 *)(v5 + 10) + 12LL * ((_QWORD)v123 + 1) <= cache_size )
        {
          if ( (a5 & (v96 == v123)) != 0 )
            return (unsigned int)-1;
          v27 = v5 + v11;
          v28 = (char *)(v5 + v9);
          v29 = 12LL * (_QWORD)v123;
          v30 = (unsigned __int16 *)(v27 + 12LL * (_QWORD)v123);
          if ( v96 )
          {
            v31 = 12LL * (_QWORD)v96;
            v32 = (_WORD *)(v27 + 12LL * (_QWORD)v96);
            if ( !v123 )
            {
              if ( !v32[2] )
                return 1;
              goto LABEL_12;
            }
            if ( v32[5] )
            {
              v26 = gconv_cache;
              v67 = (_WORD *)(gconv_cache + *(unsigned __int16 *)(v5 + 12) - 1LL + (unsigned __int16)v32[5]);
              for ( i = (unsigned __int16)*v67; *v67; i = (unsigned __int16)*v67 )
              {
                v15 = 2LL * (int)(i - 1);
                v26 = (unsigned __int16)v67[3 * (i - 1) + 1];
                if ( v123 == (void *)v26 )
                {
                  *a4 = i;
                  v99 = v25;
                  v106 = v28;
                  v110 = v27;
                  v114 = v32;
                  v117 = v24;
                  v69 = malloc(
                          104LL * i,
                          104LL,
                          v15,
                          (void *)v24,
                          v25,
                          v32,
                          v28,
                          v27,
                          v16,
                          v17,
                          v18,
                          v19,
                          v20,
                          v21,
                          v22,
                          v23);
                  v70 = v69;
                  v71 = v99;
                  v72 = v106;
                  v74 = v110;
                  v73 = v114;
                  *a3 = v69;
                  v12 = v117;
                  if ( !v69 )
                    return 3;
                  v75 = v69;
                  v76 = v67 + 1;
                  v77 = 0;
                  v78 = &v106[*(unsigned __int16 *)(v110 + v31)];
                  while ( 1 )
                  {
                    v90 = *v76;
                    v91 = v76[1];
                    v121 = v12;
                    v92 = v76[2];
                    *(_QWORD *)(v75 + 24) = v78;
                    v93 = *(unsigned __int16 *)(v74 + 12LL * v90);
                    *(_DWORD *)(v75 + 16) = 1;
                    v94 = (unsigned __int64 *)&v72[v92];
                    v95 = &v72[v93];
                    *(_QWORD *)(v75 + 32) = v95;
                    *(_QWORD *)(v75 + 96) = 0LL;
                    v107 = v71;
                    v111 = v95;
                    v115 = v72;
                    v118 = v74;
                    v119 = v73;
                    v120 = v76;
                    if ( v72[v91] )
                    {
                      v100 = v75;
                      module_constprop_0 = find_module_constprop_0((__int64)&v72[v91], (__int64)v94, (_QWORD *)v75);
                      v88 = v120;
                      v89 = v100;
                      v71 = v107;
                      v78 = v111;
                      v72 = v115;
                      v74 = v118;
                      v73 = v119;
                      v12 = v121;
                      if ( module_constprop_0 )
                      {
                        free(v70, v80, v81, v82, v83, v84, v85, v86, v87);
                        v27 = v118;
                        v32 = v119;
                        v25 = v107;
                        v28 = v115;
                        v24 = v121;
                        if ( !v119[2] )
                          return 1;
LABEL_27:
                        if ( !v30[4] )
                          return 1;
LABEL_12:
                        v97 = v25;
                        v103 = v28;
                        v108 = v27;
                        v112 = v32;
                        v116 = v24;
                        v33 = malloc(
                                208LL,
                                v26,
                                v15,
                                (void *)v24,
                                v25,
                                v32,
                                v28,
                                v27,
                                v16,
                                v17,
                                v18,
                                v19,
                                v20,
                                v21,
                                v22,
                                v23);
                        v34 = v33;
                        if ( v33 )
                        {
                          *a3 = v33;
                          v35 = *(unsigned __int16 *)(v108 + v31);
                          *a4 = 0LL;
                          *(_QWORD *)(v34 + 24) = &v103[v35];
                          *(_QWORD *)(v34 + 32) = "INTERNAL";
                          *(_QWORD *)(v34 + 96) = 0LL;
                          v36 = (unsigned __int16)v112[3];
                          v37 = (unsigned __int16)v112[4];
                          *(_DWORD *)(v34 + 16) = 1;
                          v38 = (unsigned __int64 *)&v103[v37];
                          if ( v103[v36] )
                          {
                            v39 = find_module_constprop_0((__int64)&v103[v36], (__int64)v38, (_QWORD *)v34);
                            v48 = v108;
                            v49 = v97;
                            v50 = v103;
                            v12 = v116;
                            if ( !v39 )
                              goto LABEL_15;
                            v102 = v39;
                            free(v34, v40, v41, v42, v43, v44, v45, v46, v47);
                            return v102;
                          }
                          _gconv_get_builtin_trans(v38, v34);
                          v48 = v108;
                          v49 = v97;
                          v50 = v103;
                          v12 = v116;
LABEL_15:
                          v51 = *a4 + 1;
                          *a4 = v51;
                          if ( !v49 )
                            return v12;
LABEL_22:
                          v53 = v30[1];
                          v54 = v34 + 104LL * (int)v51;
                          v55 = &v50[*(unsigned __int16 *)(v48 + v29)];
                          v56 = v30[2];
                          *(_QWORD *)(v54 + 24) = "INTERNAL";
                          *(_QWORD *)(v54 + 32) = v55;
                          *(_DWORD *)(v54 + 16) = 1;
                          v57 = (unsigned __int64 *)&v50[v56];
                          *(_QWORD *)(v54 + 96) = 0LL;
                          v98 = v12;
                          if ( v50[v53] )
                          {
                            v105 = v51;
                            v58 = find_module_constprop_0(
                                    (__int64)&v50[v53],
                                    (__int64)v57,
                                    (_QWORD *)(v34 + 104LL * (int)v51));
                            v12 = v98;
                            if ( v58 )
                            {
                              if ( v105 )
                                _gconv_release_step(v34);
                              free(v34, v59, v60, v61, v62, v63, v64, v65, v66);
                              return v58;
                            }
                          }
                          else
                          {
                            _gconv_get_builtin_trans(v57, v54);
                            v12 = v98;
                          }
                          ++*a4;
                          return v12;
                        }
                        return 3;
                      }
                    }
                    else
                    {
                      v101 = v75;
                      _gconv_get_builtin_trans(v94, v75);
                      v88 = v120;
                      v89 = v101;
                      v71 = v107;
                      v78 = v111;
                      v72 = v115;
                      v74 = v118;
                      v73 = v119;
                      v12 = v121;
                    }
                    ++v77;
                    v75 = v89 + 104;
                    v76 = v88 + 3;
                    if ( (unsigned __int16)*v67 <= v77 )
                      return v12;
                  }
                }
                v67 += 3 * i + 1;
              }
            }
            if ( !v32[2] )
              return 1;
            goto LABEL_27;
          }
          if ( v123 && v30[4] )
          {
            v104 = v5 + v9;
            v109 = v5 + v11;
            v113 = module_idx;
            v52 = malloc(
                    208LL,
                    cache_size,
                    v15,
                    (void *)module_idx,
                    v123,
                    0LL,
                    v28,
                    v27,
                    v16,
                    v17,
                    v18,
                    v19,
                    v20,
                    v21,
                    v22,
                    v23);
            v34 = v52;
            if ( v52 )
            {
              v48 = v109;
              v12 = v113;
              LODWORD(v51) = 0;
              v50 = (_BYTE *)v104;
              *a3 = v52;
              *a4 = 0LL;
              goto LABEL_22;
            }
            return 3;
          }
        }
      }
    }
    return 1;
  }
  return 2LL;
}
// 42784C: variable 'v26' is possibly undefined
// 42784C: variable 'v15' is possibly undefined
// 42784C: variable 'v16' is possibly undefined
// 42784C: variable 'v17' is possibly undefined
// 42784C: variable 'v18' is possibly undefined
// 42784C: variable 'v19' is possibly undefined
// 42784C: variable 'v20' is possibly undefined
// 42784C: variable 'v21' is possibly undefined
// 42784C: variable 'v22' is possibly undefined
// 42784C: variable 'v23' is possibly undefined
// 427B68: variable 'v40' is possibly undefined
// 427B68: variable 'v41' is possibly undefined
// 427B68: variable 'v42' is possibly undefined
// 427B68: variable 'v43' is possibly undefined
// 427B68: variable 'v44' is possibly undefined
// 427B68: variable 'v45' is possibly undefined
// 427B68: variable 'v46' is possibly undefined
// 427B68: variable 'v47' is possibly undefined
// 427B88: variable 'v59' is possibly undefined
// 427B88: variable 'v60' is possibly undefined
// 427B88: variable 'v61' is possibly undefined
// 427B88: variable 'v62' is possibly undefined
// 427B88: variable 'v63' is possibly undefined
// 427B88: variable 'v64' is possibly undefined
// 427B88: variable 'v65' is possibly undefined
// 427B88: variable 'v66' is possibly undefined
// 427BBC: variable 'v80' is possibly undefined
// 427BBC: variable 'v81' is possibly undefined
// 427BBC: variable 'v82' is possibly undefined
// 427BBC: variable 'v83' is possibly undefined
// 427BBC: variable 'v84' is possibly undefined
// 427BBC: variable 'v85' is possibly undefined
// 427BBC: variable 'v86' is possibly undefined
// 427BBC: variable 'v87' is possibly undefined
// 496D58: using guessed type __int64 gconv_cache;
// 496D60: using guessed type __int64 cache_size;

//----- (0000000000427C00) ----------------------------------------------------
void __fastcall _gconv_release_cache(
        unsigned __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  if ( gconv_cache )
    free(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}
// 496D58: using guessed type __int64 gconv_cache;

//----- (0000000000427C20) ----------------------------------------------------
void __fastcall _gconv_cache_freemem(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  if ( cache_malloced )
  {
    free(gconv_cache, a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else if ( gconv_cache )
  {
    munmap((void *)gconv_cache, cache_size);
  }
}
// 496D58: using guessed type __int64 gconv_cache;
// 496D60: using guessed type __int64 cache_size;
// 496D68: using guessed type int cache_malloced;

//----- (0000000000427C60) ----------------------------------------------------
unsigned __int64 __fastcall known_compare(unsigned __int64 **a1, unsigned __int64 *a2)
{
  return strcmp(*a1, *a2);
}

//----- (0000000000427C6C) ----------------------------------------------------
__int64 __fastcall do_release_shlib(
        __int64 result,
        int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  bool v8; // zf
  __int64 v9; // x1
  __int64 v10; // x2
  __int64 v11; // [xsp+18h] [xbp-8h]

  if ( a2 )
    v8 = a2 == 3;
  else
    v8 = 1;
  if ( v8 )
  {
    v9 = *(_QWORD *)result;
    result = *(unsigned int *)(*(_QWORD *)result + 8LL);
    if ( a3 == v9 )
    {
      if ( (int)result <= 0 )
        _libc_assert_fail((__int64)"obj->counter > 0", (__int64)"gconv_dl.c", 0xA2u, (__int64)"do_release_shlib");
      result = (unsigned int)(result - 1);
      *(_DWORD *)(a3 + 8) = result;
    }
    else
    {
      v10 = (unsigned int)(result + 2);
      if ( (_DWORD)v10 == 2 || (unsigned int)result >= 0xFFFFFFFE )
      {
        result = (unsigned int)(result - 1);
        *(_DWORD *)(v9 + 8) = result;
        if ( (_DWORD)result == -3 )
        {
          result = *(_QWORD *)(v9 + 16);
          if ( result )
          {
            v11 = v9;
            result = _libc_dlclose(result, v9, v10, a4, a5, a6, a7, a8);
            *(_QWORD *)(v11 + 16) = 0LL;
          }
        }
      }
    }
  }
  return result;
}
// 427D0C: using guessed type __int64 do_release_all(void);

//----- (0000000000427D0C) ----------------------------------------------------
void __fastcall do_release_all(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  __int64 v17; // x0
  unsigned __int64 v18; // x0
  unsigned __int64 v19; // [xsp+18h] [xbp+18h]

  v17 = *(_QWORD *)(a1 + 16);
  if ( v17 )
  {
    v19 = a1;
    _libc_dlclose(v17, a1, a11, a12, a13, a14, a15, a16);
    v18 = v19;
  }
  else
  {
    v18 = a1;
  }
  free(v18, a2, a3, a4, a5, a6, a7, a8, a9);
}
// 427D3C: variable 'a2' is possibly undefined
// 427D3C: variable 'a3' is possibly undefined
// 427D3C: variable 'a4' is possibly undefined
// 427D3C: variable 'a5' is possibly undefined
// 427D3C: variable 'a6' is possibly undefined
// 427D3C: variable 'a7' is possibly undefined
// 427D3C: variable 'a8' is possibly undefined
// 427D3C: variable 'a9' is possibly undefined

//----- (0000000000427D40) ----------------------------------------------------
__int64 __fastcall _gconv_find_shlib(__int64 a1)
{
  __int64 *v1; // x0
  __int64 v2; // x2
  __int64 v3; // x3
  __int64 v4; // x4
  __int64 v5; // x5
  __int64 v6; // x6
  __int64 v7; // x7
  __int64 v8; // x19
  int v9; // w0
  __int64 v10; // x1
  __int64 v11; // x0
  __int64 v12; // x2
  __int64 v13; // x3
  __int64 v14; // x4
  __int64 v15; // x5
  __int64 v16; // x6
  __int64 v17; // x7
  __int64 v18; // x0
  __int64 v19; // x2
  __int64 v20; // x3
  __int64 v21; // x4
  __int64 v22; // x5
  __int64 v23; // x6
  __int64 v24; // x7
  __int64 v25; // x2
  __int64 v26; // x3
  __int64 v27; // x4
  __int64 v28; // x5
  __int64 v29; // x6
  __int64 v30; // x7
  __int64 v31; // x0
  int8x16_t v32; // q30
  __int64 result; // x0
  bool v34; // vf
  int v35; // w0
  __int64 v36; // x1
  void *v37; // x3
  void *v38; // x4
  void *v39; // x5
  void *v40; // x6
  __int64 v41; // x7
  double v42; // d0
  double v43; // d1
  double v44; // d2
  double v45; // d3
  double v46; // d4
  double v47; // d5
  double v48; // d6
  double v49; // d7
  _QWORD *v50; // x3
  void *v51; // x4
  void *v52; // x5
  __int64 *v53; // x6
  __int64 v54; // x7
  double v55; // d0
  double v56; // d1
  double v57; // d2
  double v58; // d3
  double v59; // d4
  double v60; // d5
  double v61; // d6
  double v62; // d7
  double v63; // d0
  double v64; // d1
  double v65; // d2
  double v66; // d3
  double v67; // d4
  double v68; // d5
  double v69; // d6
  double v70; // d7
  unsigned __int64 (__fastcall *v71)(__int64); // [xsp+38h] [xbp+38h]
  unsigned __int64 v72; // [xsp+38h] [xbp+38h]
  __int64 v73; // [xsp+48h] [xbp+48h] BYREF

  v73 = a1;
  v1 = tfind((__int64)&v73, (unsigned __int64 *)&loaded, (__int64 (__fastcall *)(__int64, _QWORD))known_compare);
  if ( v1 )
  {
    v8 = *v1;
    if ( *v1 )
      goto LABEL_3;
    return 0LL;
  }
  v71 = strlen();
  v50 = (_QWORD *)malloc(
                    (__int64)v71 + 49,
                    v36,
                    (__int64)v71,
                    v37,
                    v38,
                    v39,
                    v40,
                    v41,
                    v42,
                    v43,
                    v44,
                    v45,
                    v46,
                    v47,
                    v48,
                    v49);
  v8 = (__int64)v50;
  if ( !v50 )
    return 0LL;
  v72 = (unsigned __int64)v50;
  *v50 = j_memcpy();
  *(_DWORD *)(v72 + 8) = -3;
  *(_QWORD *)(v72 + 16) = 0LL;
  if ( !tsearch(
          v72,
          &loaded,
          (__int64 (__fastcall *)(__int64, _QWORD))known_compare,
          (void *)v72,
          v51,
          v52,
          v53,
          v54,
          v55,
          v56,
          v57,
          v58,
          v59,
          v60,
          v61,
          v62) )
  {
    free(v72, v63, v64, v65, v66, v67, v68, v69, v70);
    return 0LL;
  }
LABEL_3:
  v9 = *(_DWORD *)(v8 + 8);
  v10 = *(_QWORD *)(v8 + 16);
  if ( v9 < -2 )
  {
    if ( v10 )
      _libc_assert_fail((__int64)"found->handle == NULL", (__int64)"gconv_dl.c", 0x71u, (__int64)"__gconv_find_shlib");
    v11 = _libc_dlopen_mode(*(_QWORD *)v8, -2147483646, v2, v3, v4, v5, v6, v7);
    *(_QWORD *)(v8 + 16) = v11;
    if ( v11 )
    {
      v18 = _libc_dlsym(v11, (__int64)"gconv", v12, v13, v14, v15, v16, v17);
      *(_QWORD *)(v8 + 24) = v18;
      if ( v18 )
      {
        *(_QWORD *)(v8 + 32) = _libc_dlsym(*(_QWORD *)(v8 + 16), (__int64)"gconv_init", v19, v20, v21, v22, v23, v24);
        v31 = _libc_dlsym(*(_QWORD *)(v8 + 16), (__int64)"gconv_end", v25, v26, v27, v28, v29, v30);
        v32 = veorq_s8(*(int8x16_t *)(v8 + 24), vdupq_lane_s64(_pointer_chk_guard_local, 0));
        *(_QWORD *)(v8 + 40) = v31 ^ _pointer_chk_guard_local;
        *(_DWORD *)(v8 + 8) = 1;
        result = v8;
        *(int8x16_t *)(v8 + 24) = v32;
        return result;
      }
      twalk_r(loaded, (void (__fastcall *)(__int64, __int64, __int64))do_release_shlib, v8);
    }
    return 0LL;
  }
  if ( v10 )
  {
    v34 = __OFADD__(v9, 1);
    v35 = v9 + 1;
    if ( (v35 < 0) ^ v34 | (v35 == 0) )
      v35 = 1;
    *(_DWORD *)(v8 + 8) = v35;
  }
  return v8;
}
// 427D9C: variable 'v2' is possibly undefined
// 427D9C: variable 'v3' is possibly undefined
// 427D9C: variable 'v4' is possibly undefined
// 427D9C: variable 'v5' is possibly undefined
// 427D9C: variable 'v6' is possibly undefined
// 427D9C: variable 'v7' is possibly undefined
// 427DB0: variable 'v12' is possibly undefined
// 427DB0: variable 'v13' is possibly undefined
// 427DB0: variable 'v14' is possibly undefined
// 427DB0: variable 'v15' is possibly undefined
// 427DB0: variable 'v16' is possibly undefined
// 427DB0: variable 'v17' is possibly undefined
// 427DC8: variable 'v19' is possibly undefined
// 427DC8: variable 'v20' is possibly undefined
// 427DC8: variable 'v21' is possibly undefined
// 427DC8: variable 'v22' is possibly undefined
// 427DC8: variable 'v23' is possibly undefined
// 427DC8: variable 'v24' is possibly undefined
// 427DDC: variable 'v25' is possibly undefined
// 427DDC: variable 'v26' is possibly undefined
// 427DDC: variable 'v27' is possibly undefined
// 427DDC: variable 'v28' is possibly undefined
// 427DDC: variable 'v29' is possibly undefined
// 427DDC: variable 'v30' is possibly undefined
// 427E94: variable 'v36' is possibly undefined
// 427E94: variable 'v37' is possibly undefined
// 427E94: variable 'v38' is possibly undefined
// 427E94: variable 'v39' is possibly undefined
// 427E94: variable 'v40' is possibly undefined
// 427E94: variable 'v41' is possibly undefined
// 427E94: variable 'v42' is possibly undefined
// 427E94: variable 'v43' is possibly undefined
// 427E94: variable 'v44' is possibly undefined
// 427E94: variable 'v45' is possibly undefined
// 427E94: variable 'v46' is possibly undefined
// 427E94: variable 'v47' is possibly undefined
// 427E94: variable 'v48' is possibly undefined
// 427E94: variable 'v49' is possibly undefined
// 427ED8: variable 'v51' is possibly undefined
// 427ED8: variable 'v52' is possibly undefined
// 427ED8: variable 'v53' is possibly undefined
// 427ED8: variable 'v54' is possibly undefined
// 427ED8: variable 'v55' is possibly undefined
// 427ED8: variable 'v56' is possibly undefined
// 427ED8: variable 'v57' is possibly undefined
// 427ED8: variable 'v58' is possibly undefined
// 427ED8: variable 'v59' is possibly undefined
// 427ED8: variable 'v60' is possibly undefined
// 427ED8: variable 'v61' is possibly undefined
// 427ED8: variable 'v62' is possibly undefined
// 427EE8: variable 'v63' is possibly undefined
// 427EE8: variable 'v64' is possibly undefined
// 427EE8: variable 'v65' is possibly undefined
// 427EE8: variable 'v66' is possibly undefined
// 427EE8: variable 'v67' is possibly undefined
// 427EE8: variable 'v68' is possibly undefined
// 427EE8: variable 'v69' is possibly undefined
// 427EE8: variable 'v70' is possibly undefined
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;
// 496D70: using guessed type __int64 loaded;

//----- (0000000000427F10) ----------------------------------------------------
__int64 __fastcall _gconv_release_shlib(__int64 a1)
{
  return twalk_r(loaded, (void (__fastcall *)(__int64, __int64, __int64))do_release_shlib, a1);
}
// 496D70: using guessed type __int64 loaded;

//----- (0000000000427F28) ----------------------------------------------------
void _gconv_dl_freemem()
{
  tdestroy((_QWORD *)loaded, (void (__fastcall *)(_QWORD))do_release_all);
  loaded = 0LL;
}
// 496D70: using guessed type __int64 loaded;

//----- (0000000000427F60) ----------------------------------------------------
__int64 (__fastcall *__fastcall new_composite_name(
        int a1,
        unsigned __int64 **a2))(__int64 result, __int64 *a2, unsigned __int64 a3)
{
  __int64 v2; // x19
  __int64 v3; // x20
  _BOOL4 v5; // w21
  unsigned __int64 *v7; // x25
  __int64 v8; // x2
  void *v9; // x3
  void *v10; // x4
  void *v11; // x5
  void *v12; // x6
  __int64 v13; // x7
  unsigned __int64 (__fastcall *v14)(__int64); // x27
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  unsigned __int64 v23; // x1
  __int64 v24; // x20
  unsigned __int64 *v25; // x19
  const char *v26; // x20
  __int64 v27; // x1
  __int64 v28; // x2
  void *v29; // x3
  void *v30; // x4
  void *v31; // x5
  void *v32; // x6
  __int64 v33; // x7
  double v34; // d0
  double v35; // d1
  double v36; // d2
  double v37; // d3
  double v38; // d4
  double v39; // d5
  double v40; // d6
  double v41; // d7
  _QWORD *v43; // x0
  _QWORD *v44; // x20
  __int64 v45; // x19
  unsigned __int64 *v46; // x27
  __int64 v47; // x1
  char *v48; // x0
  char *v49; // x0

  v2 = 0LL;
  v3 = 1LL;
  v5 = 1;
  if ( a1 == 6 )
    goto LABEL_11;
LABEL_2:
  if ( a1 == (_DWORD)v2 )
    v7 = *a2;
  else
    v7 = (unsigned __int64 *)nl_global_locale[v2 + 16];
  while ( 1 )
  {
    v14 = strlen();
    v23 = (unsigned __int64)v14 + nl_category_name_sizes[v2] + 1;
    v24 = v23 + v3;
    if ( v5 )
    {
      v23 = (unsigned __int64)*a2;
      if ( *a2 != v7 )
        v5 = strcmp(v7, v23) == 0;
    }
    if ( ++v2 == 13 )
      break;
    v3 = v24 + 1;
    if ( v2 == 6 )
      v2 = 7LL;
    if ( a1 != 6 )
      goto LABEL_2;
LABEL_11:
    v7 = a2[v2];
  }
  if ( v5 )
  {
    v25 = *a2;
    v26 = "C";
    if ( !(unsigned int)strcmp(*a2, (unsigned __int64)"C") || !(unsigned int)strcmp(v25, (unsigned __int64)"POSIX") )
      return (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))v26;
    if ( malloc((__int64)v14 + 1, v27, v28, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41) )
      return j_memcpy();
    return 0LL;
  }
  v43 = (_QWORD *)malloc(v24, v23, v8, v9, v10, v11, v12, v13, v15, v16, v17, v18, v19, v20, v21, v22);
  v44 = v43;
  if ( !v43 )
    return 0LL;
  v45 = 0LL;
  if ( a1 == 6 )
    goto LABEL_25;
LABEL_19:
  if ( a1 == (_DWORD)v45 )
    v46 = *a2;
  else
    v46 = (unsigned __int64 *)nl_global_locale[v45 + 16];
  while ( 1 )
  {
    v47 = (unsigned __int8)nl_category_name_idxs[v45++];
    v48 = stpcpy(v43, (unsigned __int64)&nl_category_names[v47]);
    *v48 = 61;
    v49 = stpcpy(v48 + 1, (unsigned __int64)v46);
    if ( v45 == 13 )
      break;
    *v49 = 59;
    v43 = v49 + 1;
    if ( v45 == 6 )
      v45 = 7LL;
    if ( a1 != 6 )
      goto LABEL_19;
LABEL_25:
    v46 = a2[v45];
  }
  *v49 = 0;
  return (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))v44;
}
// 428098: variable 'v23' is possibly undefined
// 428098: variable 'v8' is possibly undefined
// 428098: variable 'v9' is possibly undefined
// 428098: variable 'v10' is possibly undefined
// 428098: variable 'v11' is possibly undefined
// 428098: variable 'v12' is possibly undefined
// 428098: variable 'v13' is possibly undefined
// 428098: variable 'v15' is possibly undefined
// 428098: variable 'v16' is possibly undefined
// 428098: variable 'v17' is possibly undefined
// 428098: variable 'v18' is possibly undefined
// 428098: variable 'v19' is possibly undefined
// 428098: variable 'v20' is possibly undefined
// 428098: variable 'v21' is possibly undefined
// 428098: variable 'v22' is possibly undefined
// 428168: variable 'v27' is possibly undefined
// 428168: variable 'v28' is possibly undefined
// 428168: variable 'v29' is possibly undefined
// 428168: variable 'v30' is possibly undefined
// 428168: variable 'v31' is possibly undefined
// 428168: variable 'v32' is possibly undefined
// 428168: variable 'v33' is possibly undefined
// 428168: variable 'v34' is possibly undefined
// 428168: variable 'v35' is possibly undefined
// 428168: variable 'v36' is possibly undefined
// 428168: variable 'v37' is possibly undefined
// 428168: variable 'v38' is possibly undefined
// 428168: variable 'v39' is possibly undefined
// 428168: variable 'v40' is possibly undefined
// 428168: variable 'v41' is possibly undefined
// 457800: using guessed type unsigned __int8 nl_category_name_sizes[16];
// 491820: using guessed type char **nl_global_locale[6];

//----- (00000000004281A0) ----------------------------------------------------
void __fastcall free_category(
        int a1,
        char **a2,
        char **a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  unsigned __int64 *v13; // x19
  void (*v14)(void); // x0
  char *v15; // x0
  unsigned __int64 *v16; // x20
  double v17; // d0
  double v18; // d1
  double v19; // d2
  double v20; // d3
  double v21; // d4
  double v22; // d5
  double v23; // d6
  double v24; // d7
  unsigned __int64 v25; // x1
  bool v26; // zf
  double v27; // d0
  double v28; // d1
  double v29; // d2
  double v30; // d3
  double v31; // d4
  double v32; // d5
  double v33; // d6
  double v34; // d7
  double v35; // d0
  double v36; // d1
  double v37; // d2
  double v38; // d3
  double v39; // d4
  double v40; // d5
  double v41; // d6
  double v42; // d7

  v13 = (unsigned __int64 *)nl_locale_file_list[a1];
  if ( a2 != a3 )
  {
    if ( nl_current_used[a1] )
    {
      v14 = (void (*)(void))nl_category_postload[a1];
      nl_global_locale[a1] = a3;
      if ( v14 )
        v14();
    }
    v15 = (char *)nl_global_locale[a1 + 16];
    if ( v15 != "C" )
    {
      free((unsigned __int64)v15, a4, a5, a6, a7, a8, a9, a10, a11);
      nl_global_locale[a1 + 16] = (char **)"C";
    }
  }
  if ( v13 )
  {
    while ( 1 )
    {
      v25 = v13[2];
      if ( v25 )
        v26 = a3 == (char **)v25;
      else
        v26 = 1;
      if ( v26 )
      {
        v16 = (unsigned __int64 *)v13[3];
        free(*v13, a4, a5, a6, a7, a8, a9, a10, a11);
        free((unsigned __int64)v13, v17, v18, v19, v20, v21, v22, v23, v24);
        if ( !v16 )
          return;
      }
      else
      {
        nl_unload_locale(a1, v25, a4, a5, a6, a7, a8, a9, a10, a11);
        v16 = (unsigned __int64 *)v13[3];
        free(*v13, v27, v28, v29, v30, v31, v32, v33, v34);
        free((unsigned __int64)v13, v35, v36, v37, v38, v39, v40, v41, v42);
        if ( !v16 )
          return;
      }
      v13 = v16;
    }
  }
}
// 42821C: variable 'a4' is possibly undefined
// 42821C: variable 'a5' is possibly undefined
// 42821C: variable 'a6' is possibly undefined
// 42821C: variable 'a7' is possibly undefined
// 42821C: variable 'a8' is possibly undefined
// 42821C: variable 'a9' is possibly undefined
// 42821C: variable 'a10' is possibly undefined
// 42821C: variable 'a11' is possibly undefined
// 428240: variable 'v17' is possibly undefined
// 428240: variable 'v18' is possibly undefined
// 428240: variable 'v19' is possibly undefined
// 428240: variable 'v20' is possibly undefined
// 428240: variable 'v21' is possibly undefined
// 428240: variable 'v22' is possibly undefined
// 428240: variable 'v23' is possibly undefined
// 428240: variable 'v24' is possibly undefined
// 42826C: variable 'v27' is possibly undefined
// 42826C: variable 'v28' is possibly undefined
// 42826C: variable 'v29' is possibly undefined
// 42826C: variable 'v30' is possibly undefined
// 42826C: variable 'v31' is possibly undefined
// 42826C: variable 'v32' is possibly undefined
// 42826C: variable 'v33' is possibly undefined
// 42826C: variable 'v34' is possibly undefined
// 428274: variable 'v35' is possibly undefined
// 428274: variable 'v36' is possibly undefined
// 428274: variable 'v37' is possibly undefined
// 428274: variable 'v38' is possibly undefined
// 428274: variable 'v39' is possibly undefined
// 428274: variable 'v40' is possibly undefined
// 428274: variable 'v41' is possibly undefined
// 428274: variable 'v42' is possibly undefined
// 48F950: using guessed type _QWORD nl_current_used[14];
// 48F9C0: using guessed type __int64 (__fastcall *nl_category_postload[14])();
// 491820: using guessed type char **nl_global_locale[6];
// 496FE0: using guessed type _QWORD nl_locale_file_list[2];

//----- (000000000042828C) ----------------------------------------------------
char **__fastcall setlocale(int a1, unsigned __int64 *a2)
{
  __int64 v2; // x21
  unsigned __int64 *v3; // x26
  __int64 v4; // x24
  unsigned __int8 *v5; // x0
  __int64 v6; // x0
  __int64 v7; // x28
  char **locale; // x0
  char **v9; // x25
  char *v10; // x23
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7
  void (*v19)(void); // x0
  char **v20; // x20
  char *v21; // x0
  double v22; // d0
  double v23; // d1
  double v24; // d2
  double v25; // d3
  double v26; // d4
  double v27; // d5
  double v28; // d6
  double v29; // d7
  int v32; // w4
  unsigned __int64 **v33; // x20
  unsigned __int64 **v34; // x2
  int v35; // w4
  unsigned int v36; // w20
  int v37; // w4
  __int64 v38; // x23
  __int64 v39; // x26
  char **v40; // x0
  double v41; // d0
  double v42; // d1
  double v43; // d2
  double v44; // d3
  double v45; // d4
  double v46; // d5
  double v47; // d6
  double v48; // d7
  unsigned __int64 *v49; // x24
  unsigned __int64 *v50; // x25
  int v51; // w0
  char *v52; // x20
  char ***v53; // x25
  unsigned int v54; // w4
  __int64 v55; // x23
  void (*v56)(void); // x0
  char *v57; // x0
  unsigned __int64 *v58; // x26
  unsigned __int64 *v59; // x0
  __int64 v60; // x23
  __int64 v61; // x19
  char *v62; // x0
  double v63; // d0
  double v64; // d1
  double v65; // d2
  double v66; // d3
  double v67; // d4
  double v68; // d5
  double v69; // d6
  double v70; // d7
  double v71; // d0
  double v72; // d1
  double v73; // d2
  double v74; // d3
  double v75; // d4
  double v76; // d5
  double v77; // d6
  double v78; // d7
  int8x16_t *v79; // x23
  __int64 v80; // x24
  unsigned __int64 v81; // x2
  double v82; // d0
  double v83; // d1
  double v84; // d2
  double v85; // d3
  double v86; // d4
  double v87; // d5
  double v88; // d6
  double v89; // d7
  int v90; // w0
  _BYTE *v91; // x0
  int v92; // w0
  int v93; // [xsp+60h] [xbp+60h]
  unsigned int v94; // [xsp+60h] [xbp+60h]
  int v95; // [xsp+60h] [xbp+60h]
  unsigned __int64 v96; // [xsp+60h] [xbp+60h]
  int v97; // [xsp+68h] [xbp+68h]
  unsigned __int64 v98; // [xsp+70h] [xbp+70h]
  __int64 v99; // [xsp+78h] [xbp+78h]
  const char *v100; // [xsp+80h] [xbp+80h] BYREF
  __int64 v101; // [xsp+88h] [xbp+88h] BYREF
  unsigned __int64 *v102[13]; // [xsp+90h] [xbp+90h] BYREF
  unsigned __int64 *v103[13]; // [xsp+F8h] [xbp+F8h] BYREF

  v2 = a1;
  if ( (unsigned __int64)a1 > 0xC )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return 0LL;
  }
  v3 = a2;
  if ( !a2 )
    return nl_global_locale[a1 + 16];
  v4 = a1 + 16LL;
  pthread_rwlock_wrlock((pthread_rwlock_t *)_libc_setlocale_lock);
  if ( !(unsigned int)strcmp(v3, (unsigned __int64)nl_global_locale[v4]) )
  {
    pthread_rwlock_unlock((int *)_libc_setlocale_lock);
    return nl_global_locale[v4];
  }
  v100 = 0LL;
  v101 = 0LL;
  v5 = (unsigned __int8 *)getenv("LOCPATH");
  if ( v5
    && *v5
    && ((unsigned int)argz_create_sep(v5, 58, (unsigned __int64 *)&v100, &v101)
     || (unsigned int)argz_add_sep((unsigned __int64 *)&v100, &v101, "/lib/locale", 58)) )
  {
    pthread_rwlock_unlock((int *)_libc_setlocale_lock);
    return 0LL;
  }
  if ( (_DWORD)v2 != 6 )
  {
    v6 = nl_current_used[(int)v2];
    v103[0] = v3;
    v7 = v6;
    if ( v6 )
    {
      locale = nl_find_locale(v100, v101, v2, v103);
      v9 = locale;
      if ( !locale )
        goto LABEL_80;
      v3 = v103[0];
      if ( *((_DWORD *)locale + 10) != -1 )
        *((_DWORD *)locale + 10) = -1;
    }
    else
    {
      v9 = 0LL;
    }
    if ( v3 == (unsigned __int64 *)"C" || (v103[0] = (unsigned __int64 *)strdup()) != 0LL )
    {
      v10 = (char *)new_composite_name(v2, v103);
      if ( v10 )
      {
        if ( v7 )
        {
          nl_global_locale[(int)v2] = v9;
          v19 = (void (*)(void))nl_category_postload[(int)v2];
          if ( v19 )
            v19();
        }
        v20 = (char **)v103[0];
        v21 = (char *)nl_global_locale[v2 + 16];
        if ( (char *)v103[0] != v21 )
        {
          if ( v21 != "C" )
            free((unsigned __int64)v21, v11, v12, v13, v14, v15, v16, v17, v18);
          nl_global_locale[v2 + 16] = v20;
        }
        if ( v10 != off_4918D0[0] )
        {
          if ( off_4918D0[0] != "C" )
            free((unsigned __int64)off_4918D0[0], v11, v12, v13, v14, v15, v16, v17, v18);
          off_4918D0[0] = v10;
        }
        ++nl_msg_cat_cntr;
        goto LABEL_26;
      }
      if ( (char *)v103[0] != "C" )
        free((unsigned __int64)v103[0], v11, v12, v13, v14, v15, v16, v17, v18);
    }
LABEL_80:
    v103[0] = 0LL;
LABEL_26:
    pthread_rwlock_unlock((int *)_libc_setlocale_lock);
    free((unsigned __int64)v100, v22, v23, v24, v25, v26, v27, v28, v29);
    return (char **)v103[0];
  }
  v32 = 0;
  v33 = v102;
  v34 = v102;
  do
  {
    if ( v32 == 6 )
    {
      ++v34;
      v32 = 7;
    }
    ++v32;
    *v34++ = v3;
  }
  while ( v32 != 13 );
  v98 = strchr((__int64)v3, 0x3Bu);
  v35 = 13;
  if ( v98 )
  {
    v98 = (unsigned __int64)strdup();
    v79 = (int8x16_t *)v98;
    if ( v98 )
    {
      v35 = 13;
      while ( 1 )
      {
        v95 = v35;
        v99 = strchr((__int64)v79, 0x3Du);
        v35 = v95;
        if ( !v99 )
          break;
        v80 = 0LL;
        v81 = v99 - (_QWORD)v79;
        while ( 1 )
        {
          if ( v80 == 6 )
            v80 = 7LL;
          if ( v81 == nl_category_name_sizes[v80] )
          {
            v96 = v81;
            v97 = v35;
            v90 = memcmp(v79, (int8x16_t *)&nl_category_names[(unsigned __int8)nl_category_name_idxs[v80]], v81);
            v81 = v96;
            v35 = v97;
            if ( !v90 )
              break;
          }
          if ( ++v80 == 13 )
            goto LABEL_91;
        }
        v102[(int)v80] = (unsigned __int64 *)(v99 + 1);
        v91 = (_BYTE *)strchr(v99 + 1, 0x3Bu);
        v35 = v97;
        if ( !v91 )
          break;
        *v91 = 0;
        v79 = (int8x16_t *)(v91 + 1);
      }
      v92 = 0;
      while ( *v33 != v3 )
      {
        if ( ++v92 == 13 )
          goto LABEL_35;
        ++v33;
        if ( v92 == 6 )
        {
          if ( v3 == v33[1] )
            break;
          v33 += 2;
          v92 = 8;
        }
      }
LABEL_91:
      pthread_rwlock_unlock((int *)_libc_setlocale_lock);
      free(v98, v82, v83, v84, v85, v86, v87, v88, v89);
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    }
    else
    {
      pthread_rwlock_unlock((int *)_libc_setlocale_lock);
    }
    return 0LL;
  }
  do
  {
LABEL_35:
    v36 = v35 - 1;
    if ( v35 == 7 )
    {
      v37 = 5;
    }
    else
    {
      v36 = v35;
      v37 = v35 - 1;
    }
    v38 = v37;
    v39 = (unsigned int)v37;
    v93 = v37;
    v40 = nl_find_locale(v100, v101, v37, &v102[v37]);
    v35 = v93;
    v103[v38] = (unsigned __int64 *)v40;
    v49 = v102[v38];
    if ( v40 )
    {
      if ( *((_DWORD *)v40 + 10) != -1 )
        *((_DWORD *)v40 + 10) = -1;
      if ( v49 != (unsigned __int64 *)"C" )
      {
        v50 = (unsigned __int64 *)nl_global_locale[v38 + 16];
        v51 = strcmp(v49, (unsigned __int64)v50);
        v35 = v93;
        if ( v51 )
        {
          v59 = (unsigned __int64 *)strdup();
          v102[v38] = v59;
          v35 = v93;
          if ( !v59 )
            goto LABEL_61;
        }
        else
        {
          v102[v38] = v50;
        }
      }
    }
    else if ( v49 != (unsigned __int64 *)"C" )
    {
LABEL_61:
      if ( v36 != 13 )
      {
        v39 = v36;
        v54 = v36;
        goto LABEL_63;
      }
LABEL_69:
      v52 = 0LL;
      goto LABEL_70;
    }
  }
  while ( v35 );
  v52 = (char *)new_composite_name(6, v102);
  v53 = nl_global_locale;
  v54 = 0;
  v55 = 1LL;
  if ( !v52 )
  {
LABEL_63:
    v60 = 13 - v54;
    v61 = 0LL;
    do
    {
      if ( v54 + (_DWORD)v61 != 6 )
      {
        v62 = (char *)(&v102[v39])[v61];
        if ( v62 != "C" && v62 != (char *)(&nl_global_locale[v39 + 16])[v61] )
        {
          v94 = v54;
          free((unsigned __int64)v62, v41, v42, v43, v44, v45, v46, v47, v48);
          v54 = v94;
        }
      }
      ++v61;
    }
    while ( v61 != v60 );
    goto LABEL_69;
  }
  while ( 1 )
  {
    if ( (_DWORD)v55 == 7 )
    {
      ++v53;
      v55 = 8LL;
    }
    if ( nl_current_used[v55 - 1] )
    {
      *v53 = (char **)v102[v55 + 12];
      v56 = (void (*)(void))nl_category_postload[v55 - 1];
      if ( v56 )
        v56();
    }
    v57 = (char *)v53[16];
    v58 = v102[v55 - 1];
    if ( v58 != (unsigned __int64 *)v57 )
    {
      if ( v57 != "C" )
        free((unsigned __int64)v57, v41, v42, v43, v44, v45, v46, v47, v48);
      v53[16] = (char **)v58;
    }
    if ( ++v55 == 14 )
      break;
    ++v53;
  }
  if ( v52 != off_4918D0[0] )
  {
    if ( off_4918D0[0] != "C" )
      free((unsigned __int64)off_4918D0[0], v41, v42, v43, v44, v45, v46, v47, v48);
    off_4918D0[0] = v52;
  }
  ++nl_msg_cat_cntr;
LABEL_70:
  pthread_rwlock_unlock((int *)_libc_setlocale_lock);
  free((unsigned __int64)v100, v63, v64, v65, v66, v67, v68, v69, v70);
  free(v98, v71, v72, v73, v74, v75, v76, v77, v78);
  return (char **)v52;
}
// 4283D0: variable 'v11' is possibly undefined
// 4283D0: variable 'v12' is possibly undefined
// 4283D0: variable 'v13' is possibly undefined
// 4283D0: variable 'v14' is possibly undefined
// 4283D0: variable 'v15' is possibly undefined
// 4283D0: variable 'v16' is possibly undefined
// 4283D0: variable 'v17' is possibly undefined
// 4283D0: variable 'v18' is possibly undefined
// 428428: variable 'v22' is possibly undefined
// 428428: variable 'v23' is possibly undefined
// 428428: variable 'v24' is possibly undefined
// 428428: variable 'v25' is possibly undefined
// 428428: variable 'v26' is possibly undefined
// 428428: variable 'v27' is possibly undefined
// 428428: variable 'v28' is possibly undefined
// 428428: variable 'v29' is possibly undefined
// 428634: variable 'v41' is possibly undefined
// 428634: variable 'v42' is possibly undefined
// 428634: variable 'v43' is possibly undefined
// 428634: variable 'v44' is possibly undefined
// 428634: variable 'v45' is possibly undefined
// 428634: variable 'v46' is possibly undefined
// 428634: variable 'v47' is possibly undefined
// 428634: variable 'v48' is possibly undefined
// 428740: variable 'v63' is possibly undefined
// 428740: variable 'v64' is possibly undefined
// 428740: variable 'v65' is possibly undefined
// 428740: variable 'v66' is possibly undefined
// 428740: variable 'v67' is possibly undefined
// 428740: variable 'v68' is possibly undefined
// 428740: variable 'v69' is possibly undefined
// 428740: variable 'v70' is possibly undefined
// 428748: variable 'v71' is possibly undefined
// 428748: variable 'v72' is possibly undefined
// 428748: variable 'v73' is possibly undefined
// 428748: variable 'v74' is possibly undefined
// 428748: variable 'v75' is possibly undefined
// 428748: variable 'v76' is possibly undefined
// 428748: variable 'v77' is possibly undefined
// 428748: variable 'v78' is possibly undefined
// 428890: variable 'v82' is possibly undefined
// 428890: variable 'v83' is possibly undefined
// 428890: variable 'v84' is possibly undefined
// 428890: variable 'v85' is possibly undefined
// 428890: variable 'v86' is possibly undefined
// 428890: variable 'v87' is possibly undefined
// 428890: variable 'v88' is possibly undefined
// 428890: variable 'v89' is possibly undefined
// 457800: using guessed type unsigned __int8 nl_category_name_sizes[16];
// 48F950: using guessed type _QWORD nl_current_used[14];
// 48F9C0: using guessed type __int64 (__fastcall *nl_category_postload[14])();
// 491820: using guessed type char **nl_global_locale[6];
// 4918D0: using guessed type char *off_4918D0[8];
// 496D78: using guessed type unsigned int _libc_setlocale_lock[14];
// 496EB0: using guessed type int nl_msg_cat_cntr;

//----- (0000000000428970) ----------------------------------------------------
void __fastcall nl_locale_subfreeres(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7

  free_category(
    0,
    **(char ****)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 16),
    &nl_C_LC_CTYPE,
    a1,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8);
  free_category(
    1,
    **(char ****)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 24),
    &nl_C_LC_NUMERIC,
    v8,
    v9,
    v10,
    v11,
    v12,
    v13,
    v14,
    v15);
  if ( off_4918D0[0] != "C" )
  {
    free((unsigned __int64)off_4918D0[0], v16, v17, v18, v19, v20, v21, v22, v23);
    off_4918D0[0] = "C";
  }
  nl_archive_subfreeres(v16, v17, v18, v19, v20, v21, v22, v23);
}
// 428A34: variable 'v8' is possibly undefined
// 428A34: variable 'v9' is possibly undefined
// 428A34: variable 'v10' is possibly undefined
// 428A34: variable 'v11' is possibly undefined
// 428A34: variable 'v12' is possibly undefined
// 428A34: variable 'v13' is possibly undefined
// 428A34: variable 'v14' is possibly undefined
// 428A34: variable 'v15' is possibly undefined
// 428BD8: variable 'v16' is possibly undefined
// 428BD8: variable 'v17' is possibly undefined
// 428BD8: variable 'v18' is possibly undefined
// 428BD8: variable 'v19' is possibly undefined
// 428BD8: variable 'v20' is possibly undefined
// 428BD8: variable 'v21' is possibly undefined
// 428BD8: variable 'v22' is possibly undefined
// 428BD8: variable 'v23' is possibly undefined
// 48CF90: using guessed type char *nl_C_LC_CTYPE;
// 48D608: using guessed type char *nl_C_LC_NUMERIC;
// 4918D0: using guessed type char *off_4918D0[8];

//----- (0000000000428C00) ----------------------------------------------------
__int64 nl_postload_ctype()
{
  __int64 result; // x0
  _QWORD *StatusReg; // x4
  char ***v2; // x5
  char *v3; // x1
  char *v4; // x3
  char *v5; // x2

  result = (__int64)nl_global_locale;
  StatusReg = (_QWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v2 = (char ***)StatusReg[4];
  v3 = nl_global_locale[0][10] + 512;
  v4 = nl_global_locale[0][7] + 256;
  v5 = nl_global_locale[0][8] + 512;
  off_491888 = v4;
  off_491890 = v3;
  off_491898 = v5;
  if ( v2 == nl_global_locale )
  {
    StatusReg[9] = v4;
    StatusReg[10] = v5;
    result = 88LL;
    StatusReg[11] = v3;
  }
  return result;
}
// 491820: using guessed type char **nl_global_locale[6];
// 491888: using guessed type _UNKNOWN *off_491888;
// 491890: using guessed type _UNKNOWN *off_491890;
// 491898: using guessed type _UNKNOWN *off_491898;

//----- (0000000000428C80) ----------------------------------------------------
void __fastcall __noreturn _libc_assert_fail(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  __int64 v7; // x0
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  char v16; // [xsp+3Ah] [xbp+3Ah] BYREF

  v16 = 0;
  v7 = itoa_word(a3, (__int64)&v16, 0xAu, 0);
  _libc_message_impl(
    "Fatal glibc error: %s:%s (%s): assertion failed: %s\n",
    v8,
    v9,
    v10,
    v11,
    v12,
    v13,
    v14,
    v15,
    a2,
    v7,
    a4,
    a1);
}
// 428CCC: variable 'v8' is possibly undefined
// 428CCC: variable 'v9' is possibly undefined
// 428CCC: variable 'v10' is possibly undefined
// 428CCC: variable 'v11' is possibly undefined
// 428CCC: variable 'v12' is possibly undefined
// 428CCC: variable 'v13' is possibly undefined
// 428CCC: variable 'v14' is possibly undefined
// 428CCC: variable 'v15' is possibly undefined

//----- (0000000000428CE0) ----------------------------------------------------
unsigned __int64 _ctype_b_loc()
{
  return _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 72;
}

//----- (0000000000428D00) ----------------------------------------------------
unsigned __int64 _ctype_toupper_loc()
{
  return _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 80;
}

//----- (0000000000428D20) ----------------------------------------------------
unsigned __int64 _ctype_tolower_loc()
{
  return _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 88;
}

//----- (0000000000428D40) ----------------------------------------------------
__int64 _ctype_init()
{
  unsigned __int64 StatusReg; // x2
  _QWORD *v1; // x0
  __int64 v2; // x1
  __int64 v3; // x3
  __int64 result; // x0

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v1 = **(_QWORD ***)(StatusReg + 16);
  v3 = v1[7];
  v2 = v1[8];
  result = v1[10] + 512LL;
  *(_QWORD *)(StatusReg + 72) = v3 + 256;
  *(_QWORD *)(StatusReg + 80) = v2 + 512;
  *(_QWORD *)(StatusReg + 88) = result;
  return result;
}

//----- (0000000000428D80) ----------------------------------------------------
unsigned __int64 *__fastcall dcgettext(unsigned __int64 *a1, unsigned __int64 *a2, unsigned int a3)
{
  return _dcigettext(a1, a2, 0LL, 0, 0LL, a3);
}

//----- (0000000000428DA0) ----------------------------------------------------
unsigned __int64 __fastcall plural_eval(int *a1, __int64 a2)
{
  int *v2; // x2
  int v3; // w0
  bool v4; // cc
  __int64 v5; // x3
  int v7; // w0
  __int64 v8; // x0
  int v9; // w0
  unsigned __int64 v10; // x4
  unsigned __int64 v11; // x3
  int *v12; // [xsp+10h] [xbp+10h]
  int *v13; // [xsp+10h] [xbp+10h]
  __int64 v14; // [xsp+18h] [xbp+18h]
  unsigned __int64 v15; // [xsp+18h] [xbp+18h]

  v2 = a1;
  v3 = *a1;
  v4 = v3 <= 2;
  if ( v3 == 2 )
  {
LABEL_13:
    v13 = v2;
    v5 = plural_eval(*((_QWORD *)v2 + 1));
    v9 = v13[1];
    if ( v9 == 15 )
    {
      if ( v5 )
        return 1LL;
    }
    else
    {
      if ( v9 != 14 )
      {
        v15 = v5;
        v10 = plural_eval(*((_QWORD *)v13 + 2));
        v11 = v15;
        switch ( v13[1] )
        {
          case 3:
            return v15 * v10;
          case 4:
            if ( v10 )
              return v15 / v10;
            raise(8u);
            return v15 / 0;
          case 5:
            if ( !v10 )
            {
              raise(8u);
              v11 = v15;
              v10 = 0LL;
            }
            return v11 % v10;
          case 6:
            return v15 + v10;
          case 7:
            return v15 - v10;
          case 8:
            return v15 < v10;
          case 9:
            return v15 > v10;
          case 10:
            return v15 <= v10;
          case 11:
            return v15 >= v10;
          case 12:
            return v15 == v10;
          case 13:
            return v15 != v10;
          default:
            return 0LL;
        }
      }
      if ( !v5 )
        return v5;
    }
    return plural_eval(*((_QWORD *)v13 + 2)) != 0;
  }
  while ( !v4 )
  {
    if ( v3 != 3 )
      return 0LL;
    v12 = v2;
    v14 = a2;
    v8 = plural_eval(*((_QWORD *)v2 + 1));
    a2 = v14;
    v2 = *(int **)&v12[2 * (v8 == 0) + 4];
    v3 = *v2;
    v4 = *v2 <= 2;
    if ( *v2 == 2 )
      goto LABEL_13;
  }
  if ( v3 )
  {
    if ( v3 == 1 )
      return plural_eval(*((_QWORD *)v2 + 1)) == 0;
  }
  else
  {
    v7 = v2[1];
    v5 = a2;
    if ( !v7 )
      return v5;
    if ( v7 == 1 )
      return *((_QWORD *)v2 + 1);
  }
  return 0LL;
}

//----- (0000000000428F80) ----------------------------------------------------
unsigned __int64 __fastcall transcmp(__int64 a1, __int64 a2)
{
  unsigned __int64 *v4; // x0
  unsigned __int64 v5; // x1
  unsigned __int64 result; // x0

  if ( *(_QWORD *)(a1 + 32) )
    v4 = (unsigned __int64 *)(a1 + 56);
  else
    v4 = *(unsigned __int64 **)(a1 + 56);
  if ( *(_QWORD *)(a2 + 32) )
    v5 = a2 + 56;
  else
    v5 = *(_QWORD *)(a2 + 56);
  result = strcmp(v4, v5);
  if ( !(_DWORD)result )
  {
    result = strcmp(*(unsigned __int64 **)a1, *(_QWORD *)a2);
    if ( !(_DWORD)result )
    {
      result = strcmp(*(unsigned __int64 **)(a1 + 16), *(_QWORD *)(a2 + 16));
      if ( !(_DWORD)result )
        return (unsigned int)(*(_DWORD *)(a1 + 8) - *(_DWORD *)(a2 + 8));
    }
  }
  return result;
}

//----- (0000000000429000) ----------------------------------------------------
__int64 __fastcall nl_find_msg(__int64 a1, __int64 a2, unsigned __int64 *a3, int a4, _QWORD *a5)
{
  __int64 *v6; // x20
  unsigned int v7; // w19
  unsigned int v8; // w0
  unsigned int v9; // w2
  __int64 v10; // x26
  int v11; // w25
  unsigned int v12; // w28
  unsigned int v13; // w27
  unsigned int v14; // w21
  unsigned int v15; // w24
  unsigned int *v16; // x8
  unsigned int v17; // w0
  __int64 v18; // x1
  unsigned int v19; // w0
  unsigned int v20; // w1
  unsigned int v21; // w0
  unsigned int v22; // w22
  _QWORD *v23; // x0
  unsigned __int64 v24; // x27
  unsigned __int64 v25; // x22
  __int64 *v26; // x22
  __int64 v27; // x22
  unsigned __int64 v28; // x25
  unsigned __int64 i; // x26
  unsigned int v30; // w2
  __int64 v31; // x0
  int v32; // w0
  __int64 v34; // x22
  unsigned int *v35; // x2
  unsigned int v36; // w0
  unsigned int v37; // w2
  __int64 v38; // x0
  unsigned __int64 v39; // x28
  __int64 v40; // x23
  __int64 v41; // x25
  __int64 v42; // x0
  __int64 *v43; // x0
  char *v44; // x0
  __int64 v45; // x1
  __int64 v46; // x2
  void *v47; // x3
  void *v48; // x4
  void *v49; // x5
  void *v50; // x6
  __int64 v51; // x7
  double v52; // d0
  double v53; // d1
  double v54; // d2
  double v55; // d3
  double v56; // d4
  double v57; // d5
  double v58; // d6
  double v59; // d7
  int v60; // w0
  __int64 v61; // x1
  int v62; // w28
  _QWORD *v63; // x0
  int v64; // w0
  __int64 *v65; // x24
  double v66; // d0
  double v67; // d1
  double v68; // d2
  double v69; // d3
  double v70; // d4
  double v71; // d5
  double v72; // d6
  double v73; // d7
  __int64 v74; // x1
  __int64 v75; // x2
  void *v76; // x3
  void *v77; // x4
  void *v78; // x5
  void *v79; // x6
  __int64 v80; // x7
  double v81; // d0
  double v82; // d1
  double v83; // d2
  double v84; // d3
  double v85; // d4
  double v86; // d5
  double v87; // d6
  double v88; // d7
  unsigned __int64 v89; // x21
  __int64 v90; // x24
  __int64 v91; // x26
  unsigned __int64 **v92; // x23
  unsigned __int64 *v93; // t1
  __int64 v94; // x1
  __int64 v95; // x2
  __int64 v96; // x3
  void *v97; // x4
  void *v98; // x5
  void *v99; // x6
  int v100; // w0
  unsigned __int64 v101; // x24
  __int64 (__fastcall *v102)(__int64, __int64 *, unsigned __int64); // x0
  unsigned __int64 v103; // x23
  __int64 msg; // x0
  __int64 v105; // x2
  __int64 v106; // x3
  __int64 v107; // x4
  __int64 v108; // x5
  __int64 v109; // x6
  __int64 v110; // x7
  __int64 v111; // x1
  __int64 v112; // x0
  unsigned __int64 v113; // x21
  int v114; // w26
  double v115; // d0
  double v116; // d1
  double v117; // d2
  double v118; // d3
  double v119; // d4
  double v120; // d5
  double v121; // d6
  double v122; // d7
  __int64 v123; // x0
  __int64 v124; // x1
  __int64 v125; // x2
  void *v126; // x3
  void *v127; // x4
  void *v128; // x5
  void *v129; // x6
  __int64 v130; // x7
  double v131; // d0
  double v132; // d1
  double v133; // d2
  double v134; // d3
  double v135; // d4
  double v136; // d5
  double v137; // d6
  double v138; // d7
  int v139; // w0
  __int64 v140; // x1
  __int64 v141; // x2
  __int64 v142; // x3
  void *v143; // x4
  void *v144; // x5
  void *v145; // x6
  int v146; // w0
  unsigned __int64 (__fastcall *v147)(__int64); // x0
  __int64 v148; // x1
  __int64 v149; // x2
  void *v150; // x3
  void *v151; // x4
  void *v152; // x5
  void *v153; // x6
  __int64 v154; // x7
  double v155; // d0
  double v156; // d1
  double v157; // d2
  double v158; // d3
  double v159; // d4
  double v160; // d5
  double v161; // d6
  double v162; // d7
  __int64 v163; // x1
  __int64 v164; // x2
  __int64 v165; // x3
  void *v166; // x4
  void *v167; // x5
  void *v168; // x6
  int v169; // w0
  __int64 v170; // x27
  __int64 v171; // x1
  __int64 v172; // x0
  __int64 v173; // x0
  __int64 v174; // x1
  __int64 v175; // x2
  __int64 v176; // x3
  void *v177; // x4
  void *v178; // x5
  void *v179; // x6
  int v180; // w0
  int8x16_t *(__fastcall *v181)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  double v182; // d0
  double v183; // d1
  double v184; // d2
  double v185; // d3
  double v186; // d4
  double v187; // d5
  double v188; // d6
  double v189; // d7
  char v190; // [xsp+0h] [xbp+0h]
  unsigned __int64 v195; // [xsp+88h] [xbp+88h]
  unsigned int v196; // [xsp+90h] [xbp+90h]
  pthread_rwlock_t *v197; // [xsp+90h] [xbp+90h]
  __int64 v198; // [xsp+98h] [xbp+98h]
  __int64 v199; // [xsp+A8h] [xbp+A8h] BYREF
  _QWORD *v200; // [xsp+B0h] [xbp+B0h] BYREF
  unsigned __int64 v201[2]; // [xsp+B8h] [xbp+B8h] BYREF
  char v202; // [xsp+C8h] [xbp+C8h]

  if ( *(int *)(a1 + 8) <= 0 )
    nl_load_domain(a1, a2);
  v6 = *(__int64 **)(a1 + 16);
  if ( !v6 )
    return 0LL;
  v7 = *((_DWORD *)v6 + 10);
  if ( !v6[12] )
  {
    v25 = v7;
    v28 = 0LL;
    for ( i = v7; i > v28; i = (i + v28) >> 1 )
    {
      while ( 1 )
      {
        v24 = (i + v28) >> 1;
        v30 = *(_DWORD *)(v6[6] + 8 * v24 + 4);
        LODWORD(v31) = bswap32(v30);
        v31 = *((_DWORD *)v6 + 6) ? (unsigned int)v31 : v30;
        v32 = strcmp(a3, *v6 + v31);
        if ( v32 < 0 )
          break;
        if ( !v32 )
          goto LABEL_21;
        v28 = v24 + 1;
        if ( i <= v24 + 1 )
          return 0LL;
      }
    }
    return 0LL;
  }
  v196 = (unsigned int)strlen();
  v8 = _hash_string((unsigned __int8 *)a3);
  v9 = *((_DWORD *)v6 + 22);
  v10 = v6[12];
  v11 = *((_DWORD *)v6 + 26);
  v12 = v8 % v9;
  v13 = v8 % (v9 - 2) + 1;
  v14 = v9 - v13;
  v15 = v13 - v9;
  while ( 1 )
  {
    v20 = *(_DWORD *)(v10 + 4LL * v12);
    v21 = bswap32(v20);
    if ( v11 )
      v20 = v21;
    if ( !v20 )
      return 0LL;
    v22 = v20 - 1;
    if ( v7 <= v20 - 1 )
      break;
    v195 = v22;
    v16 = (unsigned int *)(v6[6] + 8LL * (v20 - 1));
    v17 = *v16;
    if ( *((_DWORD *)v6 + 6) )
    {
      if ( v196 > bswap32(v17) )
        goto LABEL_10;
      v18 = *v6;
      v19 = bswap32(v16[1]);
    }
    else
    {
      if ( v196 > v17 )
        goto LABEL_10;
      v18 = *v6;
      v19 = v16[1];
    }
    if ( !(unsigned int)strcmp(a3, v18 + v19) )
      goto LABEL_20;
LABEL_10:
    if ( v14 <= v12 )
      v12 += v15;
    else
      v12 += v13;
  }
  v23 = (_QWORD *)(v6[9] + 16LL * (v22 - v7));
  if ( *v23 <= (unsigned __int64)v196 || (unsigned int)strcmp(a3, v23[1]) )
    goto LABEL_10;
  v195 = v22;
LABEL_20:
  v24 = v195;
  v25 = v7;
LABEL_21:
  if ( v25 > v24 )
  {
    v34 = *v6;
    v35 = (unsigned int *)(v6[7] + 8 * v24);
    v36 = *v35;
    v37 = v35[1];
    if ( *((_DWORD *)v6 + 6) )
    {
      v38 = bswap32(v36) + 1;
      v27 = v34 + bswap32(v37);
    }
    else
    {
      v38 = v36 + 1;
      v27 = v34 + v37;
    }
    v198 = v38;
  }
  else
  {
    v26 = (__int64 *)(v6[10] + 16 * (v24 - v25));
    v198 = *v26;
    v27 = v26[1];
  }
  if ( !a4 )
  {
LABEL_24:
    *a5 = v198;
    return v27;
  }
  if ( !a2 || (v39 = *(_QWORD *)(a2 + 16)) == 0 )
  {
    if ( output_charset_cached_1 )
    {
      v39 = output_charset_cache_0;
    }
    else
    {
      v44 = getenv("OUTPUT_CHARSET");
      if ( v44 && *v44 )
      {
        v147 = strlen();
        v39 = malloc(
                (__int64)v147 + 1,
                v148,
                v149,
                v150,
                v151,
                v152,
                v153,
                v154,
                v155,
                v156,
                v157,
                v158,
                v159,
                v160,
                v161,
                v162);
        if ( v39 )
        {
          j_memcpy();
          output_charset_cache_0 = v39;
          output_charset_cached_1 = 1;
          goto LABEL_43;
        }
        output_charset_cached_1 = 1;
        output_charset_cache_0 = 0LL;
        goto LABEL_54;
      }
      v39 = output_charset_cache_0;
      output_charset_cached_1 = 1;
    }
    if ( v39 )
      goto LABEL_43;
LABEL_54:
    v39 = *(_QWORD *)(**(_QWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 16) + 168LL);
  }
LABEL_43:
  v197 = (pthread_rwlock_t *)(v6 + 16);
  pthread_rwlock_rdlock((unsigned int *)v6 + 32);
  v40 = v6[15];
  while ( v40 )
  {
    --v40;
    v41 = v6[14] + 24 * v40;
    if ( !(unsigned int)strcmp(*(unsigned __int64 **)v41, v39) )
      goto LABEL_46;
  }
  pthread_rwlock_unlock(&v197->__lock);
  pthread_rwlock_wrlock(v197);
  v89 = v6[14];
  v90 = v6[15];
  v91 = 24 * v90;
  v92 = (unsigned __int64 **)(v89 + 24 * v90 - 24);
  while ( v90 )
  {
    v41 = (__int64)v92;
    --v90;
    v93 = *v92;
    v92 -= 3;
    if ( !(unsigned int)strcmp(v93, v39) )
      goto LABEL_46;
  }
  if ( v89 )
    v101 = realloc(v89, v91 + 24, v75, v76, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88);
  else
    v101 = malloc(v91 + 24, v74, v75, v76, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87, v88);
  if ( !v101 || (v6[14] = v101, v102 = strdup(), (v103 = (unsigned __int64)v102) == 0) )
  {
    v27 = -1LL;
    pthread_rwlock_unlock(&v197->__lock);
    return v27;
  }
  v41 = v101 + v91;
  *(_QWORD *)(v101 + v91) = v102;
  *(_QWORD *)(v101 + v91 + 8) = -1LL;
  msg = nl_find_msg(a1, a2, &qword_454610, 0LL, &v200);
  v111 = msg;
  if ( msg == -1 )
    return v111;
  if ( !msg )
    goto LABEL_87;
  v112 = strstr(msg, (int8x16_t *)"charset=", v105, v106, v107, v108, v109, v110, v190);
  if ( !v112 )
    goto LABEL_87;
  v113 = strcspn(v112 + 8, " \t\n");
  *((_BYTE *)j_memcpy() + v113) = 0;
  _gconv_create_spec((__int64)v201);
  v202 = 1;
  v114 = _gconv_open((__int64)v201, (unsigned __int64 *)(v41 + 8), 1u);
  _gconv_destroy_spec(v201, v115, v116, v117, v118, v119, v120, v121, v122);
  if ( !v114 )
    goto LABEL_87;
  if ( v114 != -1 )
  {
    pthread_rwlock_unlock(&v197->__lock);
    free(v103, v182, v183, v184, v185, v186, v187, v188, v189);
    return 0LL;
  }
  *(_QWORD *)(v41 + 8) = -1LL;
LABEL_87:
  v123 = v6[15];
  *(_QWORD *)(v41 + 16) = 0LL;
  v6[15] = v123 + 1;
LABEL_46:
  pthread_rwlock_unlock(&v197->__lock);
  if ( *(_QWORD *)(v41 + 8) == -1LL )
    goto LABEL_24;
  v42 = *(_QWORD *)(v41 + 16);
  if ( !v42 )
  {
    _aarch64_cas4_acq();
    if ( v139 )
      _lll_lock_wait_private(
        lock_4,
        v131,
        v132,
        v133,
        v134,
        v135,
        v136,
        v137,
        v138,
        v124,
        v125,
        (__int64)v126,
        v127,
        v128,
        v129);
    if ( !*(_QWORD *)(v41 + 16) )
    {
      v181 = calloc(
               v7 + *((_DWORD *)v6 + 16),
               8uLL,
               v125,
               v126,
               v131,
               v132,
               v133,
               v134,
               v135,
               v136,
               v137,
               v138,
               (__int64)v127,
               v128,
               (__int64)v129,
               v130);
      if ( v181 )
      {
        *(_QWORD *)(v41 + 16) = v181;
        goto LABEL_61;
      }
      *(_QWORD *)(v41 + 16) = -1LL;
    }
    _aarch64_swp4_rel();
    if ( v146 > 1 )
      _lll_lock_wake_private(lock_4, v140, v141, v142, v143, v144, v145);
    v42 = *(_QWORD *)(v41 + 16);
  }
  if ( v42 == -1 )
    return -1LL;
  v43 = *(__int64 **)(v42 + 8 * v24);
  if ( v43 )
  {
LABEL_50:
    v27 = (__int64)(v43 + 1);
    v198 = *v43;
    goto LABEL_24;
  }
  _aarch64_cas4_acq();
  if ( v60 )
    _lll_lock_wait_private(lock_4, v52, v53, v54, v55, v56, v57, v58, v59, v45, v46, (__int64)v47, v48, v49, v50);
LABEL_61:
  v61 = freemem_size_2;
  v199 = v27;
  v200 = (_QWORD *)(freemem_3 + 8);
  if ( (unsigned __int64)freemem_size_2 <= 7 )
    goto LABEL_63;
  v62 = 0;
  while ( 2 )
  {
    v64 = _gconv(*(_QWORD **)(v41 + 8), &v199, v199 + v198, (__int64 *)&v200, (__int64)v200 + v61 - 8, v201);
    if ( (v64 & 0xFFFFFFFB) == 0 )
    {
      v170 = 8 * v24;
      v171 = (__int64)v200;
      v172 = freemem_3;
      *(_QWORD *)freemem_3 = (char *)v200 - freemem_3 - 8;
      *(_QWORD *)(*(_QWORD *)(v41 + 16) + v170) = v172;
      v173 = freemem_size_2 - (v171 - v172);
      freemem_3 = v171 + (v173 & 7);
      freemem_size_2 = v173 & 0xFFFFFFFFFFFFFFF8LL;
      _aarch64_swp4_rel();
      if ( v180 > 1 )
        _lll_lock_wake_private(lock_4, v174, v175, v176, v177, v178, v179);
      v43 = *(__int64 **)(*(_QWORD *)(v41 + 16) + v170);
      goto LABEL_50;
    }
    if ( v64 != 5 )
    {
      _aarch64_swp4_rel();
      if ( v169 > 1 )
        _lll_lock_wake_private(lock_4, v163, v164, v165, v166, v167, v168);
      return 0LL;
    }
    v199 = v27;
    if ( !v62 )
    {
LABEL_63:
      v63 = (_QWORD *)malloc(4080LL, v61, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59);
      if ( !v63 )
        goto LABEL_76;
      v62 = 1;
      *v63 = transmem_list;
      v61 = 4072LL;
      goto LABEL_65;
    }
    ++v62;
    v65 = (__int64 *)transmem_list;
    v63 = (_QWORD *)realloc(
                      transmem_list,
                      4080 * v62,
                      v46,
                      v47,
                      v48,
                      v49,
                      v50,
                      v51,
                      v52,
                      v53,
                      v54,
                      v55,
                      v56,
                      v57,
                      v58,
                      v59);
    if ( v63 )
    {
      v61 = 4080 * v62 - 8LL;
LABEL_65:
      freemem_3 = (__int64)(v63 + 1);
      freemem_size_2 = v61;
      transmem_list = (__int64)v63;
      v200 = v63 + 2;
      continue;
    }
    break;
  }
  transmem_list = *v65;
  free((unsigned __int64)v65, v66, v67, v68, v69, v70, v71, v72, v73);
LABEL_76:
  freemem_3 = 0LL;
  freemem_size_2 = 0LL;
  _aarch64_swp4_rel();
  if ( v100 <= 1 )
    return -1LL;
  v27 = -1LL;
  _lll_lock_wake_private(lock_4, v94, v95, v96, v97, v98, v99);
  return v27;
}
// 429388: variable 'v60' is possibly undefined
// 429744: variable 'v52' is possibly undefined
// 429744: variable 'v53' is possibly undefined
// 429744: variable 'v54' is possibly undefined
// 429744: variable 'v55' is possibly undefined
// 429744: variable 'v56' is possibly undefined
// 429744: variable 'v57' is possibly undefined
// 429744: variable 'v58' is possibly undefined
// 429744: variable 'v59' is possibly undefined
// 429744: variable 'v45' is possibly undefined
// 429744: variable 'v46' is possibly undefined
// 429744: variable 'v47' is possibly undefined
// 429744: variable 'v48' is possibly undefined
// 429744: variable 'v49' is possibly undefined
// 429744: variable 'v50' is possibly undefined
// 4293BC: variable 'v61' is possibly undefined
// 4293BC: variable 'v51' is possibly undefined
// 4294CC: variable 'v66' is possibly undefined
// 4294CC: variable 'v67' is possibly undefined
// 4294CC: variable 'v68' is possibly undefined
// 4294CC: variable 'v69' is possibly undefined
// 4294CC: variable 'v70' is possibly undefined
// 4294CC: variable 'v71' is possibly undefined
// 4294CC: variable 'v72' is possibly undefined
// 4294CC: variable 'v73' is possibly undefined
// 4294E8: variable 'v100' is possibly undefined
// 4294FC: variable 'v94' is possibly undefined
// 4294FC: variable 'v95' is possibly undefined
// 4294FC: variable 'v96' is possibly undefined
// 4294FC: variable 'v97' is possibly undefined
// 4294FC: variable 'v98' is possibly undefined
// 4294FC: variable 'v99' is possibly undefined
// 429514: variable 'v75' is possibly undefined
// 429514: variable 'v76' is possibly undefined
// 429514: variable 'v77' is possibly undefined
// 429514: variable 'v78' is possibly undefined
// 429514: variable 'v79' is possibly undefined
// 429514: variable 'v80' is possibly undefined
// 429514: variable 'v81' is possibly undefined
// 429514: variable 'v82' is possibly undefined
// 429514: variable 'v83' is possibly undefined
// 429514: variable 'v84' is possibly undefined
// 429514: variable 'v85' is possibly undefined
// 429514: variable 'v86' is possibly undefined
// 429514: variable 'v87' is possibly undefined
// 429514: variable 'v88' is possibly undefined
// 429578: variable 'v105' is possibly undefined
// 429578: variable 'v106' is possibly undefined
// 429578: variable 'v107' is possibly undefined
// 429578: variable 'v108' is possibly undefined
// 429578: variable 'v109' is possibly undefined
// 429578: variable 'v110' is possibly undefined
// 429578: variable 'v190' is possibly undefined
// 4295E8: variable 'v115' is possibly undefined
// 4295E8: variable 'v116' is possibly undefined
// 4295E8: variable 'v117' is possibly undefined
// 4295E8: variable 'v118' is possibly undefined
// 4295E8: variable 'v119' is possibly undefined
// 4295E8: variable 'v120' is possibly undefined
// 4295E8: variable 'v121' is possibly undefined
// 4295E8: variable 'v122' is possibly undefined
// 42961C: variable 'v139' is possibly undefined
// 429784: variable 'v131' is possibly undefined
// 429784: variable 'v132' is possibly undefined
// 429784: variable 'v133' is possibly undefined
// 429784: variable 'v134' is possibly undefined
// 429784: variable 'v135' is possibly undefined
// 429784: variable 'v136' is possibly undefined
// 429784: variable 'v137' is possibly undefined
// 429784: variable 'v138' is possibly undefined
// 429784: variable 'v124' is possibly undefined
// 429784: variable 'v125' is possibly undefined
// 429784: variable 'v126' is possibly undefined
// 429784: variable 'v127' is possibly undefined
// 429784: variable 'v128' is possibly undefined
// 429784: variable 'v129' is possibly undefined
// 429640: variable 'v146' is possibly undefined
// 429650: variable 'v140' is possibly undefined
// 429650: variable 'v141' is possibly undefined
// 429650: variable 'v142' is possibly undefined
// 429650: variable 'v143' is possibly undefined
// 429650: variable 'v144' is possibly undefined
// 429650: variable 'v145' is possibly undefined
// 429668: variable 'v148' is possibly undefined
// 429668: variable 'v149' is possibly undefined
// 429668: variable 'v150' is possibly undefined
// 429668: variable 'v151' is possibly undefined
// 429668: variable 'v152' is possibly undefined
// 429668: variable 'v153' is possibly undefined
// 429668: variable 'v154' is possibly undefined
// 429668: variable 'v155' is possibly undefined
// 429668: variable 'v156' is possibly undefined
// 429668: variable 'v157' is possibly undefined
// 429668: variable 'v158' is possibly undefined
// 429668: variable 'v159' is possibly undefined
// 429668: variable 'v160' is possibly undefined
// 429668: variable 'v161' is possibly undefined
// 429668: variable 'v162' is possibly undefined
// 4296A8: variable 'v169' is possibly undefined
// 4296B0: variable 'v163' is possibly undefined
// 4296B0: variable 'v164' is possibly undefined
// 4296B0: variable 'v165' is possibly undefined
// 4296B0: variable 'v166' is possibly undefined
// 4296B0: variable 'v167' is possibly undefined
// 4296B0: variable 'v168' is possibly undefined
// 429708: variable 'v180' is possibly undefined
// 429790: variable 'v174' is possibly undefined
// 429790: variable 'v175' is possibly undefined
// 429790: variable 'v176' is possibly undefined
// 429790: variable 'v177' is possibly undefined
// 429790: variable 'v178' is possibly undefined
// 429790: variable 'v179' is possibly undefined
// 429718: variable 'v74' is possibly undefined
// 429730: variable 'v130' is possibly undefined
// 429770: variable 'v182' is possibly undefined
// 429770: variable 'v183' is possibly undefined
// 429770: variable 'v184' is possibly undefined
// 429770: variable 'v185' is possibly undefined
// 429770: variable 'v186' is possibly undefined
// 429770: variable 'v187' is possibly undefined
// 429770: variable 'v188' is possibly undefined
// 429770: variable 'v189' is possibly undefined
// 454610: using guessed type __int64 qword_454610;
// 496DB0: using guessed type int output_charset_cached_1;
// 496DB8: using guessed type __int64 output_charset_cache_0;
// 496DC0: using guessed type _DWORD lock_4[2];
// 496DC8: using guessed type __int64 freemem_3;
// 496DD0: using guessed type __int64 freemem_size_2;
// 496DD8: using guessed type __int64 transmem_list;

//----- (00000000004297C0) ----------------------------------------------------
unsigned __int64 *__fastcall _dcigettext(
        unsigned __int64 *a1,
        unsigned __int64 *a2,
        __int64 a3,
        int a4,
        __int64 a5,
        unsigned int a6)
{
  bool v10; // zf
  unsigned __int64 v11; // x3
  unsigned __int64 *v13; // x22
  __int64 *v14; // x23
  _QWORD *v15; // x0
  _QWORD *v16; // x28
  int v17; // w0
  __int64 v18; // x2
  void *v19; // x3
  void *v20; // x4
  void *v21; // x5
  void *v22; // x6
  __int64 v23; // x7
  double v24; // d0
  double v25; // d1
  double v26; // d2
  double v27; // d3
  double v28; // d4
  double v29; // d5
  double v30; // d6
  double v31; // d7
  const char *v32; // x24
  char *v33; // x19
  unsigned __int8 *v34; // x26
  int v35; // w0
  bool v36; // zf
  char *v37; // x0
  unsigned __int64 (__fastcall *v38)(__int64); // x25
  unsigned __int64 (__fastcall *v39)(__int64); // x0
  __int64 v40; // x1
  __int64 v41; // x2
  void *v42; // x3
  void *v43; // x4
  void *v44; // x5
  void *v45; // x6
  __int64 v46; // x7
  double v47; // d0
  double v48; // d1
  double v49; // d2
  double v50; // d3
  double v51; // d4
  double v52; // d5
  double v53; // d6
  double v54; // d7
  _QWORD *v55; // x0
  double v56; // d0
  double v57; // d1
  double v58; // d2
  double v59; // d3
  double v60; // d4
  double v61; // d5
  double v62; // d6
  double v63; // d7
  unsigned __int64 v64; // x23
  unsigned __int64 (__fastcall *v65)(__int64); // x0
  __int64 v66; // x1
  __int64 v67; // x2
  void *v68; // x3
  void *v69; // x4
  void *v70; // x5
  void *v71; // x6
  __int64 v72; // x7
  double v73; // d0
  double v74; // d1
  double v75; // d2
  double v76; // d3
  double v77; // d4
  double v78; // d5
  double v79; // d6
  double v80; // d7
  unsigned __int64 v81; // x0
  unsigned __int64 v82; // x19
  __int64 v83; // x27
  int v84; // w0
  double v85; // d0
  double v86; // d1
  double v87; // d2
  double v88; // d3
  double v89; // d4
  double v90; // d5
  double v91; // d6
  double v92; // d7
  double v93; // d0
  double v94; // d1
  double v95; // d2
  double v96; // d3
  double v97; // d4
  double v98; // d5
  double v99; // d6
  double v100; // d7
  bool v101; // zf
  const char *v102; // x0
  unsigned __int64 v103; // x23
  int v104; // w19
  double v105; // d0
  double v106; // d1
  double v107; // d2
  double v108; // d3
  double v109; // d4
  double v110; // d5
  double v111; // d6
  double v112; // d7
  _BYTE *v113; // x1
  int v114; // t1
  unsigned __int64 domain; // x0
  unsigned __int64 v117; // x19
  __int64 msg; // x3
  unsigned __int64 v119; // x0
  unsigned __int64 v120; // x27
  double v121; // d0
  double v122; // d1
  double v123; // d2
  double v124; // d3
  double v125; // d4
  double v126; // d5
  double v127; // d6
  double v128; // d7
  double v129; // d0
  double v130; // d1
  double v131; // d2
  double v132; // d3
  double v133; // d4
  double v134; // d5
  double v135; // d6
  double v136; // d7
  __int64 v137; // x3
  __int64 v138; // x0
  int v139; // w1
  __int64 v140; // x0
  __int64 v141; // x24
  __int64 v142; // x0
  unsigned __int64 v143; // x3
  __int64 v144; // x20
  __int64 v145; // x19
  unsigned __int64 v146; // x21
  unsigned __int64 v147; // x19
  unsigned __int64 v148; // x20
  char *v149; // x19
  unsigned __int64 (__fastcall *v150)(__int64); // x0
  __int64 v151; // x2
  void *v152; // x3
  void *v153; // x4
  void *v154; // x5
  void *v155; // x6
  __int64 v156; // x7
  double v157; // d0
  double v158; // d1
  double v159; // d2
  double v160; // d3
  double v161; // d4
  double v162; // d5
  double v163; // d6
  double v164; // d7
  unsigned __int64 v165; // x23
  char *v166; // x20
  _QWORD *v167; // x19
  int v168; // w0
  void *v169; // x3
  void *v170; // x4
  void *v171; // x5
  __int64 *v172; // x6
  __int64 v173; // x7
  double v174; // d0
  double v175; // d1
  double v176; // d2
  double v177; // d3
  double v178; // d4
  double v179; // d5
  double v180; // d6
  double v181; // d7
  _QWORD *v182; // x19
  double v183; // d0
  double v184; // d1
  double v185; // d2
  double v186; // d3
  double v187; // d4
  double v188; // d5
  double v189; // d6
  double v190; // d7
  __int64 v191; // x19
  __int64 v192; // x21
  unsigned __int64 v193; // x20
  unsigned __int64 v194; // x19
  unsigned __int64 v195; // x21
  int v196; // w0
  __int64 v198; // [xsp+68h] [xbp+68h]
  __int64 v199; // [xsp+68h] [xbp+68h]
  unsigned __int64 v200; // [xsp+68h] [xbp+68h]
  unsigned __int64 v201; // [xsp+68h] [xbp+68h]
  __int64 v202; // [xsp+68h] [xbp+68h]
  int v206; // [xsp+8Ch] [xbp+8Ch]
  unsigned __int64 StatusReg; // [xsp+90h] [xbp+90h]
  __int64 *v208; // [xsp+A0h] [xbp+A0h]
  unsigned __int64 v209; // [xsp+A8h] [xbp+A8h]
  unsigned __int64 v210; // [xsp+B8h] [xbp+B8h]
  const char *v211; // [xsp+C8h] [xbp+C8h]
  const char *v212; // [xsp+D0h] [xbp+D0h] BYREF
  __int64 v213; // [xsp+D8h] [xbp+D8h] BYREF
  unsigned __int64 *v214; // [xsp+E0h] [xbp+E0h] BYREF
  unsigned int v215; // [xsp+E8h] [xbp+E8h]
  unsigned __int64 v216; // [xsp+F0h] [xbp+F0h]
  __int64 v217; // [xsp+100h] [xbp+100h]
  unsigned __int64 *v218; // [xsp+118h] [xbp+118h]

  v212 = 0LL;
  if ( !a2 )
    return 0LL;
  if ( a6 > 0xC || a6 == 6 )
  {
    if ( a4 )
      v10 = a5 == 1;
    else
      v10 = 1;
    if ( !v10 )
      return (unsigned __int64 *)a3;
    return a2;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v206 = *(_DWORD *)(StatusReg + 40);
  pthread_rwlock_rdlock(_libc_setlocale_lock);
  pthread_rwlock_rdlock(nl_state_lock);
  v215 = a6;
  v13 = (unsigned __int64 *)nl_current_default_domain;
  v217 = 0LL;
  if ( a1 )
    v13 = a1;
  v214 = v13;
  v218 = a2;
  v209 = _current_locale_name(a6);
  v216 = v209;
  pthread_rwlock_rdlock((unsigned int *)&tree_lock);
  v14 = tfind((__int64)&v214, (unsigned __int64 *)&root, (__int64 (__fastcall *)(__int64, _QWORD))transcmp);
  v208 = v14;
  pthread_rwlock_unlock(&tree_lock.__lock);
  if ( v14 )
  {
    v15 = (_QWORD *)*v14;
    if ( *(_DWORD *)(*v14 + 24) == nl_msg_cat_cntr )
    {
      v143 = v15[5];
      if ( a4 )
      {
        v144 = v15[6];
        v201 = v15[5];
        v145 = *(_QWORD *)(v15[4] + 16LL);
        v146 = plural_eval(*(int **)(v145 + 184), a5);
        v143 = v201;
        if ( v146 < *(_QWORD *)(v145 + 192) )
        {
          v147 = v201;
          v148 = v201 + v144;
          while ( v146 )
          {
            --v146;
            v147 += (unsigned __int64)strlen() + 1;
            if ( v147 >= v148 )
            {
              v143 = v201;
              goto LABEL_76;
            }
          }
          v143 = v147;
        }
      }
LABEL_76:
      v200 = v143;
      pthread_rwlock_unlock((int *)nl_state_lock);
      pthread_rwlock_unlock((int *)_libc_setlocale_lock);
      v11 = v200;
      *(_DWORD *)(StatusReg + 40) = v206;
      return (unsigned __int64 *)v11;
    }
  }
  v16 = (_QWORD *)nl_domain_bindings;
  if ( nl_domain_bindings )
  {
    while ( 1 )
    {
      v17 = strcmp(v13, (unsigned __int64)(v16 + 3));
      if ( !v17 )
        break;
      if ( v17 < 0 )
      {
        v16 = 0LL;
        v32 = "/usr/share/locale";
        goto LABEL_24;
      }
      v16 = (_QWORD *)*v16;
      if ( !v16 )
        goto LABEL_70;
    }
    v32 = (const char *)v16[1];
    if ( *v32 == 47 )
      goto LABEL_24;
    v102 = (const char *)getcwd(0LL, 0LL, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31);
    v103 = (unsigned __int64)v102;
    if ( v102 )
    {
      v104 = asprintf((unsigned __int64 *)&v212, (__int64)"%s/%s", v102, v32);
      free(v103, v105, v106, v107, v108, v109, v110, v111, v112);
      if ( (v104 & 0x80000000) == 0 )
      {
        v32 = v212;
        goto LABEL_24;
      }
    }
    goto LABEL_74;
  }
LABEL_70:
  v32 = "/usr/share/locale";
LABEL_24:
  v33 = &nl_category_names[(unsigned __int8)nl_category_name_idxs[a6]];
  v34 = (unsigned __int8 *)_current_locale_name(a6);
  if ( *v34 != 67 || ((v35 = v34[1], v35 != 46) ? (v36 = v35 == 0) : (v36 = 1), !v36) )
  {
    v37 = getenv("LANGUAGE");
    if ( v37 )
    {
      if ( *v37 )
        v34 = (unsigned __int8 *)v37;
    }
  }
  v38 = strlen();
  v39 = strlen();
  v55 = (_QWORD *)malloc(
                    (__int64)v38 + (_QWORD)v39 + 5,
                    v40,
                    v41,
                    v42,
                    v43,
                    v44,
                    v45,
                    v46,
                    v47,
                    v48,
                    v49,
                    v50,
                    v51,
                    v52,
                    v53,
                    v54);
  v64 = (unsigned __int64)v55;
  if ( !v55 )
  {
LABEL_74:
    v82 = 0LL;
    v64 = 0LL;
    goto LABEL_38;
  }
  *(_WORD *)stpcpy(v55, (unsigned __int64)v33) = 47;
  *(_DWORD *)((char *)v38 + (_QWORD)j_memcpy()) = 7302446;
  v65 = strlen();
  v81 = malloc((__int64)v65 + 1, v66, v67, v68, v69, v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80);
  v82 = v81;
  if ( v81 )
  {
    v83 = v81;
    while ( 1 )
    {
      do
      {
        do
        {
LABEL_35:
          while ( 1 )
          {
            v84 = *v34;
            if ( v84 != 58 )
              break;
            ++v34;
          }
          if ( !*v34 )
          {
            *(_WORD *)v83 = 67;
            v82 = v83;
            goto LABEL_38;
          }
          v113 = (_BYTE *)v83;
          do
          {
            *v113++ = v84;
            v114 = *++v34;
            v84 = v114;
          }
          while ( v114 != 58 && v84 != 0 );
          *v113 = 0;
        }
        while ( _libc_enable_secure && strchr(v83, 0x2Fu) );
        if ( *(_BYTE *)v83 == 67 )
        {
          v196 = *(unsigned __int8 *)(v83 + 1);
          if ( v196 == 46 || v196 == 0 )
            goto LABEL_69;
        }
        if ( !(unsigned int)strcmp((unsigned __int64 *)v83, (unsigned __int64)"POSIX") )
          goto LABEL_69;
        domain = nl_find_domain((unsigned __int64)v32, (unsigned __int8 *)v83, v64, (__int64)v16);
        v117 = domain;
      }
      while ( !domain );
      msg = nl_find_msg(domain, (__int64)v16, a2, 1, &v213);
      if ( msg )
        break;
      v140 = *(_QWORD *)(v117 + 32);
      if ( v140 )
      {
        v210 = v117;
        v211 = v32;
        v141 = 0LL;
        while ( 1 )
        {
          v142 = nl_find_msg(v140, (__int64)v16, a2, 1, &v213);
          if ( v142 == -1 )
            break;
          if ( v142 )
          {
            v82 = v83;
            msg = v142;
            v120 = *(_QWORD *)(v210 + 8LL * (int)v141 + 32);
            goto LABEL_60;
          }
          ++v141;
          v140 = *(_QWORD *)(v117 + 32 + 8 * v141);
          if ( !v140 )
          {
            v32 = v211;
            goto LABEL_35;
          }
        }
LABEL_69:
        v82 = v83;
        goto LABEL_38;
      }
    }
    v119 = v83;
    v120 = v117;
    v82 = v119;
    if ( msg == -1 )
      goto LABEL_38;
LABEL_60:
    v198 = msg;
    free((unsigned __int64)v212, v56, v57, v58, v59, v60, v61, v62, v63);
    free(v64, v121, v122, v123, v124, v125, v126, v127, v128);
    free(v82, v129, v130, v131, v132, v133, v134, v135, v136);
    v137 = v198;
    if ( v208 )
    {
      v138 = *v208;
      v139 = nl_msg_cat_cntr;
      *(_QWORD *)(v138 + 32) = v120;
      *(_QWORD *)(v138 + 40) = v198;
      *(_DWORD *)(v138 + 24) = v139;
      *(_QWORD *)(v138 + 48) = v213;
    }
    else
    {
      v149 = (char *)strlen() + 1;
      v150 = strlen();
      v165 = malloc(
               (__int64)&v149[(_QWORD)v150 + (unsigned __int64)v38 + 58],
               (__int64)v38 + 58,
               v151,
               v152,
               v153,
               v154,
               v155,
               v156,
               v157,
               v158,
               v159,
               v160,
               v161,
               v162,
               v163,
               v164);
      v137 = v198;
      if ( v165 )
      {
        v166 = &v149[(_QWORD)j_memcpy()];
        v167 = (_QWORD *)((char *)v38 + (_QWORD)v166 + 1);
        j_memcpy();
        strcpy(v167, v209);
        *(_QWORD *)v165 = v166;
        *(_DWORD *)(v165 + 8) = a6;
        *(_QWORD *)(v165 + 16) = v167;
        v168 = nl_msg_cat_cntr;
        *(_QWORD *)(v165 + 32) = v120;
        *(_QWORD *)(v165 + 40) = v198;
        *(_DWORD *)(v165 + 24) = v168;
        *(_QWORD *)(v165 + 48) = v213;
        pthread_rwlock_wrlock(&tree_lock);
        v182 = tsearch(
                 v165,
                 &root,
                 (__int64 (__fastcall *)(__int64, _QWORD))transcmp,
                 v169,
                 v170,
                 v171,
                 v172,
                 v173,
                 v174,
                 v175,
                 v176,
                 v177,
                 v178,
                 v179,
                 v180,
                 v181);
        pthread_rwlock_unlock(&tree_lock.__lock);
        v137 = v198;
        if ( !v182 || *v182 != v165 )
        {
          free(v165, v183, v184, v185, v186, v187, v188, v189, v190);
          v137 = v198;
        }
      }
    }
    *(_DWORD *)(StatusReg + 40) = v206;
    if ( a4 )
    {
      v191 = *(_QWORD *)(v120 + 16);
      v202 = v137;
      v192 = v213;
      v193 = plural_eval(*(int **)(v191 + 184), a5);
      v137 = v202;
      if ( v193 < *(_QWORD *)(v191 + 192) )
      {
        v194 = v202;
        v195 = v202 + v192;
        while ( v193 )
        {
          --v193;
          v194 += (unsigned __int64)strlen() + 1;
          if ( v194 >= v195 )
          {
            v137 = v202;
            goto LABEL_63;
          }
        }
        v137 = v194;
      }
    }
LABEL_63:
    v199 = v137;
    pthread_rwlock_unlock((int *)nl_state_lock);
    pthread_rwlock_unlock((int *)_libc_setlocale_lock);
    return (unsigned __int64 *)v199;
  }
LABEL_38:
  free((unsigned __int64)v212, v56, v57, v58, v59, v60, v61, v62, v63);
  free(v64, v85, v86, v87, v88, v89, v90, v91, v92);
  free(v82, v93, v94, v95, v96, v97, v98, v99, v100);
  pthread_rwlock_unlock((int *)nl_state_lock);
  pthread_rwlock_unlock((int *)_libc_setlocale_lock);
  *(_DWORD *)(StatusReg + 40) = v206;
  if ( a4 )
    v101 = a5 == 1;
  else
    v101 = 1;
  if ( v101 )
    return a2;
  return (unsigned __int64 *)a3;
}
// 429998: variable 'v40' is possibly undefined
// 429998: variable 'v41' is possibly undefined
// 429998: variable 'v42' is possibly undefined
// 429998: variable 'v43' is possibly undefined
// 429998: variable 'v44' is possibly undefined
// 429998: variable 'v45' is possibly undefined
// 429998: variable 'v46' is possibly undefined
// 429998: variable 'v47' is possibly undefined
// 429998: variable 'v48' is possibly undefined
// 429998: variable 'v49' is possibly undefined
// 429998: variable 'v50' is possibly undefined
// 429998: variable 'v51' is possibly undefined
// 429998: variable 'v52' is possibly undefined
// 429998: variable 'v53' is possibly undefined
// 429998: variable 'v54' is possibly undefined
// 4299D8: variable 'v66' is possibly undefined
// 4299D8: variable 'v67' is possibly undefined
// 4299D8: variable 'v68' is possibly undefined
// 4299D8: variable 'v69' is possibly undefined
// 4299D8: variable 'v70' is possibly undefined
// 4299D8: variable 'v71' is possibly undefined
// 4299D8: variable 'v72' is possibly undefined
// 4299D8: variable 'v73' is possibly undefined
// 4299D8: variable 'v74' is possibly undefined
// 4299D8: variable 'v75' is possibly undefined
// 4299D8: variable 'v76' is possibly undefined
// 4299D8: variable 'v77' is possibly undefined
// 4299D8: variable 'v78' is possibly undefined
// 4299D8: variable 'v79' is possibly undefined
// 4299D8: variable 'v80' is possibly undefined
// 429A28: variable 'v56' is possibly undefined
// 429A28: variable 'v57' is possibly undefined
// 429A28: variable 'v58' is possibly undefined
// 429A28: variable 'v59' is possibly undefined
// 429A28: variable 'v60' is possibly undefined
// 429A28: variable 'v61' is possibly undefined
// 429A28: variable 'v62' is possibly undefined
// 429A28: variable 'v63' is possibly undefined
// 429A30: variable 'v85' is possibly undefined
// 429A30: variable 'v86' is possibly undefined
// 429A30: variable 'v87' is possibly undefined
// 429A30: variable 'v88' is possibly undefined
// 429A30: variable 'v89' is possibly undefined
// 429A30: variable 'v90' is possibly undefined
// 429A30: variable 'v91' is possibly undefined
// 429A30: variable 'v92' is possibly undefined
// 429A38: variable 'v93' is possibly undefined
// 429A38: variable 'v94' is possibly undefined
// 429A38: variable 'v95' is possibly undefined
// 429A38: variable 'v96' is possibly undefined
// 429A38: variable 'v97' is possibly undefined
// 429A38: variable 'v98' is possibly undefined
// 429A38: variable 'v99' is possibly undefined
// 429A38: variable 'v100' is possibly undefined
// 429AA0: variable 'v18' is possibly undefined
// 429AA0: variable 'v19' is possibly undefined
// 429AA0: variable 'v20' is possibly undefined
// 429AA0: variable 'v21' is possibly undefined
// 429AA0: variable 'v22' is possibly undefined
// 429AA0: variable 'v23' is possibly undefined
// 429AA0: variable 'v24' is possibly undefined
// 429AA0: variable 'v25' is possibly undefined
// 429AA0: variable 'v26' is possibly undefined
// 429AA0: variable 'v27' is possibly undefined
// 429AA0: variable 'v28' is possibly undefined
// 429AA0: variable 'v29' is possibly undefined
// 429AA0: variable 'v30' is possibly undefined
// 429AA0: variable 'v31' is possibly undefined
// 429ACC: variable 'v105' is possibly undefined
// 429ACC: variable 'v106' is possibly undefined
// 429ACC: variable 'v107' is possibly undefined
// 429ACC: variable 'v108' is possibly undefined
// 429ACC: variable 'v109' is possibly undefined
// 429ACC: variable 'v110' is possibly undefined
// 429ACC: variable 'v111' is possibly undefined
// 429ACC: variable 'v112' is possibly undefined
// 429B98: variable 'v121' is possibly undefined
// 429B98: variable 'v122' is possibly undefined
// 429B98: variable 'v123' is possibly undefined
// 429B98: variable 'v124' is possibly undefined
// 429B98: variable 'v125' is possibly undefined
// 429B98: variable 'v126' is possibly undefined
// 429B98: variable 'v127' is possibly undefined
// 429B98: variable 'v128' is possibly undefined
// 429BA0: variable 'v129' is possibly undefined
// 429BA0: variable 'v130' is possibly undefined
// 429BA0: variable 'v131' is possibly undefined
// 429BA0: variable 'v132' is possibly undefined
// 429BA0: variable 'v133' is possibly undefined
// 429BA0: variable 'v134' is possibly undefined
// 429BA0: variable 'v135' is possibly undefined
// 429BA0: variable 'v136' is possibly undefined
// 429DAC: variable 'v151' is possibly undefined
// 429DAC: variable 'v152' is possibly undefined
// 429DAC: variable 'v153' is possibly undefined
// 429DAC: variable 'v154' is possibly undefined
// 429DAC: variable 'v155' is possibly undefined
// 429DAC: variable 'v156' is possibly undefined
// 429DAC: variable 'v157' is possibly undefined
// 429DAC: variable 'v158' is possibly undefined
// 429DAC: variable 'v159' is possibly undefined
// 429DAC: variable 'v160' is possibly undefined
// 429DAC: variable 'v161' is possibly undefined
// 429DAC: variable 'v162' is possibly undefined
// 429DAC: variable 'v163' is possibly undefined
// 429DAC: variable 'v164' is possibly undefined
// 429E48: variable 'v169' is possibly undefined
// 429E48: variable 'v170' is possibly undefined
// 429E48: variable 'v171' is possibly undefined
// 429E48: variable 'v172' is possibly undefined
// 429E48: variable 'v173' is possibly undefined
// 429E48: variable 'v174' is possibly undefined
// 429E48: variable 'v175' is possibly undefined
// 429E48: variable 'v176' is possibly undefined
// 429E48: variable 'v177' is possibly undefined
// 429E48: variable 'v178' is possibly undefined
// 429E48: variable 'v179' is possibly undefined
// 429E48: variable 'v180' is possibly undefined
// 429E48: variable 'v181' is possibly undefined
// 429E74: variable 'v183' is possibly undefined
// 429E74: variable 'v184' is possibly undefined
// 429E74: variable 'v185' is possibly undefined
// 429E74: variable 'v186' is possibly undefined
// 429E74: variable 'v187' is possibly undefined
// 429E74: variable 'v188' is possibly undefined
// 429E74: variable 'v189' is possibly undefined
// 429E74: variable 'v190' is possibly undefined
// 491570: using guessed type int _libc_enable_secure;
// 491908: using guessed type __int64 nl_current_default_domain;
// 496D78: using guessed type unsigned int _libc_setlocale_lock[14];
// 496DE0: using guessed type unsigned int nl_state_lock[14];
// 496E18: using guessed type pthread_rwlock_t tree_lock;
// 496E50: using guessed type __int64 root;
// 496E58: using guessed type __int64 nl_domain_bindings;
// 496EB0: using guessed type int nl_msg_cat_cntr;

//----- (0000000000429F2C) ----------------------------------------------------
void __fastcall _intl_freemem(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  __int64 *i; // x19
  char *v9; // x0
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7
  double v18; // d0
  double v19; // d1
  double v20; // d2
  double v21; // d3
  double v22; // d4
  double v23; // d5
  double v24; // d6
  double v25; // d7
  _QWORD *v26; // x19
  unsigned __int64 v27; // x0

  for ( i = (__int64 *)nl_domain_bindings; nl_domain_bindings; i = (__int64 *)nl_domain_bindings )
  {
    v9 = (char *)i[1];
    nl_domain_bindings = *i;
    if ( v9 != "/usr/share/locale" )
      free((unsigned __int64)v9, a1, a2, a3, a4, a5, a6, a7, a8);
    free(i[2], a1, a2, a3, a4, a5, a6, a7, a8);
    free((unsigned __int64)i, v10, v11, v12, v13, v14, v15, v16, v17);
  }
  if ( (char *)nl_current_default_domain != "messages" )
    free(nl_current_default_domain, a1, a2, a3, a4, a5, a6, a7, a8);
  tdestroy((_QWORD *)root, (void (__fastcall *)(_QWORD))free);
  root = 0LL;
  v26 = (_QWORD *)transmem_list;
  if ( transmem_list )
  {
    do
    {
      v27 = (unsigned __int64)v26;
      v26 = (_QWORD *)*v26;
      transmem_list = (__int64)v26;
      free(v27, v18, v19, v20, v21, v22, v23, v24, v25);
    }
    while ( v26 );
  }
}
// 429F70: variable 'a1' is possibly undefined
// 429F70: variable 'a2' is possibly undefined
// 429F70: variable 'a3' is possibly undefined
// 429F70: variable 'a4' is possibly undefined
// 429F70: variable 'a5' is possibly undefined
// 429F70: variable 'a6' is possibly undefined
// 429F70: variable 'a7' is possibly undefined
// 429F70: variable 'a8' is possibly undefined
// 429F80: variable 'v10' is possibly undefined
// 429F80: variable 'v11' is possibly undefined
// 429F80: variable 'v12' is possibly undefined
// 429F80: variable 'v13' is possibly undefined
// 429F80: variable 'v14' is possibly undefined
// 429F80: variable 'v15' is possibly undefined
// 429F80: variable 'v16' is possibly undefined
// 429F80: variable 'v17' is possibly undefined
// 429FD4: variable 'v18' is possibly undefined
// 429FD4: variable 'v19' is possibly undefined
// 429FD4: variable 'v20' is possibly undefined
// 429FD4: variable 'v21' is possibly undefined
// 429FD4: variable 'v22' is possibly undefined
// 429FD4: variable 'v23' is possibly undefined
// 429FD4: variable 'v24' is possibly undefined
// 429FD4: variable 'v25' is possibly undefined
// 491908: using guessed type __int64 nl_current_default_domain;
// 496DD8: using guessed type __int64 transmem_list;
// 496E50: using guessed type __int64 root;
// 496E58: using guessed type __int64 nl_domain_bindings;

//----- (000000000042A000) ----------------------------------------------------
unsigned __int64 __fastcall nl_find_domain(unsigned __int64 a1, unsigned __int8 *a2, __int64 a3, __int64 a4)
{
  unsigned __int64 (__fastcall *v8)(__int64); // x0
  unsigned __int64 l10nflist; // x19
  __int64 v11; // x0
  _QWORD *v12; // x20
  __int64 v13; // t1
  __int64 v14; // x27
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  unsigned __int64 (__fastcall *v23)(__int64); // x0
  __int64 v24; // x1
  __int64 v25; // x2
  void *v26; // x3
  void *v27; // x4
  void *v28; // x5
  void *v29; // x6
  __int64 v30; // x7
  double v31; // d0
  double v32; // d1
  double v33; // d2
  double v34; // d3
  double v35; // d4
  double v36; // d5
  double v37; // d6
  double v38; // d7
  int v39; // w20
  char v40; // w25
  unsigned __int64 (__fastcall *v41)(__int64); // x0
  double v42; // d0
  double v43; // d1
  double v44; // d2
  double v45; // d3
  double v46; // d4
  double v47; // d5
  double v48; // d6
  double v49; // d7
  __int64 v50; // x0
  _QWORD *v51; // x20
  __int64 v52; // t1
  unsigned __int64 v53; // [xsp+88h] [xbp+68h] BYREF
  unsigned __int64 v54; // [xsp+90h] [xbp+70h] BYREF
  unsigned __int64 v55; // [xsp+98h] [xbp+78h] BYREF
  unsigned __int64 *v56; // [xsp+A0h] [xbp+80h] BYREF
  unsigned __int64 v57; // [xsp+A8h] [xbp+88h] BYREF

  pthread_rwlock_rdlock((unsigned int *)&lock_0);
  v8 = strlen();
  l10nflist = nl_make_l10nflist(
                (unsigned __int64 *)&nl_loaded_domains,
                a1,
                (__int64)v8 + 1,
                0,
                (unsigned __int64)a2,
                0LL,
                0LL,
                0LL,
                0LL,
                a3,
                0);
  pthread_rwlock_unlock(&lock_0.__lock);
  if ( l10nflist )
  {
    if ( *(int *)(l10nflist + 8) <= 0 )
      nl_load_domain(l10nflist, a4);
    if ( !*(_QWORD *)(l10nflist + 16) )
    {
      v11 = *(_QWORD *)(l10nflist + 32);
      if ( v11 )
      {
        v12 = (_QWORD *)(l10nflist + 32);
        do
        {
          if ( *(int *)(v11 + 8) <= 0 )
            nl_load_domain(v11, a4);
          if ( *(_QWORD *)(*v12 + 16LL) )
            break;
          v13 = v12[1];
          ++v12;
          v11 = v13;
        }
        while ( v13 );
      }
    }
    return l10nflist;
  }
  v14 = nl_expand_alias((__int64)a2);
  if ( v14 )
  {
    v23 = strlen();
    a2 = (unsigned __int8 *)malloc(
                              (__int64)v23 + 1,
                              v24,
                              v25,
                              v26,
                              v27,
                              v28,
                              v29,
                              v30,
                              v31,
                              v32,
                              v33,
                              v34,
                              v35,
                              v36,
                              v37,
                              v38);
    if ( !a2 )
      return l10nflist;
    j_memcpy();
  }
  v39 = nl_explode_name(a2, &v53, &v54, (char *)&v55, &v56, &v57, v15, v16, v17, v18, v19, v20, v21, v22);
  v40 = v39;
  if ( v39 != -1 )
  {
    pthread_rwlock_wrlock(&lock_0);
    v41 = strlen();
    l10nflist = nl_make_l10nflist(
                  (unsigned __int64 *)&nl_loaded_domains,
                  a1,
                  (__int64)v41 + 1,
                  v39,
                  v53,
                  v55,
                  (unsigned __int64)v56,
                  v57,
                  v54,
                  a3,
                  1);
    pthread_rwlock_unlock(&lock_0.__lock);
    if ( l10nflist )
    {
      if ( *(int *)(l10nflist + 8) <= 0 )
        nl_load_domain(l10nflist, a4);
      if ( !*(_QWORD *)(l10nflist + 16) )
      {
        v50 = *(_QWORD *)(l10nflist + 32);
        if ( v50 )
        {
          v51 = (_QWORD *)(l10nflist + 32);
          do
          {
            if ( *(int *)(v50 + 8) <= 0 )
              nl_load_domain(v50, a4);
            if ( *(_QWORD *)(*v51 + 16LL) )
              break;
            v52 = v51[1];
            ++v51;
            v50 = v52;
          }
          while ( v52 );
        }
      }
      if ( v14 )
        free((unsigned __int64)a2, v42, v43, v44, v45, v46, v47, v48, v49);
    }
    if ( (v40 & 1) != 0 )
    {
      free(v57, v42, v43, v44, v45, v46, v47, v48, v49);
      return l10nflist;
    }
  }
  return l10nflist;
}
// 42A124: variable 'v24' is possibly undefined
// 42A124: variable 'v25' is possibly undefined
// 42A124: variable 'v26' is possibly undefined
// 42A124: variable 'v27' is possibly undefined
// 42A124: variable 'v28' is possibly undefined
// 42A124: variable 'v29' is possibly undefined
// 42A124: variable 'v30' is possibly undefined
// 42A124: variable 'v31' is possibly undefined
// 42A124: variable 'v32' is possibly undefined
// 42A124: variable 'v33' is possibly undefined
// 42A124: variable 'v34' is possibly undefined
// 42A124: variable 'v35' is possibly undefined
// 42A124: variable 'v36' is possibly undefined
// 42A124: variable 'v37' is possibly undefined
// 42A124: variable 'v38' is possibly undefined
// 42A154: variable 'v15' is possibly undefined
// 42A154: variable 'v16' is possibly undefined
// 42A154: variable 'v17' is possibly undefined
// 42A154: variable 'v18' is possibly undefined
// 42A154: variable 'v19' is possibly undefined
// 42A154: variable 'v20' is possibly undefined
// 42A154: variable 'v21' is possibly undefined
// 42A154: variable 'v22' is possibly undefined
// 42A1D8: variable 'v42' is possibly undefined
// 42A1D8: variable 'v43' is possibly undefined
// 42A1D8: variable 'v44' is possibly undefined
// 42A1D8: variable 'v45' is possibly undefined
// 42A1D8: variable 'v46' is possibly undefined
// 42A1D8: variable 'v47' is possibly undefined
// 42A1D8: variable 'v48' is possibly undefined
// 42A1D8: variable 'v49' is possibly undefined
// 496E60: using guessed type pthread_rwlock_t lock_0;
// 496E98: using guessed type __int64 nl_loaded_domains;

//----- (000000000042A260) ----------------------------------------------------
void __fastcall nl_finddomain_subfreeres(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  unsigned __int64 *v8; // x19
  unsigned __int64 v9; // x0
  unsigned __int64 *v10; // x20
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7

  v8 = (unsigned __int64 *)nl_loaded_domains;
  if ( nl_loaded_domains )
  {
    while ( 1 )
    {
      v9 = v8[2];
      if ( v9 )
        nl_unload_domain(v9, a1, a2, a3, a4, a5, a6, a7, a8);
      v10 = (unsigned __int64 *)v8[3];
      free(*v8, a1, a2, a3, a4, a5, a6, a7, a8);
      free((unsigned __int64)v8, v11, v12, v13, v14, v15, v16, v17, v18);
      if ( !v10 )
        break;
      v8 = v10;
    }
  }
}
// 42A288: variable 'a1' is possibly undefined
// 42A288: variable 'a2' is possibly undefined
// 42A288: variable 'a3' is possibly undefined
// 42A288: variable 'a4' is possibly undefined
// 42A288: variable 'a5' is possibly undefined
// 42A288: variable 'a6' is possibly undefined
// 42A288: variable 'a7' is possibly undefined
// 42A288: variable 'a8' is possibly undefined
// 42A29C: variable 'v11' is possibly undefined
// 42A29C: variable 'v12' is possibly undefined
// 42A29C: variable 'v13' is possibly undefined
// 42A29C: variable 'v14' is possibly undefined
// 42A29C: variable 'v15' is possibly undefined
// 42A29C: variable 'v16' is possibly undefined
// 42A29C: variable 'v17' is possibly undefined
// 42A29C: variable 'v18' is possibly undefined
// 496E98: using guessed type __int64 nl_loaded_domains;

//----- (000000000042A2C0) ----------------------------------------------------
void __fastcall nl_load_domain(__int64 a1, __int64 a2)
{
  unsigned __int64 StatusReg; // x23
  __int64 v5; // x1
  __int64 v6; // x2
  __int64 v7; // x3
  void *v8; // x4
  void *v9; // x5
  void *v10; // x6
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7
  int v19; // w0
  int v20; // w2
  const char *v21; // x0
  int v22; // w0
  int v23; // w24
  int v24; // w27
  size_t v25; // x28
  __int64 v26; // x1
  __int64 v27; // x2
  void *v28; // x3
  void *v29; // x4
  void *v30; // x5
  void *v31; // x6
  __int64 v32; // x7
  _DWORD *v33; // x20
  double v34; // d0
  double v35; // d1
  double v36; // d2
  double v37; // d3
  double v38; // d4
  double v39; // d5
  double v40; // d6
  double v41; // d7
  __int64 v42; // x2
  void *v43; // x3
  void *v44; // x4
  void *v45; // x5
  void *v46; // x6
  __int64 v47; // x7
  double v48; // d0
  double v49; // d1
  double v50; // d2
  double v51; // d3
  double v52; // d4
  double v53; // d5
  double v54; // d6
  double v55; // d7
  unsigned __int64 v57; // x0
  __int64 v58; // x6
  uint64x2_t v59; // q0
  double v60; // d1
  double v61; // d2
  double v62; // d3
  double v63; // d4
  double v64; // d5
  double v65; // d6
  double v66; // d7
  uint64x2_t *v67; // x5
  uint64x2_t v68; // q31
  unsigned __int64 v69; // x3
  _BOOL4 v70; // w1
  signed int v71; // w0
  __int64 v72; // x2
  uint32x2_t v73; // d30
  __int64 v74; // x7
  unsigned int v75; // w8
  char *v76; // x8
  unsigned int v77; // w9
  unsigned int v78; // w24
  unsigned int v79; // w23
  unsigned int v80; // w22
  __int64 v81; // x1
  __int64 v82; // x2
  __int64 v83; // x3
  void *v84; // x4
  void *v85; // x5
  void *v86; // x6
  int v87; // w0
  uint32x2_t v88; // d0
  unsigned __int64 v89; // x0
  double v90; // d0
  double v91; // d1
  double v92; // d2
  double v93; // d3
  double v94; // d4
  double v95; // d5
  double v96; // d6
  double v97; // d7
  double v98; // d0
  double v99; // d1
  double v100; // d2
  double v101; // d3
  double v102; // d4
  double v103; // d5
  double v104; // d6
  double v105; // d7
  _QWORD *v106; // x4
  __int64 msg; // x0
  __int64 v108; // x3
  __int64 v109; // x4
  __int64 v110; // x6
  __int64 v111; // x7
  size_t v112; // x22
  unsigned __int64 v113; // x0
  unsigned __int64 v114; // x20
  char *v115; // x23
  signed __int64 nocancel; // x0
  __int64 v117; // x8
  __int64 v118; // x2
  int8x16_t *(__fastcall *v119)(int8x16_t *, unsigned __int8, unsigned __int64); // x6
  unsigned int v120; // w7
  char *v121; // x13
  unsigned int v122; // w0
  unsigned int v123; // w1
  unsigned __int8 *v124; // x0
  int v125; // w1
  char *v126; // x1
  unsigned int v127; // w11
  unsigned int v128; // w12
  unsigned int *v129; // x11
  int8x16_t *(__fastcall *v130)(int8x16_t *, unsigned __int8, unsigned __int64); // x22
  unsigned int v131; // w21
  char **v132; // x25
  unsigned int v133; // w1
  char *v134; // x1
  unsigned __int64 v135; // x3
  unsigned __int64 v136; // x6
  _QWORD *v137; // x4
  uint64x2_t *v138; // x5
  unsigned int *v139; // x24
  char *i; // x0
  char *v141; // x20
  unsigned int v142; // w3
  int v143; // w15
  unsigned int v144; // w12
  int v145; // w12
  unsigned __int64 v147; // x0
  unsigned __int64 v148; // x18
  __int64 v149; // x7
  unsigned int *v150; // x12
  int v151; // w23
  unsigned __int64 v152; // x30
  char *v153; // x8
  unsigned __int64 v154; // x10
  _QWORD *v155; // x4
  _DWORD *v156; // x0
  int8x16_t *(__fastcall *v157)(int8x16_t *, unsigned __int8, unsigned __int64); // x20
  __int64 v158; // x6
  unsigned __int64 v159; // x21
  __int64 v160; // x9
  unsigned int *v161; // x11
  unsigned int v162; // w3
  __int64 v163; // x22
  __int64 v164; // x1
  int v165; // w13
  __int64 v166; // x1
  _QWORD *v167; // x16
  int v168; // w17
  unsigned int *v169; // x13
  __int64 v170; // x15
  __int64 v171; // x14
  __int64 v172; // x25
  unsigned int *v173; // x20
  unsigned int v174; // w0
  unsigned int v175; // w22
  __int64 j; // x1
  unsigned int v177; // w2
  __int64 v178; // x21
  int8x16_t *(__fastcall *v179)(int8x16_t *, unsigned __int8, unsigned __int64); // x6
  _DWORD *v180; // x20
  __int64 v181; // x0
  unsigned int v182; // w1
  _DWORD *v183; // x25
  unsigned __int64 v184; // x23
  unsigned __int8 **v185; // x20
  uint64x2_t *v186; // x21
  int v187; // w24
  unsigned int v188; // w0
  unsigned __int32 v189; // w3
  unsigned int v190; // w1
  int *v191; // x2
  unsigned int v192; // w4
  unsigned int v193; // w6
  unsigned __int32 v194; // w3
  unsigned int v195; // w2
  __int64 v196; // x0
  bool v197; // cf
  int v198; // w0
  int v199; // w1
  int v200; // w12
  unsigned __int64 v201; // [xsp+60h] [xbp+60h]
  uint64x2_t *v202; // [xsp+60h] [xbp+60h]
  _DWORD *v203; // [xsp+60h] [xbp+60h]
  int v204; // [xsp+60h] [xbp+60h]
  uint64x2_t *v205; // [xsp+60h] [xbp+60h]
  int v206; // [xsp+60h] [xbp+60h]
  unsigned __int64 v207; // [xsp+60h] [xbp+60h]
  __int64 v208; // [xsp+60h] [xbp+60h]
  _QWORD *v209; // [xsp+68h] [xbp+68h]
  unsigned int v210; // [xsp+68h] [xbp+68h]
  unsigned int *v211; // [xsp+68h] [xbp+68h]
  _QWORD *v212; // [xsp+68h] [xbp+68h]
  int8x16_t *(__fastcall *v213)(int8x16_t *, unsigned __int8, unsigned __int64); // [xsp+68h] [xbp+68h]
  unsigned int v214; // [xsp+70h] [xbp+70h]
  unsigned int *v215; // [xsp+70h] [xbp+70h]
  int v216; // [xsp+70h] [xbp+70h]
  char *v217; // [xsp+78h] [xbp+78h]
  _DWORD *v218; // [xsp+78h] [xbp+78h]
  char *v219; // [xsp+78h] [xbp+78h]
  __int64 v220; // [xsp+78h] [xbp+78h]
  uint64x2_t *v221; // [xsp+80h] [xbp+80h]
  unsigned int v222; // [xsp+80h] [xbp+80h]
  __int64 v223; // [xsp+88h] [xbp+88h]
  __int64 v224; // [xsp+88h] [xbp+88h]
  _QWORD *v225; // [xsp+88h] [xbp+88h]
  unsigned int v226; // [xsp+90h] [xbp+90h]
  unsigned int *v227; // [xsp+98h] [xbp+98h]
  _DWORD *v228; // [xsp+98h] [xbp+98h]
  uint64x2_t *v229; // [xsp+A0h] [xbp+A0h]
  uint64x2_t *v230; // [xsp+A0h] [xbp+A0h]
  __int64 v231; // [xsp+A8h] [xbp+A8h]
  unsigned int *v232; // [xsp+A8h] [xbp+A8h]
  char *v233; // [xsp+B0h] [xbp+B0h]
  __int64 v234; // [xsp+B0h] [xbp+B0h]
  unsigned int *v235; // [xsp+B8h] [xbp+B8h]
  __int64 v236; // [xsp+C0h] [xbp+C0h]
  unsigned int *v237; // [xsp+C8h] [xbp+C8h]
  unsigned __int64 v238; // [xsp+C8h] [xbp+C8h]
  __int64 v239; // [xsp+D0h] [xbp+D0h]
  __int64 v240; // [xsp+D0h] [xbp+D0h]
  _QWORD *v241; // [xsp+D8h] [xbp+D8h]
  unsigned int *v242; // [xsp+E0h] [xbp+E0h]
  __int64 v243; // [xsp+E8h] [xbp+E8h]
  __int64 v244; // [xsp+F0h] [xbp+F0h]
  _QWORD *v245; // [xsp+F8h] [xbp+F8h]
  _QWORD v246[2]; // [xsp+100h] [xbp+100h] BYREF
  char v247; // [xsp+110h] [xbp+110h] BYREF
  size_t v248; // [xsp+140h] [xbp+140h]

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( qword_496EA8 != StatusReg - 1824 )
  {
    _aarch64_cas4_acq();
    if ( v19 )
      _lll_lock_wait_private(&lock_0_0, v11, v12, v13, v14, v15, v16, v17, v18, v5, v6, v7, v8, v9, v10);
    qword_496EA8 = StatusReg - 1824;
  }
  v20 = dword_496EA4++;
  if ( *(_DWORD *)(a1 + 8) )
    goto LABEL_26;
  *(_DWORD *)(a1 + 8) = -1;
  v21 = *(const char **)a1;
  *(_QWORD *)(a1 + 16) = 0LL;
  if ( !v21 )
    goto LABEL_25;
  v22 = _open_nocancel(v21, 0);
  v23 = v22;
  if ( v22 == -1 )
  {
    v20 = dword_496EA4 - 1;
    goto LABEL_25;
  }
  v24 = fstat64(v22, (struct stat *)&v247);
  if ( v24 )
    goto LABEL_47;
  v25 = v248;
  if ( v248 <= 0x2F )
    goto LABEL_47;
  v33 = (_DWORD *)mmap64(0LL, v248, 1, 2, v23, 0LL);
  if ( v33 != (_DWORD *)-1LL )
  {
    _close_nocancel(v23);
    if ( *v33 != -1794895138 && *v33 != -569244523 )
    {
      munmap(v33, v25);
      v20 = dword_496EA4 - 1;
      goto LABEL_25;
    }
    v24 = 1;
    goto LABEL_17;
  }
  v112 = v25;
  v113 = malloc(v25, v26, v27, v28, v29, v30, v31, v32, v34, v35, v36, v37, v38, v39, v40, v41);
  if ( !v113 )
  {
LABEL_47:
    _close_nocancel(v23);
    goto LABEL_48;
  }
  v114 = StatusReg;
  v115 = (char *)v113;
  v203 = (_DWORD *)v113;
  while ( 1 )
  {
    nocancel = _read_nocancel(v23, v115, v112);
    if ( nocancel > 0 )
      break;
LABEL_45:
    if ( nocancel != -1 || *(_DWORD *)(v114 + 40) != 4 )
      goto LABEL_47;
  }
  while ( 1 )
  {
    v112 -= nocancel;
    if ( !v112 )
      break;
    v115 += nocancel;
    nocancel = _read_nocancel(v23, v115, v112);
    if ( nocancel <= 0 )
      goto LABEL_45;
  }
  v33 = v203;
  _close_nocancel(v23);
  if ( *v203 != -1794895138 && *v203 != -569244523 )
  {
    free((unsigned __int64)v203, v48, v49, v50, v51, v52, v53, v54, v55);
    v20 = dword_496EA4 - 1;
    goto LABEL_25;
  }
LABEL_17:
  v57 = malloc(200LL, 3725722773LL, v42, v43, v44, v45, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55);
  v67 = (uint64x2_t *)v57;
  if ( !v57 )
  {
LABEL_48:
    v20 = dword_496EA4 - 1;
    goto LABEL_25;
  }
  *(_DWORD *)(v57 + 8) = v24;
  v68 = vdupq_n_s64((unsigned __int64)v33);
  *(_QWORD *)v57 = v33;
  v69 = (unsigned int)*v33;
  *(_QWORD *)(v57 + 16) = v25;
  *(_QWORD *)(v57 + 32) = 0LL;
  v70 = v69 != -1794895138;
  *(_DWORD *)(v57 + 24) = v70;
  v71 = v33[1];
  *(_QWORD *)(a1 + 16) = v67;
  if ( (_DWORD)v69 != -1794895138 )
  {
    v71 = bswap32(v71);
    if ( (unsigned int)(v71 >> 16) > 1 )
      goto LABEL_33;
    v72 = bswap32(v33[2]);
    v67[2].n128_u32[2] = v72;
    v73.n64_u64[0] = vrev32_s8(*(int8x8_t *)(v33 + 3)).n64_u64[0];
    v74 = bswap32(v33[5]);
    v67[5].n128_u32[2] = v74;
    v67[3] = vaddw_u32(v68, v73);
    if ( (unsigned int)v74 > 2 )
    {
      v75 = v33[6];
      v67[6].n128_u32[2] = 1;
      v76 = (char *)v33 + bswap32(v75);
      v67[6].n128_u64[0] = (unsigned __int64)v76;
      if ( (_WORD)v71 )
      {
        v77 = v33[9];
        if ( v77 )
        {
          v78 = bswap32(v77);
          v79 = bswap32(v33[7]);
          v80 = bswap32(v33[8]);
          goto LABEL_52;
        }
      }
LABEL_37:
      v106 = v246;
      v67[4].n128_u32[0] = 0;
      v67[4].n128_u64[1] = 0LL;
      v67[5].n128_u64[0] = 0LL;
      goto LABEL_38;
    }
LABEL_32:
    v67[6].n128_u64[0] = 0LL;
    v67[6].n128_u32[2] = v70;
    if ( (_WORD)v71 )
      goto LABEL_33;
    goto LABEL_37;
  }
  if ( (unsigned int)(v71 >> 16) > 1 )
    goto LABEL_33;
  v72 = (unsigned int)v33[2];
  v67[2].n128_u32[2] = v72;
  v88.n64_u64[0] = *(unsigned __int64 *)(v33 + 3);
  v74 = (unsigned int)v33[5];
  v67[5].n128_u32[2] = v74;
  v59 = vaddw_u32(v68, v88);
  v67[3] = v59;
  if ( (unsigned int)v74 <= 2 )
    goto LABEL_32;
  v117 = (unsigned int)v33[6];
  v67[6].n128_u32[2] = 0;
  v76 = (char *)v33 + v117;
  v67[6].n128_u64[0] = (unsigned __int64)v76;
  if ( !(_WORD)v71 )
    goto LABEL_37;
  v78 = v33[9];
  if ( !v78 )
    goto LABEL_37;
  v79 = v33[7];
  v80 = v33[8];
LABEL_52:
  v210 = v74;
  v214 = v69;
  v217 = v76;
  v221 = v67;
  v119 = calloc(v79, 8uLL, v72, (void *)v69, v59.n128_f64[0], v60, v61, v62, v63, v64, v65, v66, v79, v67, v58, v74);
  v67 = v221;
  if ( !v119 )
    goto LABEL_33;
  v120 = v210;
  if ( v79 )
  {
    v121 = (char *)v33 + v80;
    v118 = 0LL;
    while ( 1 )
    {
      v122 = *(_DWORD *)&v121[v118 + 4];
      v123 = *(_DWORD *)&v121[v118];
      if ( v214 == -1794895138 )
      {
        v124 = (unsigned __int8 *)v33 + v122;
      }
      else
      {
        v123 = bswap32(v123);
        v124 = (unsigned __int8 *)v33 + bswap32(v122);
      }
      if ( !v123 || v124[v123 - 1] )
        break;
      v125 = *v124;
      if ( v125 == 80 )
      {
        v126 = 0LL;
        if ( v124[1] == 82 && v124[2] == 73 )
        {
          v143 = v124[3];
          v144 = (unsigned __int8)(v143 - 88);
          if ( v144 <= 0x20 && ((0x120821001uLL >> v144) & 1) != 0 )
          {
            v145 = v124[4];
            switch ( v145 )
            {
              case '8':
                if ( !v124[5] )
                {
                  switch ( v143 )
                  {
                    case 'd':
                      v126 = "d";
                      break;
                    case 'i':
                      v126 = "i";
                      break;
                    case 'o':
                      v126 = "o";
                      break;
                    case 'u':
                      v126 = "u";
                      break;
                    default:
                      v126 = "x";
                      if ( v143 != 120 )
                        v126 = "X";
                      break;
                  }
                }
                break;
              case '1':
                if ( v124[5] == 54 )
                {
                  if ( v124[6] )
                  {
                    v126 = 0LL;
                  }
                  else
                  {
                    switch ( v143 )
                    {
                      case 'd':
                        v126 = "d";
                        break;
                      case 'i':
                        v126 = "i";
                        break;
                      case 'o':
                        v126 = "o";
                        break;
                      case 'u':
                        v126 = "u";
                        break;
                      default:
                        v126 = "x";
                        if ( v143 != 120 )
                          v126 = "X";
                        break;
                    }
                  }
                }
                break;
              case '3':
                v126 = 0LL;
                if ( v124[5] == 50 && !v124[6] )
                {
                  switch ( v143 )
                  {
                    case 'd':
                      v126 = "d";
                      break;
                    case 'i':
                      v126 = "i";
                      break;
                    case 'o':
                      v126 = "o";
                      break;
                    case 'u':
                      v126 = "u";
                      break;
                    default:
                      v126 = "x";
                      if ( v143 != 120 )
                        v126 = "X";
                      break;
                  }
                }
                break;
              case '6':
                if ( v124[5] == 52 )
                {
                  if ( v124[6] )
                  {
                    v126 = 0LL;
                  }
                  else
                  {
                    switch ( v143 )
                    {
                      case 'd':
                        v126 = "ld";
                        break;
                      case 'i':
                        v126 = "li";
                        break;
                      case 'o':
                        v126 = "lo";
                        break;
                      case 'u':
                        v126 = "lu";
                        break;
                      default:
                        v126 = "lx";
                        if ( v143 != 120 )
                          v126 = "lX";
                        break;
                    }
                  }
                }
                else
                {
                  v126 = 0LL;
                }
                break;
              case 'L':
                if ( v124[5] == 69 )
                {
                  if ( v124[6] == 65 )
                  {
                    if ( v124[7] == 83 )
                    {
                      if ( v124[8] == 84 )
                      {
                        v199 = v124[9];
                        switch ( v199 )
                        {
                          case '8':
                            if ( v124[10] )
                            {
                              v126 = 0LL;
                            }
                            else
                            {
                              switch ( v143 )
                              {
                                case 'd':
                                  v126 = "d";
                                  break;
                                case 'i':
                                  v126 = "i";
                                  break;
                                case 'o':
                                  v126 = "o";
                                  break;
                                case 'u':
                                  v126 = "u";
                                  break;
                                default:
                                  v126 = "x";
                                  if ( v143 != 120 )
                                    v126 = "X";
                                  break;
                              }
                            }
                            break;
                          case '1':
                            if ( v124[10] == 54 )
                            {
                              if ( v124[11] )
                              {
                                v126 = 0LL;
                              }
                              else
                              {
                                switch ( v143 )
                                {
                                  case 'd':
                                    v126 = "d";
                                    break;
                                  case 'i':
                                    v126 = "i";
                                    break;
                                  case 'o':
                                    v126 = "o";
                                    break;
                                  case 'u':
                                    v126 = "u";
                                    break;
                                  default:
                                    v126 = "x";
                                    if ( v143 != 120 )
                                      v126 = "X";
                                    break;
                                }
                              }
                            }
                            else
                            {
                              v126 = 0LL;
                            }
                            break;
                          case '3':
                            if ( v124[10] == 50 )
                            {
                              if ( v124[11] )
                              {
                                v126 = 0LL;
                              }
                              else
                              {
                                switch ( v143 )
                                {
                                  case 'd':
                                    v126 = "d";
                                    break;
                                  case 'i':
                                    v126 = "i";
                                    break;
                                  case 'o':
                                    v126 = "o";
                                    break;
                                  case 'u':
                                    v126 = "u";
                                    break;
                                  default:
                                    v126 = "x";
                                    if ( v143 != 120 )
                                      v126 = "X";
                                    break;
                                }
                              }
                            }
                            else
                            {
                              v126 = 0LL;
                            }
                            break;
                          case '6':
                            if ( v124[10] == 52 )
                            {
                              if ( v124[11] )
                              {
                                v126 = 0LL;
                              }
                              else
                              {
                                switch ( v143 )
                                {
                                  case 'd':
                                    v126 = "ld";
                                    break;
                                  case 'i':
                                    v126 = "li";
                                    break;
                                  case 'o':
                                    v126 = "lo";
                                    break;
                                  case 'u':
                                    v126 = "lu";
                                    break;
                                  default:
                                    v126 = "lx";
                                    if ( v143 != 120 )
                                      v126 = "lX";
                                    break;
                                }
                              }
                            }
                            else
                            {
                              v126 = 0LL;
                            }
                            break;
                          default:
                            v126 = 0LL;
                            break;
                        }
                      }
                      else
                      {
                        v126 = 0LL;
                      }
                    }
                    else
                    {
                      v126 = 0LL;
                    }
                  }
                  else
                  {
                    v126 = 0LL;
                  }
                }
                else
                {
                  v126 = 0LL;
                }
                break;
              case 'F':
                v126 = 0LL;
                if ( v124[5] == 65 && v124[6] == 83 && v124[7] == 84 )
                {
                  v200 = v124[8];
                  switch ( v200 )
                  {
                    case '8':
                      if ( !v124[9] )
                      {
                        switch ( v143 )
                        {
                          case 'd':
                            v126 = "d";
                            break;
                          case 'i':
                            v126 = "i";
                            break;
                          case 'o':
                            v126 = "o";
                            break;
                          case 'u':
                            v126 = "u";
                            break;
                          default:
                            v126 = "x";
                            if ( v143 != 120 )
                              v126 = "X";
                            break;
                        }
                      }
                      break;
                    case '1':
                      if ( v124[9] == 54 )
                      {
                        if ( v124[10] )
                        {
                          v126 = 0LL;
                        }
                        else
                        {
                          switch ( v143 )
                          {
                            case 'd':
                              v126 = "ld";
                              break;
                            case 'i':
                              v126 = "li";
                              break;
                            case 'o':
                              v126 = "lo";
                              break;
                            case 'u':
                              v126 = "lu";
                              break;
                            default:
                              v126 = "lx";
                              if ( v143 != 120 )
                                v126 = "lX";
                              break;
                          }
                        }
                      }
                      break;
                    case '3':
                      if ( v124[9] == 50 )
                      {
                        if ( v124[10] )
                        {
                          v126 = 0LL;
                        }
                        else
                        {
                          switch ( v143 )
                          {
                            case 'd':
                              v126 = "ld";
                              break;
                            case 'i':
                              v126 = "li";
                              break;
                            case 'o':
                              v126 = "lo";
                              break;
                            case 'u':
                              v126 = "lu";
                              break;
                            default:
                              v126 = "lx";
                              if ( v143 != 120 )
                                v126 = "lX";
                              break;
                          }
                        }
                      }
                      else
                      {
                        v126 = 0LL;
                      }
                      break;
                    case '6':
                      if ( v124[9] == 52 )
                      {
                        if ( v124[10] )
                        {
                          v126 = 0LL;
                        }
                        else
                        {
                          switch ( v143 )
                          {
                            case 'd':
                              v126 = "ld";
                              break;
                            case 'i':
                              v126 = "li";
                              break;
                            case 'o':
                              v126 = "lo";
                              break;
                            case 'u':
                              v126 = "lu";
                              break;
                            default:
                              v126 = "lx";
                              if ( v143 != 120 )
                                v126 = "lX";
                              break;
                          }
                        }
                      }
                      else
                      {
                        v126 = 0LL;
                      }
                      break;
                    default:
                      v126 = 0LL;
                      break;
                  }
                }
                break;
              case 'M':
                v126 = 0LL;
                if ( v124[5] == 65 && v124[6] == 88 && !v124[7] )
                {
                  switch ( v143 )
                  {
                    case 'd':
                      v126 = "ld";
                      break;
                    case 'i':
                      v126 = "li";
                      break;
                    case 'o':
                      v126 = "lo";
                      break;
                    case 'u':
                      v126 = "lu";
                      break;
                    default:
                      v126 = "lx";
                      if ( v143 != 120 )
                        v126 = "lX";
                      break;
                  }
                }
                break;
              case 'P':
                v126 = 0LL;
                if ( v124[5] == 84 && v124[6] == 82 && !v124[7] )
                {
                  switch ( v143 )
                  {
                    case 'd':
                      v126 = "ld";
                      break;
                    case 'i':
                      v126 = "li";
                      break;
                    case 'o':
                      v126 = "lo";
                      break;
                    case 'u':
                      v126 = "lu";
                      break;
                    default:
                      v126 = "lx";
                      if ( v143 != 120 )
                        v126 = "lX";
                      break;
                  }
                }
                break;
              default:
                v126 = 0LL;
                break;
            }
          }
        }
      }
      else if ( v125 == 73 )
      {
        if ( v124[1] )
          v126 = 0LL;
        else
          v126 = "I";
      }
      else
      {
        v126 = 0LL;
      }
      *(_QWORD *)((char *)v119 + v118) = v126;
      v118 += 8LL;
      if ( v118 == 8LL * v79 )
        goto LABEL_65;
    }
    free((unsigned __int64)v119, v59.n128_f64[0], v60, v61, v62, v63, v64, v65, v66);
    v67 = v221;
LABEL_33:
    v89 = 0LL;
    goto LABEL_34;
  }
LABEL_65:
  v127 = v33[10];
  v128 = v33[11];
  if ( v214 == -1794895138 )
  {
    v129 = (_DWORD *)((char *)v33 + v127);
  }
  else
  {
    v128 = bswap32(v128);
    v129 = (_DWORD *)((char *)v33 + bswap32(v127));
  }
  v130 = v119;
  v231 = a1;
  v233 = v217;
  v131 = v214;
  v211 = (_DWORD *)((char *)v33 + v128);
  v215 = v129;
  v218 = v33;
  v222 = 0;
  v223 = 4LL * v120;
  v227 = &v129[v78];
  v229 = v67;
  v235 = v211;
  v236 = v223;
  v237 = v129;
  v239 = 4LL * v78;
  do
  {
    v132 = (char **)v246;
    if ( v131 != -1794895138 )
    {
      v204 = 0;
      v133 = *v215;
      goto LABEL_70;
    }
    v204 = 0;
    v134 = (char *)v218 + *v215;
    if ( *((_DWORD *)v134 + 2) == -1 )
    {
      while ( 1 )
      {
        *v132++ = 0LL;
        if ( v204 )
          break;
LABEL_79:
        v134 = (char *)v218 + *v211;
        v204 = 1;
        if ( *((_DWORD *)v134 + 2) != -1 )
          goto LABEL_80;
      }
    }
    else
    {
LABEL_80:
      while ( 1 )
      {
        v139 = (unsigned int *)(v134 + 4);
        for ( i = 0LL; ; i = &v141[(_QWORD)strlen()] )
        {
          v142 = *v139;
          v118 = v139[1];
          if ( v131 == -1794895138 )
          {
            v141 = &i[v142];
          }
          else
          {
            v118 = bswap32(v118);
            v141 = &i[bswap32(v142)];
          }
          if ( (_DWORD)v118 == -1 )
            break;
          if ( (unsigned int)v118 >= v79 )
          {
            a1 = v231;
            v33 = v218;
            free((unsigned __int64)v130, v59.n128_f64[0], v60, v61, v62, v63, v64, v65, v66);
            v67 = v229;
            goto LABEL_33;
          }
          if ( !*((_QWORD *)v130 + (unsigned int)v118) )
            goto LABEL_73;
          v139 += 2;
        }
        *v132 = v141;
        if ( v204 )
          break;
        ++v132;
        if ( v131 == -1794895138 )
          goto LABEL_79;
        while ( 1 )
        {
          v133 = *v211;
          v204 = 1;
LABEL_70:
          v134 = (char *)v218 + bswap32(v133);
          if ( *((_DWORD *)v134 + 2) != -1 )
            break;
          *v132++ = 0LL;
          if ( v204 )
            goto LABEL_72;
        }
      }
    }
LABEL_72:
    ++v222;
    v223 += v246[0] + v246[1];
LABEL_73:
    ++v211;
    ++v215;
  }
  while ( v215 != v227 );
  v135 = v131;
  v33 = v218;
  v136 = (unsigned __int64)v130;
  v137 = v246;
  v138 = v229;
  a1 = v231;
  if ( !v222 )
  {
    v229[4].n128_u32[0] = 0;
    v229[4].n128_u64[1] = 0LL;
    v229[5].n128_u64[0] = 0LL;
    goto LABEL_76;
  }
  v206 = v135;
  v147 = malloc(
           v223 + 32LL * v222,
           v223,
           v118,
           (void *)v135,
           v246,
           v229,
           v130,
           v236,
           v59.n128_f64[0],
           v60,
           v61,
           v62,
           v63,
           v64,
           v65,
           v66);
  v67 = v229;
  v148 = v147;
  if ( !v147 )
    goto LABEL_33;
  v150 = v235;
  v149 = v236;
  v151 = v206;
  v152 = v147 + 16LL * v222;
  v153 = v233;
  v154 = v147 + 32LL * v222;
  v155 = v246;
  v156 = v218;
  v157 = v130;
  v158 = v231;
  v159 = v154 + v236;
  v161 = v237;
  v160 = v239;
  v162 = 0;
  v163 = 0LL;
  v229[2].n128_u64[0] = v148;
  while ( 2 )
  {
    if ( v151 == -1794895138 )
    {
      v165 = 0;
      v164 = (__int64)v156 + *(unsigned int *)((char *)v161 + v163);
      if ( *(_DWORD *)(v164 + 8) != -1 )
        goto LABEL_154;
    }
    else
    {
      v164 = (__int64)v156 + bswap32(*(unsigned int *)((char *)v161 + v163));
      if ( *(_DWORD *)(v164 + 8) != -1 )
      {
        v165 = 0;
        goto LABEL_154;
      }
    }
    do
    {
      if ( v151 == -1794895138 )
      {
        v165 = 1;
        v164 = (__int64)v156 + *(unsigned int *)((char *)v150 + v163);
        if ( *(_DWORD *)(v164 + 8) == -1 )
        {
          v166 = 16LL * v162;
LABEL_162:
          v167 = (_QWORD *)(v148 + v166);
          v168 = 0;
          v169 = (_DWORD *)((char *)v156 + *(unsigned int *)((char *)v161 + v163));
          v170 = (__int64)v156 + *v169;
          if ( v169[2] == -1 )
            goto LABEL_163;
          goto LABEL_146;
        }
      }
      else
      {
        v165 = 1;
        v164 = (__int64)v156 + bswap32(*(unsigned int *)((char *)v150 + v163));
        if ( *(_DWORD *)(v164 + 8) == -1 )
        {
          v166 = 16LL * v162;
          goto LABEL_143;
        }
      }
LABEL_154:
      for ( j = v164 + 4; ; j += 8LL )
      {
        v177 = *(_DWORD *)(j + 4);
        if ( v151 != -1794895138 )
          v177 = bswap32(v177);
        if ( v177 == -1 )
          break;
        if ( !*((_QWORD *)v157 + v177) )
          goto LABEL_167;
      }
    }
    while ( !v165 );
    v166 = 16LL * v162;
    if ( v151 == -1794895138 )
      goto LABEL_162;
LABEL_143:
    v167 = (_QWORD *)(v148 + v166);
    v168 = 0;
    v169 = (_DWORD *)((char *)v156 + bswap32(*(unsigned int *)((char *)v161 + v163)));
    v170 = (__int64)v156 + bswap32(*v169);
    if ( v169[2] == -1 )
    {
      do
      {
        *v167 = bswap32(v169[1]);
        v167[1] = v170;
        if ( v168 )
          goto LABEL_166;
LABEL_145:
        v167 = (_QWORD *)(v152 + v166);
        v168 = 1;
        v171 = bswap32(*(unsigned int *)((char *)v150 + v163));
        v169 = (_DWORD *)((char *)v156 + v171);
        v170 = (__int64)v156 + bswap32(*(_DWORD *)((char *)v156 + (unsigned int)v171));
      }
      while ( *(_DWORD *)((char *)v156 + v171 + 8) == -1 );
    }
LABEL_146:
    while ( 1 )
    {
      v172 = v170;
      v167[1] = v159;
      v213 = v157;
      v173 = v169 + 1;
      v216 = v168;
      v219 = v153;
      v224 = v166;
      v226 = v162;
      v228 = v156;
      v230 = v67;
      v232 = v150;
      v234 = v149;
      v238 = v154;
      v240 = v163;
      v241 = v167;
      v242 = v161;
      v243 = v160;
      v244 = v158;
      v245 = v155;
      while ( 1 )
      {
        v174 = *v173;
        if ( v151 == -1794895138 )
        {
          v175 = v173[1];
        }
        else
        {
          v174 = bswap32(v174);
          v175 = bswap32(v173[1]);
        }
        if ( v174 )
        {
          v208 = v174;
          j_memcpy();
          v159 += v208;
          v172 += v208;
        }
        if ( v175 == -1 )
          break;
        v173 += 2;
        v159 += (unsigned __int64)strlen();
        j_memcpy();
      }
      v161 = v242;
      v156 = v228;
      v67 = v230;
      v150 = v232;
      v149 = v234;
      v154 = v238;
      v163 = v240;
      v160 = v243;
      v158 = v244;
      *v241 = v159 - v241[1];
      v157 = v213;
      v153 = v219;
      v166 = v224;
      v155 = v245;
      v162 = v226;
      if ( v216 )
        break;
      if ( v151 != -1794895138 )
        goto LABEL_145;
      while ( 1 )
      {
        v167 = (_QWORD *)(v152 + v166);
        v168 = 1;
        v169 = (_DWORD *)((char *)v156 + *(unsigned int *)((char *)v150 + v163));
        v170 = (__int64)v156 + *v169;
        if ( v169[2] != -1 )
          break;
LABEL_163:
        *v167 = v169[1];
        v167[1] = v170;
        if ( v168 )
          goto LABEL_166;
      }
    }
LABEL_166:
    ++v162;
LABEL_167:
    v163 += 4LL;
    if ( v163 != v160 )
      continue;
    break;
  }
  v178 = v158;
  v179 = v157;
  v180 = v156;
  v181 = 0LL;
  if ( v222 != v162 )
    abort();
  while ( 1 )
  {
    v182 = *(_DWORD *)&v153[v181];
    if ( v151 != -1794895138 )
      break;
    *(_DWORD *)(v154 + v181) = v182;
    v181 += 4LL;
    if ( v181 == v149 )
      goto LABEL_171;
  }
  while ( 1 )
  {
    *(_DWORD *)(v154 + v181) = bswap32(v182);
    v181 += 4LL;
    if ( v181 == v149 )
      break;
    v182 = *(_DWORD *)&v153[v181];
  }
LABEL_171:
  v183 = v180;
  v184 = v154;
  v185 = (unsigned __int8 **)(v148 + 8);
  v220 = v178;
  v186 = v67;
  v187 = 0;
  v207 = (unsigned __int64)v179;
  v225 = v155;
  do
  {
    v188 = _hash_string(*v185);
    v189 = v186[5].n128_u32[2];
    v190 = v188 % v189;
    v191 = (int *)(v184 + 4LL * (v188 % v189));
    if ( *v191 )
    {
      v192 = v188 % (v189 - 2) + 1;
      v193 = v189 - v192;
      v194 = v192 - v189;
      do
      {
        v195 = v190 + v194;
        LODWORD(v196) = v190 + v192;
        v197 = v190 >= v193;
        if ( v190 >= v193 )
          v190 += v194;
        else
          v190 += v192;
        if ( v197 )
          v196 = v195;
        else
          v196 = (unsigned int)v196;
        v191 = (int *)(v184 + 4 * v196);
      }
      while ( *v191 );
    }
    v185 += 2;
    v198 = v186[2].n128_u32[2] + 1 + v187++;
    *v191 = v198;
  }
  while ( v222 != v187 );
  v138 = v186;
  v136 = v207;
  v33 = v183;
  a1 = v220;
  v138[4].n128_u32[0] = v222;
  v137 = v225;
  v138[4].n128_u64[1] = v148;
  v138[5].n128_u64[0] = v152;
  v138[6].n128_u64[0] = v184;
  v138[6].n128_u32[2] = 0;
LABEL_76:
  v205 = v138;
  v212 = v137;
  free(v136, v59.n128_f64[0], v60, v61, v62, v63, v64, v65, v66);
  v67 = v205;
  v106 = v212;
LABEL_38:
  v209 = v106;
  v67[7].n128_u64[0] = 0LL;
  v67[7].n128_u64[1] = 0LL;
  v202 = v67;
  pthread_rwlock_init((__int64)&v67[8], 0LL);
  msg = nl_find_msg(a1, a2, &qword_454610, 0LL, v209);
  v67 = v202;
  if ( msg != -1 )
  {
    _gettext_extract_plural(msg, &v202[11].n128_i64[1], v202[12].n128_u64, v108, v109, (__int64)v202, v110, v111);
    v20 = dword_496EA4 - 1;
    goto LABEL_25;
  }
  v89 = v202[2].n128_u64[0];
LABEL_34:
  v201 = (unsigned __int64)v67;
  free(v89, v59.n128_f64[0], v60, v61, v62, v63, v64, v65, v66);
  if ( v24 )
    munmap(v33, v25);
  else
    free((unsigned __int64)v33, v90, v91, v92, v93, v94, v95, v96, v97);
  free(v201, v98, v99, v100, v101, v102, v103, v104, v105);
  *(_QWORD *)(a1 + 16) = 0LL;
  v20 = dword_496EA4 - 1;
LABEL_25:
  *(_DWORD *)(a1 + 8) = 1;
LABEL_26:
  dword_496EA4 = v20;
  if ( !v20 )
  {
    qword_496EA8 = 0LL;
    _aarch64_swp4_rel();
    if ( v87 > 1 )
      _lll_lock_wake_private(&lock_0_0, v81, v82, v83, v84, v85, v86);
  }
}
// 42A30C: variable 'v19' is possibly undefined
// 42A66C: variable 'v11' is possibly undefined
// 42A66C: variable 'v12' is possibly undefined
// 42A66C: variable 'v13' is possibly undefined
// 42A66C: variable 'v14' is possibly undefined
// 42A66C: variable 'v15' is possibly undefined
// 42A66C: variable 'v16' is possibly undefined
// 42A66C: variable 'v17' is possibly undefined
// 42A66C: variable 'v18' is possibly undefined
// 42A66C: variable 'v5' is possibly undefined
// 42A66C: variable 'v6' is possibly undefined
// 42A66C: variable 'v7' is possibly undefined
// 42A66C: variable 'v8' is possibly undefined
// 42A66C: variable 'v9' is possibly undefined
// 42A66C: variable 'v10' is possibly undefined
// 42A3D4: variable 'v42' is possibly undefined
// 42A3D4: variable 'v43' is possibly undefined
// 42A3D4: variable 'v44' is possibly undefined
// 42A3D4: variable 'v45' is possibly undefined
// 42A3D4: variable 'v46' is possibly undefined
// 42A3D4: variable 'v47' is possibly undefined
// 42A3D4: variable 'v48' is possibly undefined
// 42A3D4: variable 'v49' is possibly undefined
// 42A3D4: variable 'v50' is possibly undefined
// 42A3D4: variable 'v51' is possibly undefined
// 42A3D4: variable 'v52' is possibly undefined
// 42A3D4: variable 'v53' is possibly undefined
// 42A3D4: variable 'v54' is possibly undefined
// 42A3D4: variable 'v55' is possibly undefined
// 42A4DC: variable 'v87' is possibly undefined
// 42A4E4: variable 'v81' is possibly undefined
// 42A4E4: variable 'v82' is possibly undefined
// 42A4E4: variable 'v83' is possibly undefined
// 42A4E4: variable 'v84' is possibly undefined
// 42A4E4: variable 'v85' is possibly undefined
// 42A4E4: variable 'v86' is possibly undefined
// 42A534: variable 'v59' is possibly undefined
// 42A534: variable 'v60' is possibly undefined
// 42A534: variable 'v61' is possibly undefined
// 42A534: variable 'v62' is possibly undefined
// 42A534: variable 'v63' is possibly undefined
// 42A534: variable 'v64' is possibly undefined
// 42A534: variable 'v65' is possibly undefined
// 42A534: variable 'v66' is possibly undefined
// 42A550: variable 'v98' is possibly undefined
// 42A550: variable 'v99' is possibly undefined
// 42A550: variable 'v100' is possibly undefined
// 42A550: variable 'v101' is possibly undefined
// 42A550: variable 'v102' is possibly undefined
// 42A550: variable 'v103' is possibly undefined
// 42A550: variable 'v104' is possibly undefined
// 42A550: variable 'v105' is possibly undefined
// 42A5C0: variable 'v108' is possibly undefined
// 42A5C0: variable 'v109' is possibly undefined
// 42A5C0: variable 'v110' is possibly undefined
// 42A5C0: variable 'v111' is possibly undefined
// 42A5E0: variable 'v26' is possibly undefined
// 42A5E0: variable 'v27' is possibly undefined
// 42A5E0: variable 'v28' is possibly undefined
// 42A5E0: variable 'v29' is possibly undefined
// 42A5E0: variable 'v30' is possibly undefined
// 42A5E0: variable 'v31' is possibly undefined
// 42A5E0: variable 'v32' is possibly undefined
// 42A5E0: variable 'v34' is possibly undefined
// 42A5E0: variable 'v35' is possibly undefined
// 42A5E0: variable 'v36' is possibly undefined
// 42A5E0: variable 'v37' is possibly undefined
// 42A5E0: variable 'v38' is possibly undefined
// 42A5E0: variable 'v39' is possibly undefined
// 42A5E0: variable 'v40' is possibly undefined
// 42A5E0: variable 'v41' is possibly undefined
// 42A6B8: variable 'v58' is possibly undefined
// 42AA08: variable 'v90' is possibly undefined
// 42AA08: variable 'v91' is possibly undefined
// 42AA08: variable 'v92' is possibly undefined
// 42AA08: variable 'v93' is possibly undefined
// 42AA08: variable 'v94' is possibly undefined
// 42AA08: variable 'v95' is possibly undefined
// 42AA08: variable 'v96' is possibly undefined
// 42AA08: variable 'v97' is possibly undefined
// 42AB9C: variable 'v118' is possibly undefined
// 429000: using guessed type __int64 __fastcall nl_find_msg(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 454610: using guessed type __int64 qword_454610;
// 496EA0: using guessed type _DWORD lock_0_0;
// 496EA4: using guessed type int dword_496EA4;
// 496EA8: using guessed type __int64 qword_496EA8;

//----- (000000000042B760) ----------------------------------------------------
void __fastcall nl_unload_domain(
        unsigned __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  void *v10; // x0
  __int64 v11; // x19
  unsigned __int64 i; // x20
  __int64 *v13; // x0
  unsigned __int64 *v14; // x22
  unsigned __int64 v15; // x0
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  double v24; // d0
  double v25; // d1
  double v26; // d2
  double v27; // d3
  double v28; // d4
  double v29; // d5
  double v30; // d6
  double v31; // d7
  void *v32; // x0
  double v33; // d0
  double v34; // d1
  double v35; // d2
  double v36; // d3
  double v37; // d4
  double v38; // d5
  double v39; // d6
  double v40; // d7

  v10 = *(void **)(a1 + 184);
  if ( v10 != &_gettext_germanic_plural )
    _gettext_free_exp((unsigned __int64)v10, a2, a3, a4, a5, a6, a7, a8, a9);
  v11 = 0LL;
  for ( i = 0LL; *(_QWORD *)(a1 + 120) > i; v11 += 24LL )
  {
    v14 = (unsigned __int64 *)(*(_QWORD *)(a1 + 112) + v11);
    free(*v14, a2, a3, a4, a5, a6, a7, a8, a9);
    v15 = v14[2];
    if ( v15 - 1 <= 0xFFFFFFFFFFFFFFFDLL )
      free(v15, a2, a3, a4, a5, a6, a7, a8, a9);
    v13 = (__int64 *)v14[1];
    if ( v13 != (__int64 *)-1LL )
      _gconv_close(v13, a2, a3, a4, a5, a6, a7, a8, a9);
    ++i;
  }
  free(*(_QWORD *)(a1 + 112), a2, a3, a4, a5, a6, a7, a8, a9);
  free(*(_QWORD *)(a1 + 32), v16, v17, v18, v19, v20, v21, v22, v23);
  v32 = *(void **)a1;
  if ( *(_DWORD *)(a1 + 8) )
    munmap(v32, *(_QWORD *)(a1 + 16));
  else
    free((unsigned __int64)v32, v24, v25, v26, v27, v28, v29, v30, v31);
  free(a1, v33, v34, v35, v36, v37, v38, v39, v40);
}
// 42B7AC: variable 'a2' is possibly undefined
// 42B7AC: variable 'a3' is possibly undefined
// 42B7AC: variable 'a4' is possibly undefined
// 42B7AC: variable 'a5' is possibly undefined
// 42B7AC: variable 'a6' is possibly undefined
// 42B7AC: variable 'a7' is possibly undefined
// 42B7AC: variable 'a8' is possibly undefined
// 42B7AC: variable 'a9' is possibly undefined
// 42B7F8: variable 'v16' is possibly undefined
// 42B7F8: variable 'v17' is possibly undefined
// 42B7F8: variable 'v18' is possibly undefined
// 42B7F8: variable 'v19' is possibly undefined
// 42B7F8: variable 'v20' is possibly undefined
// 42B7F8: variable 'v21' is possibly undefined
// 42B7F8: variable 'v22' is possibly undefined
// 42B7F8: variable 'v23' is possibly undefined
// 42B838: variable 'v33' is possibly undefined
// 42B838: variable 'v34' is possibly undefined
// 42B838: variable 'v35' is possibly undefined
// 42B838: variable 'v36' is possibly undefined
// 42B838: variable 'v37' is possibly undefined
// 42B838: variable 'v38' is possibly undefined
// 42B838: variable 'v39' is possibly undefined
// 42B838: variable 'v40' is possibly undefined
// 42B824: variable 'v24' is possibly undefined
// 42B824: variable 'v25' is possibly undefined
// 42B824: variable 'v26' is possibly undefined
// 42B824: variable 'v27' is possibly undefined
// 42B824: variable 'v28' is possibly undefined
// 42B824: variable 'v29' is possibly undefined
// 42B824: variable 'v30' is possibly undefined
// 42B824: variable 'v31' is possibly undefined

//----- (000000000042B840) ----------------------------------------------------
__int64 __fastcall alias_compare(__int64 *a1, __int64 *a2)
{
  return strcasecmp_l(*a1, *a2, (__int64)nl_C_locobj);
}
// 48FA30: using guessed type char **nl_C_locobj[6];

//----- (000000000042B860) ----------------------------------------------------
// bad sp value at call has been detected, the output may be wrong!
__int64 __fastcall read_alias_file(__int64 a1, int a2)
{
  __int64 v2; // x19
  __int64 (__fastcall *v4)(__int64, __int64 *, unsigned __int64); // x0
  void *v5; // x3
  void *v6; // x4
  void *v7; // x5
  void *v8; // x6
  __int64 v9; // x7
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7
  __int64 *v18; // x0
  __int64 v19; // x3
  void *v20; // x4
  void *v21; // x5
  void *v22; // x6
  __int64 v23; // x7
  double v24; // d0
  double v25; // d1
  double v26; // d2
  double v27; // d3
  double v28; // d4
  double v29; // d5
  double v30; // d6
  double v31; // d7
  __int64 v32; // x1
  int *v33; // x21
  __int64 v34; // x24
  __int64 v35; // x2
  unsigned __int16 **v36; // x22
  __int64 v37; // x1
  __int64 i; // x2
  __int64 v39; // x3
  void *v40; // x4
  void *v41; // x5
  void *v42; // x6
  __int64 v43; // x7
  __int64 v44; // x27
  _BYTE *v45; // x19
  unsigned __int16 *v46; // x0
  unsigned int v47; // t1
  double v49; // d0
  double v50; // d1
  double v51; // d2
  double v52; // d3
  double v53; // d4
  double v54; // d5
  double v55; // d6
  double v56; // d7
  unsigned int v58; // t1
  _BYTE *v59; // x26
  unsigned int v60; // t1
  int v61; // w1
  int v62; // t1
  __int64 v63; // x28
  char *v64; // x3
  void *v65; // x6
  __int64 v66; // x7
  double v67; // d0
  double v68; // d1
  double v69; // d2
  double v70; // d3
  double v71; // d4
  double v72; // d5
  double v73; // d6
  double v74; // d7
  __int64 v75; // x2
  __int64 v76; // x4
  char *v77; // x8
  unsigned __int64 v78; // x25
  __int64 v79; // x0
  unsigned __int64 v80; // x0
  __int64 v81; // x1
  __int64 v82; // x6
  __int64 v83; // x5
  __int64 (__fastcall *v84)(__int64, __int64 *, unsigned __int64); // x0
  unsigned __int64 v85; // x1
  __int64 v86; // x3
  unsigned __int64 v87; // x0
  __int64 v88; // x10
  int64x2_t v89; // q31
  int64x2_t *v90; // x4
  __int64 v91; // [xsp+0h] [xbp+0h] BYREF
  char *v92; // [xsp+60h] [xbp+60h]
  __int64 v93; // [xsp+68h] [xbp+68h]
  char *v94; // [xsp+70h] [xbp+70h]
  __int64 v95; // [xsp+78h] [xbp+78h]
  __int64 v96; // [xsp+80h] [xbp+80h]
  __int64 v97; // [xsp+88h] [xbp+88h]
  _BYTE v98[400]; // [xsp+90h] [xbp+90h] BYREF

  v2 = a2;
  v4 = j_memcpy();
  *(_QWORD *)((char *)v4 + a2) = *(_QWORD *)"/locale.alias";
  strcpy((char *)v4 + v2 + 6, "e.alias");
  v18 = (__int64 *)fopen64(
                     (char *)&v91,
                     "rce",
                     v10,
                     v11,
                     v12,
                     v13,
                     v14,
                     v15,
                     v16,
                     v17,
                     *(__int64 *)"/locale.alias",
                     v5,
                     v6,
                     v7,
                     v8,
                     v9);
  if ( !v18 )
    return 0LL;
  v32 = *(unsigned int *)v18;
  v33 = (int *)v18;
  v34 = 0LL;
  v35 = (unsigned int)v32 | 0x8000;
  *(_DWORD *)v18 = v35;
  if ( (v32 & 0x10) != 0 )
  {
    fclose(v18, v24, v25, v26, v27, v28, v29, v30, v31, v32, v35, v19, v20, v21, v22, v23);
    return 0LL;
  }
  v36 = (unsigned __int16 **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 72);
  while ( fgets_unlocked(v98, 400, v33, v24, v25, v26, v27, v28, v29, v30, v31) )
  {
    v44 = strchr((__int64)v98, 0xAu);
    v37 = v98[0];
    v45 = v98;
    v46 = *v36;
    for ( i = (*v36)[v98[0]]; (i & 0x2000) != 0; i = v46[(unsigned __int8)v47] )
    {
      v47 = (unsigned __int8)*++v45;
      v37 = v47;
    }
    if ( (_DWORD)v37 == 35 || (_DWORD)v37 == 0 )
      goto LABEL_12;
    LOBYTE(v37) = v45[1];
    i = (__int64)(v45 + 1);
    if ( !(_BYTE)v37 )
    {
      v37 = *v46;
      v59 = v45 + 1;
      if ( (v37 & 0x2000) == 0 )
        goto LABEL_12;
      do
      {
LABEL_26:
        v60 = (unsigned __int8)*++v59;
        v37 = v60;
        i = v46[(unsigned __int8)v60];
      }
      while ( (i & 0x2000) != 0 );
      goto LABEL_27;
    }
    do
    {
      if ( (v46[(unsigned __int8)v37] & 0x2000) != 0 )
      {
        *(_BYTE *)i = 0;
        v59 = (_BYTE *)(i + 1);
        v37 = *(unsigned __int8 *)(i + 1);
        goto LABEL_25;
      }
      v58 = *(unsigned __int8 *)++i;
      v37 = v58;
    }
    while ( v58 );
    v59 = (_BYTE *)i;
LABEL_25:
    i = v46[(unsigned __int8)v37];
    if ( (i & 0x2000) != 0 )
      goto LABEL_26;
LABEL_27:
    if ( (_DWORD)v37 )
    {
      v61 = (unsigned __int8)v59[1];
      if ( v59[1] )
      {
        i = (__int64)(v59 + 1);
        while ( (v46[(unsigned __int8)v61] & 0x2000) == 0 )
        {
          v62 = *(unsigned __int8 *)++i;
          v61 = v62;
          if ( !v62 )
            goto LABEL_34;
        }
        if ( v61 == 10 )
          *(_WORD *)i = 2560;
        else
          *(_BYTE *)i = 0;
      }
LABEL_34:
      v63 = nmap;
      if ( nmap >= (unsigned __int64)maxmap )
      {
        if ( maxmap )
        {
          v86 = 2 * maxmap;
          v85 = 32 * maxmap;
        }
        else
        {
          v85 = 1600LL;
          v86 = 100LL;
        }
        v97 = v86;
        v87 = realloc(map_0, v85, i, (void *)v86, v40, v41, v42, v43, v24, v25, v26, v27, v28, v29, v30, v31);
        if ( !v87 )
          break;
        maxmap = v97;
        map_0 = v87;
      }
      v97 = (__int64)strlen() + 1;
      v64 = (char *)strlen() + 1;
      v75 = v97;
      v76 = string_space;
      v77 = (char *)(string_space_act + v97);
      v78 = (unsigned __int64)&v64[string_space_act + v97];
      if ( v78 <= string_space_max )
      {
        v82 = map_0;
        v83 = 16 * v63;
      }
      else
      {
        v79 = (__int64)&v64[v97];
        v92 = (char *)(string_space_act + v97);
        v93 = string_space_act;
        if ( (unsigned __int64)&v64[v97] < 0x400 )
          v79 = 1024LL;
        v94 = v64;
        v95 = v97;
        v96 = v79 + string_space_max;
        v97 = string_space;
        v80 = realloc(
                string_space,
                v79 + string_space_max,
                v75,
                v64,
                (void *)string_space,
                (void *)0x400,
                v65,
                v66,
                v67,
                v68,
                v69,
                v70,
                v71,
                v72,
                v73,
                v74);
        if ( !v80 )
          break;
        v81 = v96;
        v82 = map_0;
        v77 = v92;
        v64 = v94;
        if ( v80 == v97 )
        {
          v83 = 16 * v63;
        }
        else
        {
          v83 = 0LL;
          if ( v63 )
          {
            v83 = 16 * v63;
            v88 = map_0 + 16 * v63;
            v89 = vdupq_n_s64(v80 - v97);
            v90 = (int64x2_t *)map_0;
            do
            {
              *v90 = vaddq_s64(*v90, v89);
              ++v90;
            }
            while ( v90 != (int64x2_t *)v88 );
          }
        }
        string_space_max = v81;
        string_space = v80;
        v76 = v80;
      }
      v92 = v64;
      v93 = (__int64)v77;
      v94 = (char *)v83;
      v95 = v82;
      ++v34;
      v96 = v82 + v83;
      v97 = v76;
      *(_QWORD *)(v82 + v83) = j_memcpy();
      v84 = j_memcpy();
      nmap = v63 + 1;
      string_space_act = v78;
      *(_QWORD *)(v96 + 8) = v84;
    }
LABEL_12:
    if ( !v44 )
    {
      while ( fgets_unlocked(v98, 400, v33, v24, v25, v26, v27, v28, v29, v30, v31) && !strchr((__int64)v98, 0xAu) )
        ;
    }
    if ( (*v33 & 0x10) != 0 )
      break;
  }
  fclose((__int64 *)v33, v24, v25, v26, v27, v28, v29, v30, v31, v37, i, v39, v40, v41, v42, v43);
  if ( v34 )
    qsort(
      map_0,
      nmap,
      0x10uLL,
      (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))alias_compare,
      v49,
      v50,
      v51,
      v52,
      v53,
      v54,
      v55,
      v56);
  return v34;
}
// 42B9C8: bad sp value at call
// 42B9DC: bad sp value at call
// 42B8CC: variable 'v10' is possibly undefined
// 42B8CC: variable 'v11' is possibly undefined
// 42B8CC: variable 'v12' is possibly undefined
// 42B8CC: variable 'v13' is possibly undefined
// 42B8CC: variable 'v14' is possibly undefined
// 42B8CC: variable 'v15' is possibly undefined
// 42B8CC: variable 'v16' is possibly undefined
// 42B8CC: variable 'v17' is possibly undefined
// 42B8CC: variable 'v5' is possibly undefined
// 42B8CC: variable 'v6' is possibly undefined
// 42B8CC: variable 'v7' is possibly undefined
// 42B8CC: variable 'v8' is possibly undefined
// 42B8CC: variable 'v9' is possibly undefined
// 42B914: variable 'v24' is possibly undefined
// 42B914: variable 'v25' is possibly undefined
// 42B914: variable 'v26' is possibly undefined
// 42B914: variable 'v27' is possibly undefined
// 42B914: variable 'v28' is possibly undefined
// 42B914: variable 'v29' is possibly undefined
// 42B914: variable 'v30' is possibly undefined
// 42B914: variable 'v31' is possibly undefined
// 42B970: variable 'v37' is possibly undefined
// 42B970: variable 'i' is possibly undefined
// 42B970: variable 'v39' is possibly undefined
// 42B970: variable 'v40' is possibly undefined
// 42B970: variable 'v41' is possibly undefined
// 42B970: variable 'v42' is possibly undefined
// 42B970: variable 'v43' is possibly undefined
// 42B994: variable 'v49' is possibly undefined
// 42B994: variable 'v50' is possibly undefined
// 42B994: variable 'v51' is possibly undefined
// 42B994: variable 'v52' is possibly undefined
// 42B994: variable 'v53' is possibly undefined
// 42B994: variable 'v54' is possibly undefined
// 42B994: variable 'v55' is possibly undefined
// 42B994: variable 'v56' is possibly undefined
// 42BAD4: variable 'v65' is possibly undefined
// 42BAD4: variable 'v66' is possibly undefined
// 42BAD4: variable 'v67' is possibly undefined
// 42BAD4: variable 'v68' is possibly undefined
// 42BAD4: variable 'v69' is possibly undefined
// 42BAD4: variable 'v70' is possibly undefined
// 42BAD4: variable 'v71' is possibly undefined
// 42BAD4: variable 'v72' is possibly undefined
// 42BAD4: variable 'v73' is possibly undefined
// 42BAD4: variable 'v74' is possibly undefined
// 42BBF8: variable 'v19' is possibly undefined
// 42BBF8: variable 'v20' is possibly undefined
// 42BBF8: variable 'v21' is possibly undefined
// 42BBF8: variable 'v22' is possibly undefined
// 42BBF8: variable 'v23' is possibly undefined
// 496EB8: using guessed type __int64 nmap;
// 496EC0: using guessed type __int64 maxmap;
// 496EC8: using guessed type __int64 map_0;
// 496ED0: using guessed type __int64 string_space_act;
// 496ED8: using guessed type __int64 string_space_max;
// 496EE0: using guessed type __int64 string_space;

//----- (000000000042BC04) ----------------------------------------------------
__int64 __fastcall nl_expand_alias(__int64 a1)
{
  __int64 v2; // x1
  __int64 v3; // x2
  __int64 v4; // x3
  void *v5; // x4
  void *v6; // x5
  void *v7; // x6
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  int v16; // w0
  unsigned __int64 v17; // x23
  __int64 i; // x0
  _BYTE *v19; // x1
  int v20; // w2
  unsigned __int8 *v21; // x0
  int v22; // w2
  int v23; // t1
  unsigned __int64 v24; // x0
  unsigned __int8 *v25; // x2
  int v26; // w3
  int v27; // t1
  __int64 v29; // x20
  __int64 v30; // x1
  __int64 v31; // x2
  __int64 v32; // x3
  void *v33; // x4
  void *v34; // x5
  void *v35; // x6
  int v36; // w0
  __int64 v38; // x25
  unsigned __int64 v39; // x24
  __int64 *v40; // x26
  int v41; // w0
  int v42; // w0

  _aarch64_cas4_acq();
  if ( v16 )
    _lll_lock_wait_private(lock_0, v8, v9, v10, v11, v12, v13, v14, v15, v2, v3, v4, v5, v6, v7);
  if ( !locale_alias_path_1 )
    locale_alias_path_1 = (__int64)"/usr/share/locale";
LABEL_5:
  v17 = nmap;
  if ( !nmap )
  {
LABEL_6:
    for ( i = 0LL; ; i = read_alias_file(v24, (int)v19 - (int)v24) )
    {
      if ( i )
        goto LABEL_5;
      v19 = (_BYTE *)locale_alias_path_1;
      v20 = *(unsigned __int8 *)locale_alias_path_1;
      if ( !*(_BYTE *)locale_alias_path_1 )
      {
LABEL_20:
        if ( (_DWORD)i )
          locale_alias_path_1 = (__int64)v19;
        v29 = 0LL;
        _aarch64_swp4_rel();
        if ( v36 > 1 )
          goto LABEL_34;
        return v29;
      }
      while ( 1 )
      {
        v21 = v19 + 1;
        if ( v20 != 58 )
          break;
        do
        {
          v19 = v21;
          v23 = *v21++;
          v22 = v23;
        }
        while ( v23 == 58 );
        v24 = (unsigned __int64)v19;
        if ( v22 )
          goto LABEL_12;
LABEL_19:
        v20 = (unsigned __int8)*v19;
        LODWORD(i) = 1;
        if ( !*v19 )
          goto LABEL_20;
      }
      v24 = (unsigned __int64)v19;
LABEL_12:
      v25 = (unsigned __int8 *)(v24 + 1);
      do
      {
        v19 = v25;
        v27 = *v25++;
        v26 = v27;
      }
      while ( v27 != 58 && v26 != 0 );
      if ( (unsigned __int64)v19 <= v24 )
        goto LABEL_19;
      locale_alias_path_1 = (__int64)v19;
    }
  }
  v38 = map_0;
  while ( 1 )
  {
    v39 = v17 >> 1;
    v40 = (__int64 *)(v38 + 16 * (v17 >> 1));
    v41 = strcasecmp_l(a1, *v40, (__int64)nl_C_locobj);
    if ( !v41 )
      break;
    if ( v41 <= 0 )
    {
      v17 >>= 1;
      if ( !v39 )
        goto LABEL_6;
    }
    else
    {
      v38 = (__int64)(v40 + 2);
      v17 = (v17 - 1) >> 1;
      if ( !v17 )
        goto LABEL_6;
    }
  }
  v29 = v40[1];
  _aarch64_swp4_rel();
  if ( v42 <= 1 )
    return v29;
LABEL_34:
  _lll_lock_wake_private(lock_0, v30, v31, v32, v33, v34, v35);
  return v29;
}
// 42BC38: variable 'v16' is possibly undefined
// 42BDC4: variable 'v8' is possibly undefined
// 42BDC4: variable 'v9' is possibly undefined
// 42BDC4: variable 'v10' is possibly undefined
// 42BDC4: variable 'v11' is possibly undefined
// 42BDC4: variable 'v12' is possibly undefined
// 42BDC4: variable 'v13' is possibly undefined
// 42BDC4: variable 'v14' is possibly undefined
// 42BDC4: variable 'v15' is possibly undefined
// 42BDC4: variable 'v2' is possibly undefined
// 42BDC4: variable 'v3' is possibly undefined
// 42BDC4: variable 'v4' is possibly undefined
// 42BDC4: variable 'v5' is possibly undefined
// 42BDC4: variable 'v6' is possibly undefined
// 42BDC4: variable 'v7' is possibly undefined
// 42BCEC: variable 'v36' is possibly undefined
// 42BD88: variable 'v42' is possibly undefined
// 42BD90: variable 'v30' is possibly undefined
// 42BD90: variable 'v31' is possibly undefined
// 42BD90: variable 'v32' is possibly undefined
// 42BD90: variable 'v33' is possibly undefined
// 42BD90: variable 'v34' is possibly undefined
// 42BD90: variable 'v35' is possibly undefined
// 48FA30: using guessed type char **nl_C_locobj[6];
// 496EB8: using guessed type __int64 nmap;
// 496EC8: using guessed type __int64 map_0;
// 496EE8: using guessed type _DWORD lock_0[2];
// 496EF0: using guessed type __int64 locale_alias_path_1;

//----- (000000000042BDCC) ----------------------------------------------------
void __fastcall _libc_localealias_freemem(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7

  free(string_space, a1, a2, a3, a4, a5, a6, a7, a8);
  free(map_0, v8, v9, v10, v11, v12, v13, v14, v15);
}
// 42BDF4: variable 'v8' is possibly undefined
// 42BDF4: variable 'v9' is possibly undefined
// 42BDF4: variable 'v10' is possibly undefined
// 42BDF4: variable 'v11' is possibly undefined
// 42BDF4: variable 'v12' is possibly undefined
// 42BDF4: variable 'v13' is possibly undefined
// 42BDF4: variable 'v14' is possibly undefined
// 42BDF4: variable 'v15' is possibly undefined
// 496EC8: using guessed type __int64 map_0;
// 496EE0: using guessed type __int64 string_space;

//----- (000000000042BE00) ----------------------------------------------------
unsigned __int64 __fastcall nl_make_l10nflist(
        unsigned __int64 *a1,
        unsigned __int64 a2,
        __int64 a3,
        int a4,
        unsigned __int64 a5,
        unsigned __int64 a6,
        unsigned __int64 a7,
        unsigned __int64 a8,
        unsigned __int64 a9,
        __int64 a10,
        int a11)
{
  __int64 v15; // x25
  int v16; // w28
  unsigned __int64 (__fastcall *v17)(__int64); // x21
  char *v18; // x0
  char *v19; // x21
  char *v20; // x22
  char *v21; // x22
  unsigned __int64 v22; // x25
  char *v23; // x23
  unsigned __int64 (__fastcall *v24)(__int64); // x0
  __int64 v25; // x1
  __int64 v26; // x2
  void *v27; // x3
  void *v28; // x4
  void *v29; // x5
  void *v30; // x6
  __int64 v31; // x7
  double v32; // d0
  double v33; // d1
  double v34; // d2
  double v35; // d3
  double v36; // d4
  double v37; // d5
  double v38; // d6
  double v39; // d7
  unsigned __int64 v40; // x21
  __int64 v41; // x25
  _BYTE *i; // x23
  _BYTE *v43; // x23
  unsigned __int64 (__fastcall *v44)(__int64); // x0
  char *v45; // x0
  __int64 v46; // x1
  __int64 v47; // x2
  void *v48; // x3
  void *v49; // x4
  void *v50; // x5
  void *v51; // x6
  __int64 v52; // x7
  double v53; // d0
  double v54; // d1
  double v55; // d2
  double v56; // d3
  double v57; // d4
  double v58; // d5
  double v59; // d6
  double v60; // d7
  unsigned __int64 v61; // x27
  unsigned __int64 v62; // x28
  unsigned __int64 v63; // x25
  int v64; // w0
  __int64 v65; // x22
  signed int v66; // w0
  unsigned __int64 v67; // x28
  __int64 v68; // x23
  unsigned __int64 (__fastcall *v69)(__int64); // x0
  __int64 v70; // x1
  __int64 v71; // x2
  void *v72; // x4
  void *v73; // x5
  void *v74; // x6
  __int64 v75; // x7
  double v76; // d0
  double v77; // d1
  double v78; // d2
  double v79; // d3
  double v80; // d4
  double v81; // d5
  double v82; // d6
  double v83; // d7
  void *v84; // x3
  __int64 v85; // x0
  _QWORD *v86; // x0
  double v87; // d0
  double v88; // d1
  double v89; // d2
  double v90; // d3
  double v91; // d4
  double v92; // d5
  double v93; // d6
  double v94; // d7
  unsigned __int64 v95; // x23
  __int64 v96; // x21
  unsigned __int64 (__fastcall *v97)(__int64); // x0
  __int64 v98; // x22
  unsigned __int64 v99; // x25
  unsigned __int64 (__fastcall *v100)(__int64); // x0
  char *v101; // x1
  __int64 v102; // x0
  unsigned int v103; // w27
  __int64 v104; // x22
  bool v105; // zf
  unsigned __int64 v107; // x23
  unsigned __int64 v108; // x21
  unsigned __int64 (__fastcall *v109)(__int64); // x0
  __int64 v113; // [xsp+98h] [xbp+78h]

  v15 = a3 + 2;
  v16 = a4 & 4;
  v17 = strlen();
  v18 = 0LL;
  if ( (a4 & 4) != 0 )
    v18 = (char *)strlen() + 1;
  v19 = &v18[(_QWORD)v17];
  v20 = 0LL;
  if ( (a4 & 2) != 0 )
    v20 = (char *)strlen() + 1;
  v21 = &v20[v15];
  v22 = 0LL;
  if ( (a4 & 1) != 0 )
    v22 = (unsigned __int64)strlen() + 1;
  v23 = 0LL;
  if ( (a4 & 8) != 0 )
    v23 = (char *)strlen() + 1;
  v24 = strlen();
  v40 = malloc(
          (__int64)&v19[(_QWORD)v24 + v22 + (unsigned __int64)&v21[(_QWORD)v23]],
          v25,
          v26,
          v27,
          v28,
          v29,
          v30,
          v31,
          v32,
          v33,
          v34,
          v35,
          v36,
          v37,
          v38,
          v39);
  if ( !v40 )
    return 0LL;
  j_memcpy();
  if ( a3 )
  {
    v41 = a3;
    for ( i = (_BYTE *)v40; ; i = v43 + 1 )
    {
      v44 = strlen();
      v41 = v41 - (_QWORD)v44 - 1;
      if ( !v41 )
        break;
      v43 = (char *)v44 + (_QWORD)i;
      *v43 = 58;
    }
  }
  *(_BYTE *)(v40 + a3 - 1) = 47;
  v45 = stpcpy((_QWORD *)(v40 + a3), a5);
  if ( v16 )
  {
    *v45 = 95;
    v45 = stpcpy(v45 + 1, a6);
  }
  if ( (a4 & 2) == 0 )
  {
    if ( (a4 & 1) == 0 )
      goto LABEL_18;
LABEL_56:
    *v45 = 46;
    v45 = stpcpy(v45 + 1, a8);
    if ( (a4 & 8) == 0 )
      goto LABEL_19;
    goto LABEL_57;
  }
  *v45 = 46;
  v45 = stpcpy(v45 + 1, a7);
  if ( (a4 & 1) != 0 )
    goto LABEL_56;
LABEL_18:
  if ( (a4 & 8) == 0 )
    goto LABEL_19;
LABEL_57:
  *v45 = 64;
  v45 = stpcpy(v45 + 1, a9);
LABEL_19:
  *v45 = 47;
  j_memcpy();
  v61 = *a1;
  if ( *a1 )
  {
    v62 = *a1;
    v63 = 0LL;
    while ( 1 )
    {
      if ( *(_QWORD *)v62 )
      {
        v64 = strcmp(*(unsigned __int64 **)v62, v40);
        if ( !v64 )
          goto LABEL_54;
        if ( v64 < 0 )
          goto LABEL_26;
        v63 = v62;
      }
      v62 = *(_QWORD *)(v62 + 24);
      if ( !v62 )
        goto LABEL_26;
    }
  }
  v63 = 0LL;
LABEL_26:
  if ( a11 )
  {
    if ( a3 )
    {
      v65 = a3;
      v66 = (((int)(((a4 >> 1) & 0xFFFFD555) + (a4 & 0x5555)) >> 2) & 0xFFFFF333)
          + ((((a4 >> 1) & 0xFFFFD555) + (a4 & 0x5555)) & 0x3333);
      v67 = a2;
      v68 = 0LL;
      v113 = 1 << (((v66 + (v66 >> 4)) & 0xF) + ((unsigned __int16)((v66 + (v66 >> 4)) & 0xF0F) >> 8));
      do
      {
        v69 = strlen();
        v84 = (char *)v69 + 1;
        v85 = v65 - (_QWORD)v69;
        v67 += (unsigned __int64)v84;
        ++v68;
        v65 = v85 - 1;
      }
      while ( v85 != 1 );
      v86 = (_QWORD *)malloc(
                        8 * (v68 * v113 + 5),
                        v70,
                        v71,
                        v84,
                        v72,
                        v73,
                        v74,
                        v75,
                        v76,
                        v77,
                        v78,
                        v79,
                        v80,
                        v81,
                        v82,
                        v83);
      v62 = (unsigned __int64)v86;
      if ( v86 )
      {
        v95 = a2;
        *v86 = v40;
        v96 = a3;
        do
        {
          v97 = strlen();
          v95 += (unsigned __int64)v97 + 1;
          ++v65;
          v96 = v96 - (_QWORD)v97 - 1;
        }
        while ( v96 );
        if ( v65 == 1 )
        {
          *(_QWORD *)(v62 + 16) = 0LL;
          *(_DWORD *)(v62 + 8) = (a4 & 3) == 3;
          if ( v63 )
            goto LABEL_35;
        }
        else
        {
          *(_DWORD *)(v62 + 8) = 1;
          *(_QWORD *)(v62 + 16) = 0LL;
          if ( v63 )
          {
LABEL_35:
            *(_QWORD *)(v62 + 24) = *(_QWORD *)(v63 + 24);
            *(_QWORD *)(v63 + 24) = v62;
            goto LABEL_36;
          }
        }
        *(_QWORD *)(v62 + 24) = v61;
        *a1 = v62;
LABEL_36:
        v98 = a3;
        v99 = a2;
        do
        {
          v100 = strlen();
          v101 = (char *)v100 + 1;
          v102 = v98 - (_QWORD)v100;
          v99 += (unsigned __int64)v101;
          ++v96;
          v98 = v102 - 1;
        }
        while ( v102 != 1 );
        v103 = a4 - (v96 == 1);
LABEL_39:
        v104 = 0LL;
        if ( (v103 & 0x80000000) == 0 )
        {
          do
          {
            while ( (v103 & ~a4) != 0 )
              --v103;
            if ( a3 )
              v105 = a2 == 0;
            else
              v105 = 1;
            if ( !v105 )
            {
              v107 = a2;
              v108 = a2 + a3;
              do
              {
                v109 = strlen();
                ++v104;
                *(_QWORD *)(v62 + 24 + 8 * v104) = nl_make_l10nflist(
                                                     a1,
                                                     v107,
                                                     (char *)v109 + 1,
                                                     v103,
                                                     a5,
                                                     a6,
                                                     a7,
                                                     a8,
                                                     a9,
                                                     a10,
                                                     1);
                if ( v108 <= v107 )
                  break;
                v107 += (unsigned __int64)strlen() + 1;
              }
              while ( v107 < v108 );
            }
            --v103;
          }
          while ( v103 != -1 );
        }
        *(_QWORD *)(v62 + 8 * (v104 + 4)) = 0LL;
        return v62;
      }
    }
    else
    {
      v62 = malloc(40LL, v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60);
      if ( v62 )
      {
        *(_QWORD *)v62 = v40;
        *(_DWORD *)(v62 + 8) = 1;
        *(_QWORD *)(v62 + 16) = 0LL;
        if ( v63 )
        {
          *(_QWORD *)(v62 + 24) = *(_QWORD *)(v63 + 24);
          v103 = a4;
          *(_QWORD *)(v63 + 24) = v62;
        }
        else
        {
          *(_QWORD *)(v62 + 24) = v61;
          v103 = a4;
          *a1 = v62;
        }
        goto LABEL_39;
      }
    }
    free(v40, v87, v88, v89, v90, v91, v92, v93, v94);
    return 0LL;
  }
  v62 = 0LL;
LABEL_54:
  free(v40, v53, v54, v55, v56, v57, v58, v59, v60);
  return v62;
}
// 42BEE0: variable 'v25' is possibly undefined
// 42BEE0: variable 'v26' is possibly undefined
// 42BEE0: variable 'v27' is possibly undefined
// 42BEE0: variable 'v28' is possibly undefined
// 42BEE0: variable 'v29' is possibly undefined
// 42BEE0: variable 'v30' is possibly undefined
// 42BEE0: variable 'v31' is possibly undefined
// 42BEE0: variable 'v32' is possibly undefined
// 42BEE0: variable 'v33' is possibly undefined
// 42BEE0: variable 'v34' is possibly undefined
// 42BEE0: variable 'v35' is possibly undefined
// 42BEE0: variable 'v36' is possibly undefined
// 42BEE0: variable 'v37' is possibly undefined
// 42BEE0: variable 'v38' is possibly undefined
// 42BEE0: variable 'v39' is possibly undefined
// 42C034: variable 'v70' is possibly undefined
// 42C034: variable 'v71' is possibly undefined
// 42C034: variable 'v72' is possibly undefined
// 42C034: variable 'v73' is possibly undefined
// 42C034: variable 'v74' is possibly undefined
// 42C034: variable 'v75' is possibly undefined
// 42C034: variable 'v76' is possibly undefined
// 42C034: variable 'v77' is possibly undefined
// 42C034: variable 'v78' is possibly undefined
// 42C034: variable 'v79' is possibly undefined
// 42C034: variable 'v80' is possibly undefined
// 42C034: variable 'v81' is possibly undefined
// 42C034: variable 'v82' is possibly undefined
// 42C034: variable 'v83' is possibly undefined
// 42C164: variable 'v53' is possibly undefined
// 42C164: variable 'v54' is possibly undefined
// 42C164: variable 'v55' is possibly undefined
// 42C164: variable 'v56' is possibly undefined
// 42C164: variable 'v57' is possibly undefined
// 42C164: variable 'v58' is possibly undefined
// 42C164: variable 'v59' is possibly undefined
// 42C164: variable 'v60' is possibly undefined
// 42C240: variable 'v46' is possibly undefined
// 42C240: variable 'v47' is possibly undefined
// 42C240: variable 'v48' is possibly undefined
// 42C240: variable 'v49' is possibly undefined
// 42C240: variable 'v50' is possibly undefined
// 42C240: variable 'v51' is possibly undefined
// 42C240: variable 'v52' is possibly undefined
// 42C294: variable 'v87' is possibly undefined
// 42C294: variable 'v88' is possibly undefined
// 42C294: variable 'v89' is possibly undefined
// 42C294: variable 'v90' is possibly undefined
// 42C294: variable 'v91' is possibly undefined
// 42C294: variable 'v92' is possibly undefined
// 42C294: variable 'v93' is possibly undefined
// 42C294: variable 'v94' is possibly undefined

//----- (000000000042C2A0) ----------------------------------------------------
_DWORD *__fastcall nl_normalize_codeset(
        int8x16_t *a1,
        __int64 a2,
        _WORD *a3,
        char *a4,
        unsigned __int64 a5,
        __int64 a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  int8x16_t v16; // q28
  int8x16_t v17; // q29
  int8x16_t *v18; // x19
  char *v19; // x20
  int8x16_t v20; // q22
  int8x16_t *v21; // x12
  int64x2_t v22; // q23
  int16x8_t v23; // q19
  uint32x4_t v24; // q24
  uint32x4_t v25; // q25
  int8x16_t v26; // q26
  int8x16_t v27; // t1
  int16x8_t v28; // q31
  uint16x8_t v29; // q30
  uint16x8_t v30; // q27
  int16x8_t v31; // q28
  int16x8_t v32; // q28
  int8x16_t v33; // q17
  int16x8_t v34; // q29
  int8x16_t v35; // q18
  int8x16_t v36; // q31
  int8x16_t v37; // off
  int8x16_t v38; // q30
  int8x16_t v39; // q30
  __int64 v40; // x0
  _DWORD *result; // x0
  _BYTE *v42; // x1
  unsigned __int8 *v43; // x2
  unsigned __int8 *v44; // x20
  int v45; // w3
  __int64 v46; // x0

  v18 = a1;
  v19 = (char *)a2;
  if ( !a2 )
  {
    v46 = 4LL;
    goto LABEL_19;
  }
  a3 = word_45EA40;
  if ( (unsigned __int64)(a2 - 1) <= 0xE )
  {
    v40 = 0LL;
    a4 = 0LL;
    a6 = 1LL;
    do
    {
LABEL_6:
      a5 = (unsigned __int8)a4[(_QWORD)v18];
      a2 = (unsigned __int16)word_45EA40[a5];
      if ( (a2 & 8) != 0 )
      {
        a5 = (unsigned int)(a5 - 48);
        ++v40;
        a2 = (unsigned int)a5 <= 9;
        a6 = (unsigned int)a6 & (unsigned int)a2;
      }
      ++a4;
    }
    while ( v19 > a4 );
    goto LABEL_9;
  }
  a4 = (char *)(a2 & 0xFFFFFFFFFFFFFFF0LL);
  v20 = 0uLL;
  v21 = (int8x16_t *)((char *)a1 + (a2 & 0xFFFFFFFFFFFFFFF0LL));
  v22 = 0uLL;
  v23.n128_u64[0] = 0x8000800080008LL;
  v23.n128_u64[1] = 0x8000800080008LL;
  v24.n128_u64[0] = 0x2F0000002FLL;
  v24.n128_u64[1] = 0x2F0000002FLL;
  v25.n128_u64[0] = 0x900000009LL;
  v25.n128_u64[1] = 0x900000009LL;
  v26.n128_u64[0] = 0x100000001LL;
  v26.n128_u64[1] = 0x100000001LL;
  do
  {
    v27 = *a1++;
    v28.n128_u64[1] = v27.n128_u64[1];
    v29 = vzip1q_s8(v27, (int8x16_t)0LL);
    v30 = vzip2q_s8(v27, (int8x16_t)0LL);
    v17.n128_u16[0] = word_45EA40[v27.n128_u8[0]];
    v17.n128_u16[1] = word_45EA40[v27.n128_u8[2]];
    v17.n128_u16[2] = word_45EA40[v27.n128_u8[4]];
    a8 = v27.n128_u8[14];
    v17.n128_u16[3] = word_45EA40[v27.n128_u8[6]];
    v16.n128_u16[0] = word_45EA40[v27.n128_u8[1]];
    a7 = (void *)v27.n128_u8[9];
    v16.n128_u16[1] = word_45EA40[v27.n128_u8[3]];
    a5 = v27.n128_u8[13];
    v16.n128_u16[2] = word_45EA40[v27.n128_u8[5]];
    a2 = v27.n128_u8[15];
    v16.n128_u16[3] = word_45EA40[v27.n128_u8[7]];
    v31 = vzip1q_s16(v17, v16);
    v17.n128_u16[0] = word_45EA40[v27.n128_u8[8]];
    v17.n128_u16[1] = word_45EA40[v27.n128_u8[10]];
    v32 = vtstq_s16(v31, v23);
    v17.n128_u16[2] = word_45EA40[v27.n128_u8[12]];
    v33 = vmovl_s16((int16x4_t)v32.n128_u64[0]);
    v16 = vmovl_high_s16(v32);
    v17.n128_u16[3] = word_45EA40[v27.n128_u8[14]];
    v28.n128_u16[0] = word_45EA40[v27.n128_u8[9]];
    v28.n128_u16[1] = word_45EA40[v27.n128_u8[11]];
    v28.n128_u16[2] = word_45EA40[v27.n128_u8[13]];
    v28.n128_u16[3] = word_45EA40[v27.n128_u8[15]];
    v34 = vtstq_s16(vzip1q_s16(v17, v28), v23);
    v35 = vmovl_s16((int16x4_t)v34.n128_u64[0]);
    v17 = vmovl_high_s16(v34);
    v36 = vandq_s8(
            vandq_s8(
              vornq_s8(vandq_s8(vcgeq_u32(v25, vaddw_high_u16(v24, v30)), v26), v17),
              vornq_s8(vandq_s8(vcgeq_u32(v25, vaddw_u16(v24, (uint16x4_t)v30.n128_u64[0])), v26), v35)),
            vandq_s8(
              vornq_s8(vandq_s8(vcgeq_u32(v25, vaddw_high_u16(v24, v29)), v26), v16),
              vornq_s8(vandq_s8(vcgeq_u32(v25, vaddw_u16(v24, (uint16x4_t)v29.n128_u64[0])), v26), v33)));
    v37.n128_u64[0] = v33.n128_i32[2];
    v37.n128_u64[1] = v33.n128_i32[3];
    v38 = v37;
    v20 = vandq_s8(v20, v36);
    v37.n128_u64[0] = v16.n128_i32[2];
    v37.n128_u64[1] = v16.n128_i32[3];
    v22 = vaddq_s64(
            v22,
            vaddq_s64(
              vsubw_high_s32(
                vsubw_high_s32(vsubw_s32(vandq_s8(v37, (int8x16_t)xmmword_45B7A0), (int32x2_t)v16.n128_u64[0]), v35),
                v17),
              vsubw_s32(
                vsubw_s32(
                  vsubw_s32(vandq_s8(v38, (int8x16_t)xmmword_45B7A0), (int32x2_t)v33.n128_u64[0]),
                  (int32x2_t)v35.n128_u64[0]),
                (int32x2_t)v17.n128_u64[0])));
  }
  while ( a1 != v21 );
  v39 = vandq_s8(vextq_s8(v20, (int8x16_t)0, 8uLL), v20);
  a6 = vandq_s8(vextq_s8(v39, (int8x16_t)0, 4uLL), v39).n128_u8[0] & 1;
  v40 = vaddvq_s64(v22);
  if ( v19 != a4 )
    goto LABEL_6;
LABEL_9:
  if ( !(_DWORD)a6 )
  {
    result = (_DWORD *)malloc(
                         v40 + 1,
                         a2,
                         (__int64)word_45EA40,
                         a4,
                         (void *)a5,
                         (void *)a6,
                         a7,
                         a8,
                         a9,
                         a10,
                         a11,
                         a12,
                         a13,
                         a14,
                         a15,
                         a16);
    v42 = result;
    if ( result )
    {
LABEL_11:
      v43 = (unsigned __int8 *)v18;
      v44 = (unsigned __int8 *)&v19[(_QWORD)v18];
      while ( 1 )
      {
        while ( 1 )
        {
          v45 = *v43;
          if ( (word_45EA40[*v43] & 0x400) == 0 )
            break;
          *v42++ = dword_45DB40[*v43];
LABEL_13:
          if ( ++v43 == v44 )
            goto LABEL_17;
        }
        if ( (unsigned int)(v45 - 48) > 9 )
          goto LABEL_13;
        ++v43;
        *v42++ = v45;
        if ( v43 == v44 )
          goto LABEL_17;
      }
    }
    return 0LL;
  }
  v46 = v40 + 4;
LABEL_19:
  result = (_DWORD *)malloc(
                       v46,
                       a2,
                       (__int64)a3,
                       a4,
                       (void *)a5,
                       (void *)a6,
                       a7,
                       a8,
                       a9,
                       a10,
                       a11,
                       a12,
                       a13,
                       a14,
                       a15,
                       a16);
  if ( !result )
    return 0LL;
  *result = 7304041;
  v42 = (char *)result + 3;
  if ( v19 )
    goto LABEL_11;
LABEL_17:
  *v42 = 0;
  return result;
}
// 42C39C: variable 'v17' is possibly undefined
// 42C39C: variable 'v16' is possibly undefined
// 45B7A0: using guessed type __int128 xmmword_45B7A0;
// 45DB40: using guessed type _DWORD dword_45DB40[256];
// 45EA40: using guessed type _WORD word_45EA40[256];

//----- (000000000042C5A0) ----------------------------------------------------
__int64 __fastcall nl_explode_name(
        unsigned __int8 *a1,
        _QWORD *a2,
        _WORD *a3,
        char *a4,
        unsigned __int64 **a5,
        _QWORD *a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14)
{
  unsigned __int8 *v14; // x1
  int v15; // w6
  unsigned __int8 *v17; // x7
  void *v19; // x6
  __int64 v20; // x7
  int v23; // t1
  unsigned int v24; // w0
  int8x16_t *v26; // x0
  int8x16_t *v27; // x8
  int8x16_t *v28; // x11
  unsigned __int8 v29; // t1
  _DWORD *v30; // x0
  int v31; // w0
  double v32; // d0
  double v33; // d1
  double v34; // d2
  double v35; // d3
  double v36; // d4
  double v37; // d5
  double v38; // d6
  double v39; // d7
  unsigned __int64 **v40; // x4
  _QWORD *v41; // x2
  char *v42; // x3
  int v43; // w6
  unsigned int v44; // w7
  int8x16_t *v45; // x1
  unsigned __int64 v48; // [xsp+18h] [xbp-38h]
  int8x16_t *v49; // [xsp+20h] [xbp-30h]
  unsigned int v50; // [xsp+28h] [xbp-28h]
  int8x16_t *v53; // [xsp+40h] [xbp-10h]
  int v54; // [xsp+4Ch] [xbp-4h]

  *(_QWORD *)a3 = 0LL;
  *(_QWORD *)a4 = 0LL;
  *a5 = 0LL;
  *a6 = 0LL;
  *a2 = a1;
  v14 = a1;
  v15 = *a1;
  if ( v15 == 95 || v15 == 0 )
  {
LABEL_20:
    LODWORD(v20) = 0;
    goto LABEL_21;
  }
  while ( 1 )
  {
    if ( v15 == 64 || v15 == 46 )
    {
      if ( a1 == v14 )
        goto LABEL_20;
LABEL_15:
      LODWORD(v19) = *v14;
      v20 = 0LL;
      if ( (_DWORD)v19 != 46 )
        goto LABEL_16;
      goto LABEL_40;
    }
    v15 = v14[1];
    v17 = v14 + 1;
    if ( v15 == 95 || v15 == 0 )
      break;
    ++v14;
  }
  if ( a1 == v17 )
    goto LABEL_20;
  if ( v15 != 95 )
  {
    ++v14;
    goto LABEL_15;
  }
  *v17 = 0;
  v14 += 2;
  *(_QWORD *)a4 = v14;
  LODWORD(v19) = v17[1];
  if ( (_DWORD)v19 != 46 && ((unsigned int)v19 & 0xFFFFFFBF) != 0 )
  {
    do
    {
      v23 = *++v14;
      LODWORD(v19) = v23;
      v24 = v23 & 0xFFFFFFBF;
    }
    while ( v23 != 46 && v24 != 0 );
  }
  v20 = 4LL;
  if ( (_DWORD)v19 != 46 )
    goto LABEL_16;
LABEL_40:
  *v14 = 0;
  v26 = (int8x16_t *)(v14 + 1);
  *a5 = (unsigned __int64 *)(v14 + 1);
  v19 = (void *)v14[1];
  if ( ((unsigned __int8)v19 & 0xBF) != 0 )
  {
    v27 = (int8x16_t *)(v14 + 1);
    do
    {
      v28 = v27;
      v29 = v27->n128_u8[1];
      v27 = (int8x16_t *)((char *)v27 + 1);
    }
    while ( (v29 & 0xBF) != 0 );
    if ( v26 != v27 )
    {
      v49 = v28;
      v50 = v20 | 2;
      v53 = v27;
      v54 = v20;
      v30 = nl_normalize_codeset(
              v26,
              (char *)v28 - (char *)v14,
              a3,
              a4,
              (unsigned __int64)a5,
              (__int64)a6,
              v19,
              v20,
              a7,
              a8,
              a9,
              a10,
              a11,
              a12,
              a13,
              a14);
      *a6 = v30;
      if ( v30 )
      {
        v48 = (unsigned __int64)v30;
        v31 = strcmp(*a5, (unsigned __int64)v30);
        v40 = a5;
        v41 = a3;
        v42 = a4;
        if ( v31 )
        {
          v43 = v49->n128_u8[1];
          v44 = v54 | 3;
          v45 = v53;
        }
        else
        {
          free(v48, v32, v33, v34, v35, v36, v37, v38, v39);
          v45 = v53;
          v44 = v50;
          v40 = a5;
          v41 = a3;
          v42 = a4;
          v43 = v49->n128_u8[1];
        }
        if ( v43 == 64 )
        {
          v45->n128_u8[0] = 0;
          *v41 = (char *)v45->n128_u64 + 1;
          if ( v45->n128_u8[1] )
            v44 |= 8u;
        }
        if ( *(_QWORD *)v42 && !**(_BYTE **)v42 )
          v44 &= ~4u;
        if ( *v40 && !*(_BYTE *)*v40 )
          v44 &= ~2u;
      }
      else
      {
        return (unsigned int)-1;
      }
      return v44;
    }
  }
  LODWORD(v20) = v20 | 2;
  ++v14;
LABEL_16:
  if ( (_DWORD)v19 == 64 )
  {
    *v14 = 0;
    *(_QWORD *)a3 = v14 + 1;
    if ( v14[1] )
      LODWORD(v20) = v20 | 8;
  }
LABEL_21:
  if ( *(_QWORD *)a4 && !**(_BYTE **)a4 )
    LODWORD(v20) = v20 & 0xFFFFFFFB;
  if ( *a5 )
  {
    if ( !*(_BYTE *)*a5 )
      LODWORD(v20) = v20 & 0xFFFFFFFD;
  }
  return (unsigned int)v20;
}
// 42C7F0: variable 'v32' is possibly undefined
// 42C7F0: variable 'v33' is possibly undefined
// 42C7F0: variable 'v34' is possibly undefined
// 42C7F0: variable 'v35' is possibly undefined
// 42C7F0: variable 'v36' is possibly undefined
// 42C7F0: variable 'v37' is possibly undefined
// 42C7F0: variable 'v38' is possibly undefined
// 42C7F0: variable 'v39' is possibly undefined

//----- (000000000042C820) ----------------------------------------------------
void __fastcall _gettext_free_exp(
        unsigned __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  int v10; // w0

  if ( a1 )
  {
    v10 = *(_DWORD *)a1;
    if ( v10 != 2 )
    {
      if ( v10 != 3 )
      {
        if ( v10 != 1 )
        {
LABEL_6:
          free(a1, a2, a3, a4, a5, a6, a7, a8, a9);
          return;
        }
LABEL_5:
        a2 = _gettext_free_exp(*(_QWORD *)(a1 + 8));
        goto LABEL_6;
      }
      _gettext_free_exp(*(_QWORD *)(a1 + 24));
    }
    _gettext_free_exp(*(_QWORD *)(a1 + 16));
    goto LABEL_5;
  }
}
// 42C864: variable 'a3' is possibly undefined
// 42C864: variable 'a4' is possibly undefined
// 42C864: variable 'a5' is possibly undefined
// 42C864: variable 'a6' is possibly undefined
// 42C864: variable 'a7' is possibly undefined
// 42C864: variable 'a8' is possibly undefined
// 42C864: variable 'a9' is possibly undefined

//----- (000000000042C880) ----------------------------------------------------
__int64 __fastcall _gettextparse(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned __int64 a4,
        void *a5,
        __int64 a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  int v16; // w19
  _BYTE *v17; // x24
  __int64 v18; // x23
  _BYTE *v19; // x28
  unsigned __int64 *v20; // x27
  __int64 v21; // x25
  int v22; // w26
  unsigned __int64 v23; // x22
  __int64 v24; // x24
  __int64 v25; // x27
  char *v26; // x22
  unsigned int v27; // w0
  unsigned int v28; // w11
  char *v29; // x3
  int v30; // t1
  signed int v31; // w0
  __int64 v32; // x1
  int v33; // w26
  unsigned __int64 v34; // x3
  unsigned __int64 v35; // x0
  double v36; // d0
  double v37; // d1
  double v38; // d2
  double v39; // d3
  double v40; // d4
  double v41; // d5
  double v42; // d6
  double v43; // d7
  unsigned __int64 *v44; // x3
  char *v45; // x24
  int v46; // w9
  int v47; // w0
  unsigned int v48; // w19
  int v50; // w9
  unsigned __int64 v51; // x9
  void *v52; // x3
  bool v53; // zf
  _BYTE *v54; // x9
  _BYTE *v55; // x10
  bool v56; // zf
  int v57; // w3
  void *v58; // x3
  unsigned __int64 v59; // x9
  bool v60; // zf
  bool v61; // zf
  unsigned __int64 v62; // x9
  unsigned __int64 v63; // x9
  void *v64; // x3
  __int64 v65; // x10
  bool v66; // zf
  bool v67; // zf
  void *v68; // x3
  double v69; // d0
  double v70; // d1
  double v71; // d2
  double v72; // d3
  double v73; // d4
  double v74; // d5
  double v75; // d6
  double v76; // d7
  int v77; // w3
  int v78; // t1
  int v79; // w5
  _BYTE *v80; // x10
  unsigned int v81; // w3
  unsigned int v82; // w3
  _BYTE *v83; // x10
  unsigned int v84; // w3
  int v85; // w5
  _BYTE *v86; // x10
  unsigned int v87; // w3
  __int64 v88; // x3
  __int64 v89; // [xsp+60h] [xbp+60h]
  unsigned int v90; // [xsp+74h] [xbp+74h]
  __int64 v91; // [xsp+78h] [xbp+78h]
  unsigned __int64 v93; // [xsp+90h] [xbp+90h]
  void *v94; // [xsp+90h] [xbp+90h]
  unsigned __int64 v95; // [xsp+90h] [xbp+90h]
  unsigned __int64 v96; // [xsp+90h] [xbp+90h]
  __int64 v97; // [xsp+90h] [xbp+90h]
  void *v98; // [xsp+90h] [xbp+90h]
  unsigned __int64 v99; // [xsp+90h] [xbp+90h]
  __int64 v100; // [xsp+90h] [xbp+90h]
  unsigned __int64 v101; // [xsp+98h] [xbp+98h]
  unsigned __int64 v102; // [xsp+A0h] [xbp+A0h]
  void *v103; // [xsp+A0h] [xbp+A0h]
  void *v104; // [xsp+A0h] [xbp+A0h]
  void *v105; // [xsp+A0h] [xbp+A0h]
  int v106; // [xsp+A8h] [xbp+A8h]
  unsigned __int64 v107; // [xsp+A8h] [xbp+A8h]
  _QWORD v108[3]; // [xsp+B0h] [xbp+B0h] BYREF
  _BYTE v109[200]; // [xsp+C8h] [xbp+C8h] BYREF
  char v110; // [xsp+190h] [xbp+190h] BYREF

  v16 = -2;
  v17 = v109;
  v18 = 199LL;
  v19 = v109;
  v20 = (unsigned __int64 *)&v110;
  v21 = 200LL;
  v22 = 0;
  v90 = 0;
  while ( 1 )
  {
    *v17 = v22;
    if ( v17 >= &v19[v18] )
      break;
LABEL_11:
    if ( v22 == 9 )
    {
      v48 = 0;
      goto LABEL_36;
    }
    a8 = v22;
    v26 = "US-ASCII//" + 10;
    v27 = yypact[v22];
    v28 = v27;
    if ( v27 == -4 )
      goto LABEL_17;
    if ( v16 == -2 )
    {
      v54 = *(_BYTE **)a1;
      do
      {
        v57 = (unsigned __int8)*v54;
        if ( !*v54 )
        {
          *(_QWORD *)a1 = v54;
          goto LABEL_15;
        }
        v55 = v54;
        v56 = v57 == 32 || v57 == 9;
        ++v54;
      }
      while ( v56 );
      a6 = (unsigned int)(v57 - 10);
      v16 = v57;
      switch ( v57 )
      {
        case 10:
        case 59:
          *(_QWORD *)a1 = v55;
          goto LABEL_15;
        case 33:
          if ( v55[1] == 61 )
          {
            v83 = v55 + 2;
            v84 = 13;
LABEL_117:
            v50 = 7;
            v16 = 258;
            v26 = "US-ASCII//" + 10;
            v101 = v101 & 0xFFFFFFFF00000000LL | v84;
            *(_QWORD *)a1 = v83;
          }
          else
          {
            v16 = 33;
            v26 = "US-ASCII//" + 10;
            *(_QWORD *)a1 = v54;
            v50 = 6;
          }
          break;
        case 37:
          v82 = 5;
          goto LABEL_114;
        case 38:
        case 124:
          a6 = (unsigned __int8)v55[1];
          if ( (_DWORD)a6 != v57 )
            goto LABEL_61;
          v26 = "";
          *(_QWORD *)a1 = v55 + 2;
          v50 = yytranslate[v57];
          break;
        case 40:
        case 41:
        case 58:
        case 63:
        case 110:
          v26 = "";
          *(_QWORD *)a1 = v54;
          v50 = yytranslate[v57];
          break;
        case 42:
          v82 = 3;
          goto LABEL_114;
        case 43:
          v87 = 6;
          goto LABEL_122;
        case 45:
          v87 = 7;
LABEL_122:
          v16 = 260;
          v26 = "US-ASCII//" + 10;
          v101 = v101 & 0xFFFFFFFF00000000LL | v87;
          *(_QWORD *)a1 = v54;
          v50 = 9;
          break;
        case 47:
          v82 = 4;
LABEL_114:
          v16 = 261;
          v26 = "US-ASCII//" + 10;
          v101 = v101 & 0xFFFFFFFF00000000LL | v82;
          *(_QWORD *)a1 = v54;
          v50 = 10;
          break;
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          a6 = v57 - 48;
          v77 = (unsigned __int8)v55[1] - 48;
          if ( (unsigned __int8)(v55[1] - 48) <= 9u )
          {
            do
            {
              a6 = v77 + 10 * a6;
              v78 = (unsigned __int8)*++v54;
              v77 = v78 - 48;
            }
            while ( (unsigned __int8)(v78 - 48) <= 9u );
          }
          v16 = 262;
          v26 = "US-ASCII//" + 10;
          v101 = a6;
          *(_QWORD *)a1 = v54;
          v50 = 11;
          break;
        case 60:
          v85 = (unsigned __int8)v55[1];
          v86 = v55 + 2;
          v53 = v85 == 61;
          a6 = 10LL;
          if ( v53 )
          {
            v54 = v86;
            v81 = 10;
          }
          else
          {
            v81 = 8;
          }
          goto LABEL_112;
        case 61:
          if ( v55[1] != 61 )
            goto LABEL_61;
          v83 = v55 + 2;
          v84 = 12;
          goto LABEL_117;
        case 62:
          v79 = (unsigned __int8)v55[1];
          v80 = v55 + 2;
          v53 = v79 == 61;
          a6 = 11LL;
          if ( v53 )
          {
            v54 = v80;
            v81 = 11;
          }
          else
          {
            v81 = 9;
          }
LABEL_112:
          v16 = 259;
          v26 = "US-ASCII//" + 10;
          v101 = v101 & 0xFFFFFFFF00000000LL | v81;
          *(_QWORD *)a1 = v54;
          v50 = 8;
          break;
        default:
LABEL_61:
          v16 = 257;
          v26 = "US-ASCII//" + 10;
          *(_QWORD *)a1 = v54;
          v50 = 2;
          break;
      }
LABEL_40:
      v28 = v27 + v50;
      if ( v27 + v50 > 0x38 )
      {
        LODWORD(a4) = v26[v22 + 944];
        if ( !v26[v22 + 944] )
        {
          if ( v90 == 3 )
            v16 = -2;
          goto LABEL_21;
        }
        goto LABEL_30;
      }
      v29 = v26 + 672;
      if ( v26[v28 + 976] == v50 )
        goto LABEL_42;
LABEL_17:
      LODWORD(a4) = v26[v22 + 944];
      if ( !v26[v22 + 944] )
      {
        if ( v90 == 3 )
        {
          if ( !v16 )
            goto LABEL_35;
          v16 = -2;
        }
        goto LABEL_21;
      }
LABEL_30:
      v32 = (int)a4;
      v91 = (int)a4;
      v33 = v26[(int)a4 + 1104];
      v34 = (unsigned int)(a4 - 2);
      v35 = v20[1 - v33];
      switch ( (int)v34 )
      {
        case 0:
          if ( !*v20 )
            goto LABEL_35;
          *(_QWORD *)(a1 + 8) = *v20;
          break;
        case 1:
          v63 = *v20;
          v108[2] = v63;
          v64 = (void *)*(v20 - 2);
          v65 = *(v20 - 4);
          v108[0] = v65;
          v108[1] = v64;
          if ( v63 )
            v66 = v64 == 0LL;
          else
            v66 = 1;
          v67 = v66 || v65 == 0;
          if ( v67
            || (v97 = v65,
                v105 = v64,
                v107 = v63,
                (v35 = malloc(32LL, v32, a3, v64, a5, (void *)a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16)) == 0) )
          {
            v88 = 1LL;
            do
            {
              v100 = v88;
              _gettext_free_exp(v108[v88 + 1], a9, a10, a11, a12, a13, a14, a15, a16);
              v88 = v100 - 1;
            }
            while ( v100 != -1 );
            v35 = 0LL;
          }
          else
          {
            *(_QWORD *)v35 = 0x1000000003LL;
            *(_QWORD *)(v35 + 8) = v97;
            *(_QWORD *)(v35 + 16) = v105;
            *(_QWORD *)(v35 + 24) = v107;
          }
          break;
        case 2:
          v58 = (void *)*v20;
          v59 = *(v20 - 2);
          if ( *v20 )
            v60 = v59 == 0;
          else
            v60 = 1;
          if ( v60 )
            goto LABEL_97;
          v95 = *(v20 - 2);
          v103 = (void *)*v20;
          v35 = malloc(32LL, v32, a3, v58, a5, (void *)a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
          v59 = v95;
          v58 = v103;
          if ( !v35 )
            goto LABEL_97;
          *(_QWORD *)(v35 + 16) = v103;
          *(_QWORD *)v35 = 0xF00000002LL;
          *(_QWORD *)(v35 + 8) = v95;
          break;
        case 3:
          v58 = (void *)*v20;
          v59 = *(v20 - 2);
          if ( *v20 )
            v61 = v59 == 0;
          else
            v61 = 1;
          if ( v61
            || (v96 = *(v20 - 2),
                v104 = (void *)*v20,
                v35 = malloc(32LL, v32, a3, v58, a5, (void *)a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16),
                v59 = v96,
                v58 = v104,
                !v35) )
          {
LABEL_97:
            v99 = v59;
            _gettext_free_exp((unsigned __int64)v58, a9, a10, a11, a12, a13, a14, a15, a16);
            _gettext_free_exp(v99, v69, v70, v71, v72, v73, v74, v75, v76);
            v35 = 0LL;
          }
          else
          {
            *(_QWORD *)(v35 + 16) = v104;
            *(_QWORD *)v35 = 0xE00000002LL;
            *(_QWORD *)(v35 + 8) = v96;
          }
          break;
        case 4:
        case 5:
        case 6:
        case 7:
          v51 = *v20;
          v52 = (void *)*(v20 - 2);
          if ( *v20 )
            v53 = v52 == 0LL;
          else
            v53 = 1;
          if ( v53
            || (v94 = (void *)*(v20 - 2),
                v102 = *v20,
                v106 = *((_DWORD *)v20 - 2),
                v35 = malloc(32LL, v32, a3, v52, a5, (void *)a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16),
                v52 = v94,
                v51 = v102,
                !v35) )
          {
            v93 = (unsigned __int64)v52;
            _gettext_free_exp(v51, a9, a10, a11, a12, a13, a14, a15, a16);
            _gettext_free_exp(v93, v36, v37, v38, v39, v40, v41, v42, v43);
            v35 = 0LL;
          }
          else
          {
            *(_DWORD *)v35 = 2;
            *(_DWORD *)(v35 + 4) = v106;
            *(_QWORD *)(v35 + 8) = v94;
            *(_QWORD *)(v35 + 16) = v102;
          }
          break;
        case 8:
          v68 = (void *)*v20;
          if ( *v20
            && (v98 = (void *)*v20,
                v35 = malloc(32LL, v32, a3, v68, a5, (void *)a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16),
                v68 = v98,
                v35) )
          {
            *(_QWORD *)v35 = 0x200000001LL;
            *(_QWORD *)(v35 + 8) = v98;
          }
          else
          {
            _gettext_free_exp((unsigned __int64)v68, a9, a10, a11, a12, a13, a14, a15, a16);
            v35 = 0LL;
          }
          break;
        case 9:
          v35 = malloc(32LL, v32, a3, (void *)v34, a5, (void *)a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
          if ( v35 )
            *(_QWORD *)v35 = 0LL;
          break;
        case 10:
          v35 = malloc(32LL, v32, a3, (void *)v34, a5, (void *)a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
          if ( v35 )
          {
            v62 = *v20;
            *(_QWORD *)v35 = 0x100000000LL;
            *(_QWORD *)(v35 + 8) = v62;
          }
          break;
        case 11:
          v35 = *(v20 - 1);
          break;
        default:
          break;
      }
      v44 = &v20[-v33];
      a8 = (__int64)(v26 + 672);
      v45 = &v17[-v33];
      v44[1] = v35;
      v20 = v44 + 1;
      v46 = *v45;
      a2 = (__int64)yypgoto;
      v47 = v26[v91 + 1120] - 16;
      a4 = (unsigned int)(yypgoto[v47] + v46);
      if ( (unsigned int)a4 <= 0x38 && v26[(int)a4 + 976] == v46 )
      {
        a8 = (__int64)(v26 + 1040);
        v17 = v45 + 1;
        v22 = v26[(int)a4 + 1040];
      }
      else
      {
        v17 = v45 + 1;
        a6 = (__int64)(v26 + 1136);
        v22 = v26[v47 + 1136];
      }
    }
    else
    {
      if ( v16 )
      {
        v26 = "";
        v50 = yytranslate[v16];
        goto LABEL_40;
      }
LABEL_15:
      if ( v27 > 0x38 )
      {
        v26 = "";
        LODWORD(a4) = yydefact[v22];
        if ( yydefact[v22] )
        {
          v16 = 0;
          goto LABEL_30;
        }
        if ( v90 == 3 )
        {
LABEL_35:
          v48 = 1;
          goto LABEL_36;
        }
        v16 = 0;
LABEL_21:
        a2 = (__int64)&unk_45B000;
        a8 = (__int64)yypact;
        a6 = (__int64)(v26 + 1040);
        while ( 1 )
        {
          if ( v27 != -4 )
          {
            v31 = v27 + 1;
            if ( (unsigned int)v31 <= 0x38 )
            {
              a4 = (unsigned int)v26[v31 + 976];
              if ( (_DWORD)a4 == 1 )
              {
                v22 = *(char *)(a6 + v31);
                if ( v22 > 0 )
                  break;
              }
            }
          }
          if ( v19 == v17 )
            goto LABEL_35;
          v30 = (char)*--v17;
          --v20;
          v27 = yypact[v30];
        }
        ++v20;
        ++v17;
        *v20 = v101;
        v90 = 3;
      }
      else
      {
        v26 = "";
        v29 = yytranslate;
        v16 = 0;
        if ( yycheck[v27] )
          goto LABEL_17;
LABEL_42:
        v22 = v29[v28 + 368];
        a4 = (unsigned int)-v22;
        if ( v22 <= 0 )
          goto LABEL_30;
        a2 = v90;
        ++v20;
        ++v17;
        v16 = -2;
        v90 -= v90 != 0;
        *v20 = v101;
      }
    }
  }
  if ( v21 != 10000 )
  {
    v21 *= 2LL;
    if ( v21 > 10000 )
      v21 = 10000LL;
    v23 = malloc(9 * v21 + 7, a2, a3, (void *)a4, a5, (void *)a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
    if ( v23 )
    {
      v24 = v17 - v19;
      j_memcpy();
      v25 = 8 * (v24 + 1);
      a6 = (__int64)j_memcpy();
      if ( v19 != v109 )
      {
        v89 = a6;
        free((unsigned __int64)v19, a9, a10, a11, a12, a13, a14, a15, a16);
        a6 = v89;
      }
      v18 = v21 - 1;
      v17 = (_BYTE *)(v23 + v24);
      if ( (unsigned __int64)v17 >= v23 + v21 - 1 )
      {
        v19 = (_BYTE *)v23;
        v48 = 1;
        goto LABEL_37;
      }
      v19 = (_BYTE *)v23;
      v20 = (unsigned __int64 *)(a6 + v25 - 8);
      goto LABEL_11;
    }
  }
  v48 = 2;
LABEL_36:
  if ( v19 == v109 )
    return v48;
LABEL_37:
  free((unsigned __int64)v19, a9, a10, a11, a12, a13, a14, a15, a16);
  return v48;
}
// 42C910: variable 'a3' is possibly undefined
// 42C910: variable 'a5' is possibly undefined
// 42C910: variable 'a6' is possibly undefined
// 42C910: variable 'a7' is possibly undefined
// 42C910: variable 'a9' is possibly undefined
// 42C910: variable 'a10' is possibly undefined
// 42C910: variable 'a11' is possibly undefined
// 42C910: variable 'a12' is possibly undefined
// 42C910: variable 'a13' is possibly undefined
// 42C910: variable 'a14' is possibly undefined
// 42C910: variable 'a15' is possibly undefined
// 42C910: variable 'a16' is possibly undefined
// 42CA74: variable 'v101' is possibly undefined
// 42CAE8: variable 'v36' is possibly undefined
// 42CAE8: variable 'v37' is possibly undefined
// 42CAE8: variable 'v38' is possibly undefined
// 42CAE8: variable 'v39' is possibly undefined
// 42CAE8: variable 'v40' is possibly undefined
// 42CAE8: variable 'v41' is possibly undefined
// 42CAE8: variable 'v42' is possibly undefined
// 42CAE8: variable 'v43' is possibly undefined
// 42CE64: variable 'v69' is possibly undefined
// 42CE64: variable 'v70' is possibly undefined
// 42CE64: variable 'v71' is possibly undefined
// 42CE64: variable 'v72' is possibly undefined
// 42CE64: variable 'v73' is possibly undefined
// 42CE64: variable 'v74' is possibly undefined
// 42CE64: variable 'v75' is possibly undefined
// 42CE64: variable 'v76' is possibly undefined
// 45C3D0: using guessed type _BYTE yycheck[64];

//----- (000000000042D0C0) ----------------------------------------------------
__int64 __fastcall _gettext_extract_plural(
        __int64 a1,
        __int64 *a2,
        unsigned __int64 *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  __int64 v11; // x21
  __int64 v12; // x2
  __int64 v13; // x3
  __int64 v14; // x4
  __int64 v15; // x5
  __int64 v16; // x6
  __int64 v17; // x7
  __int64 v18; // x0
  unsigned __int8 v20; // w3
  unsigned __int8 *v21; // x4
  __int64 v22; // x1
  int v23; // t1
  unsigned __int64 v24; // x0
  __int64 v25; // x2
  unsigned __int64 v26; // x3
  __int64 v27; // x5
  void *v28; // x6
  __int64 v29; // x7
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  unsigned __int8 *v38; // x1
  __int64 result; // x0
  char v40; // [xsp+0h] [xbp+0h]
  char v41; // [xsp+0h] [xbp+0h]
  unsigned __int8 *v42; // [xsp+38h] [xbp+38h]
  unsigned __int8 *v43; // [xsp+48h] [xbp+48h] BYREF
  __int64 v44; // [xsp+50h] [xbp+50h] BYREF
  __int64 v45; // [xsp+58h] [xbp+58h]

  if ( !a1 )
    goto LABEL_14;
  v11 = strstr(a1, (int8x16_t *)"plural=", (__int64)a3, a4, a5, a6, a7, a8, v40);
  v18 = strstr(a1, (int8x16_t *)"nplurals=", v12, v13, v14, v15, v16, v17, v41);
  if ( !v11 || v18 == 0 )
    goto LABEL_14;
  v20 = *(_BYTE *)(v18 + 9);
  if ( !v20 )
    goto LABEL_14;
  v21 = (unsigned __int8 *)(v18 + 9);
  v22 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 72);
  while ( (*(_WORD *)(v22 + 2LL * v20) & 0x2000) != 0 )
  {
    v23 = *++v21;
    v20 = v23;
    if ( !v23 )
      goto LABEL_14;
  }
  if ( (unsigned __int8)(v20 - 48) > 9u
    || (v42 = v21, v24 = _isoc23_strtoumax(v21, &v43, 10), v38 = v43, v43 == v42)
    || (*a3 = v24,
        v44 = v11 + 7,
        (unsigned int)_gettextparse(
                        (__int64)&v44,
                        (__int64)v38,
                        v25,
                        v26,
                        v42,
                        v27,
                        v28,
                        v29,
                        v30,
                        v31,
                        v32,
                        v33,
                        v34,
                        v35,
                        v36,
                        v37)) )
  {
LABEL_14:
    *a2 = (__int64)&_gettext_germanic_plural;
    result = 2LL;
    *a3 = 2LL;
  }
  else
  {
    result = v45;
    *a2 = v45;
  }
  return result;
}
// 42D0E8: variable 'v40' is possibly undefined
// 42D0FC: variable 'v12' is possibly undefined
// 42D0FC: variable 'v13' is possibly undefined
// 42D0FC: variable 'v14' is possibly undefined
// 42D0FC: variable 'v15' is possibly undefined
// 42D0FC: variable 'v16' is possibly undefined
// 42D0FC: variable 'v17' is possibly undefined
// 42D0FC: variable 'v41' is possibly undefined
// 42D184: variable 'v25' is possibly undefined
// 42D184: variable 'v26' is possibly undefined
// 42D184: variable 'v27' is possibly undefined
// 42D184: variable 'v28' is possibly undefined
// 42D184: variable 'v29' is possibly undefined
// 42D184: variable 'v30' is possibly undefined
// 42D184: variable 'v31' is possibly undefined
// 42D184: variable 'v32' is possibly undefined
// 42D184: variable 'v33' is possibly undefined
// 42D184: variable 'v34' is possibly undefined
// 42D184: variable 'v35' is possibly undefined
// 42D184: variable 'v36' is possibly undefined
// 42D184: variable 'v37' is possibly undefined

//----- (000000000042D1E0) ----------------------------------------------------
unsigned __int64 __fastcall _hash_string(unsigned __int8 *a1)
{
  unsigned int v1; // w1
  unsigned __int8 *v2; // x3
  unsigned __int64 result; // x0
  unsigned int v4; // t1

  v1 = *a1;
  v2 = a1;
  result = 0LL;
  if ( v1 )
  {
    do
    {
      result = v1 + 16 * result;
      if ( (result & 0xF0000000) != 0 )
        result = result & 0xFFFFFFFF0FFFFFFFLL ^ ((unsigned __int64)((unsigned int)result & 0xF0000000) >> 24);
      v4 = *++v2;
      v1 = v4;
    }
    while ( v4 );
  }
  return result;
}

//----- (000000000042D220) ----------------------------------------------------
__int64 __fastcall raise(unsigned int a1)
{
  unsigned __int64 v1; // x0
  __int64 v2; // x2
  void *v3; // x3
  void *v4; // x4
  void *v5; // x5
  void *v6; // x6
  __int64 result; // x0

  v1 = pthread_self();
  result = pthread_kill(v1, (void *)a1, v2, v3, v4, v5, v6);
  if ( (_DWORD)result )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = result;
    return 0xFFFFFFFFLL;
  }
  return result;
}
// 42D234: variable 'v2' is possibly undefined
// 42D234: variable 'v3' is possibly undefined
// 42D234: variable 'v4' is possibly undefined
// 42D234: variable 'v5' is possibly undefined
// 42D234: variable 'v6' is possibly undefined

//----- (000000000042D260) ----------------------------------------------------
unsigned __int64 __fastcall _libc_sigaction(int a1, _QWORD *a2, __int64 a3)
{
  __int128 v4; // q24
  __int128 v5; // q31
  __int128 v6; // q25
  __int128 v7; // q26
  __int128 v8; // q27
  __int128 v9; // q28
  __int128 v10; // q29
  __int128 v11; // q30
  int v12; // w2
  struct sigaction *v13; // x2
  unsigned __int64 result; // x0
  bool v15; // cc
  __int128 v16; // q31
  __int128 v17; // q30
  __int128 v18; // q30
  __int128 v19; // q30
  _QWORD v20[3]; // [xsp+0h] [xbp-130h] BYREF
  __int128 v21; // [xsp+18h] [xbp-118h]
  __int128 v22; // [xsp+28h] [xbp-108h]
  __int128 v23; // [xsp+38h] [xbp-F8h]
  __int128 v24; // [xsp+48h] [xbp-E8h]
  __int128 v25; // [xsp+58h] [xbp-D8h]
  __int128 v26; // [xsp+68h] [xbp-C8h]
  __int128 v27; // [xsp+78h] [xbp-B8h]
  __int128 v28; // [xsp+88h] [xbp-A8h]
  __int64 v29; // [xsp+98h] [xbp-98h] BYREF
  __int64 v30; // [xsp+A0h] [xbp-90h]
  __int64 v31; // [xsp+A8h] [xbp-88h]
  __int128 v32; // [xsp+B0h] [xbp-80h]
  __int128 v33; // [xsp+C0h] [xbp-70h]
  __int128 v34; // [xsp+D0h] [xbp-60h]
  __int128 v35; // [xsp+E0h] [xbp-50h]
  __int128 v36; // [xsp+F0h] [xbp-40h]
  __int128 v37; // [xsp+100h] [xbp-30h]
  __int128 v38; // [xsp+110h] [xbp-20h]
  __int128 v39; // [xsp+120h] [xbp-10h]

  if ( a2 )
  {
    v4 = *(_OWORD *)(a2 + 1);
    v20[0] = *a2;
    v5 = *(_OWORD *)(a2 + 15);
    v6 = *(_OWORD *)(a2 + 3);
    v7 = *(_OWORD *)(a2 + 5);
    v8 = *(_OWORD *)(a2 + 7);
    v9 = *(_OWORD *)(a2 + 9);
    v10 = *(_OWORD *)(a2 + 11);
    v11 = *(_OWORD *)(a2 + 13);
    v21 = v4;
    v12 = *((_DWORD *)a2 + 34);
    v22 = v6;
    v20[1] = v12;
    v23 = v7;
    v24 = v8;
    v25 = v9;
    v26 = v10;
    v27 = v11;
    v28 = v5;
    if ( (v12 & 0x4000000) != 0 )
      v20[2] = a2[18];
    v13 = 0LL;
    if ( a3 )
      v13 = (struct sigaction *)&v29;
    a2 = v20;
  }
  else
  {
    v13 = (struct sigaction *)&v29;
    if ( !a3 )
    {
      result = linux_eabi_syscall(__NR_rt_sigaction, a1, 0LL, 0LL);
      if ( result <= 0xFFFFFFFFFFFFF000LL )
        goto LABEL_8;
LABEL_16:
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
      return 0xFFFFFFFFLL;
    }
  }
  result = linux_eabi_syscall(__NR_rt_sigaction, a1, (const struct sigaction *)a2, v13);
  if ( result > 0xFFFFFFFFFFFFF000LL )
    goto LABEL_16;
LABEL_8:
  if ( a3 )
    v15 = (result & 0x80000000) != 0LL;
  else
    v15 = 1;
  if ( !v15 )
  {
    v16 = v32;
    *(_QWORD *)a3 = v29;
    *(_OWORD *)(a3 + 8) = v16;
    v17 = v34;
    *(_OWORD *)(a3 + 24) = v33;
    *(_OWORD *)(a3 + 40) = v17;
    v18 = v36;
    *(_OWORD *)(a3 + 56) = v35;
    *(_OWORD *)(a3 + 72) = v18;
    v19 = v38;
    *(_OWORD *)(a3 + 88) = v37;
    *(_OWORD *)(a3 + 104) = v19;
    *(_OWORD *)(a3 + 120) = v39;
    *(_DWORD *)(a3 + 136) = v30;
    *(_QWORD *)(a3 + 144) = v31;
  }
  return result;
}

//----- (000000000042D3A0) ----------------------------------------------------
char *__fastcall getenv(_BYTE *a1)
{
  unsigned __int64 v2; // x24
  char **v3; // x20
  int v4; // w21
  unsigned __int64 (__fastcall *v5)(__int64); // x26
  char *v6; // x19
  unsigned __int64 v7; // x0

  while ( 1 )
  {
    v2 = atomic_load((unsigned __int64 *)&_environ_counter);
    v3 = environ;
    if ( !environ )
      return 0LL;
    v4 = (unsigned __int8)*a1;
    if ( !*a1 )
      return 0LL;
    v5 = strlen();
    v6 = *v3;
    if ( *v3 )
      break;
LABEL_6:
    __dmb(9u);
    v7 = atomic_load((unsigned __int64 *)&_environ_counter);
    if ( v2 == v7 )
      return 0LL;
  }
  while ( v4 != (unsigned __int8)*v6
       || (unsigned int)strncmp((unsigned __int64)a1, (unsigned __int64)v6, (unsigned __int64)v5)
       || *((_BYTE *)v5 + (_QWORD)v6) != 61 )
  {
    v6 = *++v3;
    if ( !*v3 )
      goto LABEL_6;
  }
  return (char *)v5 + (_QWORD)v6 + 1;
}
// 496EF8: using guessed type __int64 _environ_counter;

//----- (000000000042D4A0) ----------------------------------------------------
unsigned __int64 __fastcall getrandom_vdso(void *a1, void *a2, unsigned __int64 a3, char a4, void *a5, void *a6)
{
  unsigned int *v6; // x6
  unsigned __int64 v8; // x3
  unsigned __int64 StatusReg; // x20
  unsigned __int64 *v10; // x19
  unsigned __int64 v11; // x5
  void *v12; // x24
  unsigned int v13; // w23
  void *v14; // x25
  unsigned __int64 v15; // x7
  unsigned __int64 result; // x0
  __int64 v17; // x3
  void *v18; // x4
  void *v19; // x5
  int v20; // w0
  __int64 v21; // x1
  __int64 v22; // x2
  __int64 v23; // x3
  void *v24; // x4
  void *v25; // x5
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7
  _QWORD *v34; // x6
  int v35; // w0
  char *v36; // x0
  __int64 v37; // x7
  __int64 v38; // x7
  __int64 v39; // x1
  unsigned __int64 v40; // x7
  __int64 v41; // x1
  __int64 v42; // x2
  __int64 v43; // x3
  int v44; // w0
  int v45; // w0
  unsigned int v46; // w21
  char *v47; // x0
  _QWORD *v48; // x9
  unsigned __int64 v49; // x11
  unsigned __int64 v50; // x12
  unsigned __int64 v51; // x10
  size_t v52; // x21
  char *v53; // x8
  unsigned __int64 v54; // x10
  unsigned __int64 v55; // x11
  unsigned __int64 v56; // x7
  unsigned __int64 v57; // x12
  unsigned __int64 v58; // x3
  __int64 v59; // x2
  size_t v60; // x27
  unsigned __int64 v61; // x0
  unsigned __int64 v62; // x10
  void *v63; // x3
  char *v64; // x8
  unsigned __int64 v65; // x11
  unsigned __int64 v66; // x12
  void *v67; // [xsp+68h] [xbp+68h]
  void *v68; // [xsp+68h] [xbp+68h]
  unsigned __int64 v69; // [xsp+68h] [xbp+68h]
  unsigned __int64 v70; // [xsp+68h] [xbp+68h]
  void *v71; // [xsp+68h] [xbp+68h]
  unsigned __int64 v72; // [xsp+68h] [xbp+68h]
  unsigned __int64 v73; // [xsp+70h] [xbp+70h]
  unsigned __int64 v74; // [xsp+70h] [xbp+70h]
  _QWORD *v75; // [xsp+70h] [xbp+70h]
  char *v76; // [xsp+70h] [xbp+70h]
  char *v77; // [xsp+78h] [xbp+78h]
  unsigned __int64 v78; // [xsp+78h] [xbp+78h]
  unsigned __int64 v79; // [xsp+78h] [xbp+78h]
  unsigned __int64 v80; // [xsp+80h] [xbp+80h]
  unsigned __int64 v81; // [xsp+80h] [xbp+80h]
  char *v82; // [xsp+88h] [xbp+88h]
  unsigned __int64 v83; // [xsp+88h] [xbp+88h]
  _QWORD *v84; // [xsp+90h] [xbp+90h]
  unsigned __int64 v85; // [xsp+90h] [xbp+90h]
  void *v86; // [xsp+90h] [xbp+90h]
  unsigned __int64 v87; // [xsp+98h] [xbp+98h]
  char v88; // [xsp+A8h] [xbp+A8h] BYREF

  v6 = (unsigned int *)&unk_496000;
  v8 = (unsigned int)state_size;
  if ( state_size )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v10 = (unsigned __int64 *)(StatusReg - 8);
    v11 = *(_QWORD *)(StatusReg - 8);
    if ( (v11 & 1) == 0 )
    {
      v12 = a1;
      v13 = a3;
      v14 = a2;
      *v10 = v11 | 1;
      v15 = v11;
      if ( v11 )
        goto LABEL_4;
      v20 = linux_eabi_syscall(__NR_rt_sigprocmask, 0, (const sigset_t *)&sigall_set, (sigset_t *)&v88);
      _aarch64_cas4_acq();
      v34 = &unk_496000;
      if ( v35 )
      {
        _lll_lock_wait_private(
          &grnd_alloc,
          v26,
          v27,
          v28,
          v29,
          v30,
          v31,
          v32,
          v33,
          v21,
          v22,
          v23,
          v24,
          v25,
          &unk_496000);
        v34 = (_QWORD *)&unk_496000;
      }
      v36 = (char *)(v34 + 481);
      v37 = v34[484];
      if ( v37 )
        goto LABEL_15;
      v77 = (char *)(v34 + 482);
      v46 = *((_DWORD *)v36 + 12);
      v69 = dl_pagesize;
      v47 = (char *)mmap64(0LL, dl_pagesize, *((_DWORD *)v36 + 14), *((_DWORD *)v36 + 13), -1, 0LL);
      v48 = v77;
      v49 = v69;
      v34 = (_QWORD *)&unk_496000;
      if ( v47 != (char *)-1LL )
      {
        v50 = v46;
        v51 = v69 / v46;
        v52 = (v69 - 1 + v46) & -(__int64)v69;
        v78 = v50;
        v82 = v47;
        v84 = v48;
        v70 = v51;
        v74 = v49;
        _set_vma_name(v47);
        v34 = &unk_496000;
        v53 = v82;
        v54 = v70;
        v55 = v74;
        v57 = v78;
        v56 = 0LL;
        v58 = v70 + v84[3];
        if ( v58 <= v84[4] )
        {
LABEL_31:
          if ( v57 <= v55 )
          {
            v59 = (unsigned int)state_size_cache_aligned;
            do
            {
              *(_QWORD *)(qword_496F18 + 8 * v56++) = v53;
              v53 += v59;
            }
            while ( v54 > v56 );
          }
          qword_496F20 = v54;
          qword_496F28 = v58;
          __dmb(0xBu);
          v37 = qword_496F20;
LABEL_15:
          v38 = v37 - 1;
          v39 = v34[483];
          v34[484] = v38;
          v40 = *(_QWORD *)(v39 + 8 * v38);
LABEL_16:
          v73 = v40;
          __dmb(0xBu);
          v68 = v34 + 482;
          _aarch64_swp4_rel();
          v15 = v73;
          v6 = (_DWORD *)&unk_496000;
          if ( v44 > 1 )
          {
            _lll_lock_wake_private(v68, v41, v42, v43, v18, v19, &unk_496000);
            v15 = v73;
            v6 = (_DWORD *)&unk_496000;
          }
          v17 = 8LL;
          v45 = linux_eabi_syscall(__NR_rt_sigprocmask, 2, (const sigset_t *)&v88, 0LL);
          if ( !v15 )
          {
            *v10 = 0LL;
LABEL_22:
            a3 = v13;
            if ( (a4 & 1) == 0 )
            {
              result = linux_eabi_syscall(__NR_getrandom, v12, v14, (void *)v13, (void *)v17, v18, v19, v6);
              if ( result > 0xFFFFFFFFFFFFF000LL )
              {
                *(_DWORD *)(StatusReg + 40) = -(int)result;
                return -1LL;
              }
              return result;
            }
            a2 = v14;
            a1 = v12;
            return _syscall_cancel(a1, a2, (void *)a3, 0LL, 0LL, 0LL, (void *)0x116);
          }
          v11 = v15;
LABEL_4:
          v67 = (void *)v11;
          result = dl_vdso_getrandom(v12, v14, v13 | 1, v15, v6[962]);
          v19 = v67;
          if ( result <= 0xFFFFFFFFFFFFF000LL )
          {
            *v10 = (unsigned __int64)v67;
            return result;
          }
          if ( (_DWORD)result != -11 || (v13 & 1) != 0 )
          {
            *(_DWORD *)(StatusReg + 40) = -(int)result;
            *v10 = (unsigned __int64)v67;
            return -1LL;
          }
          *v10 = (unsigned __int64)v67;
          goto LABEL_22;
        }
        v60 = (dl_pagesize - 1 + 8 * v58) & -dl_pagesize;
        v71 = (void *)v84[1];
        v75 = v84;
        v85 = v55;
        v87 = v54;
        v61 = mmap64(0LL, v60, 3, 34, -1, 0LL);
        v62 = v87;
        v63 = (void *)v61;
        v64 = v82;
        v66 = v78;
        v65 = v85;
        if ( v61 != -1LL )
        {
          v75[1] = v61;
          __dmb(0xBu);
          if ( v71 )
          {
            v80 = v85;
            v86 = (void *)v61;
            munmap(v71, 8LL * v75[4]);
            v64 = v82;
            v66 = v78;
            v65 = v80;
            v62 = v87;
            v63 = v86;
          }
          v72 = 0LL;
          v76 = v64;
          v79 = v66;
          v81 = v65;
          v83 = v62;
          _set_vma_name(v63);
          v34 = &unk_496000;
          qword_496F30 = v60 >> 3;
          __dmb(0xBu);
          v54 = v83;
          v56 = v72;
          v53 = v76;
          v58 = v83 + qword_496F28;
          v57 = v79;
          v55 = v81;
          goto LABEL_31;
        }
        munmap(v82, v52);
        v34 = (_QWORD *)&unk_496000;
      }
      v40 = 0LL;
      goto LABEL_16;
    }
    a3 = (unsigned int)a3;
    if ( (a4 & 1) != 0 )
      return _syscall_cancel(a1, a2, (void *)a3, 0LL, 0LL, 0LL, (void *)0x116);
    result = linux_eabi_syscall(
               __NR_getrandom,
               a1,
               a2,
               (void *)(unsigned int)a3,
               (void *)v8,
               a5,
               (void *)v11,
               &unk_496000);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      *(_DWORD *)(StatusReg + 40) = -(int)result;
      return -1LL;
    }
  }
  else
  {
    a3 = (unsigned int)a3;
    if ( (a4 & 1) != 0 )
      return _syscall_cancel(a1, a2, (void *)a3, 0LL, 0LL, 0LL, (void *)0x116);
    result = linux_eabi_syscall(
               __NR_getrandom,
               a1,
               a2,
               (void *)(unsigned int)a3,
               (void *)(unsigned int)state_size,
               a5,
               a6,
               &unk_496000);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
      return -1LL;
    }
  }
  return result;
}
// 42D5DC: variable 'v35' is possibly undefined
// 42D87C: variable 'v26' is possibly undefined
// 42D87C: variable 'v27' is possibly undefined
// 42D87C: variable 'v28' is possibly undefined
// 42D87C: variable 'v29' is possibly undefined
// 42D87C: variable 'v30' is possibly undefined
// 42D87C: variable 'v31' is possibly undefined
// 42D87C: variable 'v32' is possibly undefined
// 42D87C: variable 'v33' is possibly undefined
// 42D87C: variable 'v21' is possibly undefined
// 42D87C: variable 'v22' is possibly undefined
// 42D87C: variable 'v23' is possibly undefined
// 42D87C: variable 'v24' is possibly undefined
// 42D87C: variable 'v25' is possibly undefined
// 42D62C: variable 'v44' is possibly undefined
// 42D868: variable 'v41' is possibly undefined
// 42D868: variable 'v42' is possibly undefined
// 42D868: variable 'v43' is possibly undefined
// 42D868: variable 'v18' is possibly undefined
// 42D868: variable 'v19' is possibly undefined
// 42D670: variable 'v17' is possibly undefined
// 42D670: variable 'v6' is possibly undefined
// 48F7B8: using guessed type __int64 (__fastcall *dl_vdso_getrandom)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 490F10: using guessed type __int64 dl_pagesize;
// 496F08: using guessed type int state_size;
// 496F10: using guessed type int grnd_alloc;
// 496F18: using guessed type __int64 qword_496F18;
// 496F20: using guessed type __int64 qword_496F20;
// 496F28: using guessed type __int64 qword_496F28;
// 496F30: using guessed type __int64 qword_496F30;
// 496F38: using guessed type int state_size_cache_aligned;

//----- (000000000042D990) ----------------------------------------------------
__int64 __fastcall _getrandom_early_init(__int64 result)
{
  __int64 v1; // x1
  __int64 v2; // x4
  __int64 v3; // x5
  __int64 v4; // x6
  __int64 v5; // x7
  __int64 v6; // x0
  int v7; // w1
  _DWORD v8[2]; // [xsp+20h] [xbp+20h] BYREF
  unsigned int v9; // [xsp+28h] [xbp+28h]

  if ( (result & 1) != 0 )
  {
    result = (__int64)&dl_vdso_getrandom;
    if ( dl_vdso_getrandom )
    {
      result = dl_vdso_getrandom(0LL, 0LL, 0LL, v8, -1LL);
      if ( !result )
      {
        state_size = v8[0];
        v6 = sysconf(190, v1, (__int64)&unk_496000, (__int64)&state_size, v2, v3, v4, v5);
        if ( v6 <= 0 )
          v7 = 1;
        else
          v7 = v6;
        result = (state_size - 1 + v7) & (unsigned int)-v7;
        state_size_cache_aligned = result;
        if ( dl_pagesize < (unsigned __int64)(unsigned int)result )
        {
          state_size = 0;
        }
        else
        {
          mmap_prot = v8[1];
          result = v9;
          mmap_flags = v9;
        }
      }
    }
  }
  return result;
}
// 42D9EC: variable 'v1' is possibly undefined
// 42D9EC: variable 'v2' is possibly undefined
// 42D9EC: variable 'v3' is possibly undefined
// 42D9EC: variable 'v4' is possibly undefined
// 42D9EC: variable 'v5' is possibly undefined
// 48F7B8: using guessed type __int64 (__fastcall *dl_vdso_getrandom)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 490F10: using guessed type __int64 dl_pagesize;
// 496F08: using guessed type int state_size;
// 496F38: using guessed type int state_size_cache_aligned;
// 496F3C: using guessed type int mmap_flags;

//----- (000000000042DA48) ----------------------------------------------------
__int64 __fastcall _getrandom_reset_state(__int64 result)
{
  unsigned __int64 v1; // x2
  bool v2; // cc
  __int64 v3; // x4

  v1 = *(_QWORD *)(result + 1816);
  if ( qword_496F18 )
    v2 = v1 > 1;
  else
    v2 = 0;
  if ( v2 )
  {
    v3 = qword_496F20;
    if ( qword_496F20 >= (unsigned __int64)qword_496F30 )
      _libc_assert_fail(
        (__int64)"grnd_alloc.len < grnd_alloc.cap",
        (__int64)"../sysdeps/unix/sysv/linux/getrandom.c",
        0x123u,
        (__int64)"__getrandom_reset_state");
    ++qword_496F20;
    *(_QWORD *)(qword_496F18 + 8 * v3) = v1 & 0xFFFFFFFFFFFFFFFELL;
    *(_QWORD *)(result + 1816) = 0LL;
  }
  return result;
}
// 42DAC0: using guessed type __int64 _getrandom_vdso_release(void);
// 496F18: using guessed type __int64 qword_496F18;
// 496F20: using guessed type __int64 qword_496F20;
// 496F30: using guessed type __int64 qword_496F30;

//----- (000000000042DAC0) ----------------------------------------------------
void __fastcall _getrandom_vdso_release(_QWORD *a1)
{
  __int64 v1; // x1
  __int64 v2; // x2
  void *v3; // x5
  void *v4; // x6
  double v5; // d0
  double v6; // d1
  double v7; // d2
  double v8; // d3
  double v9; // d4
  double v10; // d5
  double v11; // d6
  double v12; // d7
  _QWORD *v13; // x3
  _QWORD *v14; // x4
  int v15; // w0
  char *v16; // x1
  __int64 v17; // x0
  __int64 v18; // x1
  __int64 v19; // x2
  __int64 v20; // x3
  void *v21; // x4
  void *v22; // x5
  void *v23; // x6
  int v24; // w0
  void *v25; // [xsp+10h] [xbp-10h]

  if ( a1[227] > 1uLL )
  {
    _aarch64_cas4_acq();
    v13 = &unk_496000;
    v14 = a1;
    if ( v15 )
    {
      _lll_lock_wait_private(&grnd_alloc, v5, v6, v7, v8, v9, v10, v11, v12, v1, v2, (__int64)&unk_496000, a1, v3, v4);
      v14 = a1;
      v13 = (_QWORD *)&unk_496000;
    }
    v16 = (char *)(v13 + 482);
    v17 = v13[484];
    *(_QWORD *)(*((_QWORD *)v16 + 1) + 8 * v17) = v14[227];
    v14[227] = 0LL;
    __dmb(0xBu);
    *((_QWORD *)v16 + 2) = v17 + 1;
    v25 = v13 + 482;
    _aarch64_swp4_rel();
    if ( v24 > 1 )
      _lll_lock_wake_private(v25, v18, v19, v20, v21, v22, v23);
  }
}
// 42DAFC: variable 'v15' is possibly undefined
// 42DB58: variable 'v5' is possibly undefined
// 42DB58: variable 'v6' is possibly undefined
// 42DB58: variable 'v7' is possibly undefined
// 42DB58: variable 'v8' is possibly undefined
// 42DB58: variable 'v9' is possibly undefined
// 42DB58: variable 'v10' is possibly undefined
// 42DB58: variable 'v11' is possibly undefined
// 42DB58: variable 'v12' is possibly undefined
// 42DB58: variable 'v1' is possibly undefined
// 42DB58: variable 'v2' is possibly undefined
// 42DB58: variable 'v3' is possibly undefined
// 42DB58: variable 'v4' is possibly undefined
// 42DB34: variable 'v24' is possibly undefined
// 42DB4C: variable 'v18' is possibly undefined
// 42DB4C: variable 'v19' is possibly undefined
// 42DB4C: variable 'v20' is possibly undefined
// 42DB4C: variable 'v21' is possibly undefined
// 42DB4C: variable 'v22' is possibly undefined
// 42DB4C: variable 'v23' is possibly undefined
// 496F10: using guessed type int grnd_alloc;

//----- (000000000042DB68) ----------------------------------------------------
void *_getrandom_fork_subprocess()
{
  void *result; // x0

  result = &unk_496000;
  grnd_alloc = 0;
  return result;
}
// 496F10: using guessed type int grnd_alloc;

//----- (000000000042DB80) ----------------------------------------------------
unsigned __int64 __fastcall _getrandom_nocancel(
        void *a1,
        void *a2,
        unsigned __int64 a3,
        __int64 a4,
        void *a5,
        void *a6)
{
  return getrandom_vdso(a1, a2, a3, 0, a5, a6);
}

//----- (000000000042DB88) ----------------------------------------------------
unsigned __int64 __fastcall getrandom(void *a1, void *a2, unsigned __int64 a3, __int64 a4, void *a5, void *a6)
{
  return getrandom_vdso(a1, a2, a3, 1, a5, a6);
}

//----- (000000000042DBA0) ----------------------------------------------------
__int128 *__fastcall do_swap(__int128 *result, __int128 *a2, unsigned __int64 a3, int a4)
{
  int v4; // w3
  __int64 v5; // x3
  __int128 *v6; // x3
  unsigned __int64 v7; // x6
  __int128 v8; // q28
  __int128 v9; // q29
  unsigned __int64 v10; // x5
  __int64 v11; // x3
  char *v12; // x6
  char *v13; // x4
  __int64 v14; // x5
  __int64 i; // x3
  __int128 v16; // q30
  char v17; // w2
  char v18; // w2
  __int128 v19; // [xsp+10h] [xbp-10h]

  if ( a4 )
  {
    if ( a4 == 1 )
    {
      do
      {
        a3 -= 4LL;
        v4 = *(_DWORD *)((char *)result + a3);
        *(_DWORD *)((char *)result + a3) = *(_DWORD *)((char *)a2 + a3);
        *(_DWORD *)((char *)a2 + a3) = v4;
      }
      while ( a3 );
    }
    else
    {
      if ( a3 > 0x20 )
      {
        v6 = a2;
        v7 = (a3 - 33) >> 5;
        do
        {
          v19 = result[1];
          v9 = *v6;
          v8 = v6[1];
          *v6 = *result;
          v6[1] = v19;
          v6 += 2;
          *result = v9;
          result[1] = v8;
          result += 2;
        }
        while ( v6 != &a2[2 * v7 + 2] );
        v10 = (a3 - 33) & 0xFFFFFFFFFFFFFFE0LL;
        a3 = a3 - 32 - 32 * v7;
        a2 = (__int128 *)((char *)a2 + v10 + 32);
      }
      if ( a3 )
      {
        v11 = a3 - 1;
        if ( a3 - 1 <= 0xE )
          goto LABEL_20;
        v12 = (char *)a2 + a3 - 16;
        v13 = (char *)result + a3 - 16;
        v14 = -16LL;
        if ( a3 >> 4 != 1 )
          v14 = -32LL;
        for ( i = 0LL; i != v14; i -= 16LL )
        {
          v16 = *(_OWORD *)&v12[i];
          *(_OWORD *)&v12[i] = *(_OWORD *)&v13[i];
          *(_OWORD *)&v13[i] = v16;
        }
        if ( (a3 & 0xF) != 0 )
        {
          v11 = (a3 & 0xF) - 1;
          v17 = *((_BYTE *)result + v11);
          *((_BYTE *)result + v11) = *((_BYTE *)a2 + v11);
          for ( *((_BYTE *)a2 + v11) = v17; v11; *((_BYTE *)a2 + v11) = v18 )
          {
            --v11;
LABEL_20:
            v18 = *((_BYTE *)result + v11);
            *((_BYTE *)result + v11) = *((_BYTE *)a2 + v11);
          }
        }
      }
    }
  }
  else
  {
    do
    {
      a3 -= 8LL;
      v5 = *(_QWORD *)((char *)result + a3);
      *(_QWORD *)((char *)result + a3) = *(_QWORD *)((char *)a2 + a3);
      *(_QWORD *)((char *)a2 + a3) = v5;
    }
    while ( a3 );
  }
  return result;
}

//----- (000000000042DCC8) ----------------------------------------------------
__int64 (__fastcall *__fastcall msort_with_tmp_part_0(
        __int64 *a1,
        int *a2,
        unsigned __int64 a3))(__int64 result, __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x22
  unsigned __int64 v4; // x20
  __int64 *v6; // x19
  int v7; // w0
  __int64 v8; // x26
  _QWORD *v9; // x28
  int (__fastcall *v10)(int *, __int64 *, __int64); // x23
  __int64 v11; // x24
  int *v12; // x21
  int v13; // w0
  __int64 *v14; // x21
  __int64 v15; // t1
  __int64 v16; // t1
  int *v18; // x21
  int v19; // w1
  int v20; // t1
  _BOOL4 v21; // w0
  int v22; // t1
  __int64 *v23; // x21
  __int64 v24; // x1
  __int64 v25; // t1
  _BOOL4 v26; // w0
  bool v27; // zf
  __int64 v28; // t1

  v3 = a3 >> 1;
  v4 = a3 - (a3 >> 1);
  v6 = (__int64 *)((char *)a2 + (a3 >> 1) * *a1);
  if ( a3 >> 1 != 1 )
    ((void (*)(void))msort_with_tmp_part_0)();
  if ( v4 > 1 )
  {
    msort_with_tmp_part_0(a1, v6, v4);
    v7 = *((_DWORD *)a1 + 2);
    v8 = *a1;
    v9 = (_QWORD *)a1[4];
    v10 = (int (__fastcall *)(int *, __int64 *, __int64))a1[2];
    v11 = a1[3];
    if ( v7 != 1 )
    {
      if ( v7 != 2 )
      {
        if ( v7 )
        {
LABEL_7:
          v12 = a2;
          while ( v10(v12, v6, v11) <= 0 )
          {
LABEL_11:
            j_memcpy();
            v12 = (int *)((char *)v12 + v8);
            if ( v3 == 1 )
            {
              v3 = 0LL;
              goto LABEL_21;
            }
            --v3;
          }
          while ( 1 )
          {
            j_memcpy();
            v6 = (__int64 *)((char *)v6 + v8);
            if ( v4 == 1 )
              goto LABEL_21;
            --v4;
            if ( v10(v12, v6, v11) <= 0 )
              goto LABEL_11;
          }
        }
        goto LABEL_17;
      }
LABEL_32:
      v23 = (__int64 *)a2;
      do
      {
        if ( v10((int *)*v23, (__int64 *)*v6, v11) > 0 )
        {
          v25 = *v6++;
          v24 = v25;
          v26 = v4-- != 1;
        }
        else
        {
          v27 = v3-- == 1;
          v28 = *v23++;
          v24 = v28;
          v26 = !v27;
        }
        *v9++ = v24;
      }
      while ( v26 );
      goto LABEL_21;
    }
LABEL_25:
    v18 = a2;
    do
    {
      if ( v10(v18, v6, v11) > 0 )
      {
        v20 = *(_DWORD *)v6;
        v6 = (__int64 *)((char *)v6 + 4);
        v19 = v20;
        v21 = v4-- != 1;
      }
      else
      {
        v22 = *v18++;
        v19 = v22;
        v21 = v3-- != 1;
      }
      *(_DWORD *)v9 = v19;
      v9 = (_QWORD *)((char *)v9 + 4);
    }
    while ( v21 );
    goto LABEL_21;
  }
  v13 = *((_DWORD *)a1 + 2);
  v8 = *a1;
  v9 = (_QWORD *)a1[4];
  v10 = (int (__fastcall *)(int *, __int64 *, __int64))a1[2];
  v11 = a1[3];
  if ( v13 == 1 )
  {
    if ( !v4 )
      goto LABEL_31;
    v4 = 1LL;
    goto LABEL_25;
  }
  if ( v13 == 2 )
  {
    if ( !v4 )
      goto LABEL_31;
    goto LABEL_32;
  }
  if ( v13 )
  {
    if ( !v4 )
      goto LABEL_31;
    goto LABEL_7;
  }
  if ( !v4 )
  {
LABEL_31:
    j_memcpy();
    return j_memcpy();
  }
LABEL_17:
  v14 = (__int64 *)a2;
  do
  {
    while ( v10((int *)v14, v6, v11) > 0 )
    {
      v15 = *v6++;
      *v9++ = v15;
      if ( !--v4 )
        goto LABEL_21;
    }
    v16 = *v14++;
    *v9++ = v16;
    --v3;
  }
  while ( v3 );
LABEL_21:
  if ( v3 )
    goto LABEL_31;
  return j_memcpy();
}

//----- (000000000042DF4C) ----------------------------------------------------
__int64 *__fastcall indirect_msort_with_tmp(__int64 *result, __int64 a2, unsigned __int64 a3, unsigned __int64 a4)
{
  __int64 v5; // x23
  __int64 v7; // x24
  int *v8; // x26
  unsigned __int64 v9; // x24
  int *v10; // x2
  int *v11; // x1
  __int64 v12; // x27
  unsigned __int64 v13; // x22
  __int64 v14; // x20
  __int64 v15; // x0
  unsigned __int64 i; // x19
  unsigned __int64 v17; // x1

  v5 = a2;
  v7 = result[4];
  v8 = (int *)(v7 + 8 * a3);
  v9 = v7 + 16 * a3;
  if ( (unsigned __int64)v8 >= v9 )
  {
    v11 = v8;
  }
  else
  {
    v10 = v8;
    do
    {
      *(_QWORD *)v10 = a2;
      v10 += 2;
      a2 += a4;
    }
    while ( v9 > (unsigned __int64)v10 );
    v11 = (int *)(result[4] + 8 * a3);
  }
  if ( a3 <= 1 )
  {
    if ( !a3 )
      return result;
  }
  else
  {
    result = (__int64 *)msort_with_tmp_part_0(result, v11, a3);
  }
  v12 = v5;
  v13 = 0LL;
  do
  {
    while ( 1 )
    {
      v14 = *(_QWORD *)&v8[2 * v13];
      if ( v14 != v12 )
        break;
      ++v13;
      v12 += a4;
      if ( a3 <= v13 )
        return result;
    }
    j_memcpy();
    v15 = v12;
    for ( i = v13; ; v14 = *(_QWORD *)&v8[2 * i] )
    {
      v17 = i;
      i = (v14 - v5) / a4;
      *(_QWORD *)&v8[2 * v17] = v15;
      j_memcpy();
      v15 = v14;
      if ( *(_QWORD *)&v8[2 * i] == v12 )
        break;
    }
    *(_QWORD *)&v8[2 * i] = v14;
    ++v13;
    result = (__int64 *)j_memcpy();
    v12 += a4;
  }
  while ( a3 > v13 );
  return result;
}

//----- (000000000042E080) ----------------------------------------------------
void __fastcall qsort_r(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        __int64 (__fastcall *a4)(_QWORD, _QWORD, _QWORD),
        void *a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13)
{
  __int64 (__fastcall *v14)(_QWORD, _QWORD, _QWORD); // x8
  unsigned __int64 v15; // x2
  __int64 v16; // x7
  __int64 v17; // x0
  _BYTE *v18; // x6
  int v19; // w1
  double v20; // d0
  double v21; // d1
  double v22; // d2
  double v23; // d3
  double v24; // d4
  double v25; // d5
  double v26; // d6
  double v27; // d7
  _BYTE *v28; // x6
  unsigned __int64 v29; // x0
  _BYTE *v30; // x6
  __int64 StatusReg; // x1
  unsigned __int64 v32; // x19
  int v33; // w20
  unsigned __int64 v34; // x22
  unsigned __int64 v35; // x21
  unsigned __int64 v36; // x10
  __int64 i; // x3
  int v38; // w0
  __int64 v39; // x9
  int v40; // w0
  __int64 v41; // x1
  __int128 *j; // x21
  __int64 (__fastcall *v43)(_QWORD, _QWORD, _QWORD); // x8
  __int64 v44; // x3
  unsigned __int64 v45; // x10
  int v46; // w0
  __int64 v47; // x9
  int v48; // w0
  _BYTE *v49; // [xsp+30h] [xbp-470h]
  _BYTE *v50; // [xsp+30h] [xbp-470h]
  int v51; // [xsp+30h] [xbp-470h]
  __int64 (__fastcall *v52)(_QWORD, _QWORD, _QWORD); // [xsp+30h] [xbp-470h]
  __int64 (__fastcall *v53)(_QWORD, _QWORD, _QWORD); // [xsp+30h] [xbp-470h]
  int v54; // [xsp+30h] [xbp-470h]
  unsigned __int64 v55; // [xsp+30h] [xbp-470h]
  __int64 (__fastcall *v56)(_QWORD, _QWORD, _QWORD); // [xsp+30h] [xbp-470h]
  __int64 v57; // [xsp+38h] [xbp-468h]
  unsigned __int64 v58; // [xsp+38h] [xbp-468h]
  void *v59; // [xsp+38h] [xbp-468h]
  __int64 v60; // [xsp+38h] [xbp-468h]
  void *v61; // [xsp+38h] [xbp-468h]
  unsigned __int64 v62; // [xsp+38h] [xbp-468h]
  void *v63; // [xsp+38h] [xbp-468h]
  unsigned __int64 v64; // [xsp+40h] [xbp-460h]
  __int128 *v65; // [xsp+40h] [xbp-460h]
  unsigned __int64 v66; // [xsp+40h] [xbp-460h]
  __int128 *v67; // [xsp+40h] [xbp-460h]
  unsigned __int64 v68; // [xsp+48h] [xbp-458h]
  __int64 v69; // [xsp+48h] [xbp-458h]
  __int128 *v70; // [xsp+48h] [xbp-458h]
  unsigned __int64 v71; // [xsp+48h] [xbp-458h]
  __int64 v72; // [xsp+48h] [xbp-458h]
  __int128 *v73; // [xsp+48h] [xbp-458h]
  void *v75; // [xsp+50h] [xbp-450h]
  unsigned __int64 v76; // [xsp+50h] [xbp-450h]
  void *v78; // [xsp+50h] [xbp-450h]
  unsigned __int64 v79; // [xsp+50h] [xbp-450h]
  void *v80; // [xsp+58h] [xbp-448h]
  __int64 v81; // [xsp+58h] [xbp-448h]
  __int64 v82; // [xsp+58h] [xbp-448h]
  void *v83; // [xsp+58h] [xbp-448h]
  __int64 v84; // [xsp+58h] [xbp-448h]
  __int64 v85; // [xsp+58h] [xbp-448h]
  __int64 v86; // [xsp+60h] [xbp-440h]
  __int64 v87; // [xsp+60h] [xbp-440h]
  __int64 v88; // [xsp+60h] [xbp-440h]
  __int64 v89; // [xsp+60h] [xbp-440h]
  unsigned __int64 v90; // [xsp+68h] [xbp-438h]
  unsigned __int64 v91; // [xsp+68h] [xbp-438h]
  unsigned __int64 v92; // [xsp+78h] [xbp-428h] BYREF
  int v93; // [xsp+80h] [xbp-420h]
  __int64 (__fastcall *v94)(_QWORD, _QWORD, _QWORD); // [xsp+88h] [xbp-418h]
  void *v95; // [xsp+90h] [xbp-410h]
  _BYTE *v96; // [xsp+98h] [xbp-408h]
  _BYTE v97[1024]; // [xsp+A0h] [xbp-400h] BYREF

  if ( a2 <= 1 )
    return;
  v14 = a4;
  v15 = a2;
  v16 = a1;
  if ( a3 > 0x20 )
  {
    v29 = a3 + 16 * a2;
    v30 = v97;
    if ( v29 > 0x400 )
    {
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
      v90 = v15;
      v51 = *(_DWORD *)(StatusReg + 40);
      v57 = StatusReg;
      v68 = a3;
      v80 = a5;
      v86 = v16;
      v30 = (_BYTE *)malloc(
                       v29,
                       StatusReg,
                       v15,
                       (void *)0x28,
                       a5,
                       (void *)a3,
                       v97,
                       v16,
                       a6,
                       a7,
                       a8,
                       a9,
                       a10,
                       a11,
                       a12,
                       a13);
      a3 = v68;
      v14 = a4;
      a5 = v80;
      v16 = v86;
      *(_DWORD *)(v57 + 40) = v51;
      v15 = v90;
      if ( !v30 )
      {
        v32 = v90 - 1;
        goto LABEL_19;
      }
    }
    v92 = 8LL;
    v50 = v30;
    v93 = 2;
    v94 = v14;
    v95 = a5;
    v96 = v30;
    indirect_msort_with_tmp((__int64 *)&v92, v16, v15, a3);
    v28 = v50;
LABEL_6:
    if ( v28 != v97 )
      free((unsigned __int64)v28, v20, v21, v22, v23, v24, v25, v26, v27);
    return;
  }
  v17 = a2 * a3;
  v18 = v97;
  if ( a2 * a3 <= 0x400 )
    goto LABEL_4;
  v41 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v91 = v15;
  v54 = *(_DWORD *)(v41 + 40);
  v60 = v41;
  v71 = a3;
  v83 = a5;
  v88 = v16;
  v18 = (_BYTE *)malloc(v17, v41, v15, (void *)0x28, a5, (void *)a3, v97, v16, a6, a7, a8, a9, a10, a11, a12, a13);
  a3 = v71;
  v14 = a4;
  a5 = v83;
  v16 = v88;
  *(_DWORD *)(v60 + 40) = v54;
  v15 = v91;
  if ( v18 )
  {
LABEL_4:
    v92 = a3;
    v19 = 3;
    if ( ((v16 | a3) & 3) == 0 )
    {
      v19 = 1;
      if ( a3 != 4 )
      {
        v19 = 3;
        if ( a3 == 8 )
        {
          if ( (v16 & 7) != 0 )
            v19 = 3;
          else
            v19 = 0;
        }
      }
    }
    v49 = v18;
    v93 = v19;
    v94 = v14;
    v95 = a5;
    v96 = v18;
    msort_with_tmp_part_0((__int64 *)&v92, (int *)v16, v15);
    v28 = v49;
    goto LABEL_6;
  }
  v32 = v91 - 1;
  if ( ((v88 | v71) & 3) != 0 )
    goto LABEL_19;
  if ( v71 != 4 )
  {
    if ( v71 == 8 && (v88 & 7) == 0 )
    {
      v33 = 0;
      goto LABEL_20;
    }
LABEL_19:
    v33 = 3;
    goto LABEL_20;
  }
  v33 = 1;
LABEL_20:
  v34 = v32 >> 1;
  v35 = v32 | 1;
  do
  {
    v36 = v35;
    if ( v35 <= v32 )
    {
      for ( i = v34; ; i = v82 )
      {
        if ( v32 <= v36 )
          goto LABEL_25;
        v52 = v14;
        v58 = a3;
        v64 = v36;
        v69 = v16;
        v75 = a5;
        v81 = i;
        v38 = v14(v16 + a3 * v36, v16 + 2 * (a3 + i * a3), a5);
        a5 = v75;
        i = v81;
        v14 = v52;
        a3 = v58;
        v36 = v64;
        v16 = v69;
        v39 = 2 * (v81 + 1);
        if ( (v38 & 0x80000000) == 0 )
LABEL_25:
          v39 = v36;
        if ( v39 == i )
          break;
        v53 = v14;
        v59 = a5;
        v65 = (__int128 *)(v16 + a3 * i);
        v70 = (__int128 *)(v16 + a3 * v39);
        v76 = a3;
        v82 = v39;
        v87 = v16;
        v40 = v14(v65, v70, a5);
        a3 = v76;
        v16 = v87;
        v14 = v53;
        a5 = v59;
        if ( (v40 & 0x80000000) == 0 )
          break;
        do_swap(v70, v65, v76, v33);
        a3 = v76;
        a5 = v59;
        v36 = 2 * v82 + 1;
        if ( v36 > v32 )
          break;
      }
    }
    v35 -= 2LL;
    --v34;
  }
  while ( v34 != -1LL );
  for ( j = (__int128 *)(v16 + a3 * v32); ; j = (__int128 *)((char *)j - a3) )
  {
    v55 = a3;
    v61 = a5;
    do_swap((__int128 *)v16, j, a3, v33);
    if ( !--v32 )
      break;
    a3 = v55;
    a5 = v61;
    v44 = 0LL;
    v45 = 1LL;
    while ( 1 )
    {
      if ( v32 <= v45 )
        goto LABEL_42;
      v56 = v43;
      v62 = a3;
      v66 = v45;
      v72 = v16;
      v78 = a5;
      v84 = v44;
      v46 = v43(v16 + a3 * v45, v16 + 2 * (a3 + v44 * a3), a5);
      a5 = v78;
      v44 = v84;
      v43 = v56;
      a3 = v62;
      v45 = v66;
      v16 = v72;
      v47 = 2 * (v84 + 1);
      if ( (v46 & 0x80000000) == 0 )
LABEL_42:
        v47 = v45;
      if ( v47 == v44 )
        break;
      v63 = a5;
      v67 = (__int128 *)(v16 + a3 * v44);
      v73 = (__int128 *)(v16 + a3 * v47);
      v79 = a3;
      v85 = v47;
      v89 = v16;
      v48 = v43(v67, v73, a5);
      a3 = v79;
      v16 = v89;
      a5 = v63;
      if ( (v48 & 0x80000000) == 0 )
        break;
      do_swap(v73, v67, v79, v33);
      a3 = v79;
      a5 = v63;
      v45 = 2 * v85 + 1;
      if ( v32 < v45 )
        break;
      v44 = v85;
    }
  }
}
// 42E104: variable 'v20' is possibly undefined
// 42E104: variable 'v21' is possibly undefined
// 42E104: variable 'v22' is possibly undefined
// 42E104: variable 'v23' is possibly undefined
// 42E104: variable 'v24' is possibly undefined
// 42E104: variable 'v25' is possibly undefined
// 42E104: variable 'v26' is possibly undefined
// 42E104: variable 'v27' is possibly undefined
// 42E200: variable 'v14' is possibly undefined
// 42E208: variable 'v16' is possibly undefined
// 42E378: variable 'v43' is possibly undefined

//----- (000000000042E440) ----------------------------------------------------
void __fastcall qsort(
        __int64 a1,
        unsigned __int64 a2,
        unsigned __int64 a3,
        __int64 (__fastcall *a4)(_QWORD, _QWORD, _QWORD),
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  qsort_r(a1, a2, a3, a4, 0LL, a5, a6, a7, a8, a9, a10, a11, a12);
}

//----- (000000000042E460) ----------------------------------------------------
__int64 __fastcall _add_to_environ(unsigned __int64 a1, __int64 a2, unsigned __int64 a3, int a4)
{
  unsigned __int64 (__fastcall *v7)(__int64); // x19
  __int64 v8; // x1
  __int64 v9; // x2
  __int64 v10; // x3
  void *v11; // x4
  void *v12; // x5
  void *v13; // x6
  __int64 v14; // x7
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  int v23; // w0
  char **v24; // x20
  char **v25; // x21
  char *v26; // x28
  unsigned __int64 *v27; // x27
  unsigned __int64 v28; // x1
  unsigned __int64 v29; // x3
  char *v30; // t1
  __int64 v31; // x0
  char ***v32; // x1
  __int64 v33; // x28
  unsigned __int64 *v34; // x0
  __int64 v35; // x1
  unsigned __int64 v36; // x0
  __int64 v37; // x1
  __int64 v38; // x2
  __int64 v39; // x3
  void *v40; // x4
  void *v41; // x5
  void *v42; // x6
  int v43; // w0
  unsigned __int64 v45; // x21
  int8x16_t *(__fastcall *v46)(int8x16_t *, unsigned __int8, unsigned __int64); // x1
  __int64 v47; // x2
  void *v48; // x3
  void *v49; // x4
  void *v50; // x5
  void *v51; // x6
  __int64 v52; // x7
  double v53; // d0
  double v54; // d1
  double v55; // d2
  double v56; // d3
  double v57; // d4
  double v58; // d5
  double v59; // d6
  double v60; // d7
  _QWORD *v61; // x0
  unsigned __int64 *v62; // x0
  void *v63; // x3
  void *v64; // x4
  void *v65; // x5
  __int64 *v66; // x6
  __int64 v67; // x7
  double v68; // d0
  double v69; // d1
  double v70; // d2
  double v71; // d3
  double v72; // d4
  double v73; // d5
  double v74; // d6
  double v75; // d7
  unsigned __int64 v76; // x20
  int v77; // w0
  unsigned __int64 v78; // x0
  __int64 v79; // x1
  __int64 v80; // x2
  __int64 v81; // x3
  void *v82; // x4
  void *v83; // x5
  void *v84; // x6
  int v85; // w0
  char *v86; // [xsp+70h] [xbp+70h]
  unsigned __int64 v87; // [xsp+78h] [xbp+78h]

  v7 = strlen();
  if ( a3 )
  {
    _aarch64_cas4_acq();
    if ( !v23 )
      goto LABEL_3;
  }
  else
  {
    v86 = (char *)strlen() + 1;
    _aarch64_cas4_acq();
    if ( !v77 )
      goto LABEL_3;
  }
  _lll_lock_wait_private(envlock, v15, v16, v17, v18, v19, v20, v21, v22, v8, v9, v10, v11, v12, v13);
LABEL_3:
  v24 = environ;
  v25 = environ;
  if ( !environ )
  {
    v29 = 2LL;
    v31 = 0LL;
    v27 = 0LL;
    v32 = (char ***)_environ_array_list;
    v33 = _environ_array_list;
    if ( !_environ_array_list )
      goto LABEL_10;
    goto LABEL_25;
  }
  v26 = *environ;
  v27 = (unsigned __int64 *)environ;
  if ( !*environ )
  {
    v29 = 2LL;
    v31 = 0LL;
LABEL_9:
    v32 = (char ***)_environ_array_list;
    v33 = _environ_array_list;
    if ( !_environ_array_list )
      goto LABEL_10;
LABEL_25:
    if ( v24 == *v32 )
    {
      v28 = *(_QWORD *)(v33 + 8);
      if ( v28 >= v29 )
        goto LABEL_18;
      goto LABEL_27;
    }
LABEL_10:
    if ( !v33 )
      goto LABEL_31;
    v28 = *(_QWORD *)(v33 + 8);
    if ( v29 <= v28 )
    {
LABEL_12:
      if ( v27 <= (unsigned __int64 *)v24 )
      {
        v27 = *(unsigned __int64 **)v33;
        v25 = (char **)v27;
        v27[1] = 0LL;
LABEL_19:
        if ( !a3 )
          goto LABEL_35;
LABEL_20:
        atomic_store(a3, v27);
        atomic_store((unsigned __int64)v25, (unsigned __int64 *)&environ);
LABEL_21:
        _aarch64_swp4_rel();
        if ( v43 > 1 )
          _lll_lock_wake_private(envlock, v37, v38, v39, v40, v41, v42);
        return 0LL;
      }
      v9 = *(_QWORD *)v33;
      v34 = (unsigned __int64 *)v24;
      v35 = 0LL;
      do
      {
        v29 = *v34++;
        *(_QWORD *)(v9 + v35) = v29;
        v25 = (char **)v9;
        v35 += 8LL;
      }
      while ( v27 > v34 );
      v28 = 8LL;
      v36 = (((char *)v27 - (char *)v24 - 1) & 0xFFFFFFFFFFFFFFF8LL) + 8;
      if ( (char *)v24 + 1 > (char *)v27 )
        v36 = 8LL;
      v27 = (unsigned __int64 *)(v9 + v36);
LABEL_18:
      v27[1] = 0LL;
      goto LABEL_19;
    }
LABEL_27:
    v45 = 2 * v28;
    if ( 2 * v28 >= v29 )
    {
LABEL_28:
      v46 = calloc(
              v45,
              8uLL,
              v9,
              (void *)v29,
              v15,
              v16,
              v17,
              v18,
              v19,
              v20,
              v21,
              v22,
              (__int64)v11,
              v12,
              (__int64)v13,
              v14);
      if ( !v46 )
        goto LABEL_45;
      v87 = (unsigned __int64)v46;
      v61 = (_QWORD *)malloc(24LL, (__int64)v46, v47, v48, v49, v50, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60);
      v28 = v87;
      if ( !v61 )
      {
        free(v87, v15, v16, v17, v18, v19, v20, v21, v22);
        goto LABEL_45;
      }
      *v61 = v87;
      v61[1] = v45;
      _environ_array_list = (__int64)v61;
      v61[2] = v33;
      v33 = (__int64)v61;
      goto LABEL_12;
    }
LABEL_31:
    v45 = v31 + 18;
    goto LABEL_28;
  }
  while ( (unsigned int)strncmp((unsigned __int64)v26, a1, (unsigned __int64)v7) || *((_BYTE *)v7 + (_QWORD)v26) != 61 )
  {
    v30 = (char *)v27[1];
    ++v27;
    v26 = v30;
    if ( !v30 )
      goto LABEL_8;
  }
  if ( !*v27 )
  {
LABEL_8:
    v31 = ((char *)v27 - (char *)v24) >> 3;
    v29 = v31 + 2;
    goto LABEL_9;
  }
  if ( !a4 )
    goto LABEL_21;
  if ( a3 )
    goto LABEL_20;
LABEL_35:
  a3 = malloc(
         (__int64)v7 + (_QWORD)v86 + 1,
         v28,
         v9,
         (void *)v29,
         v11,
         v12,
         v13,
         v14,
         v15,
         v16,
         v17,
         v18,
         v19,
         v20,
         v21,
         v22);
  if ( a3 )
  {
    *((_BYTE *)v7 + (_QWORD)j_memcpy()) = 61;
    j_memcpy();
    v62 = tfind(a3, (unsigned __int64 *)&known_values, (__int64 (__fastcall *)(__int64, _QWORD))strcmp);
    if ( v62 && (v76 = *v62) != 0 )
    {
      v78 = a3;
      a3 = v76;
      free(v78, v68, v69, v70, v71, v72, v73, v74, v75);
    }
    else
    {
      tsearch(
        a3,
        &known_values,
        (__int64 (__fastcall *)(__int64, _QWORD))strcmp,
        v63,
        v64,
        v65,
        v66,
        v67,
        v68,
        v69,
        v70,
        v71,
        v72,
        v73,
        v74,
        v75);
    }
    goto LABEL_20;
  }
LABEL_45:
  _aarch64_swp4_rel();
  if ( v85 > 1 )
    _lll_lock_wake_private(envlock, v79, v80, v81, v82, v83, v84);
  return 0xFFFFFFFFLL;
}
// 42E4AC: variable 'v23' is possibly undefined
// 42E5A0: variable 'v43' is possibly undefined
// 42E710: variable 'v37' is possibly undefined
// 42E710: variable 'v38' is possibly undefined
// 42E710: variable 'v39' is possibly undefined
// 42E710: variable 'v40' is possibly undefined
// 42E710: variable 'v41' is possibly undefined
// 42E710: variable 'v42' is possibly undefined
// 42E610: variable 'v9' is possibly undefined
// 42E610: variable 'v15' is possibly undefined
// 42E610: variable 'v16' is possibly undefined
// 42E610: variable 'v17' is possibly undefined
// 42E610: variable 'v18' is possibly undefined
// 42E610: variable 'v19' is possibly undefined
// 42E610: variable 'v20' is possibly undefined
// 42E610: variable 'v21' is possibly undefined
// 42E610: variable 'v22' is possibly undefined
// 42E610: variable 'v11' is possibly undefined
// 42E610: variable 'v12' is possibly undefined
// 42E610: variable 'v13' is possibly undefined
// 42E610: variable 'v14' is possibly undefined
// 42E624: variable 'v47' is possibly undefined
// 42E624: variable 'v48' is possibly undefined
// 42E624: variable 'v49' is possibly undefined
// 42E624: variable 'v50' is possibly undefined
// 42E624: variable 'v51' is possibly undefined
// 42E624: variable 'v52' is possibly undefined
// 42E624: variable 'v53' is possibly undefined
// 42E624: variable 'v54' is possibly undefined
// 42E624: variable 'v55' is possibly undefined
// 42E624: variable 'v56' is possibly undefined
// 42E624: variable 'v57' is possibly undefined
// 42E624: variable 'v58' is possibly undefined
// 42E624: variable 'v59' is possibly undefined
// 42E624: variable 'v60' is possibly undefined
// 42E664: variable 'v86' is possibly undefined
// 42E66C: variable 'v28' is possibly undefined
// 42E66C: variable 'v29' is possibly undefined
// 42E6D0: variable 'v63' is possibly undefined
// 42E6D0: variable 'v64' is possibly undefined
// 42E6D0: variable 'v65' is possibly undefined
// 42E6D0: variable 'v66' is possibly undefined
// 42E6D0: variable 'v67' is possibly undefined
// 42E6D0: variable 'v68' is possibly undefined
// 42E6D0: variable 'v69' is possibly undefined
// 42E6D0: variable 'v70' is possibly undefined
// 42E6D0: variable 'v71' is possibly undefined
// 42E6D0: variable 'v72' is possibly undefined
// 42E6D0: variable 'v73' is possibly undefined
// 42E6D0: variable 'v74' is possibly undefined
// 42E6D0: variable 'v75' is possibly undefined
// 42E6FC: variable 'v77' is possibly undefined
// 42E704: variable 'v8' is possibly undefined
// 42E704: variable 'v10' is possibly undefined
// 42E75C: variable 'v85' is possibly undefined
// 42E76C: variable 'v79' is possibly undefined
// 42E76C: variable 'v80' is possibly undefined
// 42E76C: variable 'v81' is possibly undefined
// 42E76C: variable 'v82' is possibly undefined
// 42E76C: variable 'v83' is possibly undefined
// 42E76C: variable 'v84' is possibly undefined
// 496F00: using guessed type __int64 _environ_array_list;
// 496F48: using guessed type _DWORD envlock[2];
// 496F50: using guessed type __int64 known_values;

//----- (000000000042E780) ----------------------------------------------------
__int64 __fastcall setenv(_BYTE *a1, __int64 a2, int a3)
{
  if ( a1 && *a1 && !strchr((__int64)a1, 0x3Du) )
    return _add_to_environ((unsigned __int64)a1, a2, 0LL, a3);
  *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
  return 0xFFFFFFFFLL;
}

//----- (000000000042E80C) ----------------------------------------------------
__int64 __fastcall unsetenv(_BYTE *a1)
{
  unsigned __int64 (__fastcall *v2)(__int64); // x22
  __int64 v3; // x1
  __int64 v4; // x2
  __int64 v5; // x3
  void *v6; // x4
  void *v7; // x5
  void *v8; // x6
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  int v17; // w0
  char **v18; // x19
  unsigned __int64 v19; // x20
  __int64 v20; // x1
  __int64 v21; // x2
  __int64 v22; // x3
  void *v23; // x4
  void *v24; // x5
  void *v25; // x6
  int v26; // w0
  unsigned __int64 *v28; // x2
  unsigned __int64 *v29; // x3
  unsigned __int64 v30; // x0

  if ( a1 && *a1 && !strchr((__int64)a1, 0x3Du) )
  {
    v2 = strlen();
    _aarch64_cas4_acq();
    if ( v17 )
      _lll_lock_wait_private(envlock, v9, v10, v11, v12, v13, v14, v15, v16, v3, v4, v5, v6, v7, v8);
    v18 = environ;
    if ( environ )
    {
      while ( 1 )
      {
        v19 = (unsigned __int64)*v18;
        if ( !*v18 )
          break;
        while ( (unsigned int)strncmp(v19, (unsigned __int64)a1, (unsigned __int64)v2) || *((_BYTE *)v2 + v19) != 61 )
        {
          v19 = (unsigned __int64)*++v18;
          if ( !*v18 )
            goto LABEL_11;
        }
        v28 = (unsigned __int64 *)v18;
        do
        {
          v29 = v28++;
          v30 = *v28;
          atomic_store(*v28, v29);
          atomic_store(_environ_counter + 1, (unsigned __int64 *)&_environ_counter);
        }
        while ( v30 );
      }
    }
LABEL_11:
    _aarch64_swp4_rel();
    if ( v26 > 1 )
      _lll_lock_wake_private(envlock, v20, v21, v22, v23, v24, v25);
    return 0LL;
  }
  else
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return 0xFFFFFFFFLL;
  }
}
// 42E85C: variable 'v17' is possibly undefined
// 42E90C: variable 'v9' is possibly undefined
// 42E90C: variable 'v10' is possibly undefined
// 42E90C: variable 'v11' is possibly undefined
// 42E90C: variable 'v12' is possibly undefined
// 42E90C: variable 'v13' is possibly undefined
// 42E90C: variable 'v14' is possibly undefined
// 42E90C: variable 'v15' is possibly undefined
// 42E90C: variable 'v16' is possibly undefined
// 42E90C: variable 'v3' is possibly undefined
// 42E90C: variable 'v4' is possibly undefined
// 42E90C: variable 'v5' is possibly undefined
// 42E90C: variable 'v6' is possibly undefined
// 42E90C: variable 'v7' is possibly undefined
// 42E90C: variable 'v8' is possibly undefined
// 42E8BC: variable 'v26' is possibly undefined
// 42E918: variable 'v20' is possibly undefined
// 42E918: variable 'v21' is possibly undefined
// 42E918: variable 'v22' is possibly undefined
// 42E918: variable 'v23' is possibly undefined
// 42E918: variable 'v24' is possibly undefined
// 42E918: variable 'v25' is possibly undefined
// 496EF8: using guessed type __int64 _environ_counter;
// 496F48: using guessed type _DWORD envlock[2];

//----- (000000000042E960) ----------------------------------------------------
__int64 clearenv()
{
  __int64 v0; // x1
  __int64 v1; // x2
  __int64 v2; // x3
  void *v3; // x4
  void *v4; // x5
  void *v5; // x6
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7
  int v14; // w0
  char **v15; // x0
  __int64 v16; // x1
  __int64 v17; // x2
  __int64 v18; // x3
  void *v19; // x4
  void *v20; // x5
  void *v21; // x6
  int v22; // w0
  char *v24; // t1
  int v25; // w0

  _aarch64_cas4_acq();
  if ( v14 )
    _lll_lock_wait_private(envlock, v6, v7, v8, v9, v10, v11, v12, v13, v0, v1, v2, v3, v4, v5);
  v15 = environ;
  if ( _environ_array_list && environ == *(char ***)_environ_array_list )
  {
    if ( *environ )
    {
      do
      {
        *v15 = 0LL;
        v24 = v15[1];
        ++v15;
      }
      while ( v24 );
    }
    atomic_store(_environ_counter + 1, (unsigned __int64 *)&_environ_counter);
    environ = 0LL;
    _aarch64_swp4_rel();
    if ( v25 <= 1 )
      return 0LL;
  }
  else
  {
    environ = 0LL;
    _aarch64_swp4_rel();
    if ( v22 <= 1 )
      return 0LL;
  }
  _lll_lock_wake_private(envlock, v16, v17, v18, v19, v20, v21);
  return 0LL;
}
// 42E980: variable 'v14' is possibly undefined
// 42EA34: variable 'v6' is possibly undefined
// 42EA34: variable 'v7' is possibly undefined
// 42EA34: variable 'v8' is possibly undefined
// 42EA34: variable 'v9' is possibly undefined
// 42EA34: variable 'v10' is possibly undefined
// 42EA34: variable 'v11' is possibly undefined
// 42EA34: variable 'v12' is possibly undefined
// 42EA34: variable 'v13' is possibly undefined
// 42EA34: variable 'v0' is possibly undefined
// 42EA34: variable 'v1' is possibly undefined
// 42EA34: variable 'v2' is possibly undefined
// 42EA34: variable 'v3' is possibly undefined
// 42EA34: variable 'v4' is possibly undefined
// 42EA34: variable 'v5' is possibly undefined
// 42E9C0: variable 'v22' is possibly undefined
// 42EA14: variable 'v25' is possibly undefined
// 42EA1C: variable 'v16' is possibly undefined
// 42EA1C: variable 'v17' is possibly undefined
// 42EA1C: variable 'v18' is possibly undefined
// 42EA1C: variable 'v19' is possibly undefined
// 42EA1C: variable 'v20' is possibly undefined
// 42EA1C: variable 'v21' is possibly undefined
// 496EF8: using guessed type __int64 _environ_counter;
// 496F00: using guessed type __int64 _environ_array_list;
// 496F48: using guessed type _DWORD envlock[2];

//----- (000000000042EA40) ----------------------------------------------------
void _libc_setenv_freemem()
{
  double v0; // d0
  double v1; // d1
  double v2; // d2
  double v3; // d3
  double v4; // d4
  double v5; // d5
  double v6; // d6
  double v7; // d7
  unsigned __int64 *i; // x0
  unsigned __int64 v9; // x0
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7

  clearenv();
  for ( i = (unsigned __int64 *)_environ_array_list; _environ_array_list; i = (unsigned __int64 *)_environ_array_list )
  {
    free(*i, v0, v1, v2, v3, v4, v5, v6, v7);
    v9 = _environ_array_list;
    _environ_array_list = *(_QWORD *)(_environ_array_list + 16);
    free(v9, v10, v11, v12, v13, v14, v15, v16, v17);
  }
  tdestroy((_QWORD *)known_values, (void (__fastcall *)(_QWORD))free);
  known_values = 0LL;
}
// 42EA64: variable 'v0' is possibly undefined
// 42EA64: variable 'v1' is possibly undefined
// 42EA64: variable 'v2' is possibly undefined
// 42EA64: variable 'v3' is possibly undefined
// 42EA64: variable 'v4' is possibly undefined
// 42EA64: variable 'v5' is possibly undefined
// 42EA64: variable 'v6' is possibly undefined
// 42EA64: variable 'v7' is possibly undefined
// 42EA74: variable 'v10' is possibly undefined
// 42EA74: variable 'v11' is possibly undefined
// 42EA74: variable 'v12' is possibly undefined
// 42EA74: variable 'v13' is possibly undefined
// 42EA74: variable 'v14' is possibly undefined
// 42EA74: variable 'v15' is possibly undefined
// 42EA74: variable 'v16' is possibly undefined
// 42EA74: variable 'v17' is possibly undefined
// 496F00: using guessed type __int64 _environ_array_list;
// 496F50: using guessed type __int64 known_values;

//----- (000000000042EAC0) ----------------------------------------------------
__int64 __fastcall _strtoll_internal(int8x16_t *a1, int8x16_t **a2, int a3, int a4)
{
  return ___strtoll_l_internal(a1, a2, a3, a4, 0, *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 32));
}

//----- (000000000042EAE0) ----------------------------------------------------
__int64 __fastcall strtoq(int8x16_t *a1, int8x16_t **a2, int a3)
{
  return ___strtoll_l_internal(a1, a2, a3, 0, 0, *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 32));
}

//----- (000000000042EB00) ----------------------------------------------------
__int64 __fastcall _isoc23_strtoll(int8x16_t *a1, int8x16_t **a2, int a3)
{
  return ___strtoll_l_internal(a1, a2, a3, 0, 1, *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 32));
}

//----- (000000000042EB20) ----------------------------------------------------
__int64 __fastcall ___strtoll_l_internal(int8x16_t *a1, int8x16_t **a2, int a3, int a4, int a5, __int64 a6)
{
  char *v7; // x14
  int8x16_t *v8; // x1
  int8x16_t *v9; // x15
  bool v10; // zf
  _BOOL4 v11; // w6
  __int64 result; // x0
  __int64 v13; // x3
  int8x16_t *v14; // x11
  int v15; // w5
  int v16; // t1
  __int64 v17; // x18
  unsigned int v18; // w7
  unsigned int v19; // w17
  unsigned __int64 v20; // x0
  unsigned __int64 (__fastcall *v21)(__int64); // x10
  bool v22; // zf
  char *v23; // x3
  char *v24; // x3
  int8x16_t *v25; // x6
  unsigned __int64 v26; // x12
  __int64 v27; // x16
  __int64 v28; // x30
  int v29; // w3
  bool v30; // cc
  int8x16_t *v31; // x5
  bool v32; // zf
  __int64 v33; // x5
  bool v34; // zf
  unsigned __int64 (__fastcall *v35)(__int64); // x5
  int v36; // w0
  __int64 v37; // x3
  int v38; // w0
  bool v39; // zf
  unsigned __int64 (__fastcall *v40)(__int64); // x0
  unsigned __int64 (__fastcall *v41)(__int64); // x10
  unsigned __int64 v42; // x0
  int v43; // w7
  int8x16_t *v44; // x5
  int v45; // t1
  unsigned __int64 v46; // x0
  int8x16_t *v47; // x2
  unsigned __int8 *v48; // x3
  int8x16_t *v49; // x0
  int8x16_t *v50; // [xsp+28h] [xbp-38h]
  int8x16_t *v52; // [xsp+30h] [xbp-30h]
  int8x16_t **v53; // [xsp+38h] [xbp-28h]
  unsigned __int64 (__fastcall *v54)(__int64); // [xsp+38h] [xbp-28h]
  int v55; // [xsp+44h] [xbp-1Ch]
  int8x16_t *v56; // [xsp+48h] [xbp-18h]
  unsigned __int8 *v57; // [xsp+48h] [xbp-18h]
  int8x16_t *v58; // [xsp+50h] [xbp-10h]
  int8x16_t **v59; // [xsp+50h] [xbp-10h]
  int v60; // [xsp+5Ch] [xbp-4h]

  v7 = (char *)a1;
  a5 = (unsigned __int8)a5;
  v8 = 0LL;
  v9 = 0LL;
  if ( a4 )
  {
    v37 = *(_QWORD *)(a6 + 8);
    v8 = *(int8x16_t **)(v37 + 72);
    if ( (unsigned __int8)(v8->n128_u8[0] - 1) > 0xFDu )
    {
      v8 = 0LL;
    }
    else
    {
      v9 = *(int8x16_t **)(v37 + 64);
      if ( !v9->n128_u8[0] )
      {
        v8 = 0LL;
        v9 = 0LL;
      }
    }
  }
  v10 = (unsigned int)a3 > 0x24 || a3 == 1;
  v11 = v10;
  if ( v10 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return 0LL;
  }
  v13 = *(_QWORD *)(a6 + 104);
  v14 = a1;
  v15 = a1->n128_u8[0];
  if ( (*(_WORD *)(v13 + 2LL * a1->n128_u8[0]) & 0x2000) != 0 )
  {
    do
    {
      v16 = v14->n128_u8[1];
      v14 = (int8x16_t *)((char *)v14 + 1);
      v15 = v16;
    }
    while ( (*(_WORD *)(v13 + 2LL * (unsigned __int8)v16) & 0x2000) != 0 );
  }
  if ( !v15 )
  {
    if ( a2 )
      *a2 = a1;
    return 0LL;
  }
  if ( v15 == 45 )
  {
    v14 = (int8x16_t *)((char *)v14 + 1);
    v17 = 1LL;
  }
  else
  {
    v17 = 0LL;
    if ( v15 == 43 )
      v14 = (int8x16_t *)((char *)v14 + 1);
  }
  v18 = v14->n128_u8[0];
  if ( v18 != 48 )
  {
    if ( a3 && a3 != 10 )
    {
      v21 = 0LL;
      v19 = _strtol_ul_rem_tab[a3 - 2];
      v20 = _strtol_ul_max_tab[a3 - 2];
      v8 = 0LL;
      goto LABEL_22;
    }
    if ( !v8 )
    {
      v19 = 5;
      v20 = 0x1999999999999999LL;
      a3 = 10;
      v21 = 0LL;
LABEL_22:
      if ( v18 )
        v22 = !v11;
      else
        v22 = 0;
      if ( !v22 )
        goto LABEL_120;
      v23 = (char *)&unk_48F000;
      goto LABEL_28;
    }
LABEL_104:
    v50 = v14;
    v53 = a2;
    v55 = (unsigned __int8)a5;
    v56 = v9;
    v58 = v8;
    v60 = v14->n128_u8[0];
    v40 = strlen();
    a2 = v53;
    v41 = v40;
    v14 = v50;
    v7 = (char *)a1;
    a5 = v55;
    if ( !v40 )
      goto LABEL_120;
    v42 = 0LL;
    v43 = v60;
    while ( v56->n128_u8[v42] == v50->n128_u8[v42] )
    {
      if ( (unsigned __int64 (__fastcall *)(__int64))++v42 == v41 )
        goto LABEL_120;
    }
    if ( (unsigned __int64)v41 <= v42 )
    {
LABEL_120:
      v25 = v14;
      if ( !a2 )
        return 0LL;
LABEL_79:
      if ( (char *)v25 - v7 > 1 )
      {
        v38 = dword_45E140[v25[-1].n128_u8[15]];
        if ( v38 == 88 || (v38 == 66 ? (v39 = a5 == 0) : (v39 = 1), !v39) )
        {
          if ( v25[-1].n128_u8[14] == 48 )
          {
            result = 0LL;
            *a2 = (int8x16_t *)((char *)v25 - 1);
            return result;
          }
        }
      }
      *a2 = (int8x16_t *)v7;
      return 0LL;
    }
    if ( v60 )
    {
      v44 = v50;
      do
      {
        if ( (unsigned __int8)(v43 - 48) > 9u )
        {
          v46 = 0LL;
          while ( v56->n128_u8[v46] == v44->n128_u8[v46] )
          {
            if ( (unsigned __int64 (__fastcall *)(__int64))++v46 == v41 )
              goto LABEL_111;
          }
          if ( (unsigned __int64)v41 > v46
            && ((word_45EA40[(unsigned __int8)v43] & 0x400) == 0 || dword_45E140[v43] > 64) )
          {
            break;
          }
        }
LABEL_111:
        v45 = v44->n128_u8[1];
        v44 = (int8x16_t *)((char *)v44 + 1);
        v43 = v45;
      }
      while ( v45 );
    }
    else
    {
      v44 = v50;
    }
    v47 = v56;
    v48 = (unsigned __int8 *)v58;
    v52 = v56;
    v54 = v41;
    v57 = (unsigned __int8 *)v7;
    v59 = a2;
    v49 = _correctly_grouped_prefixmb((unsigned __int64)v50, v44, v47, v48);
    v14 = v50;
    v9 = v52;
    v8 = v49;
    v17 = (unsigned int)v17;
    v21 = v54;
    v20 = 0x1999999999999999LL;
    v7 = (char *)v57;
    a2 = v59;
    a5 = v55;
    v11 = v8 == v50;
    v18 = v50->n128_u8[0];
    v19 = 5;
    a3 = 10;
    goto LABEL_22;
  }
  if ( (a3 & 0xFFFFFFEF) == 0 )
  {
    v23 = (char *)&unk_48F000;
    v36 = dword_45E140[v14->n128_u8[1]];
    if ( v36 == 88 )
    {
      v18 = v14->n128_u8[2];
      v20 = 0xFFFFFFFFFFFFFFFLL;
      v14 = (int8x16_t *)((char *)v14 + 2);
      v19 = 15;
      a3 = 16;
      v21 = 0LL;
      v8 = 0LL;
      goto LABEL_22;
    }
    if ( (a5 & 1) == 0 )
    {
      if ( a3 )
      {
        v20 = 0xFFFFFFFFFFFFFFFLL;
        v19 = 15;
        a3 = 16;
      }
      else
      {
        v20 = 0x1FFFFFFFFFFFFFFFLL;
        v19 = 7;
        a3 = 8;
      }
      goto LABEL_70;
    }
    if ( a3 )
    {
      v20 = 0xFFFFFFFFFFFFFFFLL;
      v19 = 15;
      a3 = 16;
LABEL_70:
      v8 = 0LL;
      v21 = 0LL;
      goto LABEL_28;
    }
    if ( v36 != 66 )
    {
      v20 = 0x1FFFFFFFFFFFFFFFLL;
      v19 = 7;
      a3 = 8;
      goto LABEL_70;
    }
    goto LABEL_124;
  }
  if ( (a5 & 1) != 0 && a3 == 2 )
  {
    v23 = (char *)&unk_48F000;
    if ( dword_45E140[v14->n128_u8[1]] != 66 )
    {
      v20 = 0x7FFFFFFFFFFFFFFFLL;
      v19 = 1;
      goto LABEL_70;
    }
LABEL_124:
    v18 = v14->n128_u8[2];
    v20 = 0x7FFFFFFFFFFFFFFFLL;
    v14 = (int8x16_t *)((char *)v14 + 2);
    v19 = 1;
    a3 = 2;
    v21 = 0LL;
    v8 = 0LL;
    goto LABEL_22;
  }
  if ( a3 == 10 )
  {
    if ( v8 )
      goto LABEL_104;
    v19 = 5;
    v20 = 0x1999999999999999LL;
    v21 = 0LL;
    v23 = (_BYTE *)&unk_48F000;
  }
  else
  {
    v21 = 0LL;
    v23 = (_BYTE *)&unk_48F000;
    v19 = _strtol_ul_rem_tab[a3 - 2];
    v20 = _strtol_ul_max_tab[a3 - 2];
    v8 = 0LL;
  }
LABEL_28:
  v24 = v23 + 2608;
  v25 = v14;
  v26 = 0LL;
  v27 = *((_QWORD *)v24 + 13);
  v28 = *((_QWORD *)v24 + 15);
  v29 = 0;
  while ( 1 )
  {
    v33 = (unsigned __int8)(v18 - 48);
    if ( (unsigned int)v33 > 9 )
      break;
LABEL_42:
    if ( (int)v33 >= a3 )
      goto LABEL_49;
    if ( v26 > v20 || (v26 == v20 ? (v30 = (unsigned int)v33 > v19) : (v30 = 0), v30) )
    {
      v29 = 1;
      v25 = (int8x16_t *)((char *)v25 + 1);
      v18 = v25->n128_u8[0];
      if ( v25->n128_u8[0] )
        v34 = v25 == v8;
      else
        v34 = 1;
      if ( v34 )
        goto LABEL_49;
    }
    else
    {
      v26 = v33 + a3 * v26;
      v31 = v25;
LABEL_34:
      v18 = v31->n128_u8[1];
      v25 = (int8x16_t *)((char *)v31->n128_u64 + 1);
      if ( v31->n128_u8[1] )
        v32 = v25 == v8;
      else
        v32 = 1;
      if ( v32 )
        goto LABEL_49;
    }
  }
  if ( v21 )
  {
    v35 = 0LL;
    while ( *((unsigned __int8 *)v35 + (_QWORD)v9) == *((unsigned __int8 *)v35 + (_QWORD)v25) )
    {
      v35 = (unsigned __int64 (__fastcall *)(__int64))((char *)v35 + 1);
      if ( v35 == v21 )
        goto LABEL_62;
    }
    if ( v21 == v35 )
    {
LABEL_62:
      v31 = (int8x16_t *)((char *)v21 + (_QWORD)v25 - 1);
      goto LABEL_34;
    }
  }
  if ( (*(_WORD *)(v27 + 2LL * (unsigned __int8)v18) & 0x400) != 0 )
  {
    v33 = (unsigned __int8)(*(_DWORD *)(v28 + 4LL * v18) - 55);
    goto LABEL_42;
  }
LABEL_49:
  if ( v14 == v25 )
  {
    if ( !a2 )
      return 0LL;
    goto LABEL_79;
  }
  if ( a2 )
    *a2 = v25;
  if ( v29 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 34;
    return (v17 << 63 >> 63) ^ 0x7FFFFFFFFFFFFFFFLL;
  }
  else if ( (_DWORD)v17 )
  {
    result = -(__int64)v26;
    if ( v26 > 0x8000000000000000LL )
    {
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 34;
      return 0x8000000000000000LL;
    }
  }
  else
  {
    result = v26;
    if ( (v26 & 0x8000000000000000LL) != 0 )
    {
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 34;
      return 0x7FFFFFFFFFFFFFFFLL;
    }
  }
  return result;
}
// 45C4C0: using guessed type unsigned __int8 _strtol_ul_rem_tab[48];
// 45C4F0: using guessed type _QWORD _strtol_ul_max_tab[35];
// 45E140: using guessed type int dword_45E140[256];
// 45EA40: using guessed type _WORD word_45EA40[256];

//----- (000000000042F0F0) ----------------------------------------------------
__int64 __fastcall strtoll_l(int8x16_t *a1, int8x16_t **a2, int a3, __int64 a4)
{
  return ___strtoll_l_internal(a1, a2, a3, 0, 0, a4);
}

//----- (000000000042F100) ----------------------------------------------------
__int64 __fastcall _isoc23_strtoll_l(int8x16_t *a1, int8x16_t **a2, int a3, __int64 a4)
{
  return ___strtoll_l_internal(a1, a2, a3, 0, 1, a4);
}

//----- (000000000042F120) ----------------------------------------------------
unsigned __int64 __fastcall _strtoull_internal(unsigned __int8 *a1, unsigned __int8 **a2, int a3, int a4)
{
  return ___strtoull_l_internal(a1, a2, a3, a4, 0, *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 32));
}

//----- (000000000042F140) ----------------------------------------------------
unsigned __int64 __fastcall strtouq(unsigned __int8 *a1, unsigned __int8 **a2, int a3)
{
  return ___strtoull_l_internal(a1, a2, a3, 0, 0, *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 32));
}

//----- (000000000042F160) ----------------------------------------------------
unsigned __int64 __fastcall _isoc23_strtoumax(unsigned __int8 *a1, unsigned __int8 **a2, int a3)
{
  return ___strtoull_l_internal(a1, a2, a3, 0, 1, *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 32));
}

//----- (000000000042F180) ----------------------------------------------------
unsigned __int64 __fastcall ___strtoull_l_internal(
        unsigned __int8 *a1,
        unsigned __int8 **a2,
        int a3,
        int a4,
        int a5,
        __int64 a6)
{
  unsigned __int8 *v6; // x13
  unsigned __int8 *v8; // x18
  int8x16_t *v9; // x14
  bool v10; // zf
  _BOOL4 v11; // w3
  unsigned __int64 result; // x0
  __int64 v13; // x1
  unsigned __int8 *v14; // x11
  int v15; // w5
  int v16; // t1
  int v17; // w15
  unsigned int v18; // w7
  int v19; // w5
  unsigned __int64 (__fastcall *v20)(__int64); // x10
  bool v21; // zf
  char *v22; // x0
  char *v23; // x0
  unsigned __int8 *v24; // x6
  __int64 v25; // x16
  unsigned __int64 v26; // x1
  __int64 v27; // x30
  unsigned int v28; // w17
  int v29; // w3
  bool v30; // cf
  unsigned __int8 *v31; // x5
  bool v32; // zf
  __int64 v33; // x5
  bool v34; // zf
  unsigned __int64 (__fastcall *v35)(__int64); // x5
  int v36; // w1
  __int64 v37; // x1
  int v38; // w0
  bool v39; // zf
  unsigned __int64 (__fastcall *v40)(__int64); // x0
  unsigned __int64 (__fastcall *v41)(__int64); // x10
  unsigned __int64 v42; // x0
  unsigned int v43; // w7
  int8x16_t *v44; // x1
  unsigned int v45; // t1
  unsigned __int64 v46; // x0
  int8x16_t *v47; // x2
  int8x16_t *v48; // x0
  int8x16_t *v49; // [xsp+28h] [xbp-38h]
  int8x16_t *v51; // [xsp+30h] [xbp-30h]
  unsigned __int8 **v52; // [xsp+38h] [xbp-28h]
  unsigned __int64 (__fastcall *v53)(__int64); // [xsp+38h] [xbp-28h]
  int v54; // [xsp+44h] [xbp-1Ch]
  int v55; // [xsp+44h] [xbp-1Ch]
  int8x16_t *v56; // [xsp+48h] [xbp-18h]
  unsigned __int8 *v57; // [xsp+48h] [xbp-18h]
  unsigned __int8 **v58; // [xsp+50h] [xbp-10h]
  int v59; // [xsp+58h] [xbp-8h]
  int v60; // [xsp+58h] [xbp-8h]
  unsigned int v61; // [xsp+5Ch] [xbp-4h]

  v6 = a1;
  a5 = (unsigned __int8)a5;
  v8 = 0LL;
  v9 = 0LL;
  if ( a4 )
  {
    v37 = *(_QWORD *)(a6 + 8);
    v8 = *(unsigned __int8 **)(v37 + 72);
    if ( (unsigned __int8)(*v8 - 1) > 0xFDu )
    {
      v8 = 0LL;
    }
    else
    {
      v9 = *(int8x16_t **)(v37 + 64);
      if ( !v9->n128_u8[0] )
      {
        v8 = 0LL;
        v9 = 0LL;
      }
    }
  }
  v10 = (unsigned int)a3 > 0x24 || a3 == 1;
  v11 = v10;
  if ( v10 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return 0LL;
  }
  v13 = *(_QWORD *)(a6 + 104);
  v14 = a1;
  v15 = *a1;
  if ( (*(_WORD *)(v13 + 2LL * *a1) & 0x2000) != 0 )
  {
    do
    {
      v16 = *++v14;
      v15 = v16;
    }
    while ( (*(_WORD *)(v13 + 2LL * (unsigned __int8)v16) & 0x2000) != 0 );
  }
  if ( !v15 )
  {
    if ( a2 )
      *a2 = a1;
    return 0LL;
  }
  if ( v15 == 45 )
  {
    ++v14;
    v17 = 1;
  }
  else
  {
    v17 = 0;
    if ( v15 == 43 )
      ++v14;
  }
  v18 = *v14;
  if ( v18 != 48 )
  {
    if ( a3 && a3 != 10 )
    {
      v19 = a3 - 2;
      v20 = 0LL;
      v8 = 0LL;
      goto LABEL_21;
    }
    v19 = 8;
    a3 = 10;
    v20 = 0LL;
    if ( !v8 )
    {
LABEL_21:
      if ( v18 )
        v21 = !v11;
      else
        v21 = 0;
      if ( !v21 )
        goto LABEL_117;
      v22 = (char *)&unk_48F000;
      goto LABEL_27;
    }
LABEL_99:
    v49 = (int8x16_t *)v14;
    v52 = a2;
    v54 = (unsigned __int8)a5;
    v56 = v9;
    v59 = v17;
    v61 = *v14;
    v40 = strlen();
    a2 = v52;
    v41 = v40;
    v14 = (unsigned __int8 *)v49;
    v6 = a1;
    a5 = v54;
    if ( !v40 )
      goto LABEL_117;
    v42 = 0LL;
    v43 = v61;
    while ( v56->n128_u8[v42] == v49->n128_u8[v42] )
    {
      if ( v41 == (unsigned __int64 (__fastcall *)(__int64))++v42 )
        goto LABEL_117;
    }
    if ( (unsigned __int64)v41 <= v42 )
    {
LABEL_117:
      v24 = v14;
      if ( !a2 )
        return 0LL;
LABEL_75:
      if ( v24 - v6 > 1 )
      {
        v38 = dword_45E140[*(v24 - 1)];
        if ( v38 == 88 || (v38 == 66 ? (v39 = a5 == 0) : (v39 = 1), !v39) )
        {
          if ( *(v24 - 2) == 48 )
          {
            result = 0LL;
            *a2 = v24 - 1;
            return result;
          }
        }
      }
      *a2 = v6;
      return 0LL;
    }
    if ( v61 )
    {
      v44 = v49;
      do
      {
        if ( (unsigned __int8)(v43 - 48) > 9u )
        {
          v46 = 0LL;
          while ( v56->n128_u8[v46] == v44->n128_u8[v46] )
          {
            if ( (unsigned __int64 (__fastcall *)(__int64))++v46 == v41 )
              goto LABEL_106;
          }
          if ( (unsigned __int64)v41 > v46
            && ((word_45EA40[(unsigned __int8)v43] & 0x400) == 0 || dword_45E140[v43] > 64) )
          {
            break;
          }
        }
LABEL_106:
        v45 = v44->n128_u8[1];
        v44 = (int8x16_t *)((char *)v44 + 1);
        v43 = v45;
      }
      while ( v45 );
    }
    else
    {
      v44 = v49;
    }
    v47 = v56;
    v51 = v56;
    v53 = v41;
    v55 = v59;
    v57 = v6;
    v58 = a2;
    v60 = a5;
    v48 = _correctly_grouped_prefixmb((unsigned __int64)v49, v44, v47, v8);
    v14 = (unsigned __int8 *)v49;
    v9 = v51;
    v8 = (unsigned __int8 *)v48;
    v20 = v53;
    v19 = 8;
    v6 = v57;
    a2 = v58;
    a3 = 10;
    v17 = v55;
    a5 = v60;
    v11 = v48 == v49;
    v18 = v49->n128_u8[0];
    goto LABEL_21;
  }
  if ( (a3 & 0xFFFFFFEF) == 0 )
  {
    v22 = (char *)&unk_48F000;
    v36 = dword_45E140[v14[1]];
    if ( v36 == 88 )
    {
      v18 = v14[2];
      v19 = 14;
      v14 += 2;
      a3 = 16;
      v20 = 0LL;
      v8 = 0LL;
      goto LABEL_21;
    }
    if ( (a5 & 1) == 0 )
    {
      if ( a3 )
      {
        v19 = 14;
        a3 = 16;
      }
      else
      {
        v19 = 6;
        a3 = 8;
      }
      goto LABEL_69;
    }
    if ( a3 )
    {
      v19 = 14;
      a3 = 16;
LABEL_69:
      v8 = 0LL;
      v20 = 0LL;
      goto LABEL_27;
    }
    v19 = 6;
    a3 = 8;
    if ( v36 != 66 )
      goto LABEL_69;
    goto LABEL_120;
  }
  if ( (a5 & 1) != 0 && a3 == 2 )
  {
    v22 = (char *)&unk_48F000;
    if ( dword_45E140[v14[1]] != 66 )
    {
      v19 = 0;
      goto LABEL_69;
    }
LABEL_120:
    v18 = v14[2];
    v19 = 0;
    v14 += 2;
    a3 = 2;
    v20 = 0LL;
    v8 = 0LL;
    goto LABEL_21;
  }
  if ( a3 == 10 )
  {
    if ( v8 )
      goto LABEL_99;
    v19 = 8;
    v20 = 0LL;
    v22 = (_BYTE *)&unk_48F000;
  }
  else
  {
    v19 = a3 - 2;
    v8 = 0LL;
    v20 = 0LL;
    v22 = (_BYTE *)&unk_48F000;
  }
LABEL_27:
  v23 = v22 + 2608;
  v24 = v14;
  v25 = *((_QWORD *)v23 + 13);
  v26 = _strtol_ul_max_tab[v19];
  v27 = *((_QWORD *)v23 + 15);
  result = 0LL;
  v28 = _strtol_ul_rem_tab[v19];
  v29 = 0;
  while ( 1 )
  {
    v33 = (unsigned __int8)(v18 - 48);
    if ( (unsigned int)v33 > 9 )
      break;
LABEL_42:
    if ( (int)v33 >= a3 )
      goto LABEL_49;
    if ( v26 >= result && (v26 == result ? (v30 = v28 >= (unsigned int)v33) : (v30 = 1), v30) )
    {
      result = v33 + a3 * result;
      v31 = v24;
LABEL_34:
      v18 = v31[1];
      v24 = v31 + 1;
      if ( v31[1] )
        v32 = v24 == v8;
      else
        v32 = 1;
      if ( v32 )
        goto LABEL_49;
    }
    else
    {
      v29 = 1;
      v18 = *++v24;
      if ( *v24 )
        v34 = v24 == v8;
      else
        v34 = 1;
      if ( v34 )
        goto LABEL_49;
    }
  }
  if ( v20 )
  {
    v35 = 0LL;
    while ( *((unsigned __int8 *)v35 + (_QWORD)v9) == *((unsigned __int8 *)v35 + (_QWORD)v24) )
    {
      v35 = (unsigned __int64 (__fastcall *)(__int64))((char *)v35 + 1);
      if ( v35 == v20 )
        goto LABEL_61;
    }
    if ( v35 == v20 )
    {
LABEL_61:
      v31 = (unsigned __int8 *)v20 + (_QWORD)v24 - 1;
      goto LABEL_34;
    }
  }
  if ( (*(_WORD *)(v25 + 2LL * (unsigned __int8)v18) & 0x400) != 0 )
  {
    v33 = (unsigned __int8)(*(_DWORD *)(v27 + 4LL * v18) - 55);
    goto LABEL_42;
  }
LABEL_49:
  if ( v14 == v24 )
  {
    if ( !a2 )
      return 0LL;
    goto LABEL_75;
  }
  if ( a2 )
    *a2 = v24;
  if ( v17 )
    result = -(__int64)result;
  if ( v29 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 34;
    return -1LL;
  }
  return result;
}
// 45C4C0: using guessed type unsigned __int8 _strtol_ul_rem_tab[48];
// 45C4F0: using guessed type _QWORD _strtol_ul_max_tab[35];
// 45E140: using guessed type int dword_45E140[256];
// 45EA40: using guessed type _WORD word_45EA40[256];

//----- (000000000042F6B0) ----------------------------------------------------
unsigned __int64 __fastcall strtoull_l(unsigned __int8 *a1, unsigned __int8 **a2, int a3, __int64 a4)
{
  return ___strtoull_l_internal(a1, a2, a3, 0, 0, a4);
}

//----- (000000000042F6C0) ----------------------------------------------------
unsigned __int64 __fastcall _isoc23_strtoull_l(unsigned __int8 *a1, unsigned __int8 **a2, int a3, __int64 a4)
{
  return ___strtoull_l_internal(a1, a2, a3, 0, 1, a4);
}

//----- (000000000042F6E0) ----------------------------------------------------
int8x16_t *__fastcall _correctly_grouped_prefixmb(
        unsigned __int64 a1,
        int8x16_t *a2,
        int8x16_t *a3,
        unsigned __int8 *a4)
{
  unsigned __int64 (__fastcall *v7)(__int64); // x20
  int8x16_t *v8; // x22
  int8x16_t *v9; // x19
  char *v10; // x0
  int8x16_t *v11; // x0
  int8x16_t *result; // x0
  char *v13; // x0
  unsigned __int64 (__fastcall *v14)(__int64); // x27
  unsigned __int8 *v15; // x28
  int8x16_t *v16; // x27
  __int64 v17; // x23
  int8x16_t *v18; // x25
  int8x16_t *i; // x26
  unsigned __int64 (__fastcall *v20)(__int64); // x25
  int8x16_t *v21; // x26
  int8x16_t *v22; // [xsp+68h] [xbp+68h]

  if ( !a4 )
    return a2;
  v7 = strlen();
  if ( (char *)v7 <= (char *)a2 - a1 )
  {
    v8 = (int8x16_t *)(a1 - 1);
    v22 = a2;
    while ( 1 )
    {
      v9 = (int8x16_t *)((char *)v22 - (char *)v7);
      if ( a1 > (char *)v22 - (char *)v7 )
        return v22;
      while ( (unsigned int)memcmp(v9, a3, (unsigned __int64)v7) )
      {
        v9 = (int8x16_t *)((char *)v9 - 1);
        if ( a1 > (unsigned __int64)v9 )
          return v22;
      }
      v10 = (char *)v7 + *a4;
      if ( (char *)((char *)v22 - (char *)v9) != v10 )
      {
        if ( (unsigned __int64)v10 >= (char *)v22 - (char *)v9 )
          v11 = v9;
        else
          v11 = (int8x16_t *)&v10[(_QWORD)v9];
        v22 = v11;
        goto LABEL_13;
      }
      v15 = a4;
      v16 = v9;
      v17 = a4[1];
      if ( !a4[1] )
        goto LABEL_31;
      while ( 1 )
      {
        ++v15;
        v18 = (int8x16_t *)((char *)v16 - 1);
        if ( (_DWORD)v17 != 255 )
          break;
        while ( 1 )
        {
          if ( a1 > (unsigned __int64)v18 )
            return v22;
          v21 = v18;
          while ( (unsigned int)memcmp(v21, a3, (unsigned __int64)v7) )
          {
            v21 = (int8x16_t *)((char *)v21 - 1);
            if ( v8 == v21 )
              return v22;
          }
          v16 = v21;
LABEL_30:
          v17 = v15[1];
          if ( v15[1] )
            break;
LABEL_31:
          v17 = *v15;
          v18 = (int8x16_t *)((char *)v16 - 1);
          if ( (_DWORD)v17 != 255 )
            goto LABEL_22;
        }
      }
LABEL_22:
      if ( a1 > (unsigned __int64)v18 )
        return v22;
      for ( i = v18; (unsigned int)memcmp(i, a3, (unsigned __int64)v7); i = (int8x16_t *)((char *)i - 1) )
      {
        if ( v8 == (int8x16_t *)((char *)&i[-1].n128_f64[1] + 7) )
        {
          v13 = (char *)v7 - 1;
          v14 = (unsigned __int64 (__fastcall *)(__int64))((char *)v16 - (char *)i);
          goto LABEL_18;
        }
      }
      v20 = (unsigned __int64 (__fastcall *)(__int64))((char *)v18 - (char *)i);
      v13 = (char *)v7 - 1;
      if ( a1 <= (unsigned __int64)i )
      {
        if ( (unsigned __int64 (__fastcall *)(__int64))((char *)v7 + v17 - 1) == v20 )
        {
          v16 = i;
          goto LABEL_30;
        }
        goto LABEL_37;
      }
      v14 = v20;
LABEL_18:
      if ( &v13[v17] >= (char *)v14 )
        return v22;
LABEL_37:
      v22 = v9;
LABEL_13:
      if ( (char *)v22 - a1 < (char *)v7 )
        goto LABEL_14;
    }
  }
  v22 = a2;
LABEL_14:
  result = v22;
  if ( (unsigned __int64)v22 < a1 )
    return (int8x16_t *)a1;
  return result;
}

//----- (000000000042F920) ----------------------------------------------------
__int64 __fastcall itoa_word(unsigned __int64 a1, __int64 a2, unsigned int a3, int a4)
{
  bool v4; // zf
  const char *v6; // x3
  __int64 result; // x0
  bool v8; // cf
  unsigned __int64 v9; // x5
  unsigned __int64 v10; // x1
  unsigned __int64 v11; // x1
  bool v12; // cc
  unsigned __int64 v13; // x2

  v4 = a4 == 0;
  v6 = "0123456789abcdefghijklmnopqrstuvwxyz";
  if ( !v4 )
    v6 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  switch ( a3 )
  {
    case 0xAu:
      result = a2;
      do
      {
        v12 = a1 > 9;
        v13 = a1 % 0xA;
        a1 /= 0xAuLL;
        *(_BYTE *)--result = v6[v13];
      }
      while ( v12 );
      break;
    case 0x10u:
      result = a2;
      do
      {
        v10 = a1 & 0xF;
        a1 >>= 4;
        *(_BYTE *)--result = v6[v10];
      }
      while ( a1 );
      break;
    case 8u:
      result = a2;
      do
      {
        v11 = a1 & 7;
        a1 >>= 3;
        *(_BYTE *)--result = v6[v11];
      }
      while ( a1 );
      break;
    default:
      result = a2;
      do
      {
        v8 = a1 >= a3;
        v9 = a1 % a3;
        a1 /= a3;
        *(_BYTE *)--result = v6[v9];
      }
      while ( v8 );
      break;
  }
  return result;
}

//----- (000000000042F9EC) ----------------------------------------------------
char *__fastcall fitoa_word(
        unsigned __int64 a1,
        __int64 a2,
        unsigned int a3,
        int a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  unsigned __int64 v9; // x0
  __int64 v10; // x6
  char *v11; // x2

  v9 = itoa_word(a1, (__int64)&a9, a3, a4);
  if ( v9 >= (unsigned __int64)&a9 )
    return (char *)v10;
  v11 = 0LL;
  do
  {
    v11[v10] = v11[v9];
    ++v11;
  }
  while ( v11 != &a9 - v9 );
  return &a9 + v10 - v9;
}
// 42FA24: variable 'v10' is possibly undefined

//----- (000000000042FA60) ----------------------------------------------------
__int64 asprintf(unsigned __int64 *a1, __int64 a2, ...)
{
  char v3; // [xsp+0h] [xbp+0h]
  gcc_va_list va1; // [xsp+10h] [xbp+10h] BYREF
  gcc_va_list va; // [xsp+30h] [xbp+30h] BYREF
  __int64 vars80; // [xsp+D0h] [xbp+D0h]
  __int64 vars88; // [xsp+D8h] [xbp+D8h]
  __int64 vars90; // [xsp+E0h] [xbp+E0h]
  __int64 vars98; // [xsp+E8h] [xbp+E8h]
  __int64 varsA0; // [xsp+F0h] [xbp+F0h]
  __int64 varsA8; // [xsp+F8h] [xbp+F8h]

  va_start(va, a2);
  vars80 = va_arg(va, _QWORD);
  vars88 = va_arg(va, _QWORD);
  vars90 = va_arg(va, _QWORD);
  vars98 = va_arg(va, _QWORD);
  varsA0 = va_arg(va, _QWORD);
  varsA8 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a2);
  va_copy(va1, va);
  return _vasprintf_internal(a1, a2, (__int64)va1, 0LL, vars90, vars98, varsA0, varsA8, v3);
}
// 42FABC: variable 'v3' is possibly undefined

//----- (000000000042FAE0) ----------------------------------------------------
__int64 fprintf(__int64 a1, __int64 a2, ...)
{
  gcc_va_list va1; // [xsp+10h] [xbp+10h] BYREF
  gcc_va_list va; // [xsp+30h] [xbp+30h] BYREF
  __int64 vars80; // [xsp+D0h] [xbp+D0h]
  __int64 vars88; // [xsp+D8h] [xbp+D8h]
  __int64 vars90; // [xsp+E0h] [xbp+E0h]
  __int64 vars98; // [xsp+E8h] [xbp+E8h]
  __int64 varsA0; // [xsp+F0h] [xbp+F0h]
  __int64 varsA8; // [xsp+F8h] [xbp+F8h]

  va_start(va, a2);
  vars80 = va_arg(va, _QWORD);
  vars88 = va_arg(va, _QWORD);
  vars90 = va_arg(va, _QWORD);
  vars98 = va_arg(va, _QWORD);
  varsA0 = va_arg(va, _QWORD);
  varsA8 = va_arg(va, _QWORD);
  va_end(va);
  va_start(va, a2);
  va_copy(va1, va);
  return _vfprintf_internal(a1, a2, (__int128 *)va1, 0);
}

//----- (000000000042FB60) ----------------------------------------------------
void __fastcall funlockfile(__int64 a1)
{
  __int64 v1; // x2
  int v2; // w1
  __int64 v3; // x1
  __int64 v4; // x2
  __int64 v5; // x3
  void *v6; // x4
  void *v7; // x5
  void *v8; // x6
  int v9; // w0
  void *v10; // [xsp+18h] [xbp-8h]

  v1 = *(_QWORD *)(a1 + 136);
  v2 = *(_DWORD *)(v1 + 4);
  if ( _libc_single_threaded )
  {
    if ( !v2 )
    {
      *(_QWORD *)(v1 + 8) = 0LL;
      **(_DWORD **)(a1 + 136) = 0;
      return;
    }
    goto LABEL_5;
  }
  if ( v2 )
  {
LABEL_5:
    *(_DWORD *)(v1 + 4) = v2 - 1;
    return;
  }
  *(_QWORD *)(v1 + 8) = 0LL;
  v10 = *(void **)(a1 + 136);
  _aarch64_swp4_rel();
  if ( v9 > 1 )
    _lll_lock_wake_private(v10, v3, v4, v5, v6, v7, v8);
}
// 42FBB8: variable 'v9' is possibly undefined
// 42FBCC: variable 'v3' is possibly undefined
// 42FBCC: variable 'v4' is possibly undefined
// 42FBCC: variable 'v5' is possibly undefined
// 42FBCC: variable 'v6' is possibly undefined
// 42FBCC: variable 'v7' is possibly undefined
// 42FBCC: variable 'v8' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (000000000042FBE0) ----------------------------------------------------
__int64 __fastcall _grouping_iterator_init_none(__int64 a1, int a2)
{
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a2;
  *(_QWORD *)(a1 + 8) = 0LL;
  *(_QWORD *)(a1 + 16) = 0LL;
  return 0LL;
}

//----- (000000000042FBF0) ----------------------------------------------------
bool __fastcall _grouping_iterator_init(__int64 a1, int a2, __int64 a3, unsigned int a4)
{
  bool v4; // zf
  __int64 v5; // x1
  int v6; // w4
  unsigned __int8 *v7; // x1
  unsigned int v8; // w5
  int v9; // w7
  int v10; // w4
  unsigned int v11; // w2
  int v12; // w8
  unsigned int v14; // w4
  int v15; // w7

  if ( a4 <= 1
    || ((v4 = a2 == 4, v5 = *(_QWORD *)(a3 + 8LL * a2), v4) ? (v6 = 4) : (v6 = 2),
        v7 = *(unsigned __int8 **)(v5 + 8LL * v6 + 56),
        (unsigned __int8)(*v7 - 1) > 0xFDu) )
  {
    *(_DWORD *)a1 = a4;
    *(_DWORD *)(a1 + 4) = a4;
    *(_QWORD *)(a1 + 8) = 0LL;
    *(_QWORD *)(a1 + 16) = 0LL;
    return 0LL;
  }
  else
  {
    v8 = a4;
    v9 = 0;
    v10 = 0;
    while ( 1 )
    {
      v11 = *v7;
      v12 = v10;
      v10 += v11;
      if ( v11 >= v8 )
      {
        *(_DWORD *)a1 = v8;
        *(_DWORD *)(a1 + 4) = a4;
        *(_QWORD *)(a1 + 8) = v7;
        *(_DWORD *)(a1 + 16) = v10;
        *(_DWORD *)(a1 + 20) = v9;
        return v9 != 0;
      }
      ++v9;
      v8 -= v11;
      if ( v7[1] == 255 )
      {
        *(_DWORD *)a1 = v8;
        *(_DWORD *)(a1 + 4) = a4;
        *(_QWORD *)(a1 + 8) = v7 + 1;
        *(_DWORD *)(a1 + 16) = v10;
        *(_DWORD *)(a1 + 20) = v9;
        return v9 != 0;
      }
      if ( !v7[1] )
        break;
      ++v7;
    }
    *(_QWORD *)(a1 + 8) = v7;
    v14 = (v8 - 1) / v11;
    v15 = v9 + v14;
    *(_DWORD *)a1 = v8 - v11 * v14;
    *(_DWORD *)(a1 + 4) = a4;
    *(_DWORD *)(a1 + 16) = v12;
    *(_DWORD *)(a1 + 20) = v15;
    return v15 != 0;
  }
}

//----- (000000000042FCE0) ----------------------------------------------------
__int64 __fastcall _grouping_iterator_next(int *a1)
{
  int v2; // w0
  int v3; // w2
  unsigned int v4; // w0
  unsigned __int8 *v5; // x2
  __int64 result; // x0

  v2 = a1[1];
  if ( !v2 )
    _libc_assert_fail(
      (__int64)"it->remaining > 0",
      (__int64)"grouping_iterator.c",
      0x6Fu,
      (__int64)"__grouping_iterator_next");
  v3 = *a1;
  v4 = v2 - 1;
  a1[1] = v4;
  if ( v3 )
  {
    result = 0LL;
    *a1 = v3 - 1;
  }
  else
  {
    v5 = (unsigned __int8 *)*((_QWORD *)a1 + 1);
    if ( v4 < a1[4] )
      *((_QWORD *)a1 + 1) = --v5;
    result = 1LL;
    *a1 = *v5 - 1;
  }
  return result;
}

//----- (000000000042FD80) ----------------------------------------------------
__int64 __fastcall _printf_buffer_done(__int64 a1)
{
  unsigned __int64 v1; // x1
  int v2; // w2
  __int64 result; // x0

  if ( !*(_DWORD *)(a1 + 32) )
    return 0xFFFFFFFFLL;
  v1 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  v2 = 0;
  result = v1 + *(_QWORD *)(a1 + 24);
  if ( result < 0 || result < v1 )
    v2 = 1;
  if ( result != (int)result || v2 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 75;
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000042FDE0) ----------------------------------------------------
__int64 __fastcall _printf_buffer_pad_1(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        void *a4,
        __int64 a5,
        _DWORD *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  __int64 result; // x0
  unsigned __int64 v18; // x20
  unsigned __int64 v19; // x19
  __int64 v20; // x19

  result = *(unsigned int *)(a1 + 32);
  if ( (_DWORD)result )
  {
    v18 = a3;
    result = *(_QWORD *)(a1 + 8);
    do
    {
      v20 = *(_QWORD *)(a1 + 16);
      if ( v20 == result )
      {
        result = _printf_buffer_flush(a1, a9, a10, a11, a12, a13, a14, a15, a16, a2, a3, a4, a5, a6, a7, a8);
        if ( (result & 1) == 0 )
          return result;
        result = *(_QWORD *)(a1 + 8);
        v20 = *(_QWORD *)(a1 + 16);
        if ( result == v20 )
          _libc_assert_fail(
            (__int64)"buf->write_ptr != buf->write_end",
            (__int64)"Xprintf_buffer_pad_1.c",
            0x23u,
            (__int64)"__printf_buffer_pad_1");
      }
      v19 = v20 - result;
      if ( v19 > v18 )
        v19 = v18;
      memset();
      v18 -= v19;
      result = *(_QWORD *)(a1 + 8) + v19;
      *(_QWORD *)(a1 + 8) = result;
    }
    while ( v18 );
  }
  return result;
}
// 42FE48: variable 'a9' is possibly undefined
// 42FE48: variable 'a10' is possibly undefined
// 42FE48: variable 'a11' is possibly undefined
// 42FE48: variable 'a12' is possibly undefined
// 42FE48: variable 'a13' is possibly undefined
// 42FE48: variable 'a14' is possibly undefined
// 42FE48: variable 'a15' is possibly undefined
// 42FE48: variable 'a16' is possibly undefined
// 42FE48: variable 'a2' is possibly undefined
// 42FE48: variable 'a3' is possibly undefined
// 42FE48: variable 'a4' is possibly undefined
// 42FE48: variable 'a5' is possibly undefined
// 42FE48: variable 'a6' is possibly undefined
// 42FE48: variable 'a7' is possibly undefined
// 42FE48: variable 'a8' is possibly undefined

//----- (000000000042FEA0) ----------------------------------------------------
unsigned __int64 __fastcall _printf_buffer_putc_1(unsigned __int64 result, char a2)
{
  unsigned __int64 v3; // x19

  if ( *(_DWORD *)(result + 32) )
  {
    v3 = result;
    result = _printf_buffer_flush();
    if ( (result & 1) != 0 )
    {
      result = *(_QWORD *)(v3 + 8);
      if ( result >= *(_QWORD *)(v3 + 16) )
        _libc_assert_fail(
          (__int64)"buf->write_ptr < buf->write_end",
          (__int64)"Xprintf_buffer_putc_1.c",
          0x1Bu,
          (__int64)"__printf_buffer_putc_1");
      *(_QWORD *)(v3 + 8) = result + 1;
      *(_BYTE *)result = a2;
    }
  }
  return result;
}
// 42FF20: using guessed type __int64 _printf_buffer_puts_1(void);
// 444200: using guessed type __int64 _printf_buffer_flush(void);

//----- (000000000042FF20) ----------------------------------------------------
__int64 __fastcall _printf_buffer_puts_1(
        __int64 a1,
        _BYTE *a2,
        __int64 a3,
        void *a4,
        __int64 a5,
        _DWORD *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  __int64 result; // x0
  _BYTE *v18; // x20
  unsigned __int64 v19; // x19
  unsigned __int64 v20; // x21
  __int64 v21; // x1

  result = *(unsigned int *)(a1 + 32);
  if ( (_DWORD)result )
  {
    v18 = a2;
    result = (unsigned __int8)*a2;
    if ( *a2 )
    {
      v19 = *(_QWORD *)(a1 + 8);
      do
      {
        v21 = *(_QWORD *)(a1 + 16);
        if ( v21 == v19 )
        {
          result = _printf_buffer_flush(a1, a9, a10, a11, a12, a13, a14, a15, a16, v21, a3, a4, a5, a6, a7, a8);
          if ( (result & 1) == 0 )
            return result;
          v19 = *(_QWORD *)(a1 + 8);
          v21 = *(_QWORD *)(a1 + 16);
          if ( v19 == v21 )
            _libc_assert_fail(
              (__int64)"buf->write_ptr != buf->write_end",
              (__int64)"Xprintf_buffer_puts_1.c",
              0x20u,
              (__int64)"__printf_buffer_puts_1");
        }
        v20 = strnlen((__int64)v18, v21 - v19);
        j_memcpy();
        v18 += v20;
        v19 = *(_QWORD *)(a1 + 8) + v20;
        *(_QWORD *)(a1 + 8) = v19;
        result = (unsigned __int8)*v18;
      }
      while ( *v18 );
    }
  }
  return result;
}
// 42FF98: variable 'a9' is possibly undefined
// 42FF98: variable 'a10' is possibly undefined
// 42FF98: variable 'a11' is possibly undefined
// 42FF98: variable 'a12' is possibly undefined
// 42FF98: variable 'a13' is possibly undefined
// 42FF98: variable 'a14' is possibly undefined
// 42FF98: variable 'a15' is possibly undefined
// 42FF98: variable 'a16' is possibly undefined
// 42FF98: variable 'a3' is possibly undefined
// 42FF98: variable 'a4' is possibly undefined
// 42FF98: variable 'a5' is possibly undefined
// 42FF98: variable 'a6' is possibly undefined
// 42FF98: variable 'a7' is possibly undefined
// 42FF98: variable 'a8' is possibly undefined

//----- (000000000042FFE0) ----------------------------------------------------
unsigned __int64 *__fastcall _printf_buffer_to_file_switch(unsigned __int64 *result)
{
  unsigned __int64 v1; // x2
  unsigned __int64 v2; // x1
  unsigned __int64 v3; // x2

  v1 = result[5];
  v2 = *(_QWORD *)(v1 + 40);
  if ( v2 >= *(_QWORD *)(v1 + 48) )
  {
    *result = (unsigned __int64)(result + 6);
    result[1] = (unsigned __int64)(result + 6);
    result[2] = (unsigned __int64)(result + 22);
  }
  else
  {
    result[1] = v2;
    v3 = *(_QWORD *)(v1 + 48);
    *result = v2;
    result[2] = v3;
  }
  return result;
}

//----- (0000000000430020) ----------------------------------------------------
unsigned __int64 __fastcall _printf_buffer_flush_to_file(
        unsigned __int64 *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  unsigned __int64 *v9; // x3
  char *v10; // x5
  char *v11; // x2
  char *v12; // x4
  unsigned __int64 result; // x0
  unsigned __int64 v14; // x0
  unsigned __int64 *v15; // x3
  _QWORD *v16; // x1
  __int64 v17; // x2
  __int64 v18; // x6
  char *v19; // x5
  unsigned __int64 v20; // x2
  unsigned __int64 v21; // x1
  unsigned __int64 *v22; // [xsp+18h] [xbp+18h]
  unsigned __int64 v23; // [xsp+18h] [xbp+18h]
  _QWORD *v24; // [xsp+18h] [xbp+18h]
  char *v25; // [xsp+20h] [xbp+20h]
  __int64 v26; // [xsp+20h] [xbp+20h]
  __int64 v27; // [xsp+20h] [xbp+20h]
  char *v28; // [xsp+28h] [xbp+28h]
  __int64 v29; // [xsp+28h] [xbp+28h]
  unsigned __int64 *v30; // [xsp+30h] [xbp+30h]
  char *v31; // [xsp+30h] [xbp+30h]
  unsigned __int64 *v32; // [xsp+38h] [xbp+38h]

  v9 = a1;
  v10 = (char *)(a1 + 22);
  v11 = (char *)a1[1];
  v12 = (char *)a1[2];
  result = (unsigned __int64)&v11[a1[3] - *a1];
  v9[3] = result;
  if ( v12 == v10 )
  {
    v16 = v9 + 6;
    v17 = v11 - (char *)(v9 + 6);
    v18 = *(_QWORD *)(v9[5] + 216);
    if ( (unsigned __int64)(v18 - (_QWORD)&_io_vtables) > 0x92F )
    {
      v24 = v9 + 6;
      v27 = *(_QWORD *)(v9[5] + 216);
      v29 = v17;
      v31 = v10;
      v32 = v9;
      IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
      v9 = v32;
      v16 = v24;
      v18 = v27;
      v17 = v29;
      v10 = v31;
    }
    v23 = (unsigned __int64)v16;
    v26 = v17;
    v28 = v10;
    v30 = v9;
    result = (*(__int64 (**)(void))(v18 + 56))();
    v19 = v28;
    v15 = v30;
    if ( result != v26 )
      goto LABEL_10;
    v20 = v30[5];
    result = *(_QWORD *)(v20 + 40);
    if ( result < *(_QWORD *)(v20 + 48) )
    {
      v30[1] = result;
      v19 = *(char **)(v20 + 48);
    }
    else
    {
      result = v23;
      v30[1] = v23;
    }
    goto LABEL_16;
  }
  if ( v12 == (char *)v9 + 49 )
  {
    if ( v11 != v12 )
      return result;
    v22 = v9;
    v25 = v10;
    result = _overflow(v9[5], *((unsigned __int8 *)v9 + 48), a2, a3, a4, a5, a6, a7, a8, a9);
    v15 = v22;
    if ( (_DWORD)result == -1 )
    {
LABEL_10:
      *((_DWORD *)v15 + 8) = 0;
      return result;
    }
    v21 = v22[5];
    v19 = v25;
    result = *(_QWORD *)(v21 + 40);
    if ( result >= *(_QWORD *)(v21 + 48) )
    {
      result = (unsigned __int64)(v22 + 6);
      v22[1] = (unsigned __int64)(v22 + 6);
    }
    else
    {
      v22[1] = result;
      v19 = *(char **)(v21 + 48);
    }
LABEL_16:
    *v15 = result;
    v15[2] = (unsigned __int64)v19;
    return result;
  }
  v14 = v9[5];
  if ( v12 != *(char **)(v14 + 48) )
    _libc_assert_fail(
      (__int64)"buf->base.write_end == buf->fp->_IO_write_end",
      (__int64)"printf_buffer_to_file.c",
      0x56u,
      (__int64)"__printf_buffer_flush_to_file");
  *(_QWORD *)(v14 + 40) = v11;
  result = v9[1];
  if ( result == v9[2] )
  {
    result = (unsigned __int64)(v9 + 6);
    v9[1] = (unsigned __int64)(v9 + 6);
    v9[2] = (unsigned __int64)v9 + 49;
  }
  *v9 = result;
  return result;
}

//----- (00000000004301A4) ----------------------------------------------------
__int64 __fastcall _printf_buffer_to_file_init(__int64 result, __int64 a2)
{
  __int64 v2; // x4
  unsigned __int64 v3; // x3
  __int64 v4; // x2

  v2 = result + 48;
  *(_QWORD *)result = result + 48;
  *(_QWORD *)(result + 24) = 0LL;
  *(_QWORD *)(result + 8) = result + 48;
  *(_QWORD *)(result + 16) = result + 176;
  *(_DWORD *)(result + 32) = 4;
  *(_QWORD *)(result + 40) = a2;
  v3 = *(_QWORD *)(a2 + 40);
  if ( v3 >= *(_QWORD *)(a2 + 48) )
  {
    *(_QWORD *)result = v2;
    *(_QWORD *)(result + 8) = v2;
    *(_QWORD *)(result + 16) = result + 176;
  }
  else
  {
    *(_QWORD *)(result + 8) = v3;
    v4 = *(_QWORD *)(a2 + 48);
    *(_QWORD *)result = v3;
    *(_QWORD *)(result + 16) = v4;
  }
  return result;
}

//----- (0000000000430200) ----------------------------------------------------
__int64 __fastcall _printf_buffer_to_file_done(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  if ( !*(_DWORD *)(a1 + 32) )
    return 0xFFFFFFFFLL;
  _printf_buffer_flush_to_file((unsigned __int64 *)a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return _printf_buffer_done(a1);
}

//----- (0000000000430240) ----------------------------------------------------
__int64 __fastcall _printf_buffer_write(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  __int64 result; // x0
  unsigned __int64 v5; // x20
  unsigned __int64 v7; // x19
  __int64 v8; // x19

  result = *(unsigned int *)(a1 + 32);
  if ( (_DWORD)result )
  {
    v5 = a3;
    if ( a3 )
    {
      result = *(_QWORD *)(a1 + 8);
      do
      {
        v8 = *(_QWORD *)(a1 + 16);
        if ( v8 == result )
        {
          result = _printf_buffer_flush(a1);
          if ( (result & 1) == 0 )
            return result;
          result = *(_QWORD *)(a1 + 8);
          v8 = *(_QWORD *)(a1 + 16);
          if ( result == v8 )
            _libc_assert_fail(
              (__int64)"buf->write_ptr != buf->write_end",
              (__int64)"Xprintf_buffer_write.c",
              0x23u,
              (__int64)"__printf_buffer_write");
        }
        v7 = v8 - result;
        if ( v7 > v5 )
          v7 = v5;
        a2 += v7;
        j_memcpy();
        v5 -= v7;
        result = *(_QWORD *)(a1 + 8) + v7;
        *(_QWORD *)(a1 + 8) = result;
      }
      while ( v5 );
    }
  }
  return result;
}
// 444200: using guessed type __int64 __fastcall _printf_buffer_flush(_QWORD);

//----- (0000000000430300) ----------------------------------------------------
__int64 __fastcall hack_digit(_DWORD *a1)
{
  _QWORD *v1; // x6
  __int64 v2; // x5
  __int64 v3; // x1
  __int64 v4; // x2
  int v5; // w4
  unsigned __int64 v6; // x0
  __int64 v7; // x1
  __int64 v8; // x2
  __int64 v10; // x0
  __int64 *v11; // x2
  __int64 v12; // x4
  __int64 v13; // x2
  __int64 v14; // x2
  int v15; // w0
  unsigned int v16; // [xsp+18h] [xbp-18h]
  _QWORD *v17; // [xsp+18h] [xbp-18h]
  _QWORD *v18; // [xsp+20h] [xbp-10h]
  __int64 v19; // [xsp+20h] [xbp-10h]

  v1 = a1;
  if ( *a1 )
  {
    if ( a1[1] == 102 )
    {
      v15 = a1[2];
      *((_DWORD *)v1 + 2) = v15 - 1;
      if ( v15 > 0 )
        return 48LL;
    }
  }
  v2 = v1[5];
  v3 = v1[2];
  v4 = v1[3];
  if ( !v2 )
  {
    v14 = v4 - 1;
    v19 = *(_QWORD *)(v3 + 8 * v14);
    *(_QWORD *)(v3 + 8 * v14) = _mpn_mul_1(v1[2], v3, v14, 10LL);
    return (unsigned int)(v19 + 48);
  }
  if ( v2 <= v4 )
  {
    v17 = v1;
    v10 = _mpn_divrem(v1[6], 0LL, (unsigned __int64 *)v1[2], v1[3], (unsigned __int64 *)v1[4], v2);
    v1 = v17;
    v11 = (__int64 *)v17[6];
    v11[v17[3] - v17[5]] = v10;
    v12 = *v11;
    v13 = v17[5];
    v17[3] = v13;
    if ( !v13 )
    {
LABEL_17:
      v17[3] = 1LL;
      return (unsigned int)(v12 + 48);
    }
    v3 = v17[2];
    while ( !*(_QWORD *)(v3 - 8 + 8 * v13) )
    {
      v17[3] = --v13;
      if ( !v13 )
        goto LABEL_17;
    }
    v4 = v17[3];
    v5 = v12 + 48;
  }
  else
  {
    v5 = 48;
  }
  v16 = v5;
  v18 = v1;
  v6 = _mpn_mul_1(v3, v3, v4, 10LL);
  if ( v6 )
  {
    v8 = v18[2];
    v7 = v18[3];
    v18[3] = v7 + 1;
    *(_QWORD *)(v8 + 8 * v7) = v6;
  }
  return v16;
}

//----- (0000000000430460) ----------------------------------------------------
void __fastcall _printf_fp_buffer_1_isra_0(
        unsigned __int64 a1,
        __int64 a2,
        unsigned __int8 a3,
        unsigned __int8 a4,
        __int64 a5,
        double *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  __int16 v18; // w20
  int v19; // w0
  double v20; // d0
  __int64 v21; // x2
  void *v22; // x3
  const char *v23; // x23
  int v24; // w1
  int v25; // w24
  _BOOL4 v26; // w21
  bool v27; // zf
  _BYTE *v28; // x0
  void *v29; // x3
  __int64 v30; // x4
  _DWORD *v31; // x5
  void *v32; // x6
  __int64 v33; // x7
  double v34; // d0
  double v35; // d1
  double v36; // d2
  double v37; // d3
  double v38; // d4
  double v39; // d5
  double v40; // d6
  double v41; // d7
  __int64 v45; // x2
  int v46; // w21
  int v47; // w26
  int v48; // w5
  int v49; // w1
  int v50; // w3
  __int64 v51; // x4
  __int64 v52; // x2
  __int64 v53; // x2
  _QWORD *v54; // x24
  int v55; // w21
  int v56; // w25
  int v57; // w27
  int v58; // w0
  __int64 v59; // x2
  unsigned __int64 v60; // x0
  __int64 v61; // x1
  unsigned __int64 StatusReg; // x2
  signed int v63; // w0
  int v64; // w21
  bool v65; // cc
  int v66; // w2
  int v67; // w28
  signed int v68; // w24
  unsigned __int64 v69; // x20
  int v70; // w0
  _BOOL4 v71; // w0
  __int64 v72; // x1
  __int64 v73; // x2
  void *v74; // x3
  void *v75; // x4
  void *v76; // x5
  void *v77; // x6
  __int64 v78; // x7
  double v79; // d0
  double v80; // d1
  double v81; // d2
  double v82; // d3
  double v83; // d4
  double v84; // d5
  double v85; // d6
  double v86; // d7
  int v88; // w0
  __int64 *v89; // x23
  _BYTE *v90; // x4
  bool v91; // cc
  _BYTE *v92; // x27
  int v93; // w25
  int v94; // w26
  int v95; // w0
  int v96; // w0
  int v97; // w5
  int v98; // w1
  _BYTE *v99; // x0
  unsigned __int64 *v100; // x0
  __int64 v101; // x6
  unsigned __int64 v102; // x20
  unsigned __int64 *v103; // x7
  unsigned __int64 *v104; // x1
  __int64 i; // x5
  unsigned __int64 v106; // x3
  unsigned __int64 v107; // t1
  __int64 v108; // x8
  unsigned __int64 v109; // x4
  unsigned __int64 v110; // x6
  char v111; // w23
  int v112; // w4
  int v113; // w21
  __int64 v114; // x24
  __int64 v115; // x0
  unsigned __int64 v116; // x0
  __int64 v117; // x2
  unsigned __int64 v118; // x0
  __int64 *v119; // x1
  __int64 v120; // x2
  int v122; // w3
  int v123; // w24
  __int64 *v124; // x23
  int v125; // w21
  __int64 v126; // x2
  unsigned __int64 v127; // x0
  unsigned __int64 *v128; // x6
  __int64 v129; // x2
  __int64 v130; // x2
  unsigned __int64 *v131; // x5
  unsigned __int64 v132; // x4
  int v133; // w25
  int v134; // w26
  int v135; // w0
  int v136; // w0
  unsigned __int64 v137; // x0
  int v138; // w4
  int v139; // w3
  unsigned __int64 v140; // x0
  unsigned __int64 *v141; // x1
  __int64 v142; // x2
  int v143; // w21
  unsigned int v144; // w0
  __int64 v145; // x4
  double v146; // d0
  double v147; // d1
  double v148; // d2
  double v149; // d3
  double v150; // d4
  double v151; // d5
  double v152; // d6
  double v153; // d7
  bool v154; // zf
  unsigned __int64 v155; // x5
  __int64 v156; // x7
  __int64 v157; // x2
  unsigned __int64 v158; // x2
  unsigned __int64 v159; // x6
  __int64 v160; // x3
  int v161; // w2
  char v162; // w0
  int v163; // w1
  int m; // w0
  int v165; // w2
  __int16 v166; // w20
  int v167; // w25
  unsigned __int64 v168; // x21
  int v169; // w25
  __int64 v170; // x1
  _BYTE *v171; // x0
  char *v173; // x21
  char *v174; // x26
  char *v175; // x0
  char v176; // w1
  _BYTE *v177; // x0
  void *v178; // x3
  __int64 v179; // x4
  _DWORD *v180; // x5
  void *v181; // x6
  __int64 v182; // x7
  double v183; // d0
  double v184; // d1
  double v185; // d2
  double v186; // d3
  double v187; // d4
  double v188; // d5
  double v189; // d6
  double v190; // d7
  _BYTE *v192; // x0
  int v193; // w2
  int v195; // w3
  int v196; // t1
  int v198; // w3
  bool v199; // zf
  int v200; // w25
  int v201; // w2
  _BYTE *v202; // x0
  unsigned __int64 v203; // x0
  __int64 v204; // x2
  __int64 v205; // x25
  __int64 *v206; // x0
  unsigned __int64 v207; // x0
  __int16 v208; // w1
  int v209; // w1
  _BYTE *v210; // x0
  _BYTE *v211; // x0
  unsigned __int64 v212; // x1
  int v213; // w2
  unsigned __int64 v214; // x5
  __int64 v215; // x2
  unsigned __int64 *v216; // x3
  __int64 j; // x1
  __int64 v218; // x1
  unsigned __int64 *v219; // x8
  __int64 k; // x0
  unsigned __int64 v221; // x6
  int v222; // w3
  int v223; // w6
  __int64 v224; // x23
  __int64 v225; // x24
  __int64 v226; // x0
  __int64 *v227; // x1
  unsigned __int64 v228; // x1
  int v229; // w0
  unsigned __int64 *v230; // x0
  __int64 v231; // x5
  unsigned __int64 *v232; // x1
  int v233; // w4
  unsigned __int64 v234; // x3
  unsigned __int64 v235; // t1
  int v236; // w0
  int v237; // w3
  __int64 v238; // x20
  unsigned __int64 *v239; // x1
  bool v240; // zf
  __int64 v241; // x3
  unsigned __int64 *v242; // x1
  unsigned __int64 *v243; // x4
  __int64 v244; // x0
  unsigned __int64 v245; // x0
  __int64 v246; // x1
  unsigned __int64 v247; // x0
  unsigned __int64 v248; // x5
  int v249; // w1
  __int64 v251; // x2
  unsigned __int64 v252; // x4
  _BYTE v253[2]; // [xsp-2h] [xbp-10h] BYREF
  _BYTE v254[14]; // [xsp+0h] [xbp-Eh] BYREF
  __int64 v255; // [xsp+Eh] [xbp+0h] BYREF
  unsigned __int64 v256; // [xsp+76h] [xbp+68h]
  int v257; // [xsp+7Eh] [xbp+70h]
  unsigned int v258; // [xsp+82h] [xbp+74h]
  int v259; // [xsp+86h] [xbp+78h]
  int v260; // [xsp+8Ah] [xbp+7Ch]
  __int64 v261; // [xsp+8Eh] [xbp+80h]
  int v262; // [xsp+96h] [xbp+88h]
  int v263; // [xsp+9Ah] [xbp+8Ch]
  TFtype a; // [xsp+9Eh] [xbp+90h]
  long double v265; // [xsp+AEh] [xbp+A0h]
  __int64 *v266; // [xsp+BEh] [xbp+B0h]
  int v267; // [xsp+C6h] [xbp+B8h]
  int v268; // [xsp+CAh] [xbp+BCh]
  unsigned int v269; // [xsp+DAh] [xbp+CCh] BYREF
  unsigned __int64 v270[2]; // [xsp+DEh] [xbp+D0h] BYREF
  __int128 v271; // [xsp+EEh] [xbp+E0h] BYREF
  int v272; // [xsp+102h] [xbp+F4h]
  int v273; // [xsp+10Eh] [xbp+100h] BYREF
  unsigned int v274; // [xsp+112h] [xbp+104h]
  int v275; // [xsp+116h] [xbp+108h] BYREF
  unsigned __int64 *v276; // [xsp+11Eh] [xbp+110h]
  __int64 v277; // [xsp+126h] [xbp+118h]
  unsigned __int64 *v278; // [xsp+12Eh] [xbp+120h]
  __int64 v279; // [xsp+136h] [xbp+128h]
  unsigned __int64 *v280; // [xsp+13Eh] [xbp+130h]
  __int64 v281; // [xsp+146h] [xbp+138h]

  v18 = *(_WORD *)(a5 + 12);
  v267 = a3;
  v261 = a2;
  v268 = a4;
  if ( (v18 & 0x100) != 0 )
    v19 = 4;
  else
    v19 = 1;
  v263 = v19;
  v269 = 0;
  v273 = 0;
  if ( (v18 & 1) != 0 )
  {
    v265 = *(long double *)a6;
    *(_QWORD *)&a = *(_QWORD *)&v265;
    *((_QWORD *)&a + 1) = *((_QWORD *)&v265 + 1) & 0x7FFFFFFFFFFFFFFFLL;
    v20 = *(double *)&v265;
    a10 = NAN;
    if ( a > *(long double *)&xmmword_45B7B0 )
    {
      v21 = *((_QWORD *)&v265 + 1) >> 63;
      goto LABEL_7;
    }
    v45 = _mpn_extract_long_double(v270, v265, 2LL, &v275, &v269);
    v46 = ((_DWORD)v45 << 6) - 112;
    goto LABEL_39;
  }
  v20 = *a6;
  if ( fabs(*a6) <= 1.79769313e308 )
  {
    v45 = _mpn_extract_double(v270, v20, 2LL, &v275, &v269);
    v46 = ((_DWORD)v45 << 6) - 52;
LABEL_39:
    v47 = v275;
    v276 = (unsigned __int64 *)&v255;
    v277 = v45;
    v278 = (unsigned __int64 *)&v255;
    v279 = 0LL;
    v280 = (unsigned __int64 *)&v255;
    if ( v275 > 2 )
    {
      v48 = v275 + v46;
      v49 = v275 + v46 + 63;
      if ( v275 + v46 >= 0 )
        v49 = v275 + v46;
      LOBYTE(v50) = v48 & 0x3F;
      LODWORD(v51) = v49 >> 6;
      if ( (v48 & 0x3F) != 0 )
      {
        if ( v48 <= 0 )
          v50 = -(-v48 & 0x3F);
        v116 = _mpn_lshift((__int64)(&v255 + (int)v51), (__int64)v270, v45, v50);
        v47 = v275;
        v51 = (v46 + v275) / 64;
        v117 = v51 + v277;
        v277 += v51;
        if ( v116 )
        {
          v277 = v117 + 1;
          v276[v117] = v116;
        }
      }
      else
      {
        if ( v45 > 0 )
        {
          v52 = v45 - 2;
          do
          {
            *(&v255 + (int)v51 + v52 + 1) = v270[v52 + 1];
            --v52;
          }
          while ( v52 != -2 );
          v45 = v277;
        }
        v51 = (int)v51;
        v277 = (int)v51 + v45;
      }
      if ( v51 > 0 )
        memset();
      v53 = v279;
      v54 = &unk_46B1E8;
      v55 = 0;
      v56 = 12;
      v57 = 0;
      while ( 1 )
      {
        v58 = *((_DWORD *)v54 - 2);
        v54 -= 3;
        if ( v57 + v58 - 1 > v47 )
          goto LABEL_58;
        if ( v53 )
        {
          v203 = _mpn_mul((__int64)v280, (__int64)v278, v53, &_tens[*v54 + 1], v54[1] - 1LL);
          v204 = v279 + v54[1];
          if ( v203 )
            v59 = v204 - 1;
          else
            v59 = v204 - 2;
          v281 = v59;
        }
        else if ( (*(_WORD *)(a5 + 12) & 1) != 0 )
        {
          v281 = v54[1] + 1LL;
          j_memcpy();
          *v280 = 0LL;
          v59 = v281;
          v275 += 64;
        }
        else
        {
          v281 = v54[1];
          j_memcpy();
          v59 = v281;
        }
        if ( v277 <= v59 )
        {
          if ( v277 != v59 || (_mpn_cmp((__int64)v276, (__int64)v280, v59) & 0x80000000) != 0 )
          {
            v53 = v279;
LABEL_58:
            if ( !v56 )
              goto LABEL_110;
            goto LABEL_59;
          }
          v59 = v281;
        }
        v279 = v59;
        j_memcpy();
        v53 = v279;
        v57 = ((_DWORD)v279 << 6) - 129 - __clz(v278[v279 - 1]);
        v55 |= 1 << v56;
        if ( !v56 )
        {
LABEL_110:
          v275 = v55;
          if ( v53 > 0 )
          {
            v100 = v278;
            v101 = v53 - 1;
            v102 = *v278;
            if ( *v278 )
            {
              v248 = __clz(v278[v101]);
              v111 = v248;
              if ( v248 )
              {
                v249 = __clz(__rbit64(v102));
                v112 = v249;
                v102 = *v276;
                if ( *v276 )
                {
                  v252 = __rbit64(v102);
                  v102 = 0LL;
                  v112 = __clz(v252);
                  if ( v249 <= v112 )
                    v112 = v249;
                  v113 = 64 - v248;
                  v104 = v278;
                }
                else
                {
                  v113 = 64 - v248;
                  v104 = v278;
                }
LABEL_118:
                if ( v112 < v113 )
                {
                  _mpn_lshift((__int64)v278, (__int64)v278, v53, v111);
                  v245 = _mpn_lshift((__int64)v276, (__int64)v276, v277, v111);
                  if ( v245 )
                  {
                    v246 = v277++;
                    v276[v246] = v245;
                  }
                }
                else
                {
LABEL_119:
                  _mpn_rshift(v278, v104, v53 - v56, v113);
                  v114 = v56 + 1;
                  v279 -= v114;
                  _mpn_rshift(v276, (unsigned __int64 *)((char *)v276 + v102), v277 - v56, v113);
                  v115 = v277 - v56;
                  if ( !v276[v115 - 1] )
                    v115 = v277 - v114;
                  v277 = v115;
                }
              }
            }
            else
            {
              v103 = v276;
              v104 = v278;
              for ( i = 0LL; ; ++i )
              {
                v109 = *(unsigned __int64 *)((char *)v276 + v102);
                if ( v109 )
                {
                  v110 = __clz(v278[v101]);
                  v111 = v110;
                  if ( !v110 )
                  {
                    if ( !(_DWORD)i )
                      goto LABEL_64;
                    v56 = i;
                    LODWORD(v108) = i;
                    goto LABEL_334;
                  }
                  v112 = __clz(__rbit64(v109));
                  v113 = 64 - v110;
                  if ( !(_DWORD)i )
                    goto LABEL_118;
                  v108 = i;
                  v56 = i;
                  goto LABEL_353;
                }
                v107 = v104[1];
                ++v104;
                v106 = v107;
                v108 = i + 1;
                v102 += 8LL;
                if ( v107 )
                  break;
              }
              v56 = i + 1;
              v214 = __clz(v278[v101]);
              if ( !v214 )
              {
LABEL_334:
                v215 = v53 - v56;
                if ( v215 > 0 )
                {
                  v216 = &v278[(unsigned int)v108];
                  for ( j = 0LL; j < v215; ++j )
                  {
                    v100[j] = v216[j];
                    v215 = v279 - v56;
                  }
                }
                v279 = v215;
                v218 = v277 - v56;
                if ( v218 > 0 )
                {
                  v219 = &v103[(unsigned int)v108];
                  for ( k = 0LL; k < v218; ++k )
                  {
                    v103[k] = v219[k];
                    v218 = v277 - v56;
                  }
                }
                v277 = v218;
                goto LABEL_64;
              }
              v221 = *(unsigned __int64 *)((char *)v276 + v102);
              v222 = __clz(__rbit64(v106));
              v112 = v222;
              if ( v221 )
              {
                v223 = __clz(__rbit64(v221));
                if ( v222 > v223 )
                  v112 = v223;
                else
                  v112 = v222;
              }
              v113 = 64 - v214;
LABEL_353:
              if ( v113 <= v112 )
                goto LABEL_119;
              v224 = v56 - 1;
              v225 = v108 - 1;
              _mpn_rshift(v278, &v278[v225], v53 - v224, v113);
              v279 -= v56;
              _mpn_rshift(v276, &v276[v225], v277 - v224, v113);
              v226 = v277 - v224;
              if ( !v276[v277 - v224 - 1] )
                v226 = v277 - v56;
              v277 = v226;
            }
          }
LABEL_64:
          StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
          v63 = *(_DWORD *)(a5 + 8);
          v256 = StatusReg;
          v262 = (unsigned __int8)*(_DWORD *)(*(_QWORD *)(StatusReg + 88) + 4LL * v63);
          v64 = *(_DWORD *)a5;
          v260 = *(_DWORD *)(a5 + 4);
          if ( v262 == 101 )
          {
            v274 = v63;
            v69 = v64 + 8LL;
            if ( (v64 & 0x80000000) == 0 )
              goto LABEL_278;
            v266 = (__int64 *)v253;
            v89 = (__int64 *)v254;
            if ( !v273 || v63 != 102 )
            {
              v259 = 0x7FFFFFFF;
              v64 = 6;
              LODWORD(a) = 6;
              v257 = 1;
              goto LABEL_85;
            }
          }
          else
          {
            if ( v262 != 102 )
            {
              v65 = v64 < 0;
              if ( !v64 )
                v64 = 1;
              if ( v65 )
                v66 = 6;
              else
                v66 = v64;
              v259 = v66;
              if ( v273 )
              {
                if ( v275 > 4 )
                  goto LABEL_73;
                v64 = v259;
                v68 = 0;
LABEL_297:
                v208 = *(_WORD *)(a5 + 12);
                v67 = 0;
                v274 = 102;
                v207 = v64;
                v69 = v259 + 5LL;
                if ( (v208 & 8) != 0 )
                  v209 = v64;
                else
                  v209 = 0;
                LODWORD(a) = v209;
LABEL_301:
                if ( v69 < v207 )
                  goto LABEL_293;
              }
              else
              {
                if ( v66 > v275 )
                {
                  v68 = v275 + 1;
                  v64 = v259 - (v275 + 1);
                  goto LABEL_297;
                }
LABEL_73:
                v274 = v63 - 2;
                v67 = 0;
                v68 = 1;
                v64 = v259 - 1;
                v69 = v259 - 1 + 8LL;
                if ( (*(_WORD *)(a5 + 12) & 8LL) != 0 )
                  v70 = v259 - 1;
                else
                  v70 = 0;
                LODWORD(a) = v70;
              }
LABEL_77:
              v71 = _libc_alloca_cutoff(v69 + 2);
              if ( v69 + 2 <= 0x8000 || v71 )
              {
                v88 = v273;
                v266 = &v255;
                v257 = 1;
                goto LABEL_82;
              }
              v266 = (__int64 *)malloc(
                                  v69 + 2,
                                  v72,
                                  v73,
                                  v74,
                                  v75,
                                  v76,
                                  v77,
                                  v78,
                                  v79,
                                  v80,
                                  v81,
                                  v82,
                                  v83,
                                  v84,
                                  v85,
                                  v86);
              if ( v266 )
              {
                v88 = v273;
                v257 = 0;
LABEL_82:
                v89 = (__int64 *)((char *)v266 + 2);
                if ( v88 )
                {
                  if ( v274 != 102 )
                  {
                    if ( v68 != 1 )
                      _libc_assert_fail(
                        (__int64)"p.expsign == 0 || intdig_max == 1",
                        (__int64)"printf_fp.c",
                        0x2FDu,
                        (__int64)"__printf_fp_buffer_1");
LABEL_85:
                    v68 = 1;
                    *(_BYTE *)v89 = hack_digit(&v273);
LABEL_86:
                    v90 = (char *)v89 + (unsigned int)(v68 - 1) + 1;
                    goto LABEL_87;
                  }
LABEL_316:
                  v212 = (unsigned __int64)v266;
                  v68 = 0;
                  v92 = (char *)v266 + 4;
                  *((_BYTE *)v266 + 2) = 48;
                  --v275;
                  *(_BYTE *)(v212 + 3) = v268;
                }
                else
                {
                  v205 = 0LL;
                  if ( v68 > 0 )
                  {
                    do
                      *((_BYTE *)v89 + v205++) = hack_digit(&v273);
                    while ( v68 > (int)v205 );
                    goto LABEL_86;
                  }
                  v90 = (char *)v266 + 2;
                  v68 = 0;
LABEL_87:
                  v91 = (*(_WORD *)(a5 + 12) & 8) == 0 && SLODWORD(a) <= 0;
                  if ( !v91 || v64 > 0 && (v277 > 1 || *v276) )
                  {
                    v67 = 1;
                    *v90 = v268;
                    v92 = v90 + 1;
                  }
                  else
                  {
                    v92 = v90;
                    v67 = 1;
                  }
                }
                v93 = LODWORD(a);
                v94 = 0;
                LODWORD(v265) = 0;
                while ( v94 < v93 || v94 < v64 && (v277 > 1 || *v276) )
                {
                  v95 = (unsigned __int8)hack_digit(&v273);
                  *v92++ = v95;
                  v27 = v95 == 48;
                  v96 = v67 ^ 1;
                  v97 = v27;
                  ++v94;
                  v67 = 1;
                  if ( (v97 & v96) != 0 )
                  {
                    ++v64;
                    v98 = LODWORD(v265);
                    v67 = 0;
                    if ( SLODWORD(a) > 0 )
                      v98 = LODWORD(v265) + 1;
                    LODWORD(v265) = v98;
                    if ( SLODWORD(a) > 0 )
                      v93 = v98 + LODWORD(a);
                  }
                }
                v143 = (unsigned __int8)*(v92 - 1);
                if ( v268 == v143 )
                  LOBYTE(v143) = *(v92 - 2);
                v258 = v93;
                v144 = (unsigned __int8)hack_digit(&v273);
                v154 = v144 == 48 || v144 == 53;
                v155 = v258;
                v156 = !v154;
                if ( v154 )
                {
                  v157 = v277;
                  if ( v277 != 1 || *v276 )
                  {
                    if ( v279 )
                    {
LABEL_179:
                      v156 = 1LL;
                    }
                    else
                    {
                      while ( v157 )
                      {
                        if ( v276[--v157] )
                          goto LABEL_179;
                      }
                    }
                  }
                }
                v158 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 4, 0)) & 0xC00000;
                v159 = v144 > 0x34;
                v160 = v269;
                if ( (_DWORD)v158 == 0x800000 )
                {
                  if ( v269 )
                    goto LABEL_235;
                }
                else if ( (unsigned int)v158 > 0x800000 )
                {
                  if ( (_DWORD)v158 != 12582912 )
                    abort();
                }
                else if ( (_DWORD)v158 )
                {
                  if ( v269 )
                    goto LABEL_184;
LABEL_235:
                  if ( v144 > 0x34 || (_DWORD)v156 != 0 )
                  {
LABEL_239:
                    v192 = v92;
                    if ( v94 )
                    {
                      v192 = v92 - 1;
                      v193 = (unsigned __int8)*(v92 - 1);
                      v159 = (unsigned __int64)(v92 - 1);
                      if ( v193 != 57 || v268 == 57 )
                      {
                        v198 = 0;
                      }
                      else
                      {
                        do
                        {
                          v195 = (int)v192;
                          *v192 = 48;
                          v196 = (unsigned __int8)*--v192;
                          v193 = v196;
                        }
                        while ( v196 == 57 && v268 != 57 );
                        v159 = (unsigned int)v92;
                        v198 = (_DWORD)v92 - v195;
                      }
                      v145 = LODWORD(a);
                      v199 = LODWORD(v265) && v198 == LODWORD(a);
                      v160 = v199;
                      v200 = LODWORD(v265) - v160;
                      if ( v268 == v193 )
                      {
                        v201 = (unsigned __int8)*v192;
                        if ( v262 == 103 )
                        {
                          v160 = v274;
                          if ( v274 == 102 )
                          {
                            v160 = *(unsigned __int16 *)(a5 + 12);
                            if ( (v160 & 8) != 0 )
                            {
                              v160 = (__int64)v266 + 3;
                              if ( v192 == (char *)v266 + 3 )
                              {
                                v160 = *((unsigned __int8 *)v266 + 2) == 48;
                                v200 -= v160;
                              }
                            }
                          }
                        }
                      }
                      else
                      {
                        v201 = (unsigned __int8)(v193 + 1);
                        *v192 = v201;
                      }
                      v155 = (unsigned int)(v200 + LODWORD(a));
                      if ( v268 != v201 )
                      {
                        v161 = v274;
                        if ( v94 <= (int)v155 )
                          goto LABEL_192;
                        do
                        {
LABEL_188:
                          if ( *(v92 - 1) != 48 )
                            break;
                          --v94;
                          --v92;
                        }
                        while ( v94 > (int)v155 );
LABEL_189:
                        if ( !v94 && (*(_WORD *)(a5 + 12) & 8) == 0 )
                          v92 -= (unsigned __int8)*(v92 - 1) == v268;
LABEL_192:
                        if ( v161 != 102 )
                        {
                          if ( v273 && (v262 == 103 ? (v240 = v275 == 4) : (v240 = 0), v240) )
                          {
                            if ( v92 < (_BYTE *)v89 + 1 )
                              _libc_assert_fail(
                                (__int64)"wcp >= wstartp + 1",
                                (__int64)"printf_fp.c",
                                0x3AEu,
                                (__int64)"__printf_fp_buffer_1");
                            if ( *(_BYTE *)v89 != 49 )
                              _libc_assert_fail(
                                (__int64)"wstartp[0] == '1'",
                                (__int64)"printf_fp.c",
                                0x3AFu,
                                (__int64)"__printf_fp_buffer_1");
                            qmemcpy(v89, "0.0001", 6);
                            *((_BYTE *)v89 + 1) = v268;
                            if ( v92 >= (_BYTE *)v89 + 2 )
                            {
                              v92 += 4;
                              memset();
                            }
                            else
                            {
                              v92 += 5;
                            }
                          }
                          else
                          {
                            *v92 = v161;
                            if ( v273 )
                              v162 = 45;
                            else
                              v162 = 43;
                            v92[1] = v162;
                            v163 = v275;
                            if ( v275 <= 9 )
                            {
                              v92[2] = 48;
                              v155 = (unsigned __int64)(v92 + 3);
                              LOBYTE(v163) = v275;
                            }
                            else
                            {
                              v155 = (unsigned __int64)(v92 + 2);
                              for ( m = 10; m <= v275; m *= 10 )
                                ;
                              v145 = 3435973837LL;
                              do
                              {
                                v165 = m;
                                m /= 0xAu;
                                *(_BYTE *)v155++ = v163 / m + 48;
                                v160 = (unsigned int)v275;
                                v163 = v275 % m;
                                v275 %= m;
                              }
                              while ( v165 > 109 );
                            }
                            *(_BYTE *)v155 = v163 + 48;
                            v92 = (_BYTE *)(v155 + 1);
                          }
                        }
                        v166 = *(_WORD *)(a5 + 12);
                        if ( v267 && (v166 & 0x80) != 0 )
                        {
                          _grouping_iterator_init((__int64)&v271, v263, v261, v68);
                          v166 = *(_WORD *)(a5 + 12);
                          v167 = v272;
                        }
                        else
                        {
                          v167 = 0;
                          v272 = 0;
                        }
                        v168 = v92 - (_BYTE *)v89;
                        if ( v269 )
                        {
                          v169 = v260 - 1 - v168 - v167;
                          if ( (v166 & 0x20) != 0 )
                            goto LABEL_210;
                          v170 = *(unsigned int *)(a5 + 16);
                          if ( (_DWORD)v170 == 48 || v169 <= 0 )
                            goto LABEL_210;
LABEL_265:
                          _printf_buffer_pad_1(
                            a1,
                            v170,
                            (unsigned int)v169,
                            (void *)v160,
                            v145,
                            (_DWORD *)v155,
                            (void *)v159,
                            v156,
                            v146,
                            v147,
                            v148,
                            v149,
                            v150,
                            v151,
                            v152,
                            v153);
                          if ( !v269 )
                          {
                            v166 = *(_WORD *)(a5 + 12);
                            goto LABEL_267;
                          }
LABEL_210:
                          v171 = *(_BYTE **)(a1 + 8);
                          if ( v171 == *(_BYTE **)(a1 + 16) )
                          {
                            _printf_buffer_putc_1(a1, 45);
                          }
                          else
                          {
                            *(_QWORD *)(a1 + 8) = v171 + 1;
                            *v171 = 45;
                          }
                          v166 = *(_WORD *)(a5 + 12);
LABEL_213:
                          if ( (v166 & 0x20) == 0 && *(_DWORD *)(a5 + 16) == 48 && v169 > 0 )
                            _printf_buffer_pad_1(
                              a1,
                              48LL,
                              (unsigned int)v169,
                              (void *)v160,
                              v145,
                              (_DWORD *)v155,
                              (void *)v159,
                              v156,
                              v146,
                              v147,
                              v148,
                              v149,
                              v150,
                              v151,
                              v152,
                              v153);
LABEL_219:
                          if ( !v272 || !v68 )
                          {
LABEL_229:
                            _printf_buffer_write(a1, (__int64)v89, v168);
                            if ( (*(_WORD *)(a5 + 12) & 0x20) != 0 && v169 > 0 )
                              _printf_buffer_pad_1(
                                a1,
                                *(unsigned __int8 *)(a5 + 16),
                                (unsigned int)v169,
                                v178,
                                v179,
                                v180,
                                v181,
                                v182,
                                v183,
                                v184,
                                v185,
                                v186,
                                v187,
                                v188,
                                v189,
                                v190);
                            if ( !v257 )
                              free((unsigned __int64)v266, v183, v184, v185, v186, v187, v188, v189, v190);
                            return;
                          }
                          v173 = (char *)v89 + v68;
                          v174 = (char *)v89;
                          while ( 2 )
                          {
                            while ( 2 )
                            {
                              if ( (_grouping_iterator_next((int *)&v271) & 1) != 0 )
                              {
                                v177 = *(_BYTE **)(a1 + 8);
                                if ( v177 != *(_BYTE **)(a1 + 16) )
                                {
                                  *(_QWORD *)(a1 + 8) = v177 + 1;
                                  *v177 = v267;
                                  v175 = *(char **)(a1 + 8);
                                  v176 = *v174;
                                  if ( v175 != *(char **)(a1 + 16) )
                                  {
LABEL_223:
                                    *(_QWORD *)(a1 + 8) = v175 + 1;
                                    ++v174;
                                    *v175 = v176;
                                    if ( v174 == v173 )
                                      goto LABEL_228;
                                    continue;
                                  }
                                  goto LABEL_227;
                                }
                                _printf_buffer_putc_1(a1, v267);
                              }
                              break;
                            }
                            v175 = *(char **)(a1 + 8);
                            v176 = *v174;
                            if ( v175 != *(char **)(a1 + 16) )
                              goto LABEL_223;
LABEL_227:
                            ++v174;
                            _printf_buffer_putc_1(a1, v176);
                            if ( v174 == v173 )
                            {
LABEL_228:
                              v89 = (__int64 *)((char *)v89 + (unsigned int)(v68 - 1) + 1);
                              v168 = v92 - (_BYTE *)v89;
                              goto LABEL_229;
                            }
                            continue;
                          }
                        }
                        if ( (v166 & 0x50) != 0 )
                        {
                          v169 = v260 - 1 - v168 - v167;
                          if ( (v166 & 0x20) == 0 )
                            goto LABEL_263;
                        }
                        else
                        {
                          v169 = v260 - v168 - v167;
                          if ( (v166 & 0x20) != 0 )
                            goto LABEL_219;
LABEL_263:
                          v170 = *(unsigned int *)(a5 + 16);
                          if ( (_DWORD)v170 != 48 && v169 > 0 )
                            goto LABEL_265;
                        }
LABEL_267:
                        if ( (v166 & 0x40) != 0 )
                        {
                          v210 = *(_BYTE **)(a1 + 8);
                          if ( v210 == *(_BYTE **)(a1 + 16) )
                          {
                            _printf_buffer_putc_1(a1, 43);
                          }
                          else
                          {
                            *(_QWORD *)(a1 + 8) = v210 + 1;
                            *v210 = 43;
                          }
                          v166 = *(_WORD *)(a5 + 12);
                        }
                        else if ( (v166 & 0x10) != 0 )
                        {
                          v202 = *(_BYTE **)(a1 + 8);
                          if ( v202 == *(_BYTE **)(a1 + 16) )
                          {
                            _printf_buffer_putc_1(a1, 32);
                          }
                          else
                          {
                            *(_QWORD *)(a1 + 8) = v202 + 1;
                            *v202 = 32;
                          }
                          v166 = *(_WORD *)(a5 + 12);
                        }
                        goto LABEL_213;
                      }
                    }
                    v206 = (__int64 *)&v192[-((unsigned __int8)*(v192 - 1) == v268) - 1];
                    if ( v206 < v89 )
                      goto LABEL_324;
                    v160 = 48LL;
                    v159 = (unsigned __int64)v266 + 1;
                    do
                    {
                      if ( *(_BYTE *)v206 != 57 )
                        break;
                      *(_BYTE *)v206 = 48;
                      v206 = (__int64 *)((char *)v206 - 1);
                    }
                    while ( v206 != (__int64 *)v159 );
                    if ( v206 < v89 )
                    {
LABEL_324:
                      if ( v274 == 102 )
                      {
                        v227 = v266;
                        if ( v68 == v259 )
                        {
                          *((_BYTE *)v266 + 1) = v268;
                          *(_BYTE *)v227 = 49;
                          if ( (*(_WORD *)(a5 + 12) & 8LL) == 0 && v94 == 0 )
                          {
                            v94 = v259;
                          }
                          else
                          {
                            v94 += 1 + v259;
                            *((_BYTE *)v227 + v259 + 2) = 48;
                          }
                          v68 = 1;
                          v251 = *(int *)(a5 + 8);
                          ++v275;
                          v89 = v266;
                          if ( (*(_WORD *)(*(_QWORD *)(v256 + 72) + 2 * v251) & 0x100) != 0 )
                            v161 = 69;
                          else
                            v161 = 101;
                          v274 = v161;
                        }
                        else
                        {
                          *((_BYTE *)v266 + 1) = 49;
                          v89 = (__int64 *)((char *)v227 + 1);
                          ++v68;
                          v161 = v274;
                        }
                      }
                      else
                      {
                        *((_BYTE *)v266 + 2) = 49;
                        if ( v273 )
                          v213 = -1;
                        else
                          v213 = 1;
                        v275 += v213;
                        v161 = v274;
                        if ( !v275 )
                          v273 = 0;
                      }
                      v160 = (unsigned int)(v68 + v94);
                      v159 = (unsigned __int64)&v92[-((int)v160 - v259)];
                      if ( (int)v160 > v259 )
                      {
                        v92 -= (int)v160 - v259;
                        v94 = v259 - v68;
                      }
                    }
                    else
                    {
                      ++*(_BYTE *)v206;
                      v161 = v274;
                    }
LABEL_185:
                    if ( v94 > (int)v155 )
                      goto LABEL_188;
                    goto LABEL_189;
                  }
                }
                else if ( v144 > 0x34 )
                {
                  v156 = (unsigned int)v156 | v143 & 1;
                  if ( (_DWORD)v156 )
                    goto LABEL_239;
                }
LABEL_184:
                v161 = v274;
                goto LABEL_185;
              }
LABEL_294:
              *(_DWORD *)(a1 + 32) = 0;
              return;
            }
            v274 = 102;
            if ( (v64 & 0x80000000) == 0 )
            {
              v207 = v64;
              if ( !v273 )
              {
LABEL_292:
                v69 = v275 + 2LL + v207;
                if ( v69 <= 0xFFFFFFFFFFFFFFFCLL )
                {
                  v68 = v275 + 1;
                  v67 = 1;
                  v259 = 0x7FFFFFFF;
                  LODWORD(a) = v64;
                  goto LABEL_301;
                }
LABEL_293:
                *(_DWORD *)(v256 + 40) = 34;
                goto LABEL_294;
              }
              v69 = v64 + 2LL;
LABEL_278:
              v67 = 1;
              v68 = 1;
              v259 = 0x7FFFFFFF;
              LODWORD(a) = v64;
              goto LABEL_77;
            }
            if ( !v273 )
            {
              v207 = 6LL;
              v64 = 6;
              goto LABEL_292;
            }
            v89 = (__int64 *)v254;
            v266 = (__int64 *)v253;
          }
          v259 = 0x7FFFFFFF;
          v64 = 6;
          v67 = 1;
          v257 = 1;
          LODWORD(a) = 6;
          goto LABEL_316;
        }
LABEL_59:
        v47 = v275;
        --v56;
      }
    }
    if ( (v275 & 0x80000000) == 0 )
    {
      if ( v275 + v46 > 63 )
        _libc_assert_fail(
          (__int64)"0 <= p.exponent && p.exponent < 3 && p.exponent + to_shift < BITS_PER_MP_LIMB",
          (__int64)"printf_fp.c",
          0x28Fu,
          (__int64)"__printf_fp_buffer_1");
      v60 = _mpn_lshift((__int64)&v255, (__int64)v270, v45, (unsigned __int8)v275 + (unsigned __int8)v46);
      v61 = v277++;
      v276[v61] = v60;
      v275 = 0;
      goto LABEL_64;
    }
    v118 = _mpn_lshift((__int64)&v255, (__int64)v270, v45, v46);
    v119 = (__int64 *)v276;
    v120 = v277++;
    v276[v120] = v118;
    if ( v118 != 1 && (v119[v277 - 2] || *v119) )
      _libc_assert_fail(
        (__int64)"cy == 1 || (p.frac[p.fracsize - 2] == 0 && p.frac[0] == 0)",
        (__int64)"printf_fp.c",
        0x1F5u,
        (__int64)"__printf_fp_buffer_1");
    v273 = 1;
    v122 = -v275;
    v275 = v122;
    if ( v122 >= 13604 )
    {
      v125 = 0;
      v124 = &qword_46B1D0;
      v123 = 12;
      goto LABEL_140;
    }
    v123 = 12;
    v124 = &qword_46B1D0;
    v125 = 0;
    while ( 1 )
    {
      if ( v122 <= 0 )
        goto LABEL_163;
      while ( 1 )
      {
        v136 = *((_DWORD *)v124 - 1);
        v124 -= 3;
        --v123;
        if ( v136 <= v122 )
          break;
        if ( v123 == 1 )
          goto LABEL_152;
      }
      v119 = (__int64 *)v276;
LABEL_140:
      v126 = v124[1] - 1;
      if ( v277 >= v126 )
        v127 = _mpn_mul((__int64)v280, (__int64)v119, v277, &_tens[*v124 + 1], v124[1] - 1);
      else
        v127 = _mpn_mul((__int64)v280, (__int64)&_tens[*v124 + 1], v126, v119, v277);
      v128 = v280;
      if ( v127 )
        v129 = v277 + v124[1] + 1;
      else
        v129 = v277 + v124[1];
      v130 = v129 - 2;
      v281 = v130;
      v131 = &v280[v130 - 1];
      v132 = __clz(*v131);
      v133 = v132;
      v134 = ~(_DWORD)v132 + (((_DWORD)v130 - (_DWORD)v277 + 1) << 6);
      if ( v134 > *((_DWORD *)v124 + 4) )
        _libc_assert_fail(
          (__int64)"incr <= powers->p_expo",
          (__int64)"printf_fp.c",
          0x217u,
          (__int64)"__printf_fp_buffer_1");
      v135 = v275;
      v122 = v275;
      if ( v134 == v275 + 3 )
      {
        if ( (int)v132 > 60 )
        {
          *(_QWORD *)&v265 = v132;
          v271 = xmmword_45B7C0;
          _mpn_lshift((__int64)&v271, (__int64)&v271, 2LL, 64 - v132);
          v135 = v275;
          LODWORD(v132) = LODWORD(v265);
          v128 = v280;
          v130 = v281;
          v122 = v275;
          if ( v134 <= v275 + 2 )
          {
LABEL_377:
            v229 = v135 - v134;
            v275 = v229;
            v125 |= 1 << v123;
            if ( v229 < 0 )
LABEL_369:
              v133 = v132 - v229;
            if ( *v128 )
            {
              if ( v133 == 63 )
              {
                v241 = 0LL;
                v233 = 0;
                goto LABEL_408;
              }
              v237 = 63 - v133;
              v238 = 0LL;
              if ( 63 - v133 > (int)__clz(__rbit64(*v128)) )
              {
                v247 = _mpn_lshift((__int64)v276, (__int64)v128, v130, (unsigned __int8)v133 + 1);
                v122 = v275;
                v277 = v281 + 1;
                v276[v281] = v247;
                goto LABEL_148;
              }
            }
            else
            {
              v230 = v128 + 1;
              v231 = 1LL;
              do
              {
                v232 = v230;
                v233 = v231;
                v235 = *v230++;
                v234 = v235;
                ++v231;
              }
              while ( !v235 );
              if ( v133 == 63 )
              {
                v241 = v233;
                v130 -= v233;
LABEL_408:
                if ( v130 > 0 )
                {
                  v242 = v276;
                  v243 = &v128[v233];
                  v244 = 0LL;
                  do
                  {
                    v242[v244] = v243[v244];
                    ++v244;
                    v130 = v281 - v241;
                  }
                  while ( v244 < v281 - v241 );
                }
                v122 = v275;
                v277 = v130;
                goto LABEL_148;
              }
              v236 = __clz(__rbit64(v234));
              v237 = 63 - v133;
              if ( v236 < 63 - v133 )
              {
                v238 = v233 - 1;
                v239 = &v128[v233 - 1];
                v130 -= (int)v238;
LABEL_376:
                _mpn_rshift(v276, v239, v130, v237);
                v122 = v275;
                v277 = v281 - v238;
                goto LABEL_148;
              }
              v238 = v233;
              v128 = v232;
              v130 -= v233;
            }
            v239 = v128;
            goto LABEL_376;
          }
          if ( v134 != v275 + 3 )
            goto LABEL_148;
          v128 = v280;
          v130 = v281;
          v228 = *((_QWORD *)&v271 + 1);
          v131 = &v280[v281 - 1];
        }
        else
        {
          v228 = 10LL << (60 - (unsigned __int8)v132);
          *(_QWORD *)&v271 = 0LL;
          *((_QWORD *)&v271 + 1) = v228;
          if ( v134 <= v275 + 2 )
            goto LABEL_377;
        }
        if ( *v131 < v228 || *v131 == v228 && v128[v130 - 2] < (unsigned __int64)v271 )
        {
          v229 = v135 - v134;
          v125 |= 1 << v123;
          v275 = v229;
          goto LABEL_369;
        }
        v122 = v135;
      }
      else if ( v134 <= v275 + 2 )
      {
        goto LABEL_377;
      }
LABEL_148:
      if ( v123 == 1 )
      {
LABEL_152:
        if ( v122 > 0 )
        {
          v137 = _mpn_mul_1((__int64)v280, (__int64)v276, v277, 10LL);
          v281 = v277;
          if ( v137 && v280[v277 - 1] > 0x13 )
            _libc_assert_fail(
              (__int64)"cy == 0 || p.tmp[p.tmpsize - 1] < 20",
              (__int64)"printf_fp.c",
              0x277u,
              (__int64)"__printf_fp_buffer_1");
          v138 = __clz(__rbit64(*v280));
          if ( v275 > 4 )
            v139 = 4;
          else
            v139 = v275;
          if ( v138 >= v139 )
          {
            _mpn_rshift(v276, v280, v277, v139);
            v141 = v276;
          }
          else
          {
            v140 = _mpn_lshift((__int64)v276, (__int64)v280, v277, 64 - (unsigned __int8)v139);
            v141 = v276;
            if ( v140 )
            {
              v142 = v281++;
              v276[v142] = v140;
            }
          }
          v277 = v281;
          if ( v141[v281 - 1] > 9 )
            _libc_assert_fail(
              (__int64)"p.frac[p.fracsize - 1] < 10",
              (__int64)"printf_fp.c",
              0x285u,
              (__int64)"__printf_fp_buffer_1");
          v125 |= 1u;
        }
LABEL_163:
        v275 = v125;
        goto LABEL_64;
      }
    }
  }
  v21 = *(_QWORD *)&v20 >> 63;
LABEL_7:
  v22 = (void *)*(unsigned __int16 *)(*(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 72)
                                    + 2LL * *(int *)(a5 + 8));
  v269 = v21;
  if ( ((unsigned __int16)v22 & 0x100) != 0 )
    v23 = "INF";
  else
    v23 = "inf";
  v24 = *(_DWORD *)(a5 + 4);
  if ( (_DWORD)v21 )
  {
    v25 = v24 - 4;
    v26 = v24 - 4 > 0;
    v27 = v24 - 4 <= 0 || (v18 & 0x20) != 0LL;
    if ( v27 )
      goto LABEL_16;
  }
  else if ( (v18 & 0x50) != 0 )
  {
    v25 = v24 - 4;
    v26 = v24 - 4 > 0;
    if ( v24 - 4 <= 0 || (v18 & 0x20) != 0LL )
    {
      if ( (v18 & 0x40) != 0 )
        goto LABEL_105;
LABEL_31:
      if ( (v18 & 0x10) != 0 )
      {
        v211 = *(_BYTE **)(a1 + 8);
        if ( v211 == *(_BYTE **)(a1 + 16) )
        {
          _printf_buffer_putc_1(a1, 32);
        }
        else
        {
          *(_QWORD *)(a1 + 8) = v211 + 1;
          *v211 = 32;
        }
      }
      goto LABEL_32;
    }
  }
  else
  {
    v25 = v24 - 3;
    v26 = v24 - 3 > 0;
    if ( v24 - 3 <= 0 || (v18 & 0x20) != 0LL )
      goto LABEL_32;
  }
  _printf_buffer_pad_1(a1, 32LL, v25, v22, a5, a6, a7, a8, v20, a10, a11, a12, a13, a14, a15, a16);
  v26 = 1;
  if ( !v269 )
  {
    v18 = *(_WORD *)(a5 + 12);
    if ( (v18 & 0x40) != 0 )
    {
LABEL_105:
      v99 = *(_BYTE **)(a1 + 8);
      if ( v99 == *(_BYTE **)(a1 + 16) )
      {
        _printf_buffer_putc_1(a1, 43);
      }
      else
      {
        *(_QWORD *)(a1 + 8) = v99 + 1;
        *v99 = 43;
      }
      goto LABEL_32;
    }
    goto LABEL_31;
  }
LABEL_16:
  v28 = *(_BYTE **)(a1 + 8);
  if ( v28 != *(_BYTE **)(a1 + 16) )
  {
    *(_QWORD *)(a1 + 8) = v28 + 1;
    *v28 = 45;
    _printf_buffer_write(a1, (__int64)v23, 3uLL);
    if ( (*(_WORD *)(a5 + 12) & 0x20LL) != 0 && v26 )
      goto LABEL_21;
    return;
  }
  _printf_buffer_putc_1(a1, 45);
LABEL_32:
  _printf_buffer_write(a1, (__int64)v23, 3uLL);
  if ( (*(_WORD *)(a5 + 12) & 0x20LL) != 0 && v26 )
LABEL_21:
    _printf_buffer_pad_1(a1, 32LL, v25, v29, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41);
}
// 4305C8: variable 'v29' is possibly undefined
// 4305C8: variable 'v30' is possibly undefined
// 4305C8: variable 'v31' is possibly undefined
// 4305C8: variable 'v32' is possibly undefined
// 4305C8: variable 'v33' is possibly undefined
// 4305C8: variable 'v34' is possibly undefined
// 4305C8: variable 'v35' is possibly undefined
// 4305C8: variable 'v36' is possibly undefined
// 4305C8: variable 'v37' is possibly undefined
// 4305C8: variable 'v38' is possibly undefined
// 4305C8: variable 'v39' is possibly undefined
// 4305C8: variable 'v40' is possibly undefined
// 4305C8: variable 'v41' is possibly undefined
// 4319C0: variable 'v160' is possibly undefined
// 4319C0: variable 'v145' is possibly undefined
// 4319C0: variable 'v155' is possibly undefined
// 4319C0: variable 'v159' is possibly undefined
// 4319C0: variable 'v156' is possibly undefined
// 4319C0: variable 'v146' is possibly undefined
// 4319C0: variable 'v147' is possibly undefined
// 4319C0: variable 'v148' is possibly undefined
// 4319C0: variable 'v149' is possibly undefined
// 4319C0: variable 'v150' is possibly undefined
// 4319C0: variable 'v151' is possibly undefined
// 4319C0: variable 'v152' is possibly undefined
// 4319C0: variable 'v153' is possibly undefined
// 4310BC: variable 'v178' is possibly undefined
// 4310BC: variable 'v179' is possibly undefined
// 4310BC: variable 'v180' is possibly undefined
// 4310BC: variable 'v181' is possibly undefined
// 4310BC: variable 'v182' is possibly undefined
// 4310BC: variable 'v183' is possibly undefined
// 4310BC: variable 'v184' is possibly undefined
// 4310BC: variable 'v185' is possibly undefined
// 4310BC: variable 'v186' is possibly undefined
// 4310BC: variable 'v187' is possibly undefined
// 4310BC: variable 'v188' is possibly undefined
// 4310BC: variable 'v189' is possibly undefined
// 4310BC: variable 'v190' is possibly undefined
// 431C34: variable 'v72' is possibly undefined
// 431C34: variable 'v73' is possibly undefined
// 431C34: variable 'v74' is possibly undefined
// 431C34: variable 'v75' is possibly undefined
// 431C34: variable 'v76' is possibly undefined
// 431C34: variable 'v77' is possibly undefined
// 431C34: variable 'v78' is possibly undefined
// 431C34: variable 'v79' is possibly undefined
// 431C34: variable 'v80' is possibly undefined
// 431C34: variable 'v81' is possibly undefined
// 431C34: variable 'v82' is possibly undefined
// 431C34: variable 'v83' is possibly undefined
// 431C34: variable 'v84' is possibly undefined
// 431C34: variable 'v85' is possibly undefined
// 431C34: variable 'v86' is possibly undefined
// 45B7B0: using guessed type __int128 xmmword_45B7B0;
// 45B7C0: using guessed type __int128 xmmword_45B7C0;
// 46B1D0: using guessed type __int64 qword_46B1D0;
// 46B220: using guessed type __int64 _tens[1725];

//----- (0000000000431D80) ----------------------------------------------------
__int64 __fastcall _printf_buffer_flush_fp(__int64 a1)
{
  __int64 v2; // x21
  char *v3; // x20
  int v4; // w3
  __int64 v5; // x0
  __int64 v6; // x1
  unsigned __int64 v7; // x2
  __int64 result; // x0
  unsigned __int64 v9; // x0
  _BYTE *v10; // x1

  v2 = a1 + 80;
  v3 = (char *)(a1 + 80);
  if ( (unsigned __int64)(a1 + 80) < *(_QWORD *)(a1 + 8) )
  {
    do
    {
      v4 = (unsigned __int8)*v3;
      if ( v4 == 44 )
      {
        v6 = *(_QWORD *)(a1 + 40);
        v7 = *(unsigned __int8 *)(a1 + 57);
      }
      else if ( v4 == 46 )
      {
        v6 = *(_QWORD *)(a1 + 48);
        v7 = *(unsigned __int8 *)(a1 + 56);
      }
      else
      {
        v5 = *(_QWORD *)(a1 + 72);
        if ( !v5 || (unsigned __int8)(v4 - 48) > 9u )
        {
LABEL_13:
          v9 = *(_QWORD *)(a1 + 64);
          v10 = *(_BYTE **)(v9 + 8);
          if ( v10 == *(_BYTE **)(v9 + 16) )
          {
            _printf_buffer_putc_1(v9, *v3);
          }
          else
          {
            *(_QWORD *)(v9 + 8) = v10 + 1;
            *v10 = v4;
          }
          goto LABEL_9;
        }
        v6 = *(_QWORD *)(v5 + 8LL * (v4 - 7) + 56);
        v7 = *(unsigned __int8 *)(*(_QWORD *)(v5 + 32) + v4 - 48 + 9LL);
      }
      if ( !v6 )
        goto LABEL_13;
      _printf_buffer_write(*(_QWORD *)(a1 + 64), v6, v7);
LABEL_9:
      ++v3;
    }
    while ( *(_QWORD *)(a1 + 8) > (unsigned __int64)v3 );
  }
  result = *(unsigned int *)(*(_QWORD *)(a1 + 64) + 32LL);
  if ( (_DWORD)result )
    *(_QWORD *)(a1 + 8) = v2;
  else
    *(_DWORD *)(a1 + 32) = 0;
  return result;
}

//----- (0000000000431E80) ----------------------------------------------------
void __fastcall _printf_fp_l_buffer(
        unsigned __int64 a1,
        __int64 *a2,
        __int64 a3,
        double **a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  __int16 v12; // w19
  __int64 v13; // x0
  unsigned __int8 *v14; // x20
  unsigned __int8 *v15; // x23
  unsigned __int8 v16; // w0
  void *v17; // x6
  __int64 v18; // x7
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7
  int v27; // w19
  bool v28; // cc
  void *v29; // x6
  __int64 v30; // x7
  double v31; // d0
  double v32; // d1
  double v33; // d2
  double v34; // d3
  double v35; // d4
  double v36; // d5
  double v37; // d6
  double v38; // d7
  double *v39; // x5
  __int64 v40; // x0
  __int64 v41; // x0
  double *v43; // [xsp+48h] [xbp+48h]
  double *v44; // [xsp+48h] [xbp+48h]
  _QWORD v45[4]; // [xsp+50h] [xbp+50h] BYREF
  int v46; // [xsp+70h] [xbp+70h]
  unsigned __int8 *v47; // [xsp+78h] [xbp+78h]
  unsigned __int8 *v48; // [xsp+80h] [xbp+80h]
  unsigned __int8 v49; // [xsp+88h] [xbp+88h]
  unsigned __int8 v50; // [xsp+89h] [xbp+89h]
  unsigned __int64 v51; // [xsp+90h] [xbp+90h]
  __int64 v52; // [xsp+98h] [xbp+98h]
  _BYTE v53[64]; // [xsp+A0h] [xbp+A0h] BYREF

  v12 = *(_WORD *)(a3 + 12);
  if ( (v12 & 0x100) != 0 )
  {
    v13 = a2[4];
    v14 = *(unsigned __int8 **)(v13 + 72);
    v15 = *(unsigned __int8 **)(v13 + 80);
    v47 = v15;
    v48 = v14;
    if ( !*v14 )
    {
      v14 = *(unsigned __int8 **)(a2[1] + 56);
      v48 = v14;
    }
  }
  else
  {
    v41 = a2[1];
    v14 = *(unsigned __int8 **)(v41 + 56);
    v15 = *(unsigned __int8 **)(v41 + 64);
    v47 = v15;
    v48 = v14;
  }
  v16 = (unsigned __int8)strlen();
  v50 = v16;
  v27 = v12 & 0x800;
  if ( v14[1] )
    v28 = 1;
  else
    v28 = v16 > 1u;
  if ( v28 )
  {
    v43 = *a4;
    v49 = (unsigned __int8)strlen();
    v39 = v43;
    v40 = 0LL;
    if ( !v27 )
      goto LABEL_10;
  }
  else
  {
    if ( !v27 )
    {
      _printf_fp_buffer_1_isra_0(a1, (__int64)a2, *v15, *v14, a3, *a4, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26);
      return;
    }
    v44 = *a4;
    v49 = (unsigned __int8)strlen();
    v39 = v44;
  }
  v40 = *a2;
LABEL_10:
  v51 = a1;
  v52 = v40;
  v45[2] = &a9;
  v45[3] = 0LL;
  v45[0] = v53;
  v45[1] = v53;
  v46 = 8;
  _printf_fp_buffer_1_isra_0(
    (unsigned __int64)v45,
    (__int64)a2,
    0x2Cu,
    0x2Eu,
    a3,
    v39,
    v29,
    v30,
    v31,
    v32,
    v33,
    v34,
    v35,
    v36,
    v37,
    v38);
  if ( v46 )
    _printf_buffer_flush_fp((__int64)v45);
  else
    *(_DWORD *)(v51 + 32) = 0;
}
// 431F38: variable 'v29' is possibly undefined
// 431F38: variable 'v30' is possibly undefined
// 431F38: variable 'v31' is possibly undefined
// 431F38: variable 'v32' is possibly undefined
// 431F38: variable 'v33' is possibly undefined
// 431F38: variable 'v34' is possibly undefined
// 431F38: variable 'v35' is possibly undefined
// 431F38: variable 'v36' is possibly undefined
// 431F38: variable 'v37' is possibly undefined
// 431F38: variable 'v38' is possibly undefined
// 431FD0: variable 'v17' is possibly undefined
// 431FD0: variable 'v18' is possibly undefined
// 431FD0: variable 'v19' is possibly undefined
// 431FD0: variable 'v20' is possibly undefined
// 431FD0: variable 'v21' is possibly undefined
// 431FD0: variable 'v22' is possibly undefined
// 431FD0: variable 'v23' is possibly undefined
// 431FD0: variable 'v24' is possibly undefined
// 431FD0: variable 'v25' is possibly undefined
// 431FD0: variable 'v26' is possibly undefined

//----- (0000000000431FE0) ----------------------------------------------------
__int64 __fastcall _printf_buffer_flush_fp_to_wide(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        _DWORD *a14,
        void *a15)
{
  unsigned __int64 v16; // x4
  unsigned __int8 *v17; // x21
  unsigned __int64 v18; // x0
  unsigned __int8 *v19; // x19
  __int64 v20; // x2
  int v21; // w1
  int *v22; // x2
  unsigned __int64 v23; // x3
  __int64 result; // x0

  v16 = *(_QWORD *)(a1 + 8);
  v17 = (unsigned __int8 *)(a1 + 64);
  if ( a1 + 64 < v16 )
  {
    v18 = *(_QWORD *)(a1 + 48);
    v19 = v17;
    while ( 1 )
    {
      v21 = *v19;
      if ( v21 != 44 )
        break;
      v21 = *(_DWORD *)(a1 + 40);
      if ( !v21 )
        goto LABEL_9;
      v22 = *(int **)(v18 + 8);
      v23 = *(_QWORD *)(v18 + 16);
      if ( v22 == (int *)v23 )
      {
LABEL_13:
        _wprintf_buffer_putc_1(v18, v21, (__int64)v22, v23, v16, a14, a15, a2, a3, a4, a5, a6, a7, a8, a9);
        ++v19;
        v16 = *(_QWORD *)(a1 + 8);
        v18 = *(_QWORD *)(a1 + 48);
        if ( v16 <= (unsigned __int64)v19 )
          goto LABEL_14;
      }
      else
      {
LABEL_8:
        *(_QWORD *)(v18 + 8) = v22 + 1;
        *v22 = v21;
LABEL_9:
        if ( v16 <= (unsigned __int64)++v19 )
          goto LABEL_14;
      }
    }
    if ( v21 == 46 )
    {
      v21 = *(_DWORD *)(a1 + 44);
    }
    else
    {
      v20 = *(_QWORD *)(a1 + 56);
      if ( v20 && (unsigned int)(v21 - 48) <= 9 )
        v21 = *(_DWORD *)(v20 + 8LL * (unsigned int)(v21 + 3) + 56);
    }
    v22 = *(int **)(v18 + 8);
    v23 = *(_QWORD *)(v18 + 16);
    if ( v22 == (int *)v23 )
      goto LABEL_13;
    goto LABEL_8;
  }
  v18 = *(_QWORD *)(a1 + 48);
LABEL_14:
  result = *(unsigned int *)(v18 + 32);
  if ( (_DWORD)result )
    *(_QWORD *)(a1 + 8) = v17;
  else
    *(_DWORD *)(a1 + 32) = 0;
  return result;
}
// 43207C: variable 'a14' is possibly undefined
// 43207C: variable 'a15' is possibly undefined
// 43207C: variable 'a2' is possibly undefined
// 43207C: variable 'a3' is possibly undefined
// 43207C: variable 'a4' is possibly undefined
// 43207C: variable 'a5' is possibly undefined
// 43207C: variable 'a6' is possibly undefined
// 43207C: variable 'a7' is possibly undefined
// 43207C: variable 'a8' is possibly undefined
// 43207C: variable 'a9' is possibly undefined

//----- (00000000004320E0) ----------------------------------------------------
__int64 __fastcall _wprintf_fp_l_buffer(
        __int64 a1,
        __int64 *a2,
        __int64 a3,
        double **a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16,
        char a17)
{
  __int16 v17; // w4
  __int64 v18; // x6
  int v19; // w5
  void *v20; // x6
  __int64 v21; // x5
  double *v22; // x5
  __int64 v23; // x2
  void *v24; // x3
  __int64 v25; // x4
  _DWORD *v26; // x5
  void *v27; // x6
  __int64 v28; // x7
  double v29; // d0
  double v30; // d1
  double v31; // d2
  double v32; // d3
  double v33; // d4
  double v34; // d5
  double v35; // d6
  double v36; // d7
  __int64 result; // x0
  __int64 v38; // x5
  _QWORD v39[4]; // [xsp+20h] [xbp+20h] BYREF
  unsigned int v40; // [xsp+40h] [xbp+40h]
  int v41; // [xsp+48h] [xbp+48h]
  int v42; // [xsp+4Ch] [xbp+4Ch]
  __int64 v43; // [xsp+50h] [xbp+50h]
  __int64 v44; // [xsp+58h] [xbp+58h]
  _BYTE v45[64]; // [xsp+60h] [xbp+60h] BYREF

  v17 = *(_WORD *)(a3 + 12);
  if ( (v17 & 0x100) != 0 )
  {
    v18 = a2[4];
    v19 = *(_DWORD *)(v18 + 400);
    v20 = (void *)*(unsigned int *)(v18 + 408);
    v41 = (int)v20;
    v42 = v19;
    if ( !v19 )
      v42 = *(_DWORD *)(a2[1] + 80);
  }
  else
  {
    v38 = a2[1];
    v20 = (void *)*(unsigned int *)(v38 + 80);
    v41 = *(_DWORD *)(v38 + 88);
    v42 = (int)v20;
  }
  v21 = 0LL;
  if ( (v17 & 0x800) != 0 )
    v21 = *a2;
  v39[0] = v45;
  v39[1] = v45;
  v39[2] = &a17;
  v39[3] = 0LL;
  v43 = a1;
  v44 = v21;
  v22 = *a4;
  v40 = 9;
  _printf_fp_buffer_1_isra_0(
    (unsigned __int64)v39,
    (__int64)a2,
    0x2Cu,
    0x2Eu,
    a3,
    v22,
    v20,
    a16,
    a5,
    a6,
    a7,
    a8,
    a9,
    a10,
    a11,
    a12);
  if ( v40 )
    return _printf_buffer_flush((__int64)v39, v29, v30, v31, v32, v33, v34, v35, v36, v40, v23, v24, v25, v26, v27, v28);
  result = v43;
  *(_DWORD *)(v43 + 32) = 0;
  return result;
}
// 432188: variable 'v29' is possibly undefined
// 432188: variable 'v30' is possibly undefined
// 432188: variable 'v31' is possibly undefined
// 432188: variable 'v32' is possibly undefined
// 432188: variable 'v33' is possibly undefined
// 432188: variable 'v34' is possibly undefined
// 432188: variable 'v35' is possibly undefined
// 432188: variable 'v36' is possibly undefined
// 432188: variable 'v23' is possibly undefined
// 432188: variable 'v24' is possibly undefined
// 432188: variable 'v25' is possibly undefined
// 432188: variable 'v26' is possibly undefined
// 432188: variable 'v27' is possibly undefined
// 432188: variable 'v28' is possibly undefined

//----- (00000000004321A0) ----------------------------------------------------
__int64 __fastcall _printf_fp(__int64 a1, __int64 a2, double **a3)
{
  __int64 v4; // x4
  __int64 v5; // x5
  __int64 v6; // x6
  __int64 v7; // x7
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  __int64 StatusReg; // x4
  __int64 v26; // x5
  __int64 v27; // x6
  __int64 v28; // x7
  double v29; // d0
  double v30; // d1
  double v31; // d2
  double v32; // d3
  double v33; // d4
  double v34; // d5
  double v35; // d6
  double v36; // d7
  char v37; // [xsp+0h] [xbp+0h]
  _BYTE v39[560]; // [xsp+30h] [xbp+30h] BYREF

  if ( (*(_WORD *)(a2 + 12) & 0x400) != 0 )
  {
    _wprintf_buffer_to_file_init((__int64)v39, a1);
    _wprintf_fp_l_buffer(
      (__int64)v39,
      *(__int64 **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 32),
      a2,
      a3,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      v14,
      v15,
      v4,
      v5,
      v6,
      v7,
      v37);
    return _wprintf_buffer_to_file_done((__int64)v39, v16, v17, v18, v19, v20, v21, v22, v23);
  }
  else
  {
    _printf_buffer_to_file_init((__int64)v39, a1);
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    _printf_fp_l_buffer((unsigned __int64)v39, *(__int64 **)(StatusReg + 32), a2, a3, StatusReg, v26, v27, v28, v37);
    return _printf_buffer_to_file_done((__int64)v39, v29, v30, v31, v32, v33, v34, v35, v36);
  }
}
// 4321E8: variable 'v8' is possibly undefined
// 4321E8: variable 'v9' is possibly undefined
// 4321E8: variable 'v10' is possibly undefined
// 4321E8: variable 'v11' is possibly undefined
// 4321E8: variable 'v12' is possibly undefined
// 4321E8: variable 'v13' is possibly undefined
// 4321E8: variable 'v14' is possibly undefined
// 4321E8: variable 'v15' is possibly undefined
// 4321E8: variable 'v4' is possibly undefined
// 4321E8: variable 'v5' is possibly undefined
// 4321E8: variable 'v6' is possibly undefined
// 4321E8: variable 'v7' is possibly undefined
// 4321E8: variable 'v37' is possibly undefined
// 4321F0: variable 'v16' is possibly undefined
// 4321F0: variable 'v17' is possibly undefined
// 4321F0: variable 'v18' is possibly undefined
// 4321F0: variable 'v19' is possibly undefined
// 4321F0: variable 'v20' is possibly undefined
// 4321F0: variable 'v21' is possibly undefined
// 4321F0: variable 'v22' is possibly undefined
// 4321F0: variable 'v23' is possibly undefined
// 43222C: variable 'v26' is possibly undefined
// 43222C: variable 'v27' is possibly undefined
// 43222C: variable 'v28' is possibly undefined
// 432234: variable 'v29' is possibly undefined
// 432234: variable 'v30' is possibly undefined
// 432234: variable 'v31' is possibly undefined
// 432234: variable 'v32' is possibly undefined
// 432234: variable 'v33' is possibly undefined
// 432234: variable 'v34' is possibly undefined
// 432234: variable 'v35' is possibly undefined
// 432234: variable 'v36' is possibly undefined

//----- (0000000000432260) ----------------------------------------------------
__int64 __fastcall _printf_fphex_buffer(
        unsigned __int64 a1,
        _BYTE *a2,
        __int64 a3,
        unsigned __int64 **a4,
        __int64 a5,
        unsigned __int64 a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16,
        char a17)
{
  __int16 v17; // w24
  int v19; // w26
  unsigned __int64 *v20; // x0
  int v22; // w21
  int v23; // w23
  unsigned __int64 v25; // x22
  __int64 v26; // x27
  unsigned __int64 v27; // x1
  char *v28; // x24
  __int64 v29; // x0
  __int64 v30; // x26
  __int64 v31; // x25
  unsigned __int64 v32; // x4
  void *v33; // x3
  __int64 v34; // x4
  _DWORD *v35; // x5
  void *v36; // x6
  __int64 v37; // x7
  __int64 v38; // x27
  double v39; // d0
  double v40; // d1
  double v41; // d2
  double v42; // d3
  double v43; // d4
  double v44; // d5
  double v45; // d6
  double v46; // d7
  __int16 v47; // w0
  int v48; // w2
  int v49; // w2
  int v50; // w23
  _BYTE *v52; // x0
  _BYTE *v53; // x2
  __int16 v54; // w1
  _BYTE *v55; // x0
  int v56; // w1
  __int64 v57; // x2
  _BYTE *v59; // x0
  _BYTE *v60; // x0
  int v61; // w1
  char v62; // w1
  char *v63; // x0
  void *v64; // x3
  __int64 v65; // x4
  _DWORD *v66; // x5
  void *v67; // x6
  __int64 v68; // x7
  double v69; // d0
  double v70; // d1
  double v71; // d2
  double v72; // d3
  double v73; // d4
  double v74; // d5
  double v75; // d6
  double v76; // d7
  __int64 result; // x0
  __int64 v78; // x1
  char *v79; // x21
  int v80; // w23
  _BOOL4 v81; // w22
  _BYTE *v83; // x0
  _BYTE *v85; // x0
  void *v86; // x3
  __int64 v87; // x4
  _DWORD *v88; // x5
  void *v89; // x6
  __int64 v90; // x7
  double v91; // d0
  double v92; // d1
  double v93; // d2
  double v94; // d3
  double v95; // d4
  double v96; // d5
  double v97; // d6
  double v98; // d7
  unsigned __int64 v100; // x0
  unsigned __int64 v101; // d31
  unsigned __int64 v102; // x5
  int8x16_t *(__fastcall *v103)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  int v104; // w2
  char *v105; // x1
  int v106; // w5
  char v107; // w2
  unsigned __int8 v108; // w2
  int v109; // w6
  _BOOL4 v110; // w1
  char v111; // w5
  unsigned int v112; // w4
  unsigned __int64 StatusReg; // x8
  unsigned __int64 v114; // x10
  _BYTE *v115; // x2
  int v116; // w3
  __int16 v118; // w0
  _BYTE *v119; // x0
  char *v120; // x24
  unsigned __int64 v121; // x2
  bool v122; // vf
  __int64 v123; // x21
  void *v124; // x3
  __int64 v125; // x4
  _DWORD *v126; // x5
  void *v127; // x6
  __int64 v128; // x7
  double v129; // d0
  double v130; // d1
  double v131; // d2
  double v132; // d3
  double v133; // d4
  double v134; // d5
  double v135; // d6
  double v136; // d7
  unsigned int v138; // w1
  __int128 v141; // [xsp+60h] [xbp+60h]
  __int64 v142; // [xsp+60h] [xbp+60h]
  unsigned __int64 v143; // [xsp+60h] [xbp+60h]
  long double a; // [xsp+70h] [xbp+70h]
  unsigned __int64 aa; // [xsp+70h] [xbp+70h]
  unsigned __int64 ab; // [xsp+70h] [xbp+70h]
  unsigned __int64 v147; // [xsp+88h] [xbp+88h]
  unsigned __int64 v148; // [xsp+88h] [xbp+88h]
  _BYTE v149[7]; // [xsp+9Dh] [xbp+9Dh] BYREF
  char v150; // [xsp+A4h] [xbp+A4h] BYREF
  char v151; // [xsp+B0h] [xbp+B0h] BYREF
  _BYTE v152[13]; // [xsp+B3h] [xbp+B3h] BYREF

  v17 = *(_WORD *)(a3 + 12);
  if ( (v17 & 0x100) != 0 )
    _libc_assert_fail(
      (__int64)"info->extra == 0",
      (__int64)"../stdio-common/printf_fphex.c",
      0x41u,
      (__int64)"__printf_fphex_buffer");
  v19 = *(_DWORD *)(a3 + 8);
  v20 = *a4;
  v22 = *(_DWORD *)a3;
  v23 = *(_DWORD *)(a3 + 4);
  if ( (v17 & 1) != 0 )
  {
    v141 = *(_OWORD *)v20;
    v25 = v20[1] >> 63;
    *(_QWORD *)&a = *v20;
    *((_QWORD *)&a + 1) = v20[1] & 0x7FFFFFFFFFFFFFFFLL;
    a9 = *(double *)v20;
    a10 = NAN;
    if ( a <= *(long double *)&xmmword_45B7B0 )
    {
      v26 = *((_QWORD *)&v141 + 1) & 0xFFFFFFFFFFFFLL | v141;
      v27 = itoa_word(v141, (__int64)&a17, 0x10u, v19 == 65);
      if ( v27 > (unsigned __int64)&v151 )
        v27 = (unsigned __int64)memset();
      v28 = (char *)itoa_word(*((_QWORD *)&v141 + 1) & 0xFFFFFFFFFFFFLL, v27, 0x10u, *(_DWORD *)(a3 + 8) == 65);
      if ( v28 > &v150 )
        v28 = (char *)memset();
      LODWORD(v141) = ((*((_QWORD *)&v141 + 1) & 0x7FFF000000000000LL) != 0) + 48;
      v29 = HIWORD(*((_QWORD *)&v141 + 1)) & 0x7FFFLL;
      if ( (_DWORD)v29 )
      {
        if ( (HIWORD(v141) & 0x7FFFu) <= 0x3FFE )
        {
          LODWORD(v30) = 1;
          LODWORD(v29) = 0x3FFF - v29;
        }
        else
        {
          LODWORD(v29) = v29 - 0x3FFF;
          LODWORD(v30) = 0;
        }
        v31 = (__int64)v28;
        if ( !v26 )
          goto LABEL_12;
LABEL_84:
        v28 = &a17;
        if ( v152[12] == 48 )
        {
          do
          {
            v104 = (unsigned __int8)*(v28 - 2);
            --v28;
          }
          while ( v104 == 48 );
        }
        v105 = &v28[-v31];
        if ( v22 == -1 )
        {
          v22 = (_DWORD)v28 - v31;
          v32 = (int)v29;
          goto LABEL_15;
        }
        if ( v22 >= (__int64)v105 )
          goto LABEL_107;
        v106 = *(unsigned __int8 *)(v31 + v22);
        if ( v22 <= 0 )
        {
          v107 = v141;
        }
        else
        {
          v107 = *(_BYTE *)(v31 + v22 - 1);
          if ( (unsigned __int8)(v107 - 65) <= 5u )
          {
            v108 = v107 - 55;
            goto LABEL_92;
          }
          if ( (unsigned __int8)(v107 - 97) <= 5u )
          {
            v108 = v107 - 87;
LABEL_92:
            if ( (unsigned __int8)(v106 - 65) > 5u && (unsigned __int8)(v106 - 97) > 5u )
            {
              v109 = v106 - 48;
              if ( (v106 & 7) != 0 )
              {
                v110 = 1;
                v111 = 1;
              }
              else
              {
                v110 = (__int64)v105 > v22 + 1;
                v111 = v110;
              }
              v112 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 4, 0)) & 0xC00000;
              if ( v112 == 0x400000 )
              {
                if ( (_DWORD)v25 )
                  goto LABEL_162;
                if ( v109 > 7 || v110 )
                  goto LABEL_100;
              }
              else
              {
                if ( v112 <= 0x400000 )
                {
                  if ( v109 <= 7 )
                    goto LABEL_107;
                  goto LABEL_99;
                }
                if ( v112 != 0x800000 )
                {
                  if ( v112 == 12582912 )
                  {
                    v32 = (int)v29;
                    goto LABEL_15;
                  }
                  goto LABEL_170;
                }
                if ( (_DWORD)v25 )
                {
                  if ( v109 > 7 || v110 )
                    goto LABEL_100;
LABEL_162:
                  v38 = itoa_word((int)v29, (__int64)v149, 0xAu, 0);
                  v48 = 4;
                  v47 = *(_WORD *)(a3 + 12);
                  goto LABEL_17;
                }
              }
LABEL_126:
              v38 = itoa_word((int)v29, (__int64)v149, 0xAu, 0);
              goto LABEL_127;
            }
            v138 = _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 4, 0)) & 0xC00000;
            if ( v138 == 0x800000 )
            {
              if ( !(_DWORD)v25 )
                goto LABEL_126;
            }
            else
            {
              if ( v138 > 0x800000 )
              {
                if ( v138 == 12582912 )
                  goto LABEL_107;
LABEL_170:
                abort();
              }
              if ( !v138 )
              {
                v111 = 1;
LABEL_99:
                if ( ((v108 | (unsigned __int8)v111) & 1) == 0 )
                  goto LABEL_107;
                goto LABEL_100;
              }
              if ( (_DWORD)v25 )
                goto LABEL_162;
            }
LABEL_100:
            StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
            if ( v22 > 0 )
            {
              v114 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
              v115 = (_BYTE *)(v22 - 1LL + v31);
              while ( 1 )
              {
                v116 = (unsigned __int8)*v115;
                if ( v116 == 57 )
                {
                  v32 = (int)v29;
                  *v115 = *(_DWORD *)(a3 + 8);
                  goto LABEL_15;
                }
                StatusReg = v114;
                if ( *(int *)(*(_QWORD *)(v114 + 88) + 4LL * (unsigned __int8)*v115) <= 101 )
                  break;
                *v115-- = 48;
                if ( (_BYTE *)(v31 - (unsigned int)(v22 - 1) + v22 - 2LL) == v115 )
                  goto LABEL_105;
              }
              v32 = (int)v29;
              *v115 = v116 + 1;
LABEL_15:
              v38 = itoa_word(v32, (__int64)v149, 0xAu, 0);
              if ( (_DWORD)v25 )
              {
                v47 = *(_WORD *)(a3 + 12);
                v48 = 4;
LABEL_17:
                v49 = v23 - (v22 + v48 + (unsigned int)v149 - v38);
                if ( v22 <= 0 )
                {
                  v50 = v49 - 2;
                  if ( (v47 & 8) != 0 )
                    v50 = v49 - 3;
                }
                else
                {
                  v50 = v49 - 3;
                }
                if ( (v47 & 0x20) == 0 && *(_DWORD *)(a3 + 16) != 48 && v50 > 0 )
                  _printf_buffer_pad_1(a1, 32LL, v50, v33, v34, v35, v36, v37, v39, v40, v41, v42, v43, v44, v45, v46);
                v53 = *(_BYTE **)(a1 + 8);
                v52 = *(_BYTE **)(a1 + 16);
                if ( (_DWORD)v25 )
                {
                  if ( v53 == v52 )
                  {
                    _printf_buffer_putc_1(a1, 45);
                  }
                  else
                  {
                    *(_QWORD *)(a1 + 8) = v53 + 1;
                    *v53 = 45;
                  }
                  v53 = *(_BYTE **)(a1 + 8);
                  v52 = *(_BYTE **)(a1 + 16);
                }
                else
                {
                  v54 = *(_WORD *)(a3 + 12);
                  if ( (v54 & 0x40) != 0 )
                  {
                    if ( v53 == v52 )
                    {
                      _printf_buffer_putc_1(a1, 43);
                    }
                    else
                    {
                      *(_QWORD *)(a1 + 8) = v53 + 1;
                      *v53 = 43;
                    }
                    v53 = *(_BYTE **)(a1 + 8);
                    v52 = *(_BYTE **)(a1 + 16);
                  }
                  else if ( (v54 & 0x10) != 0 )
                  {
                    if ( v53 == v52 )
                    {
                      _printf_buffer_putc_1(a1, 32);
                    }
                    else
                    {
                      *(_QWORD *)(a1 + 8) = v53 + 1;
                      *v53 = 32;
                    }
                    v53 = *(_BYTE **)(a1 + 8);
                    v52 = *(_BYTE **)(a1 + 16);
                  }
                }
                if ( v53 == v52 )
                {
                  _printf_buffer_putc_1(a1, 48);
                }
                else
                {
                  *(_QWORD *)(a1 + 8) = v53 + 1;
                  *v53 = 48;
                }
                v55 = *(_BYTE **)(a1 + 8);
                v56 = *(_DWORD *)(a3 + 8) + 23;
                if ( v55 == *(_BYTE **)(a1 + 16) )
                {
                  _printf_buffer_putc_1(a1, v56);
                }
                else
                {
                  v57 = (__int64)(v55 + 1);
                  *(_QWORD *)(a1 + 8) = v55 + 1;
                  *v55 = v56;
                }
                if ( (*(_WORD *)(a3 + 12) & 0x20) == 0 && *(_DWORD *)(a3 + 16) == 48 && v50 > 0 )
                  _printf_buffer_pad_1(a1, 48LL, v50, v33, v34, v35, v36, v37, v39, v40, v41, v42, v43, v44, v45, v46);
                v59 = *(_BYTE **)(a1 + 8);
                if ( v59 == *(_BYTE **)(a1 + 16) )
                {
                  _printf_buffer_putc_1(a1, v141);
                }
                else
                {
                  *(_QWORD *)(a1 + 8) = v59 + 1;
                  *v59 = v141;
                }
                if ( v22 > 0 )
                {
                  _printf_buffer_puts_1(a1, a2, v57, v33, v34, v35, v36, v37, v39, v40, v41, v42, v43, v44, v45, v46);
                  v120 = &v28[-v31];
                  v121 = v22;
                  v122 = __OFSUB__(v22, v120);
                  v123 = v22 - (_QWORD)v120;
                  if ( !((v123 < 0) ^ v122 | (v123 == 0)) )
                    v121 = (unsigned __int64)v120;
                  _printf_buffer_write(a1, v31, v121);
                  if ( v123 > 0 )
                    _printf_buffer_pad_1(
                      a1,
                      48LL,
                      v123,
                      v124,
                      v125,
                      v126,
                      v127,
                      v128,
                      v129,
                      v130,
                      v131,
                      v132,
                      v133,
                      v134,
                      v135,
                      v136);
                }
                else if ( (*(_WORD *)(a3 + 12) & 8) != 0 )
                {
                  _printf_buffer_puts_1(a1, a2, v57, v33, v34, v35, v36, v37, v39, v40, v41, v42, v43, v44, v45, v46);
                }
                v60 = *(_BYTE **)(a1 + 8);
                v61 = *(_DWORD *)(a3 + 8) + 15;
                if ( v60 == *(_BYTE **)(a1 + 16) )
                {
                  _printf_buffer_putc_1(a1, v61);
                }
                else
                {
                  *(_QWORD *)(a1 + 8) = v60 + 1;
                  *v60 = v61;
                }
                if ( (_DWORD)v30 )
                  v62 = 45;
                else
                  v62 = 43;
                v63 = *(char **)(a1 + 8);
                if ( v63 == *(char **)(a1 + 16) )
                {
                  _printf_buffer_putc_1(a1, v62);
                }
                else
                {
                  *(_QWORD *)(a1 + 8) = v63 + 1;
                  *v63 = v62;
                }
                _printf_buffer_write(a1, v38, (unsigned __int64)&v149[-v38]);
                result = *(unsigned __int16 *)(a3 + 12);
                if ( (result & 0x20) != 0 )
                {
                  v78 = *(unsigned int *)(a3 + 16);
                  if ( (_DWORD)v78 != 48 && v50 > 0 )
                    return _printf_buffer_pad_1(
                             a1,
                             v78,
                             v50,
                             v64,
                             v65,
                             v66,
                             v67,
                             v68,
                             v69,
                             v70,
                             v71,
                             v72,
                             v73,
                             v74,
                             v75,
                             v76);
                }
                return result;
              }
LABEL_127:
              v47 = *(_WORD *)(a3 + 12);
              LODWORD(v25) = 0;
              v48 = ((v47 & 0x50) != 0) + 3;
              goto LABEL_17;
            }
LABEL_105:
            if ( *(int *)(*(_QWORD *)(StatusReg + 88) + 4LL * (unsigned int)v141) > 101 )
            {
              if ( (_DWORD)v30 )
              {
                LODWORD(v32) = v29 - 4;
                if ( (int)v29 - 4 <= 0 )
                {
                  LODWORD(v30) = 0;
                  v32 = 4 - (int)v29;
                  LOBYTE(v141) = 49;
                  goto LABEL_15;
                }
              }
              else
              {
                LODWORD(v32) = v29 + 4;
              }
              v32 = (int)v32;
              LOBYTE(v141) = 49;
              goto LABEL_15;
            }
            LOBYTE(v141) = v141 + 1;
LABEL_107:
            v32 = (int)v29;
            goto LABEL_15;
          }
        }
        v108 = v107 - 48;
        goto LABEL_92;
      }
      LODWORD(v30) = 0;
      if ( v26 )
      {
        v31 = (__int64)v28;
        LODWORD(v30) = 1;
        LODWORD(v29) = 16382;
        goto LABEL_84;
      }
      goto LABEL_12;
    }
  }
  else
  {
    a6 = *v20;
    v25 = *v20 >> 63;
    if ( fabs(*(double *)v20) <= 1.79769313e308 )
    {
      v142 = a6 & 0xFFFFFFFFFFFFFLL;
      aa = *v20;
      v147 = *v20;
      v100 = itoa_word(a6 & 0xFFFFFFFFFFFFFLL, (__int64)&a17, 0x10u, v19 == 65);
      v101 = v147;
      v32 = v142;
      v31 = v100;
      v102 = aa;
      if ( v100 > (unsigned __int64)v152 )
      {
        v143 = v147;
        ab = v32;
        v148 = v102;
        v103 = memset();
        v32 = ab;
        v31 = (__int64)v103;
        v102 = v148;
        v101 = v143;
      }
      v30 = (v102 >> 52) & 0x7FF;
      LODWORD(v141) = ((v101 & 0x7FF0000000000000LL) != 0) + 48;
      if ( !(_DWORD)v30 )
      {
        if ( !v32 )
        {
          v28 = (char *)v31;
LABEL_13:
          v31 = (__int64)v28;
          if ( v22 == -1 )
            v22 = 0;
          goto LABEL_15;
        }
        LODWORD(v30) = 1;
        LODWORD(v29) = 1022;
        goto LABEL_84;
      }
      if ( ((v102 >> 52) & 0x7FF) <= 0x3FE )
      {
        LODWORD(v29) = 1023 - v30;
        LODWORD(v30) = 1;
      }
      else
      {
        LODWORD(v29) = v30 - 1023;
        LODWORD(v30) = 0;
      }
      if ( v32 )
        goto LABEL_84;
      v28 = (char *)v31;
LABEL_12:
      v32 = (int)v29;
      goto LABEL_13;
    }
  }
  v79 = "inf";
  if ( (*(_WORD *)(*(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 72) + 2LL * v19) & 0x100) != 0 )
    v79 = "INF";
  if ( (_DWORD)v25 )
  {
    v80 = v23 - 4;
    v81 = v80 > 0;
    if ( v80 > 0 && (v17 & 0x20) == 0LL )
      _printf_buffer_pad_1(a1, 32LL, v80, a4, a5, (_DWORD *)a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
    v85 = *(_BYTE **)(a1 + 8);
    if ( v85 == *(_BYTE **)(a1 + 16) )
    {
      _printf_buffer_putc_1(a1, 45);
    }
    else
    {
      *(_QWORD *)(a1 + 8) = v85 + 1;
      *v85 = 45;
    }
    goto LABEL_73;
  }
  if ( (v17 & 0x40) != 0 )
  {
    v80 = v23 - 4;
    v81 = v80 > 0;
    if ( v80 <= 0 || (v17 & 0x20) != 0LL )
      goto LABEL_64;
  }
  else if ( (v17 & 0x10) != 0 )
  {
    v80 = v23 - 4;
    v81 = v80 > 0;
    if ( v80 <= 0 || (v17 & 0x20) != 0LL )
      goto LABEL_115;
  }
  else
  {
    v80 = v23 - 3;
    v81 = v80 > 0;
    if ( v80 <= 0 || (v17 & 0x20) != 0LL )
      goto LABEL_73;
  }
  _printf_buffer_pad_1(a1, 32LL, v80, a4, a5, (_DWORD *)a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
  v118 = *(_WORD *)(a3 + 12);
  if ( (v118 & 0x40) != 0 )
  {
    v81 = 1;
LABEL_64:
    v83 = *(_BYTE **)(a1 + 8);
    if ( v83 == *(_BYTE **)(a1 + 16) )
    {
      _printf_buffer_putc_1(a1, 43);
    }
    else
    {
      *(_QWORD *)(a1 + 8) = v83 + 1;
      *v83 = 43;
    }
    goto LABEL_73;
  }
  v81 = 1;
  if ( (v118 & 0x10) != 0 )
  {
LABEL_115:
    v119 = *(_BYTE **)(a1 + 8);
    if ( v119 == *(_BYTE **)(a1 + 16) )
    {
      _printf_buffer_putc_1(a1, 32);
    }
    else
    {
      *(_QWORD *)(a1 + 8) = v119 + 1;
      *v119 = 32;
    }
  }
LABEL_73:
  _printf_buffer_puts_1(a1, v79, a3, a4, a5, (_DWORD *)a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
  result = *(unsigned __int16 *)(a3 + 12);
  if ( (result & 0x20) != 0 && v81 )
    return _printf_buffer_pad_1(a1, 32LL, v80, v86, v87, v88, v89, v90, v91, v92, v93, v94, v95, v96, v97, v98);
  return result;
}
// 432ADC: variable 'v33' is possibly undefined
// 432ADC: variable 'v34' is possibly undefined
// 432ADC: variable 'v35' is possibly undefined
// 432ADC: variable 'v36' is possibly undefined
// 432ADC: variable 'v37' is possibly undefined
// 432ADC: variable 'v39' is possibly undefined
// 432ADC: variable 'v40' is possibly undefined
// 432ADC: variable 'v41' is possibly undefined
// 432ADC: variable 'v42' is possibly undefined
// 432ADC: variable 'v43' is possibly undefined
// 432ADC: variable 'v44' is possibly undefined
// 432ADC: variable 'v45' is possibly undefined
// 432ADC: variable 'v46' is possibly undefined
// 4324D8: variable 'v57' is possibly undefined
// 432558: variable 'v64' is possibly undefined
// 432558: variable 'v65' is possibly undefined
// 432558: variable 'v66' is possibly undefined
// 432558: variable 'v67' is possibly undefined
// 432558: variable 'v68' is possibly undefined
// 432558: variable 'v69' is possibly undefined
// 432558: variable 'v70' is possibly undefined
// 432558: variable 'v71' is possibly undefined
// 432558: variable 'v72' is possibly undefined
// 432558: variable 'v73' is possibly undefined
// 432558: variable 'v74' is possibly undefined
// 432558: variable 'v75' is possibly undefined
// 432558: variable 'v76' is possibly undefined
// 43263C: variable 'a3' is possibly undefined
// 43263C: variable 'a4' is possibly undefined
// 43263C: variable 'a5' is possibly undefined
// 43263C: variable 'a6' is possibly undefined
// 43263C: variable 'a7' is possibly undefined
// 43263C: variable 'a8' is possibly undefined
// 43263C: variable 'a9' is possibly undefined
// 43263C: variable 'a10' is possibly undefined
// 43263C: variable 'a11' is possibly undefined
// 43263C: variable 'a12' is possibly undefined
// 43263C: variable 'a13' is possibly undefined
// 43263C: variable 'a14' is possibly undefined
// 43263C: variable 'a15' is possibly undefined
// 43263C: variable 'a16' is possibly undefined
// 4329F0: variable 'v86' is possibly undefined
// 4329F0: variable 'v87' is possibly undefined
// 4329F0: variable 'v88' is possibly undefined
// 4329F0: variable 'v89' is possibly undefined
// 4329F0: variable 'v90' is possibly undefined
// 4329F0: variable 'v91' is possibly undefined
// 4329F0: variable 'v92' is possibly undefined
// 4329F0: variable 'v93' is possibly undefined
// 4329F0: variable 'v94' is possibly undefined
// 4329F0: variable 'v95' is possibly undefined
// 4329F0: variable 'v96' is possibly undefined
// 4329F0: variable 'v97' is possibly undefined
// 4329F0: variable 'v98' is possibly undefined
// 4329A4: variable 'v124' is possibly undefined
// 4329A4: variable 'v125' is possibly undefined
// 4329A4: variable 'v126' is possibly undefined
// 4329A4: variable 'v127' is possibly undefined
// 4329A4: variable 'v128' is possibly undefined
// 4329A4: variable 'v129' is possibly undefined
// 4329A4: variable 'v130' is possibly undefined
// 4329A4: variable 'v131' is possibly undefined
// 4329A4: variable 'v132' is possibly undefined
// 4329A4: variable 'v133' is possibly undefined
// 4329A4: variable 'v134' is possibly undefined
// 4329A4: variable 'v135' is possibly undefined
// 4329A4: variable 'v136' is possibly undefined
// 432CE8: using guessed type __int64 _printf_fphex_l_buffer(void);
// 45B7B0: using guessed type __int128 xmmword_45B7B0;

//----- (0000000000432CE8) ----------------------------------------------------
__int64 __fastcall _printf_fphex_l_buffer(
        unsigned __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned __int64 **a4,
        __int64 a5,
        unsigned __int64 a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16,
        char a17)
{
  return _printf_fphex_buffer(
           a1,
           *(_BYTE **)(*(_QWORD *)(a2 + 8) + 56LL),
           a3,
           a4,
           a5,
           a6,
           a7,
           a8,
           a9,
           a10,
           a11,
           a12,
           a13,
           a14,
           a15,
           a16,
           a17);
}

//----- (0000000000432D00) ----------------------------------------------------
__int64 __fastcall _printf_buffer_flush_fphex_to_wide(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        _DWORD *a14,
        void *a15)
{
  unsigned __int64 v16; // x4
  unsigned __int8 *v17; // x21
  unsigned __int64 v18; // x0
  unsigned __int8 *v19; // x19
  int v20; // w1
  int *v21; // x2
  unsigned __int64 v22; // x3
  __int64 result; // x0

  v16 = *(_QWORD *)(a1 + 8);
  v17 = (unsigned __int8 *)(a1 + 56);
  if ( a1 + 56 >= v16 )
  {
    v18 = *(_QWORD *)(a1 + 48);
  }
  else
  {
    v18 = *(_QWORD *)(a1 + 48);
    v19 = v17;
    do
    {
      while ( 1 )
      {
        v20 = *v19;
        if ( v20 == 46 )
          v20 = *(_DWORD *)(a1 + 40);
        v21 = *(int **)(v18 + 8);
        v22 = *(_QWORD *)(v18 + 16);
        if ( v21 == (int *)v22 )
          break;
        *(_QWORD *)(v18 + 8) = v21 + 1;
        ++v19;
        *v21 = v20;
        if ( v16 <= (unsigned __int64)v19 )
          goto LABEL_8;
      }
      _wprintf_buffer_putc_1(v18, v20, (__int64)v21, v22, v16, a14, a15, a2, a3, a4, a5, a6, a7, a8, a9);
      ++v19;
      v16 = *(_QWORD *)(a1 + 8);
      v18 = *(_QWORD *)(a1 + 48);
    }
    while ( v16 > (unsigned __int64)v19 );
  }
LABEL_8:
  result = *(unsigned int *)(v18 + 32);
  if ( (_DWORD)result )
    *(_QWORD *)(a1 + 8) = v17;
  else
    *(_DWORD *)(a1 + 32) = 0;
  return result;
}
// 432D64: variable 'a14' is possibly undefined
// 432D64: variable 'a15' is possibly undefined
// 432D64: variable 'a2' is possibly undefined
// 432D64: variable 'a3' is possibly undefined
// 432D64: variable 'a4' is possibly undefined
// 432D64: variable 'a5' is possibly undefined
// 432D64: variable 'a6' is possibly undefined
// 432D64: variable 'a7' is possibly undefined
// 432D64: variable 'a8' is possibly undefined
// 432D64: variable 'a9' is possibly undefined

//----- (0000000000432DC0) ----------------------------------------------------
__int64 __fastcall _wprintf_fphex_l_buffer(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        unsigned __int64 **a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        __int64 a13,
        unsigned __int64 a14,
        void *a15,
        __int64 a16)
{
  __int64 v16; // x1
  __int64 v17; // x1
  __int64 v18; // x2
  __int64 v19; // x3
  __int64 v20; // x4
  _DWORD *v21; // x5
  void *v22; // x6
  double v23; // d0
  double v24; // d1
  double v25; // d2
  double v26; // d3
  double v27; // d4
  double v28; // d5
  double v29; // d6
  double v30; // d7
  __int64 result; // x0
  char v32; // [xsp+0h] [xbp+0h]
  _QWORD v33[4]; // [xsp+20h] [xbp+20h] BYREF
  int v34; // [xsp+40h] [xbp+40h]
  int v35; // [xsp+48h] [xbp+48h]
  __int64 v36; // [xsp+50h] [xbp+50h]
  _BYTE v37[64]; // [xsp+58h] [xbp+58h] BYREF
  char v38; // [xsp+98h] [xbp+98h] BYREF

  v16 = *(_QWORD *)(a2 + 8);
  v36 = a1;
  LODWORD(v16) = *(_DWORD *)(v16 + 80);
  v33[0] = v37;
  v33[1] = v37;
  v33[2] = &v38;
  v33[3] = 0LL;
  v34 = 10;
  v35 = v16;
  _printf_fphex_buffer((unsigned __int64)v33, ".", a3, a4, 10LL, a14, a15, a16, a5, a6, a7, a8, a9, a10, a11, a12, v32);
  if ( v34 )
    return _printf_buffer_flush_fphex_to_wide(
             (__int64)v33,
             v23,
             v24,
             v25,
             v26,
             v27,
             v28,
             v29,
             v30,
             v17,
             v18,
             v19,
             v20,
             v21,
             v22);
  result = v36;
  *(_DWORD *)(v36 + 32) = 0;
  return result;
}
// 432DFC: variable 'v32' is possibly undefined
// 432E1C: variable 'v23' is possibly undefined
// 432E1C: variable 'v24' is possibly undefined
// 432E1C: variable 'v25' is possibly undefined
// 432E1C: variable 'v26' is possibly undefined
// 432E1C: variable 'v27' is possibly undefined
// 432E1C: variable 'v28' is possibly undefined
// 432E1C: variable 'v29' is possibly undefined
// 432E1C: variable 'v30' is possibly undefined
// 432E1C: variable 'v17' is possibly undefined
// 432E1C: variable 'v18' is possibly undefined
// 432E1C: variable 'v19' is possibly undefined
// 432E1C: variable 'v20' is possibly undefined
// 432E1C: variable 'v21' is possibly undefined
// 432E1C: variable 'v22' is possibly undefined

//----- (0000000000432E40) ----------------------------------------------------
__int64 __fastcall _printf_function_invoke(
        __int64 *a1,
        __int64 (__fastcall *a2)(_QWORD *, __int64, _BYTE *),
        __int64 a3,
        void *a4,
        __int64 a5,
        void *a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        __int64 a15,
        __int64 a16)
{
  __int64 *v16; // x6
  int8x16_t *(__fastcall *v19)(int8x16_t *, unsigned __int8, unsigned __int64); // x19
  unsigned int v20; // w4
  __int64 v21; // x1
  unsigned int v22; // w22
  double v23; // d0
  double v24; // d1
  double v25; // d2
  double v26; // d3
  double v27; // d4
  double v28; // d5
  double v29; // d6
  double v30; // d7
  unsigned int v31; // w20
  int8x16_t *(__fastcall *v33)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  void *v34; // [xsp+48h] [xbp+48h]
  __int64 v36; // [xsp+58h] [xbp+58h]
  _BYTE v37[32]; // [xsp+68h] [xbp+68h] BYREF
  _QWORD v38[29]; // [xsp+88h] [xbp+88h] BYREF

  v16 = a1;
  if ( (unsigned __int64)a4 > 4 )
  {
    v34 = a4;
    v36 = a3;
    v33 = calloc((unsigned __int64)a4, 8uLL, a3, a4, a7, a8, a9, a10, a11, a12, a13, a14, a5, a6, (__int64)a1, a16);
    a3 = v36;
    v19 = v33;
    a4 = v34;
    v16 = a1;
    if ( !v33 )
      return (unsigned int)-1;
    goto LABEL_4;
  }
  if ( a4 )
  {
    v19 = (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))v37;
LABEL_4:
    v20 = 0;
    v21 = 0LL;
    do
    {
      *((_QWORD *)v19 + v21) = a3 + 16 * v21;
      v21 = ++v20;
    }
    while ( v20 < (unsigned __int64)a4 );
    _printf_buffer_as_file_init(v38, v16);
    v22 = a2(v38, a5, v19);
    if ( (_printf_buffer_as_file_terminate(v38) & 1) != 0 )
      v31 = v22;
    else
      v31 = -1;
    if ( (char *)v19 != v37 )
      free((unsigned __int64)v19, v23, v24, v25, v26, v27, v28, v29, v30);
    return v31;
  }
  _printf_buffer_as_file_init(v38, a1);
  v31 = a2(v38, a5, v37);
  if ( (_printf_buffer_as_file_terminate(v38) & 1) == 0 )
    return (unsigned int)-1;
  return v31;
}
// 432ED4: variable 'v23' is possibly undefined
// 432ED4: variable 'v24' is possibly undefined
// 432ED4: variable 'v25' is possibly undefined
// 432ED4: variable 'v26' is possibly undefined
// 432ED4: variable 'v27' is possibly undefined
// 432ED4: variable 'v28' is possibly undefined
// 432ED4: variable 'v29' is possibly undefined
// 432ED4: variable 'v30' is possibly undefined

//----- (0000000000432F60) ----------------------------------------------------
__int64 __fastcall register_printf_modifier(unsigned __int8 *a1)
{
  unsigned int v1; // w1
  unsigned __int8 *v2; // x22
  unsigned int v3; // t1
  int v4; // w1
  unsigned int v5; // w20
  __int64 v8; // x1
  __int64 v9; // x2
  void *v10; // x3
  void *v11; // x4
  void *v12; // x5
  void *v13; // x6
  __int64 v14; // x7
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  int v23; // w0
  unsigned __int64 v24; // x0
  unsigned __int64 v25; // x20
  char v26; // w3
  __int64 v27; // x1
  __int64 v28; // x2
  __int64 v29; // x3
  void *v30; // x4
  void *v31; // x5
  void *v32; // x6
  int v33; // w0

  v1 = *(_DWORD *)a1;
  if ( !*(_DWORD *)a1 )
  {
    v4 = 22;
LABEL_6:
    v5 = -1;
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = v4;
    return v5;
  }
  v2 = a1;
  do
  {
    if ( v1 > 0xFF )
    {
      v4 = 22;
      goto LABEL_6;
    }
    v3 = *((_DWORD *)v2 + 1);
    v2 += 4;
    v1 = v3;
  }
  while ( v3 );
  if ( (unsigned int)(next_bit - 16) <= 7 )
  {
    v4 = 28;
    goto LABEL_6;
  }
  _aarch64_cas4_acq();
  if ( v23 )
    _lll_lock_wait_private(&lock_1, v15, v16, v17, v18, v19, v20, v21, v22, v8, v9, (__int64)v10, v11, v12, v13);
  if ( (_printf_modifier_table
     || (_printf_modifier_table = (__int64)calloc(
                                             0xFFuLL,
                                             8uLL,
                                             v9,
                                             v10,
                                             v15,
                                             v16,
                                             v17,
                                             v18,
                                             v19,
                                             v20,
                                             v21,
                                             v22,
                                             (__int64)v11,
                                             v12,
                                             (__int64)v13,
                                             v14)) != 0)
    && (v24 = malloc(v2 - a1 + 16, v8, v2 - a1, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22),
        (v25 = v24) != 0) )
  {
    *(_QWORD *)v24 = *(_QWORD *)(_printf_modifier_table + 8LL * (unsigned __int8)*(_DWORD *)a1);
    v26 = next_bit++;
    *(_DWORD *)(v24 + 8) = 1 << v26;
    wmemcpy();
    *(_QWORD *)(_printf_modifier_table + 8LL * *a1) = v25;
    v5 = *(_DWORD *)(v25 + 8);
  }
  else
  {
    v5 = -1;
  }
  _aarch64_swp4_rel();
  if ( v33 > 1 )
  {
    _lll_lock_wake_private(&lock_1, v27, v28, v29, v30, v31, v32);
    return v5;
  }
  return v5;
}
// 432FE8: variable 'v23' is possibly undefined
// 4330B0: variable 'v15' is possibly undefined
// 4330B0: variable 'v16' is possibly undefined
// 4330B0: variable 'v17' is possibly undefined
// 4330B0: variable 'v18' is possibly undefined
// 4330B0: variable 'v19' is possibly undefined
// 4330B0: variable 'v20' is possibly undefined
// 4330B0: variable 'v21' is possibly undefined
// 4330B0: variable 'v22' is possibly undefined
// 4330B0: variable 'v8' is possibly undefined
// 4330B0: variable 'v9' is possibly undefined
// 4330B0: variable 'v10' is possibly undefined
// 4330B0: variable 'v11' is possibly undefined
// 4330B0: variable 'v12' is possibly undefined
// 4330B0: variable 'v13' is possibly undefined
// 433004: variable 'v14' is possibly undefined
// 433078: variable 'v33' is possibly undefined
// 4330BC: variable 'v27' is possibly undefined
// 4330BC: variable 'v28' is possibly undefined
// 4330BC: variable 'v29' is possibly undefined
// 4330BC: variable 'v30' is possibly undefined
// 4330BC: variable 'v31' is possibly undefined
// 4330BC: variable 'v32' is possibly undefined
// 496F58: using guessed type int next_bit;
// 496F5C: using guessed type _DWORD lock_1;
// 496F60: using guessed type __int64 _printf_modifier_table;

//----- (00000000004330E0) ----------------------------------------------------
__int64 __fastcall _handle_registered_modifier_mb(unsigned __int8 **a1, __int64 a2)
{
  __int64 v3; // x10
  __int64 *v4; // x6
  unsigned __int8 *v5; // x13
  int v6; // w9
  int v7; // w11
  int *v8; // x4
  unsigned __int8 *v9; // x5
  int v10; // w3
  int v11; // t1
  int v12; // w2
  bool v13; // zf
  __int64 result; // x0

  v3 = (__int64)*a1;
  v4 = *(__int64 **)(_printf_modifier_table + 8LL * **a1);
  if ( !v4 )
    return 1LL;
  v5 = 0LL;
  v6 = 0;
  v7 = 0;
  while ( 2 )
  {
    if ( *(_BYTE *)(v3 + 1) )
    {
      do
      {
        v8 = (int *)v4 + 3;
        v9 = (unsigned __int8 *)(v3 + 1);
        v10 = *(unsigned __int8 *)(v3 + 1);
        while ( 1 )
        {
          v12 = *v8;
          if ( *v8 )
            v13 = v10 == v12;
          else
            v13 = 0;
          if ( !v13 )
          {
            if ( !v12 )
              goto LABEL_12;
            goto LABEL_18;
          }
          v11 = *++v9;
          v10 = v11;
          if ( !v11 )
            break;
          ++v8;
        }
        if ( !v8[1] )
          goto LABEL_12;
LABEL_18:
        v4 = (__int64 *)*v4;
      }
      while ( v4 );
      result = 1LL;
      if ( v7 )
      {
LABEL_20:
        *(_WORD *)(a2 + 14) |= v7;
        result = 0LL;
        *a1 = v5;
      }
    }
    else
    {
      while ( *((_DWORD *)v4 + 3) )
      {
        v4 = (__int64 *)*v4;
        if ( !v4 )
          goto LABEL_15;
      }
      v9 = (unsigned __int8 *)(v3 + 1);
LABEL_12:
      if ( (__int64)&v9[-v3] > v6 )
      {
        v7 = *((_DWORD *)v4 + 2);
        v6 = (_DWORD)v9 - v3;
        v5 = v9;
      }
      v4 = (__int64 *)*v4;
      if ( v4 )
        continue;
LABEL_15:
      result = 1LL;
      if ( v7 )
        goto LABEL_20;
    }
    return result;
  }
}
// 496F60: using guessed type __int64 _printf_modifier_table;

//----- (00000000004331C0) ----------------------------------------------------
__int64 __fastcall _handle_registered_modifier_wc(unsigned int **a1, __int64 a2)
{
  __int64 v3; // x10
  __int64 *v4; // x6
  unsigned int *v5; // x13
  int v6; // w9
  int v7; // w11
  int *v8; // x4
  unsigned int *v9; // x5
  unsigned int v10; // w3
  unsigned int v11; // t1
  int v12; // w2
  bool v13; // zf
  __int64 result; // x0

  v3 = (__int64)*a1;
  v4 = *(__int64 **)(_printf_modifier_table + 8LL * **a1);
  if ( !v4 )
    return 1LL;
  v5 = 0LL;
  v6 = 0;
  v7 = 0;
  while ( 2 )
  {
    if ( *(_DWORD *)(v3 + 4) )
    {
      do
      {
        v8 = (int *)v4 + 3;
        v9 = (unsigned int *)(v3 + 4);
        v10 = *(_DWORD *)(v3 + 4);
        while ( 1 )
        {
          v12 = *v8;
          if ( *v8 )
            v13 = v12 == v10;
          else
            v13 = 0;
          if ( !v13 )
          {
            if ( !v12 )
              goto LABEL_12;
            goto LABEL_18;
          }
          v11 = v9[1];
          ++v9;
          v10 = v11;
          if ( !v11 )
            break;
          ++v8;
        }
        if ( !v8[1] )
          goto LABEL_12;
LABEL_18:
        v4 = (__int64 *)*v4;
      }
      while ( v4 );
      result = 1LL;
      if ( v7 )
      {
LABEL_20:
        *(_WORD *)(a2 + 14) |= v7;
        result = 0LL;
        *a1 = v5;
      }
    }
    else
    {
      while ( *((_DWORD *)v4 + 3) )
      {
        v4 = (__int64 *)*v4;
        if ( !v4 )
          goto LABEL_15;
      }
      v9 = (unsigned int *)(v3 + 4);
LABEL_12:
      if ( ((__int64)v9 - v3) >> 2 > v6 )
      {
        v7 = *((_DWORD *)v4 + 2);
        v6 = ((__int64)v9 - v3) >> 2;
        v5 = v9;
      }
      v4 = (__int64 *)*v4;
      if ( v4 )
        continue;
LABEL_15:
      result = 1LL;
      if ( v7 )
        goto LABEL_20;
    }
    return result;
  }
}
// 496F60: using guessed type __int64 _printf_modifier_table;

//----- (00000000004332A4) ----------------------------------------------------
void __fastcall _libc_printf_freemem(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  unsigned __int64 v8; // x0
  __int64 i; // x20
  _QWORD *v10; // x19
  unsigned __int64 v11; // x0

  v8 = _printf_modifier_table;
  if ( _printf_modifier_table )
  {
    for ( i = 0LL; i != 2040; i += 8LL )
    {
      v10 = *(_QWORD **)(v8 + i);
      if ( v10 )
      {
        do
        {
          v11 = (unsigned __int64)v10;
          v10 = (_QWORD *)*v10;
          free(v11, a1, a2, a3, a4, a5, a6, a7, a8);
        }
        while ( v10 );
        v8 = _printf_modifier_table;
      }
    }
    free(v8, a1, a2, a3, a4, a5, a6, a7, a8);
  }
}
// 4332D8: variable 'a1' is possibly undefined
// 4332D8: variable 'a2' is possibly undefined
// 4332D8: variable 'a3' is possibly undefined
// 4332D8: variable 'a4' is possibly undefined
// 4332D8: variable 'a5' is possibly undefined
// 4332D8: variable 'a6' is possibly undefined
// 4332D8: variable 'a7' is possibly undefined
// 4332D8: variable 'a8' is possibly undefined
// 496F60: using guessed type __int64 _printf_modifier_table;

//----- (0000000000433320) ----------------------------------------------------
__int64 __fastcall register_printf_specifier(unsigned int a1, __int64 a2, __int64 a3)
{
  __int64 v6; // x1
  __int64 v7; // x2
  void *v8; // x3
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  __int64 v12; // x7
  double v13; // d0
  double v14; // d1
  double v15; // d2
  double v16; // d3
  double v17; // d4
  double v18; // d5
  double v19; // d6
  double v20; // d7
  int v21; // w0
  __int64 v22; // x1
  int8x16_t *(__fastcall *v23)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  __int64 v24; // x3
  unsigned int v25; // w19
  __int64 v26; // x1
  __int64 v27; // x2
  __int64 v28; // x3
  void *v29; // x4
  void *v30; // x5
  void *v31; // x6
  int v32; // w0

  if ( a1 > 0xFF )
  {
    v25 = -1;
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return v25;
  }
  _aarch64_cas4_acq();
  if ( v21 )
    _lll_lock_wait_private(&lock_2, v13, v14, v15, v16, v17, v18, v19, v20, v6, v7, (__int64)v8, v9, v10, v11);
  v22 = _printf_function_table;
  if ( _printf_function_table )
  {
    v23 = (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))_printf_arginfo_table;
LABEL_6:
    v24 = 8LL * a1;
    v25 = 0;
    *(_QWORD *)(v22 + v24) = a2;
    *(_QWORD *)((char *)v23 + v24) = a3;
    goto LABEL_7;
  }
  v23 = calloc(
          0x100uLL,
          0x10uLL,
          (__int64)&lock_2,
          v8,
          v13,
          v14,
          v15,
          v16,
          v17,
          v18,
          v19,
          v20,
          (__int64)v9,
          v10,
          (__int64)v11,
          v12);
  _printf_arginfo_table = (__int64)v23;
  if ( v23 )
  {
    v22 = (__int64)v23 + 2048;
    _printf_function_table = (__int64)v23 + 2048;
    goto LABEL_6;
  }
  v25 = -1;
LABEL_7:
  _aarch64_swp4_rel();
  if ( v32 > 1 )
    _lll_lock_wake_private(&lock_2, v26, v27, v28, v29, v30, v31);
  return v25;
}
// 43335C: variable 'v21' is possibly undefined
// 4333E4: variable 'v13' is possibly undefined
// 4333E4: variable 'v14' is possibly undefined
// 4333E4: variable 'v15' is possibly undefined
// 4333E4: variable 'v16' is possibly undefined
// 4333E4: variable 'v17' is possibly undefined
// 4333E4: variable 'v18' is possibly undefined
// 4333E4: variable 'v19' is possibly undefined
// 4333E4: variable 'v20' is possibly undefined
// 4333E4: variable 'v6' is possibly undefined
// 4333E4: variable 'v7' is possibly undefined
// 4333E4: variable 'v8' is possibly undefined
// 4333E4: variable 'v9' is possibly undefined
// 4333E4: variable 'v10' is possibly undefined
// 4333E4: variable 'v11' is possibly undefined
// 433390: variable 'v32' is possibly undefined
// 4333D4: variable 'v26' is possibly undefined
// 4333D4: variable 'v27' is possibly undefined
// 4333D4: variable 'v28' is possibly undefined
// 4333D4: variable 'v29' is possibly undefined
// 4333D4: variable 'v30' is possibly undefined
// 4333D4: variable 'v31' is possibly undefined
// 4333B4: variable 'v12' is possibly undefined
// 496F68: using guessed type __int64 lock_2;
// 496F70: using guessed type __int64 _printf_function_table;
// 496F78: using guessed type __int64 _printf_arginfo_table;

//----- (0000000000433420) ----------------------------------------------------
__int64 __fastcall register_printf_type(__int64 a1)
{
  __int64 v2; // x1
  __int64 v3; // x2
  void *v4; // x3
  void *v5; // x4
  void *v6; // x5
  void *v7; // x6
  __int64 v8; // x7
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  int v17; // w0
  int v18; // w20
  __int64 v19; // x1
  __int64 v20; // x2
  __int64 v21; // x3
  void *v22; // x4
  void *v23; // x5
  void *v24; // x6
  int v25; // w0

  _aarch64_cas4_acq();
  if ( v17 )
    _lll_lock_wait_private(lock_3, v9, v10, v11, v12, v13, v14, v15, v16, v2, v3, (__int64)v4, v5, v6, v7);
  if ( _printf_va_arg_table
    || (_printf_va_arg_table = (__int64)calloc(
                                          0xF8uLL,
                                          8uLL,
                                          v3,
                                          v4,
                                          v9,
                                          v10,
                                          v11,
                                          v12,
                                          v13,
                                          v14,
                                          v15,
                                          v16,
                                          (__int64)v5,
                                          v6,
                                          (__int64)v7,
                                          v8)) != 0 )
  {
    v18 = pa_next_type;
    if ( pa_next_type == 256 )
    {
      v18 = -1;
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 28;
    }
    else
    {
      ++pa_next_type;
      *(_QWORD *)(_printf_va_arg_table + 8 * (v18 - 8LL)) = a1;
    }
  }
  else
  {
    v18 = -1;
  }
  _aarch64_swp4_rel();
  if ( v25 > 1 )
    _lll_lock_wake_private(lock_3, v19, v20, v21, v22, v23, v24);
  return (unsigned int)v18;
}
// 433448: variable 'v17' is possibly undefined
// 4334E8: variable 'v9' is possibly undefined
// 4334E8: variable 'v10' is possibly undefined
// 4334E8: variable 'v11' is possibly undefined
// 4334E8: variable 'v12' is possibly undefined
// 4334E8: variable 'v13' is possibly undefined
// 4334E8: variable 'v14' is possibly undefined
// 4334E8: variable 'v15' is possibly undefined
// 4334E8: variable 'v16' is possibly undefined
// 4334E8: variable 'v2' is possibly undefined
// 4334E8: variable 'v3' is possibly undefined
// 4334E8: variable 'v4' is possibly undefined
// 4334E8: variable 'v5' is possibly undefined
// 4334E8: variable 'v6' is possibly undefined
// 4334E8: variable 'v7' is possibly undefined
// 433494: variable 'v25' is possibly undefined
// 4334CC: variable 'v19' is possibly undefined
// 4334CC: variable 'v20' is possibly undefined
// 4334CC: variable 'v21' is possibly undefined
// 4334CC: variable 'v22' is possibly undefined
// 4334CC: variable 'v23' is possibly undefined
// 4334CC: variable 'v24' is possibly undefined
// 4334B4: variable 'v8' is possibly undefined
// 491910: using guessed type int pa_next_type;
// 496F80: using guessed type _DWORD lock_3[2];
// 496F88: using guessed type __int64 _printf_va_arg_table;

//----- (0000000000433520) ----------------------------------------------------
__int64 __fastcall snprintf(
        _BYTE *a1,
        __int64 a2,
        long double a3,
        long double a4,
        long double a5,
        long double a6,
        long double a7,
        long double a8,
        long double a9,
        long double a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  return _vsnprintf_internal(a1, a2);
}

//----- (00000000004335A0) ----------------------------------------------------
__int64 __fastcall _translated_number_width(__int64 a1, _BYTE *a2, _BYTE *a3)
{
  __int64 v3; // x5
  __int64 result; // x0
  int v5; // w3

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 32LL);
  result = *(unsigned __int8 *)(v3 + 19);
  if ( *(_BYTE *)(v3 + 19) )
    return (unsigned int)(result * ((_DWORD)a3 - (_DWORD)a2));
  if ( a2 < a3 )
  {
    do
    {
      v5 = (unsigned __int8)*a2 - 48;
      if ( (unsigned __int8)(*a2 - 48) > 9u )
        _libc_assert_fail(
          (__int64)"'0' <= *p && *p <= '9'",
          (__int64)"translated_number_width.c",
          0x25u,
          (__int64)"__translated_number_width");
      ++a2;
      result = (unsigned int)result + *(unsigned __int8 *)(v3 + v5 + 9);
    }
    while ( a3 != a2 );
  }
  return result;
}

//----- (0000000000433640) ----------------------------------------------------
unsigned __int64 __fastcall _wprintf_buffer_putc_1(
        unsigned __int64 result,
        int a2,
        __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        _DWORD *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  __int64 v16; // x1
  unsigned __int64 v17; // x19

  v16 = *(unsigned int *)(result + 32);
  if ( (_DWORD)v16 )
  {
    v17 = result;
    result = _wprintf_buffer_flush(result, a8, a9, a10, a11, a12, a13, a14, a15, v16, a3, a4, a5, a6, a7);
    if ( (result & 1) != 0 )
    {
      result = *(_QWORD *)(v17 + 8);
      if ( result >= *(_QWORD *)(v17 + 16) )
        _libc_assert_fail(
          (__int64)"buf->write_ptr < buf->write_end",
          (__int64)"Xprintf_buffer_putc_1.c",
          0x1Bu,
          (__int64)"__wprintf_buffer_putc_1");
      *(_QWORD *)(v17 + 8) = result + 4;
      *(_DWORD *)result = a2;
    }
  }
  return result;
}

//----- (00000000004336C0) ----------------------------------------------------
__int64 __fastcall _wprintf_buffer_flush_to_file(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v10; // x20
  __int64 v11; // x21
  __int64 v12; // x0
  __int64 v13; // x20
  __int64 v14; // x1
  __int64 result; // x0
  __int64 v16; // x0
  __int64 v17; // [xsp+38h] [xbp+38h]

  v10 = *(_QWORD *)(a1 + 8);
  v11 = a1 + 48;
  v12 = *(_QWORD *)(a1 + 40);
  v13 = (v10 - v11) >> 2;
  v14 = *(_QWORD *)(v12 + 216);
  if ( (unsigned __int64)(v14 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v17 = *(_QWORD *)(v12 + 216);
    IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
    v14 = v17;
  }
  result = (*(__int64 (**)(void))(v14 + 56))();
  if ( result == v13 )
  {
    v16 = *(_QWORD *)(a1 + 24);
    *(_QWORD *)(a1 + 8) = v11;
    result = v16 + v13;
    *(_QWORD *)(a1 + 24) = result;
  }
  else
  {
    *(_DWORD *)(a1 + 32) = 0;
  }
  return result;
}

//----- (0000000000433760) ----------------------------------------------------
__int64 __fastcall _wprintf_buffer_to_file_init(__int64 result, __int64 a2)
{
  *(_QWORD *)result = result + 48;
  *(_QWORD *)(result + 8) = result + 48;
  *(_QWORD *)(result + 16) = result + 560;
  *(_QWORD *)(result + 24) = 0LL;
  *(_DWORD *)(result + 32) = 2;
  *(_QWORD *)(result + 40) = a2;
  return result;
}

//----- (0000000000433780) ----------------------------------------------------
__int64 __fastcall _wprintf_buffer_to_file_done(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  if ( !*(_DWORD *)(a1 + 32) )
    return 0xFFFFFFFFLL;
  _wprintf_buffer_flush_to_file(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return _wprintf_buffer_done(a1);
}

//----- (00000000004337C0) ----------------------------------------------------
char *__fastcall _get_errlist(int a1)
{
  __int64 v1; // x1

  v1 = 0LL;
  if ( (a1 & 0x80000000) == 0 )
  {
    v1 = 0LL;
    if ( (unsigned __int64)a1 < 0x86 )
      return sys_errlist_internal[a1];
  }
  return (char *)v1;
}
// 48C9F0: using guessed type char *sys_errlist_internal[41];

//----- (0000000000433800) ----------------------------------------------------
__int64 __fastcall IO_file_doallocate(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  __int64 v17; // x20
  __int64 v18; // x20
  unsigned __int64 v19; // x0
  double v20; // d0
  double v21; // d1
  double v22; // d2
  double v23; // d3
  double v24; // d4
  double v25; // d5
  double v26; // d6
  double v27; // d7
  unsigned __int64 StatusReg; // x20
  _BOOL4 v30; // w0
  unsigned int v31; // [xsp+24h] [xbp+24h]
  _BYTE v32[16]; // [xsp+30h] [xbp+30h] BYREF
  int v33; // [xsp+40h] [xbp+40h]
  unsigned int v34; // [xsp+50h] [xbp+50h]
  int v35; // [xsp+54h] [xbp+54h]
  int v36; // [xsp+68h] [xbp+68h]

  if ( (*(_DWORD *)(a1 + 112) & 0x80000000) == 0 )
  {
    v17 = *(_QWORD *)(a1 + 216);
    if ( (unsigned __int64)(v17 - (_QWORD)&_io_vtables) > 0x92F )
      IO_vtable_check(a9, a10, a11, a12, a13, a14, a15, a16);
    if ( ((*(__int64 (__fastcall **)(__int64, _BYTE *))(v17 + 144))(a1, v32) & 0x80000000) == 0 )
    {
      if ( (v33 & 0xF000) != 0x2000
        || (v35 & 0xFFFFF000 | (v34 >> 8) & 0xFFF) - 136 > 7
        && (StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)),
            v31 = *(_DWORD *)(StatusReg + 40),
            v30 = isatty(*(_DWORD *)(a1 + 112)),
            a3 = v31,
            *(_DWORD *)(StatusReg + 40) = v31,
            !v30) )
      {
        LODWORD(v18) = v36;
        a2 = (unsigned int)(v36 - 1);
        if ( (unsigned int)a2 > 0x1FFE )
          goto LABEL_7;
LABEL_9:
        v18 = (int)v18;
        v19 = malloc((int)v18, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
        if ( v19 )
          goto LABEL_8;
        return 0xFFFFFFFFLL;
      }
      LODWORD(v18) = v36;
      *(_DWORD *)a1 |= 0x200u;
      a2 = (unsigned int)(v18 - 1);
      if ( (unsigned int)a2 <= 0x1FFE )
        goto LABEL_9;
    }
  }
LABEL_7:
  v18 = 0x2000LL;
  v19 = malloc(0x2000LL, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
  if ( v19 )
  {
LABEL_8:
    IO_setb((int *)a1, v19, v19 + v18, 1, v20, v21, v22, v23, v24, v25, v26, v27);
    return 1LL;
  }
  return 0xFFFFFFFFLL;
}
// 433870: variable 'a2' is possibly undefined
// 433870: variable 'a3' is possibly undefined
// 433870: variable 'a4' is possibly undefined
// 433870: variable 'a5' is possibly undefined
// 433870: variable 'a6' is possibly undefined
// 433870: variable 'a7' is possibly undefined
// 433870: variable 'a8' is possibly undefined
// 433870: variable 'a9' is possibly undefined
// 433870: variable 'a10' is possibly undefined
// 433870: variable 'a11' is possibly undefined
// 433870: variable 'a12' is possibly undefined
// 433870: variable 'a13' is possibly undefined
// 433870: variable 'a14' is possibly undefined
// 433870: variable 'a15' is possibly undefined
// 433870: variable 'a16' is possibly undefined
// 433888: variable 'v20' is possibly undefined
// 433888: variable 'v21' is possibly undefined
// 433888: variable 'v22' is possibly undefined
// 433888: variable 'v23' is possibly undefined
// 433888: variable 'v24' is possibly undefined
// 433888: variable 'v25' is possibly undefined
// 433888: variable 'v26' is possibly undefined
// 433888: variable 'v27' is possibly undefined

//----- (0000000000433940) ----------------------------------------------------
__int64 __fastcall fclose(
        __int64 *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        void *a13,
        void *a14,
        void *a15,
        __int64 a16)
{
  __int64 v17; // x1
  __int64 v18; // x22
  __int64 v19; // x20
  double v20; // d0
  double v21; // d1
  double v22; // d2
  double v23; // d3
  double v24; // d4
  double v25; // d5
  double v26; // d6
  double v27; // d7
  __int64 *v28; // x21
  __int64 v29; // x1
  __int64 v30; // x2
  __int64 v31; // x3
  void *v32; // x4
  void *v33; // x5
  void *v34; // x6
  double v35; // d0
  double v36; // d1
  double v37; // d2
  double v38; // d3
  double v39; // d4
  double v40; // d5
  double v41; // d6
  double v42; // d7
  int v43; // w0
  __int64 v44; // x1
  __int64 v45; // x2
  __int64 v46; // x3
  void *v47; // x4
  void *v48; // x5
  void *v49; // x6
  int v50; // w0
  unsigned __int64 StatusReg; // x20
  __int64 v55; // x21
  unsigned __int64 v56; // x20
  __int64 v57; // x0
  __int64 v58; // x1
  int v59; // w0
  int v60; // w0
  __int64 v61; // x1
  int v62; // w0
  void *v63; // x20
  __int64 v64; // x1
  __int64 v65; // x2
  __int64 v66; // x3
  void *v67; // x4
  void *v68; // x5
  void *v69; // x6
  int v70; // w0

  v17 = *(unsigned int *)a1;
  if ( (v17 & 0x2000) != 0 )
  {
    IO_un_link((__int64)a1);
    v17 = *(unsigned int *)a1;
    if ( (v17 & 0x8000) != 0 )
    {
      if ( (v17 & 0x2000) == 0 )
        goto LABEL_3;
      goto LABEL_36;
    }
  }
  else if ( (v17 & 0x8000) != 0 )
  {
LABEL_3:
    v18 = v17 << 58 >> 63;
    goto LABEL_4;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v55 = a1[17];
  v56 = StatusReg - 1824;
  v57 = *(_QWORD *)(v55 + 8);
  if ( !_libc_single_threaded || v57 )
  {
    if ( v56 == v57 )
    {
      ++*(_DWORD *)(v55 + 4);
      v17 = *(unsigned int *)a1;
    }
    else
    {
      _aarch64_cas4_acq();
      if ( v59 )
        _lll_lock_wait_private((_DWORD *)v55, a2, a3, a4, a5, a6, a7, a8, a9, v58, a11, a12, a13, a14, a15);
      v17 = *(unsigned int *)a1;
      *(_QWORD *)(a1[17] + 8) = v56;
    }
    if ( (v17 & 0x2000) != 0 )
      goto LABEL_36;
LABEL_26:
    v60 = v17 & 0x8000;
    v18 = v17 << 58 >> 63;
    goto LABEL_27;
  }
  *(_DWORD *)v55 = 1;
  *(_QWORD *)(v55 + 8) = v56;
  v17 = *(unsigned int *)a1;
  if ( (v17 & 0x2000) == 0 )
    goto LABEL_26;
LABEL_36:
  LODWORD(v18) = IO_new_file_close_it(
                   (__int64)a1,
                   a2,
                   a3,
                   a4,
                   a5,
                   a6,
                   a7,
                   a8,
                   a9,
                   v17,
                   a11,
                   a12,
                   (__int64)a13,
                   (__int64)a14,
                   (__int64)a15,
                   a16);
  v60 = *(_DWORD *)a1 & 0x8000;
LABEL_27:
  if ( v60 )
    goto LABEL_4;
  v61 = a1[17];
  v62 = *(_DWORD *)(v61 + 4);
  if ( !_libc_single_threaded )
  {
    if ( !v62 )
    {
      *(_QWORD *)(v61 + 8) = 0LL;
      v63 = (void *)a1[17];
      _aarch64_swp4_rel();
      if ( v70 > 1 )
        _lll_lock_wake_private(v63, v64, v65, v66, v67, v68, v69);
LABEL_4:
      v19 = a1[27];
      if ( (unsigned __int64)(v19 - (_QWORD)&_io_vtables) <= 0x92F )
        goto LABEL_5;
LABEL_31:
      IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
      (*(void (__fastcall **)(__int64 *, _QWORD))(v19 + 16))(a1, 0LL);
      if ( *((int *)a1 + 48) > 0 )
        goto LABEL_6;
      goto LABEL_32;
    }
LABEL_38:
    *(_DWORD *)(v61 + 4) = v62 - 1;
    goto LABEL_4;
  }
  if ( v62 )
    goto LABEL_38;
  *(_QWORD *)(v61 + 8) = 0LL;
  v19 = a1[27];
  *(_DWORD *)a1[17] = 0;
  if ( (unsigned __int64)(v19 - (_QWORD)&_io_vtables) > 0x92F )
    goto LABEL_31;
LABEL_5:
  (*(void (__fastcall **)(__int64 *, _QWORD))(v19 + 16))(a1, 0LL);
  if ( *((int *)a1 + 48) > 0 )
  {
LABEL_6:
    v28 = (__int64 *)a1[19];
    _aarch64_cas4_acq();
    if ( v43 )
      _lll_lock_wait_private(_gconv_lock, v35, v36, v37, v38, v39, v40, v41, v42, v29, v30, v31, v32, v33, v34);
    _gconv_release_step(*v28);
    _gconv_release_step(v28[7]);
    _aarch64_swp4_rel();
    if ( v50 > 1 )
      _lll_lock_wake_private(_gconv_lock, v44, v45, v46, v47, v48, v49);
    goto LABEL_10;
  }
LABEL_32:
  if ( a1[10] )
    IO_free_backup_area(a1, v20, v21, v22, v23, v24, v25, v26, v27);
LABEL_10:
  if ( a1 != (__int64 *)&IO_2_1_stdout_ && a1 != (__int64 *)&IO_2_1_stdin_ && a1 != &IO_2_1_stderr_ )
    free((unsigned __int64)a1, v20, v21, v22, v23, v24, v25, v26, v27);
  return (unsigned int)v18;
}
// 4339B4: variable 'v43' is possibly undefined
// 433B88: variable 'v35' is possibly undefined
// 433B88: variable 'v36' is possibly undefined
// 433B88: variable 'v37' is possibly undefined
// 433B88: variable 'v38' is possibly undefined
// 433B88: variable 'v39' is possibly undefined
// 433B88: variable 'v40' is possibly undefined
// 433B88: variable 'v41' is possibly undefined
// 433B88: variable 'v42' is possibly undefined
// 433B88: variable 'v29' is possibly undefined
// 433B88: variable 'v30' is possibly undefined
// 433B88: variable 'v31' is possibly undefined
// 433B88: variable 'v32' is possibly undefined
// 433B88: variable 'v33' is possibly undefined
// 433B88: variable 'v34' is possibly undefined
// 4339D8: variable 'v50' is possibly undefined
// 433B7C: variable 'v44' is possibly undefined
// 433B7C: variable 'v45' is possibly undefined
// 433B7C: variable 'v46' is possibly undefined
// 433B7C: variable 'v47' is possibly undefined
// 433B7C: variable 'v48' is possibly undefined
// 433B7C: variable 'v49' is possibly undefined
// 433A08: variable 'v20' is possibly undefined
// 433A08: variable 'v21' is possibly undefined
// 433A08: variable 'v22' is possibly undefined
// 433A08: variable 'v23' is possibly undefined
// 433A08: variable 'v24' is possibly undefined
// 433A08: variable 'v25' is possibly undefined
// 433A08: variable 'v26' is possibly undefined
// 433A08: variable 'v27' is possibly undefined
// 433A64: variable 'v59' is possibly undefined
// 433B94: variable 'a2' is possibly undefined
// 433B94: variable 'a3' is possibly undefined
// 433B94: variable 'a4' is possibly undefined
// 433B94: variable 'a5' is possibly undefined
// 433B94: variable 'a6' is possibly undefined
// 433B94: variable 'a7' is possibly undefined
// 433B94: variable 'a8' is possibly undefined
// 433B94: variable 'a9' is possibly undefined
// 433B94: variable 'v58' is possibly undefined
// 433B94: variable 'a11' is possibly undefined
// 433B94: variable 'a12' is possibly undefined
// 433B94: variable 'a13' is possibly undefined
// 433B94: variable 'a14' is possibly undefined
// 433B94: variable 'a15' is possibly undefined
// 433B14: variable 'a16' is possibly undefined
// 433B54: variable 'v70' is possibly undefined
// 433B5C: variable 'v64' is possibly undefined
// 433B5C: variable 'v65' is possibly undefined
// 433B5C: variable 'v66' is possibly undefined
// 433B5C: variable 'v67' is possibly undefined
// 433B5C: variable 'v68' is possibly undefined
// 433B5C: variable 'v69' is possibly undefined
// 490060: using guessed type __int64 IO_2_1_stderr_;
// 490228: using guessed type int IO_2_1_stdout_;
// 490F08: using guessed type char _libc_single_threaded;
// 496D30: using guessed type _DWORD _gconv_lock[2];

//----- (0000000000433B9C) ----------------------------------------------------
void __fastcall __noreturn sub_433B9C(_Unwind_Exception *exc)
{
  __int64 v1; // x19
  __int64 v3; // x1
  int v4; // w0
  void *v5; // x19
  __int64 v6; // x1
  __int64 v7; // x2
  __int64 v8; // x3
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  int v12; // w0

  if ( (*(_DWORD *)v1 & 0x8000) == 0 )
  {
    v3 = *(_QWORD *)(v1 + 136);
    v4 = *(_DWORD *)(v3 + 4);
    if ( _libc_single_threaded )
    {
      if ( !v4 )
      {
        *(_QWORD *)(v3 + 8) = 0LL;
        **(_DWORD **)(v1 + 136) = 0;
        goto LABEL_5;
      }
      goto LABEL_9;
    }
    if ( v4 )
    {
LABEL_9:
      *(_DWORD *)(v3 + 4) = v4 - 1;
      goto LABEL_5;
    }
    *(_QWORD *)(v3 + 8) = 0LL;
    v5 = *(void **)(v1 + 136);
    _aarch64_swp4_rel();
    if ( v12 > 1 )
      _lll_lock_wake_private(v5, v6, v7, v8, v9, v10, v11);
  }
LABEL_5:
  Unwind_Resume(exc);
}
// 433BA4: variable 'v1' is possibly undefined
// 433BF0: variable 'v12' is possibly undefined
// 433BF8: variable 'v6' is possibly undefined
// 433BF8: variable 'v7' is possibly undefined
// 433BF8: variable 'v8' is possibly undefined
// 433BF8: variable 'v9' is possibly undefined
// 433BF8: variable 'v10' is possibly undefined
// 433BF8: variable 'v11' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000433C20) ----------------------------------------------------
__int64 __fastcall _fopen_maybe_mmap(__int64 result)
{
  void *v1; // x2

  if ( (*(_QWORD *)(result + 112) & 0x100000000LL) != 0 && (*(_DWORD *)result & 8) != 0 )
  {
    v1 = &unk_48E0F8;
    if ( *(int *)(result + 192) <= 0 )
      v1 = &unk_48DF00;
    *(_QWORD *)(result + 216) = v1;
    *(_QWORD *)(*(_QWORD *)(result + 160) + 224LL) = &unk_48E0F8;
  }
  return result;
}

//----- (0000000000433C60) ----------------------------------------------------
unsigned __int64 __fastcall _fopen_internal(
        char *a1,
        unsigned __int8 *a2,
        __int64 a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  unsigned __int64 v18; // x0
  unsigned __int64 v19; // x19
  unsigned __int64 v20; // x20
  void *v21; // x1
  double v23; // d0
  double v24; // d1
  double v25; // d2
  double v26; // d3
  double v27; // d4
  double v28; // d5
  double v29; // d6
  double v30; // d7

  v18 = malloc(472LL, (__int64)a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
  if ( !v18 )
    return 0LL;
  v19 = v18;
  *(_QWORD *)(v18 + 136) = v18 + 224;
  v20 = v18;
  IO_no_init(v18, 0, 0, v18 + 240, (__int64)&IO_wfile_jumps);
  *(_QWORD *)(v19 + 216) = &IO_file_jumps;
  IO_new_file_init_internal(v19);
  if ( !IO_new_file_fopen(v19, a1, a2) )
  {
    IO_un_link(v19);
    free(v19, v23, v24, v25, v26, v27, v28, v29, v30);
    return 0LL;
  }
  if ( (*(_QWORD *)(v19 + 112) & 0x100000000LL) != 0 && (*(_DWORD *)v19 & 8) != 0 )
  {
    v21 = &unk_48E0F8;
    if ( *(int *)(v19 + 192) <= 0 )
      v21 = &unk_48DF00;
    *(_QWORD *)(v19 + 216) = v21;
    *(_QWORD *)(*(_QWORD *)(v19 + 160) + 224LL) = &unk_48E0F8;
  }
  return v20;
}
// 433D40: variable 'v23' is possibly undefined
// 433D40: variable 'v24' is possibly undefined
// 433D40: variable 'v25' is possibly undefined
// 433D40: variable 'v26' is possibly undefined
// 433D40: variable 'v27' is possibly undefined
// 433D40: variable 'v28' is possibly undefined
// 433D40: variable 'v29' is possibly undefined
// 433D40: variable 'v30' is possibly undefined

//----- (0000000000433D4C) ----------------------------------------------------
unsigned __int64 __fastcall fopen64(
        char *a1,
        unsigned __int8 *a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        void *a12,
        void *a13,
        void *a14,
        void *a15,
        __int64 a16)
{
  return _fopen_internal(a1, a2, 1LL, a12, a13, a14, a15, a16, a3, a4, a5, a6, a7, a8, a9, a10);
}

//----- (0000000000433D60) ----------------------------------------------------
__int64 __fastcall fputs(__int64 a1, __int64 a2)
{
  unsigned __int64 (__fastcall *v4)(__int64); // x20
  double v5; // d0
  double v6; // d1
  double v7; // d2
  double v8; // d3
  double v9; // d4
  double v10; // d5
  double v11; // d6
  double v12; // d7
  unsigned __int64 StatusReg; // x3
  __int64 v14; // x2
  __int64 v15; // x3
  __int64 v16; // x0
  __int64 v17; // x1
  __int64 v18; // x2
  void *v19; // x4
  void *v20; // x5
  void *v21; // x6
  __int64 v22; // x3
  int v23; // w0
  int v24; // w0
  __int64 v25; // x1
  unsigned int v26; // w20
  __int64 v27; // x1
  int v28; // w0
  void *v30; // x19
  __int64 v31; // x1
  __int64 v32; // x2
  __int64 v33; // x3
  void *v34; // x4
  void *v35; // x5
  void *v36; // x6
  int v37; // w0
  _DWORD *v38; // [xsp+30h] [xbp+30h]
  __int64 v39; // [xsp+30h] [xbp+30h]
  __int64 v40; // [xsp+38h] [xbp+38h]

  v4 = strlen();
  if ( (*(_DWORD *)a2 & 0x8000) == 0 )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v14 = *(_QWORD *)(a2 + 136);
    v15 = StatusReg - 1824;
    v16 = *(_QWORD *)(v14 + 8);
    if ( !_libc_single_threaded || v16 )
    {
      if ( v15 == v16 )
      {
        ++*(_DWORD *)(v14 + 4);
      }
      else
      {
        v38 = *(_DWORD **)(a2 + 136);
        v40 = v15;
        _aarch64_cas4_acq();
        v22 = v40;
        if ( v23 )
        {
          _lll_lock_wait_private(v38, v5, v6, v7, v8, v9, v10, v11, v12, v17, v18, v40, v19, v20, v21);
          v22 = v40;
        }
        *(_QWORD *)(*(_QWORD *)(a2 + 136) + 8LL) = v22;
      }
    }
    else
    {
      *(_DWORD *)v14 = 1;
      *(_QWORD *)(v14 + 8) = v15;
    }
  }
  v24 = *(_DWORD *)(a2 + 192);
  if ( v24 )
  {
    if ( v24 != -1 )
    {
LABEL_12:
      v26 = -1;
      goto LABEL_13;
    }
  }
  else
  {
    *(_DWORD *)(a2 + 192) = -1;
  }
  v25 = *(_QWORD *)(a2 + 216);
  if ( (unsigned __int64)(v25 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v39 = *(_QWORD *)(a2 + 216);
    IO_vtable_check(v5, v6, v7, v8, v9, v10, v11, v12);
    v25 = v39;
  }
  if ( v4 != (unsigned __int64 (__fastcall *)(__int64))(*(__int64 (__fastcall **)(__int64, __int64, unsigned __int64 (__fastcall *)(__int64)))(v25 + 56))(
                                                         a2,
                                                         a1,
                                                         v4) )
    goto LABEL_12;
  v26 = 1;
LABEL_13:
  if ( (*(_DWORD *)a2 & 0x8000) != 0 )
    return v26;
  v27 = *(_QWORD *)(a2 + 136);
  v28 = *(_DWORD *)(v27 + 4);
  if ( _libc_single_threaded )
  {
    if ( !v28 )
    {
      *(_QWORD *)(v27 + 8) = 0LL;
      **(_DWORD **)(a2 + 136) = 0;
      return v26;
    }
  }
  else if ( !v28 )
  {
    *(_QWORD *)(v27 + 8) = 0LL;
    v30 = *(void **)(a2 + 136);
    _aarch64_swp4_rel();
    if ( v37 > 1 )
      _lll_lock_wake_private(v30, v31, v32, v33, v34, v35, v36);
    return v26;
  }
  *(_DWORD *)(v27 + 4) = v28 - 1;
  return v26;
}
// 433DC4: variable 'v23' is possibly undefined
// 433EF0: variable 'v5' is possibly undefined
// 433EF0: variable 'v6' is possibly undefined
// 433EF0: variable 'v7' is possibly undefined
// 433EF0: variable 'v8' is possibly undefined
// 433EF0: variable 'v9' is possibly undefined
// 433EF0: variable 'v10' is possibly undefined
// 433EF0: variable 'v11' is possibly undefined
// 433EF0: variable 'v12' is possibly undefined
// 433EF0: variable 'v17' is possibly undefined
// 433EF0: variable 'v18' is possibly undefined
// 433EF0: variable 'v19' is possibly undefined
// 433EF0: variable 'v20' is possibly undefined
// 433EF0: variable 'v21' is possibly undefined
// 433EB0: variable 'v37' is possibly undefined
// 433EB8: variable 'v31' is possibly undefined
// 433EB8: variable 'v32' is possibly undefined
// 433EB8: variable 'v33' is possibly undefined
// 433EB8: variable 'v34' is possibly undefined
// 433EB8: variable 'v35' is possibly undefined
// 433EB8: variable 'v36' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000433EFC) ----------------------------------------------------
void __fastcall __noreturn sub_433EFC(_Unwind_Exception *exc)
{
  __int64 v1; // x19
  __int64 v3; // x1
  int v4; // w0
  void *v5; // x19
  __int64 v6; // x1
  __int64 v7; // x2
  __int64 v8; // x3
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  int v12; // w0

  if ( (*(_DWORD *)v1 & 0x8000) == 0 )
  {
    v3 = *(_QWORD *)(v1 + 136);
    v4 = *(_DWORD *)(v3 + 4);
    if ( _libc_single_threaded )
    {
      if ( !v4 )
      {
        *(_QWORD *)(v3 + 8) = 0LL;
        **(_DWORD **)(v1 + 136) = 0;
        goto LABEL_5;
      }
      goto LABEL_9;
    }
    if ( v4 )
    {
LABEL_9:
      *(_DWORD *)(v3 + 4) = v4 - 1;
      goto LABEL_5;
    }
    *(_QWORD *)(v3 + 8) = 0LL;
    v5 = *(void **)(v1 + 136);
    _aarch64_swp4_rel();
    if ( v12 > 1 )
      _lll_lock_wake_private(v5, v6, v7, v8, v9, v10, v11);
  }
LABEL_5:
  Unwind_Resume(exc);
}
// 433F04: variable 'v1' is possibly undefined
// 433F50: variable 'v12' is possibly undefined
// 433F58: variable 'v6' is possibly undefined
// 433F58: variable 'v7' is possibly undefined
// 433F58: variable 'v8' is possibly undefined
// 433F58: variable 'v9' is possibly undefined
// 433F58: variable 'v10' is possibly undefined
// 433F58: variable 'v11' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000433F80) ----------------------------------------------------
unsigned __int64 __fastcall fwrite(
        __int64 a1,
        unsigned __int64 a2,
        __int64 a3,
        __int64 a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  __int64 v12; // x20
  unsigned __int64 StatusReg; // x4
  __int64 v18; // x2
  void *v19; // x4
  void *v20; // x0
  __int64 v21; // x1
  __int64 v22; // x2
  void *v23; // x5
  void *v24; // x6
  void *v25; // x4
  int v26; // w0
  int v27; // w0
  __int64 v28; // x1
  unsigned __int64 v29; // x2
  _BOOL4 v30; // w3
  bool v31; // zf
  __int64 v33; // x1
  int v34; // w0
  void *v35; // x19
  __int64 v36; // x1
  void *v37; // x4
  void *v38; // x5
  void *v39; // x6
  int v40; // w0
  bool v41; // zf
  _DWORD *v42; // [xsp+38h] [xbp+38h]
  __int64 v43; // [xsp+38h] [xbp+38h]
  __int64 v44; // [xsp+38h] [xbp+38h]
  __int64 v45; // [xsp+40h] [xbp+40h]
  _BOOL4 v46; // [xsp+40h] [xbp+40h]
  __int64 v47; // [xsp+40h] [xbp+40h]
  void *v48; // [xsp+48h] [xbp+48h]

  v12 = a2 * a3;
  if ( !(a2 * a3) )
    return v12;
  if ( (*(_DWORD *)a4 & 0x8000) == 0 )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v18 = *(_QWORD *)(a4 + 136);
    v19 = (void *)(StatusReg - 1824);
    v20 = *(void **)(v18 + 8);
    if ( _libc_single_threaded && !v20 )
    {
      *(_DWORD *)v18 = 1;
      *(_QWORD *)(v18 + 8) = v19;
    }
    else if ( v19 == v20 )
    {
      ++*(_DWORD *)(v18 + 4);
    }
    else
    {
      v42 = *(_DWORD **)(a4 + 136);
      v45 = a1;
      v48 = v19;
      _aarch64_cas4_acq();
      a1 = v45;
      v25 = v48;
      if ( v26 )
      {
        _lll_lock_wait_private(v42, a5, a6, a7, a8, a9, a10, a11, a12, v21, v22, v45, v48, v23, v24);
        v25 = v48;
        a1 = v45;
      }
      *(_QWORD *)(*(_QWORD *)(a4 + 136) + 8LL) = v25;
    }
  }
  v27 = *(_DWORD *)(a4 + 192);
  if ( v27 )
  {
    if ( v27 != -1 )
    {
      if ( (*(_DWORD *)a4 & 0x8000) != 0 )
        return 0LL;
      v30 = 0;
      v29 = 0LL;
      goto LABEL_24;
    }
  }
  else
  {
    *(_DWORD *)(a4 + 192) = -1;
  }
  v28 = *(_QWORD *)(a4 + 216);
  if ( (unsigned __int64)(v28 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v44 = *(_QWORD *)(a4 + 216);
    v47 = a1;
    IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
    v28 = v44;
    a1 = v47;
  }
  v29 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v28 + 56))(a4, a1, v12);
  v30 = v29 == -1LL;
  if ( (*(_DWORD *)a4 & 0x8000) == 0 )
  {
LABEL_24:
    v33 = *(_QWORD *)(a4 + 136);
    v34 = *(_DWORD *)(v33 + 4);
    if ( _libc_single_threaded )
    {
      if ( !v34 )
      {
        *(_QWORD *)(v33 + 8) = 0LL;
        **(_DWORD **)(a4 + 136) = 0;
        goto LABEL_14;
      }
    }
    else if ( !v34 )
    {
      *(_QWORD *)(v33 + 8) = 0LL;
      v43 = v29;
      v35 = *(void **)(a4 + 136);
      v46 = v30;
      _aarch64_swp4_rel();
      v29 = v43;
      v30 = v46;
      if ( v40 > 1 )
      {
        _lll_lock_wake_private(v35, v36, v43, v46, v37, v38, v39);
        v29 = v43;
        v30 = v46;
      }
      goto LABEL_14;
    }
    *(_DWORD *)(v33 + 4) = v34 - 1;
    v41 = v30 || v29 == v12;
    v12 = a3;
    if ( !v41 )
      return v29 / a2;
    return v12;
  }
LABEL_14:
  v31 = v30 || v29 == v12;
  v12 = a3;
  if ( v31 )
    return v12;
  return v29 / a2;
}
// 433FF4: variable 'v26' is possibly undefined
// 43417C: variable 'a5' is possibly undefined
// 43417C: variable 'a6' is possibly undefined
// 43417C: variable 'a7' is possibly undefined
// 43417C: variable 'a8' is possibly undefined
// 43417C: variable 'a9' is possibly undefined
// 43417C: variable 'a10' is possibly undefined
// 43417C: variable 'a11' is possibly undefined
// 43417C: variable 'a12' is possibly undefined
// 43417C: variable 'v21' is possibly undefined
// 43417C: variable 'v22' is possibly undefined
// 43417C: variable 'v23' is possibly undefined
// 43417C: variable 'v24' is possibly undefined
// 4340F8: variable 'v40' is possibly undefined
// 434104: variable 'v36' is possibly undefined
// 434104: variable 'v37' is possibly undefined
// 434104: variable 'v38' is possibly undefined
// 434104: variable 'v39' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000434188) ----------------------------------------------------
void __fastcall __noreturn sub_434188(_Unwind_Exception *exc)
{
  __int64 v1; // x19
  __int64 v3; // x1
  int v4; // w0
  void *v5; // x19
  __int64 v6; // x1
  __int64 v7; // x2
  __int64 v8; // x3
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  int v12; // w0

  if ( (*(_DWORD *)v1 & 0x8000) == 0 )
  {
    v3 = *(_QWORD *)(v1 + 136);
    v4 = *(_DWORD *)(v3 + 4);
    if ( _libc_single_threaded )
    {
      if ( !v4 )
      {
        *(_QWORD *)(v3 + 8) = 0LL;
        **(_DWORD **)(v1 + 136) = 0;
        goto LABEL_5;
      }
      goto LABEL_9;
    }
    if ( v4 )
    {
LABEL_9:
      *(_DWORD *)(v3 + 4) = v4 - 1;
      goto LABEL_5;
    }
    *(_QWORD *)(v3 + 8) = 0LL;
    v5 = *(void **)(v1 + 136);
    _aarch64_swp4_rel();
    if ( v12 > 1 )
      _lll_lock_wake_private(v5, v6, v7, v8, v9, v10, v11);
  }
LABEL_5:
  Unwind_Resume(exc);
}
// 434190: variable 'v1' is possibly undefined
// 4341DC: variable 'v12' is possibly undefined
// 4341E4: variable 'v6' is possibly undefined
// 4341E4: variable 'v7' is possibly undefined
// 4341E4: variable 'v8' is possibly undefined
// 4341E4: variable 'v9' is possibly undefined
// 4341E4: variable 'v10' is possibly undefined
// 4341E4: variable 'v11' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000434200) ----------------------------------------------------
__int64 __fastcall getdelim(
        unsigned __int64 *a1,
        __int64 a2,
        __int64 a3,
        _QWORD *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  int v17; // w19
  unsigned __int64 *v19; // x23
  unsigned __int64 StatusReg; // x19
  __int64 v21; // x21
  unsigned __int64 v22; // x19
  __int64 v23; // x0
  int v24; // w0
  bool v25; // zf
  __int64 v26; // x21
  __int64 v27; // x19
  __int64 v28; // x28
  __int64 v29; // x25
  unsigned __int64 v30; // x1
  unsigned __int64 v31; // x2
  unsigned __int64 v32; // x21
  unsigned __int64 v33; // x0
  __int64 v34; // x1
  __int64 v35; // x2
  unsigned __int64 v36; // x3
  __int64 v37; // x4
  __int64 v38; // x5
  void *v39; // x6
  double v40; // d0
  double v41; // d1
  double v42; // d2
  double v43; // d3
  double v44; // d4
  double v45; // d5
  double v46; // d6
  double v47; // d7
  void *v48; // x3
  void *v49; // x4
  void *v50; // x5
  void *v51; // x6
  __int64 v52; // x7
  unsigned __int64 (__fastcall *v53)(__int64, unsigned int, unsigned __int64); // x27
  double v54; // d0
  double v55; // d1
  double v56; // d2
  double v57; // d3
  double v58; // d4
  double v59; // d5
  double v60; // d6
  double v61; // d7
  __int64 v62; // x1
  int v63; // w0
  unsigned __int64 v65; // x0
  void *v66; // x19
  __int64 v67; // x1
  __int64 v68; // x2
  __int64 v69; // x3
  void *v70; // x4
  void *v71; // x5
  void *v72; // x6
  int v73; // w0

  v17 = *(_DWORD *)a4;
  v19 = (unsigned __int64 *)a2;
  if ( (*(_DWORD *)a4 & 0x8000) != 0 )
  {
    if ( (v17 & 0x20) != 0 )
      return -1LL;
  }
  else
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v21 = a4[17];
    v22 = StatusReg - 1824;
    a2 = (unsigned __int8)_libc_single_threaded;
    v23 = *(_QWORD *)(v21 + 8);
    if ( !_libc_single_threaded || v23 )
    {
      if ( v22 == v23 )
      {
        ++*(_DWORD *)(v21 + 4);
      }
      else
      {
        _aarch64_cas4_acq();
        if ( v24 )
          _lll_lock_wait_private((_DWORD *)v21, a9, a10, a11, a12, a13, a14, a15, a16, a2, a3, (__int64)a4, a5, a6, a7);
        *(_QWORD *)(a4[17] + 8LL) = v22;
      }
    }
    else
    {
      *(_DWORD *)v21 = 1;
      *(_QWORD *)(v21 + 8) = v22;
    }
    v17 = *(_DWORD *)a4;
    if ( (*(_DWORD *)a4 & 0x20) != 0 )
    {
      v29 = -1LL;
      goto LABEL_31;
    }
  }
  if ( a1 )
    v25 = v19 == 0LL;
  else
    v25 = 1;
  if ( v25 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
LABEL_29:
    v17 = *(_DWORD *)a4;
    goto LABEL_30;
  }
  if ( !*a1 || !*v19 )
  {
    *v19 = 120LL;
    v65 = malloc(120LL, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
    *a1 = v65;
    if ( v65 )
    {
      v26 = a4[1];
      v27 = a4[2] - v26;
      if ( v27 > 0 )
        goto LABEL_15;
      goto LABEL_40;
    }
LABEL_30:
    v17 |= 0x20u;
    v29 = -1LL;
    *(_DWORD *)a4 = v17;
    goto LABEL_31;
  }
  v26 = a4[1];
  v27 = a4[2] - v26;
  if ( v27 > 0 )
    goto LABEL_15;
LABEL_40:
  if ( (unsigned int)_underflow(
                       (__int64)a4,
                       a9,
                       a10,
                       a11,
                       a12,
                       a13,
                       a14,
                       a15,
                       a16,
                       a2,
                       a3,
                       (unsigned __int64)a4,
                       (__int64)a5,
                       (__int64)a6,
                       a7) == -1 )
  {
    v17 = *(_DWORD *)a4;
    v29 = -1LL;
    goto LABEL_31;
  }
  v26 = a4[1];
  v27 = a4[2] - v26;
LABEL_15:
  v28 = 0LL;
  while ( 1 )
  {
    v53 = memchr();
    if ( v53 )
      v27 = (__int64)v53 - v26 + 1;
    if ( v27 >= 0x7FFFFFFFFFFFFFFFLL - v28 )
    {
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 75;
      goto LABEL_29;
    }
    v29 = v27 + v28;
    v30 = v27 + v28 + 1;
    if ( *v19 < v30 )
    {
      v31 = 2 * *v19;
      if ( v31 < v30 )
        v32 = v27 + v28 + 1;
      else
        v32 = 2 * *v19;
      v33 = realloc(*a1, v32, v31, v48, v49, v50, v51, v52, v54, v55, v56, v57, v58, v59, v60, v61);
      if ( !v33 )
        goto LABEL_29;
      *a1 = v33;
      *v19 = v32;
    }
    j_memcpy();
    a4[1] += v27;
    if ( v53
      || (unsigned int)_underflow((__int64)a4, v40, v41, v42, v43, v44, v45, v46, v47, v34, v35, v36, v37, v38, v39) == -1 )
    {
      break;
    }
    v26 = a4[1];
    v28 += v27;
    v27 = a4[2] - v26;
  }
  *(_BYTE *)(*a1 + v29) = 0;
  v17 = *(_DWORD *)a4;
LABEL_31:
  if ( (v17 & 0x8000) != 0 )
    return v29;
  v62 = a4[17];
  v63 = *(_DWORD *)(v62 + 4);
  if ( _libc_single_threaded )
  {
    if ( !v63 )
    {
      *(_QWORD *)(v62 + 8) = 0LL;
      *(_DWORD *)a4[17] = 0;
      return v29;
    }
  }
  else if ( !v63 )
  {
    *(_QWORD *)(v62 + 8) = 0LL;
    v66 = (void *)a4[17];
    _aarch64_swp4_rel();
    if ( v73 > 1 )
      _lll_lock_wake_private(v66, v67, v68, v69, v70, v71, v72);
    return v29;
  }
  *(_DWORD *)(v62 + 4) = v63 - 1;
  return v29;
}
// 43426C: variable 'v24' is possibly undefined
// 4344A8: variable 'a9' is possibly undefined
// 4344A8: variable 'a10' is possibly undefined
// 4344A8: variable 'a11' is possibly undefined
// 4344A8: variable 'a12' is possibly undefined
// 4344A8: variable 'a13' is possibly undefined
// 4344A8: variable 'a14' is possibly undefined
// 4344A8: variable 'a15' is possibly undefined
// 4344A8: variable 'a16' is possibly undefined
// 4344A8: variable 'a2' is possibly undefined
// 4344A8: variable 'a3' is possibly undefined
// 4344A8: variable 'a4' is possibly undefined
// 4344A8: variable 'a5' is possibly undefined
// 4344A8: variable 'a6' is possibly undefined
// 4344A8: variable 'a7' is possibly undefined
// 4342E0: variable 'v48' is possibly undefined
// 4342E0: variable 'v49' is possibly undefined
// 4342E0: variable 'v50' is possibly undefined
// 4342E0: variable 'v51' is possibly undefined
// 4342E0: variable 'v52' is possibly undefined
// 4342E0: variable 'v54' is possibly undefined
// 4342E0: variable 'v55' is possibly undefined
// 4342E0: variable 'v56' is possibly undefined
// 4342E0: variable 'v57' is possibly undefined
// 4342E0: variable 'v58' is possibly undefined
// 4342E0: variable 'v59' is possibly undefined
// 4342E0: variable 'v60' is possibly undefined
// 4342E0: variable 'v61' is possibly undefined
// 434318: variable 'v40' is possibly undefined
// 434318: variable 'v41' is possibly undefined
// 434318: variable 'v42' is possibly undefined
// 434318: variable 'v43' is possibly undefined
// 434318: variable 'v44' is possibly undefined
// 434318: variable 'v45' is possibly undefined
// 434318: variable 'v46' is possibly undefined
// 434318: variable 'v47' is possibly undefined
// 434318: variable 'v34' is possibly undefined
// 434318: variable 'v35' is possibly undefined
// 434318: variable 'v36' is possibly undefined
// 434318: variable 'v37' is possibly undefined
// 434318: variable 'v38' is possibly undefined
// 434318: variable 'v39' is possibly undefined
// 4343E0: variable 'a8' is possibly undefined
// 43447C: variable 'v73' is possibly undefined
// 434484: variable 'v67' is possibly undefined
// 434484: variable 'v68' is possibly undefined
// 434484: variable 'v69' is possibly undefined
// 434484: variable 'v70' is possibly undefined
// 434484: variable 'v71' is possibly undefined
// 434484: variable 'v72' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (00000000004344D4) ----------------------------------------------------
void __fastcall __noreturn sub_4344D4(_Unwind_Exception *exc)
{
  __int64 v1; // x20
  __int64 v3; // x1
  int v4; // w0
  void *v5; // x19
  __int64 v6; // x1
  __int64 v7; // x2
  __int64 v8; // x3
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  int v12; // w0

  if ( (*(_DWORD *)v1 & 0x8000) == 0 )
  {
    v3 = *(_QWORD *)(v1 + 136);
    v4 = *(_DWORD *)(v3 + 4);
    if ( _libc_single_threaded )
    {
      if ( !v4 )
      {
        *(_QWORD *)(v3 + 8) = 0LL;
        **(_DWORD **)(v1 + 136) = 0;
        goto LABEL_5;
      }
      goto LABEL_9;
    }
    if ( v4 )
    {
LABEL_9:
      *(_DWORD *)(v3 + 4) = v4 - 1;
      goto LABEL_5;
    }
    *(_QWORD *)(v3 + 8) = 0LL;
    v5 = *(void **)(v1 + 136);
    _aarch64_swp4_rel();
    if ( v12 > 1 )
      _lll_lock_wake_private(v5, v6, v7, v8, v9, v10, v11);
  }
LABEL_5:
  Unwind_Resume(exc);
}
// 4344DC: variable 'v1' is possibly undefined
// 434528: variable 'v12' is possibly undefined
// 434530: variable 'v6' is possibly undefined
// 434530: variable 'v7' is possibly undefined
// 434530: variable 'v8' is possibly undefined
// 434530: variable 'v9' is possibly undefined
// 434530: variable 'v10' is possibly undefined
// 434530: variable 'v11' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000434560) ----------------------------------------------------
__int64 __fastcall save_for_wbackup(
        __int64 a1,
        __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  _QWORD *v18; // x6
  _DWORD *v19; // x3
  __int64 v20; // x0
  __int64 v21; // x1
  __int64 v22; // x4
  _DWORD *v23; // x0
  __int64 v24; // x2
  __int64 v25; // x0
  __int64 v26; // x2
  unsigned __int64 v27; // x5
  unsigned __int64 v28; // x5
  __int64 v29; // x7
  __int64 v30; // x0
  __int64 v32; // x21
  unsigned __int64 v33; // x0
  double v34; // d0
  double v35; // d1
  double v36; // d2
  double v37; // d3
  double v38; // d4
  double v39; // d5
  double v40; // d6
  double v41; // d7
  unsigned __int64 v42; // x7
  _QWORD *v43; // x2
  unsigned __int64 v44; // x7
  __int64 v45; // x1
  __int64 v46; // x7
  __int64 v47; // x0
  char *v48; // x0
  __int64 v49; // x9
  unsigned __int64 v50; // [xsp+30h] [xbp+30h]
  unsigned __int64 v51; // [xsp+30h] [xbp+30h]
  __int64 v52; // [xsp+30h] [xbp+30h]
  unsigned __int64 v53; // [xsp+38h] [xbp+38h]
  unsigned __int64 v54; // [xsp+38h] [xbp+38h]
  __int64 v55; // [xsp+40h] [xbp+40h]
  __int64 v56; // [xsp+40h] [xbp+40h]
  __int64 v57; // [xsp+48h] [xbp+48h]

  v18 = *(_QWORD **)(a1 + 160);
  v19 = *(_DWORD **)(a1 + 96);
  v20 = a2 - v18[2];
  v21 = v20 >> 2;
  if ( !v19 )
  {
    v49 = v18[10];
    if ( (v20 & 0x8000000000000000LL) == 0 )
    {
      v18[9] = v49;
      return 0LL;
    }
    v29 = v49 - v18[8];
    goto LABEL_19;
  }
  v22 = v20 >> 2;
  v23 = v19;
  do
  {
    v24 = (int)v23[4];
    v23 = *(_DWORD **)v23;
    if ( v22 > v24 )
      v22 = v24;
  }
  while ( v23 );
  v25 = v18[8];
  v26 = v21 - v22;
  v27 = (v18[10] - v25) >> 2;
  if ( v21 - v22 <= v27 )
  {
    v28 = v27 - v26;
    v29 = 4 * v28;
    v30 = v25 + 4 * v28;
    if ( (v22 & 0x8000000000000000LL) == 0 )
    {
      if ( !v26 )
      {
        v18[9] = v30;
        goto LABEL_10;
      }
      v52 = 4 * v28;
      wmemcpy();
      v43 = *(_QWORD **)(a1 + 160);
      v46 = v52;
      v47 = v43[8];
      goto LABEL_20;
    }
LABEL_19:
    v56 = v29;
    wmemmove();
    wmemcpy();
    v43 = *(_QWORD **)(a1 + 160);
    v46 = v56;
    v47 = v43[8];
LABEL_20:
    v44 = v47 + v46;
    v19 = *(_DWORD **)(a1 + 96);
    v21 = (a2 - v43[2]) >> 2;
    goto LABEL_16;
  }
  v32 = 4 * (v26 + 100);
  v55 = v22;
  v57 = v18[10];
  v33 = malloc(v32, v21, v26, v19, (void *)v22, (void *)v27, v18, a16, a3, a4, a5, a6, a7, a8, a9, a10);
  if ( v33 )
  {
    v53 = v33;
    v50 = v33 + 400;
    if ( v55 < 0 )
    {
      v48 = wmempcpy(v33 + 400, v57 + 4 * v55, -v55);
      wmempcpy(
        (__int64)v48,
        *(_QWORD *)(*(_QWORD *)(a1 + 160) + 16LL),
        (a2 - *(_QWORD *)(*(_QWORD *)(a1 + 160) + 16LL)) >> 2);
    }
    else
    {
      wmemcpy();
    }
    v42 = v50;
    v51 = v53;
    v54 = v42;
    free(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 64LL), v34, v35, v36, v37, v38, v39, v40, v41);
    v43 = *(_QWORD **)(a1 + 160);
    v44 = v54;
    v45 = v43[2];
    v43[8] = v51;
    v43[10] = v51 + v32;
    v19 = *(_DWORD **)(a1 + 96);
    v21 = (a2 - v45) >> 2;
LABEL_16:
    for ( v43[9] = v44; v19; v19 = *(_DWORD **)v19 )
LABEL_10:
      v19[4] -= v21;
    return 0LL;
  }
  return 0xFFFFFFFFLL;
}
// 434660: variable 'v34' is possibly undefined
// 434660: variable 'v35' is possibly undefined
// 434660: variable 'v36' is possibly undefined
// 434660: variable 'v37' is possibly undefined
// 434660: variable 'v38' is possibly undefined
// 434660: variable 'v39' is possibly undefined
// 434660: variable 'v40' is possibly undefined
// 434660: variable 'v41' is possibly undefined

//----- (0000000000434780) ----------------------------------------------------
__int64 __fastcall IO_least_wmarker(__int64 a1, __int64 a2)
{
  __int64 result; // x0
  __int64 **v4; // x1
  __int64 v5; // x2

  result = (a2 - *(_QWORD *)(*(_QWORD *)(a1 + 160) + 16LL)) >> 2;
  v4 = *(__int64 ***)(a1 + 96);
  while ( v4 )
  {
    v5 = *((int *)v4 + 4);
    v4 = (__int64 **)*v4;
    if ( result > v5 )
      result = v5;
  }
  return result;
}

//----- (00000000004347C0) ----------------------------------------------------
_QWORD *__fastcall IO_switch_to_main_wget_area(__int64 a1)
{
  _QWORD *result; // x0
  __int64 v2; // x2
  __int64 v3; // x3
  __int64 v4; // x1

  *(_DWORD *)a1 &= ~0x100u;
  result = *(_QWORD **)(a1 + 160);
  v2 = result[2];
  v3 = result[10];
  result[10] = result[1];
  v4 = result[8];
  *result = v4;
  result[1] = v3;
  result[2] = v4;
  result[8] = v2;
  return result;
}

//----- (00000000004347F0) ----------------------------------------------------
_QWORD *__fastcall IO_switch_to_wbackup_area(__int64 a1)
{
  _QWORD *result; // x0
  __int64 v2; // x1
  __int64 v3; // x2
  __int64 v4; // x3

  *(_DWORD *)a1 |= 0x100u;
  result = *(_QWORD **)(a1 + 160);
  v2 = result[10];
  v4 = result[1];
  v3 = result[2];
  *result = v2;
  result[1] = v2;
  result[2] = result[8];
  result[8] = v3;
  result[10] = v4;
  return result;
}

//----- (0000000000434820) ----------------------------------------------------
__int64 __fastcall IO_wsetb(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        int a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  __int64 v12; // x4
  __int64 v13; // x5
  unsigned __int64 v14; // x0
  __int64 v15; // x1
  __int64 result; // x0
  int v17; // w1
  __int64 v18; // [xsp+10h] [xbp+10h]
  __int64 v19; // [xsp+18h] [xbp+18h]
  __int64 v20; // [xsp+20h] [xbp+20h]
  int v21; // [xsp+2Ch] [xbp+2Ch]

  v12 = a1;
  v13 = *(_QWORD *)(a1 + 160);
  v14 = *(_QWORD *)(v13 + 48);
  if ( v14 && (*(_QWORD *)(v12 + 112) & 0x800000000LL) == 0 )
  {
    v18 = v12;
    v19 = a2;
    v20 = a3;
    v21 = a4;
    free(v14, a5, a6, a7, a8, a9, a10, a11, a12);
    v12 = v18;
    a2 = v19;
    a3 = v20;
    a4 = v21;
    v13 = *(_QWORD *)(v18 + 160);
  }
  *(_QWORD *)(v13 + 48) = a2;
  *(_QWORD *)(v13 + 56) = a3;
  v15 = (__int64)(*(_QWORD *)(v12 + 112) << 8) >> 40;
  result = (unsigned int)v15 & 0xFFFFFFF7;
  v17 = v15 | 8;
  if ( a4 )
    v17 = result;
  *(_WORD *)(v12 + 116) = v17;
  *(_BYTE *)(v12 + 118) = BYTE2(v17);
  return result;
}

//----- (00000000004348A0) ----------------------------------------------------
__int64 __fastcall IO_wdefault_pbackfail(
        _QWORD *a1,
        unsigned int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  __int64 v10; // x3
  _DWORD *v11; // x5
  __int64 v12; // x6
  __int64 *v13; // x2
  __int64 v14; // x7
  void *v15; // x4
  unsigned __int64 v16; // x1
  __int64 v17; // x1
  int v18; // w0
  __int64 v19; // x7
  unsigned __int64 v20; // x0
  __int64 v21; // x1
  __int64 v23; // x6
  unsigned __int64 v24; // x0
  double v25; // d0
  double v26; // d1
  double v27; // d2
  double v28; // d3
  double v29; // d4
  double v30; // d5
  double v31; // d6
  double v32; // d7
  unsigned __int64 *v33; // x2
  unsigned __int64 v35; // [xsp+10h] [xbp+10h]
  __int64 *v36; // [xsp+10h] [xbp+10h]
  int v37; // [xsp+18h] [xbp+18h]
  unsigned __int64 v38; // [xsp+18h] [xbp+18h]
  __int64 v39; // [xsp+18h] [xbp+18h]
  int v41; // [xsp+20h] [xbp+20h]
  int v42; // [xsp+28h] [xbp+28h]
  int v44; // [xsp+30h] [xbp+30h]
  unsigned __int64 v45; // [xsp+38h] [xbp+38h]

  v10 = a2;
  v11 = a1;
  v12 = *(unsigned int *)a1;
  v13 = (__int64 *)a1[20];
  v14 = v12 & 0x100;
  v15 = (void *)*v13;
  v16 = v13[2];
  if ( *v13 <= v16 )
  {
    if ( (v12 & 0x100) != 0 )
    {
      v23 = v13[1];
      v42 = v10;
      v35 = v23 - v16;
      v24 = malloc(
              2 * (v23 - v16),
              v16,
              (__int64)v13,
              (void *)v10,
              v15,
              a1,
              (void *)(v23 - v16),
              v14,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              a9,
              a10);
      if ( v24 )
      {
        v45 = v24;
        v38 = v24 + v35;
        wmemcpy();
        free(*(_QWORD *)(a1[20] + 16LL), v25, v26, v27, v28, v29, v30, v31, v32);
        v33 = (unsigned __int64 *)a1[20];
        *v33 = v38;
        v33[1] = v38 + v35;
        LODWORD(v10) = v42;
        *v33 = v38 - 4;
        v33[2] = v45;
        v33[9] = v38;
        *(_DWORD *)(v38 - 4) = v42;
        return (unsigned int)v10;
      }
      return 0xFFFFFFFFLL;
    }
    if ( v13[9] )
    {
      v20 = v13[8];
      v19 = *v13;
      v15 = (void *)v13[10];
      goto LABEL_10;
    }
    goto LABEL_16;
  }
  if ( (v12 & 0x100) == 0 )
  {
    v17 = a1[1];
    v14 = *(unsigned __int8 *)(v17 - 1);
    if ( (_DWORD)v14 == (_DWORD)v10 )
    {
      a1[1] = v17 - 1;
      return (unsigned int)v10;
    }
    v16 = v13[9];
    if ( v16 )
    {
      v37 = v10;
      v18 = save_for_wbackup(
              (__int64)a1,
              *v13,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              a9,
              a10,
              (__int64)v13,
              v10,
              (__int64)v15,
              (__int64)a1,
              v12,
              v14);
      v11 = a1;
      LODWORD(v10) = v37;
      if ( !v18 )
      {
        v13 = (__int64 *)a1[20];
        LODWORD(v12) = *(_DWORD *)a1;
        v19 = *v13;
        v20 = v13[8];
        v15 = (void *)v13[10];
LABEL_10:
        v21 = v13[1];
        *v11 = v12 | 0x100;
        *v13 = (__int64)v15;
        v13[1] = (__int64)v15;
        v13[2] = v20;
        v13[8] = v19;
        v13[10] = v21;
        goto LABEL_11;
      }
      return 0xFFFFFFFFLL;
    }
LABEL_16:
    v36 = (__int64 *)a1[20];
    v39 = *v13;
    v41 = *(_DWORD *)a1;
    v44 = v10;
    v20 = malloc(512LL, v16, (__int64)v13, (void *)v10, v15, a1, (void *)v12, v14, a3, a4, a5, a6, a7, a8, a9, a10);
    if ( v20 )
    {
      v13 = v36;
      v15 = (void *)(v20 + 512);
      v36[8] = v20;
      v36[9] = v20 + 512;
      v19 = v39;
      v36[10] = v20 + 512;
      v11 = a1;
      LODWORD(v12) = v41;
      LODWORD(v10) = v44;
      goto LABEL_10;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_11:
  *v13 = (__int64)v15 - 4;
  *((_DWORD *)v15 - 1) = v10;
  return (unsigned int)v10;
}
// 4349B8: variable 'v25' is possibly undefined
// 4349B8: variable 'v26' is possibly undefined
// 4349B8: variable 'v27' is possibly undefined
// 4349B8: variable 'v28' is possibly undefined
// 4349B8: variable 'v29' is possibly undefined
// 4349B8: variable 'v30' is possibly undefined
// 4349B8: variable 'v31' is possibly undefined
// 4349B8: variable 'v32' is possibly undefined

//----- (0000000000434A44) ----------------------------------------------------
void __fastcall IO_wdefault_finish(
        _QWORD *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  _QWORD *v9; // x2
  _QWORD *v10; // x3
  unsigned __int64 v11; // x0
  _QWORD *i; // x1
  _QWORD *v13; // [xsp+18h] [xbp+18h]
  _QWORD *v14; // [xsp+18h] [xbp+18h]

  v9 = a1;
  v10 = (_QWORD *)a1[20];
  v11 = v10[6];
  if ( v11 && (v9[14] & 0x800000000LL) == 0 )
  {
    v14 = v9;
    free(v11, a2, a3, a4, a5, a6, a7, a8, a9);
    v9 = v14;
    v10 = (_QWORD *)v14[20];
    v10[6] = 0LL;
    v10[7] = 0LL;
  }
  for ( i = (_QWORD *)v9[12]; i; i = (_QWORD *)*i )
    i[1] = 0LL;
  if ( v9[9] )
  {
    v13 = v9;
    free(v10[8], a2, a3, a4, a5, a6, a7, a8, a9);
    v9 = v13;
    v13[9] = 0LL;
  }
  IO_un_link((__int64)v9);
}
// 434A88: variable 'a2' is possibly undefined
// 434A88: variable 'a3' is possibly undefined
// 434A88: variable 'a4' is possibly undefined
// 434A88: variable 'a5' is possibly undefined
// 434A88: variable 'a6' is possibly undefined
// 434A88: variable 'a7' is possibly undefined
// 434A88: variable 'a8' is possibly undefined
// 434A88: variable 'a9' is possibly undefined

//----- (0000000000434AC0) ----------------------------------------------------
__int64 __fastcall IO_wdefault_uflow(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v9; // x1
  __int64 result; // x0
  _QWORD *v12; // x1
  __int64 v13; // [xsp+28h] [xbp+28h]

  v9 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v9 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v13 = *(_QWORD *)(a1 + 216);
    IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
    v9 = v13;
  }
  result = (*(__int64 (__fastcall **)(__int64))(v9 + 32))(a1);
  if ( (_DWORD)result != -1 )
  {
    v12 = *(_QWORD **)(a1 + 160);
    result = *(unsigned int *)*v12;
    *v12 += 4LL;
  }
  return result;
}

//----- (0000000000434B2C) ----------------------------------------------------
__int64 __fastcall _woverflow(
        __int64 a1,
        unsigned int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  unsigned int v10; // w4
  __int64 v11; // x2
  __int64 v12; // x1
  __int64 v15; // [xsp+18h] [xbp+18h]
  __int64 v17; // [xsp+20h] [xbp+20h]
  unsigned int v18; // [xsp+2Ch] [xbp+2Ch]

  v10 = a2;
  v11 = a1;
  if ( *(_DWORD *)(a1 + 192) )
  {
    v12 = *(_QWORD *)(a1 + 216);
    if ( (unsigned __int64)(v12 - (_QWORD)&_io_vtables) <= 0x92F )
      return (*(__int64 (__fastcall **)(__int64, _QWORD))(v12 + 24))(v11, v10);
  }
  else
  {
    IO_fwide(a1, 1);
    v11 = a1;
    v10 = a2;
    v12 = *(_QWORD *)(a1 + 216);
    if ( (unsigned __int64)(v12 - (_QWORD)&_io_vtables) <= 0x92F )
      return (*(__int64 (__fastcall **)(__int64, _QWORD))(v12 + 24))(v11, v10);
  }
  v15 = v12;
  v17 = v11;
  v18 = v10;
  IO_vtable_check(a3, a4, a5, a6, a7, a8, a9, a10);
  return (*(__int64 (__fastcall **)(__int64, _QWORD))(v15 + 24))(v17, v18);
}
// 434BAC: variable 'a3' is possibly undefined
// 434BAC: variable 'a4' is possibly undefined
// 434BAC: variable 'a5' is possibly undefined
// 434BAC: variable 'a6' is possibly undefined
// 434BAC: variable 'a7' is possibly undefined
// 434BAC: variable 'a8' is possibly undefined
// 434BAC: variable 'a9' is possibly undefined
// 434BAC: variable 'a10' is possibly undefined

//----- (0000000000434BD0) ----------------------------------------------------
unsigned __int64 __fastcall IO_wdefault_xsputn(
        __int64 a1,
        unsigned int *a2,
        unsigned __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  unsigned __int64 i; // x21
  __int64 v15; // x25
  __int64 v16; // x0
  __int64 v17; // x19
  unsigned int v18; // w25
  __int64 v19; // x19
  __int64 v20; // x3
  __int64 v21; // x1
  __int64 v23; // x1

  if ( a3 )
  {
    for ( i = a3; ; --i )
    {
      v15 = *(_QWORD *)(a1 + 160);
      v16 = *(_QWORD *)(v15 + 32);
      if ( *(_QWORD *)(v15 + 40) - v16 <= 0 )
        goto LABEL_8;
      v17 = (*(_QWORD *)(v15 + 40) - v16) >> 2;
      if ( v17 > i )
        v17 = i;
      if ( v17 > 20 )
        break;
      if ( !v17 )
        goto LABEL_8;
      v20 = 0LL;
      do
      {
        *(_DWORD *)(v16 + v20 * 4) = a2[v20];
        ++v20;
      }
      while ( v20 != (unsigned int)v17 );
      v21 = (unsigned int)(v17 - 1);
      i -= v17;
      a2 += v21 + 1;
      *(_QWORD *)(v15 + 32) = v16 + 4 + 4 * v21;
      if ( !i )
        return a3;
LABEL_9:
      v18 = *a2;
      if ( *(_DWORD *)(a1 + 192) )
      {
        v19 = *(_QWORD *)(a1 + 216);
        if ( (unsigned __int64)(v19 - (_QWORD)&_io_vtables) <= 0x92F )
          goto LABEL_11;
      }
      else
      {
        IO_fwide(a1, 1);
        v19 = *(_QWORD *)(a1 + 216);
        if ( (unsigned __int64)(v19 - (_QWORD)&_io_vtables) <= 0x92F )
        {
LABEL_11:
          if ( (*(unsigned int (__fastcall **)(__int64, _QWORD))(v19 + 24))(a1, v18) == -1 )
            return a3 - i;
          goto LABEL_12;
        }
      }
      IO_vtable_check(a4, a5, a6, a7, a8, a9, a10, a11);
      if ( (*(unsigned int (__fastcall **)(__int64, _QWORD))(v19 + 24))(a1, v18) == -1 )
        return a3 - i;
LABEL_12:
      ++a2;
    }
    v23 = (__int64)a2;
    a2 += v17;
    i -= v17;
    *(_QWORD *)(v15 + 32) = wmempcpy(v16, v23, v17);
LABEL_8:
    if ( !i )
      return a3;
    goto LABEL_9;
  }
  return 0LL;
}
// 434CEC: variable 'a4' is possibly undefined
// 434CEC: variable 'a5' is possibly undefined
// 434CEC: variable 'a6' is possibly undefined
// 434CEC: variable 'a7' is possibly undefined
// 434CEC: variable 'a8' is possibly undefined
// 434CEC: variable 'a9' is possibly undefined
// 434CEC: variable 'a10' is possibly undefined
// 434CEC: variable 'a11' is possibly undefined

//----- (0000000000434D4C) ----------------------------------------------------
__int64 __fastcall IO_wdoallocbuf(__int64 result)
{
  _QWORD *v1; // x2
  __int64 v2; // x1
  double v3; // d0
  double v4; // d1
  double v5; // d2
  double v6; // d3
  double v7; // d4
  double v8; // d5
  double v9; // d6
  double v10; // d7
  __int64 v11; // x1
  __int64 v12; // x2
  __int64 v13; // x4
  __int64 v14; // x3
  unsigned __int64 v15; // x0
  int v16; // w0
  int v17; // w0
  __int64 v18; // [xsp+18h] [xbp-18h]
  __int64 v19; // [xsp+18h] [xbp-18h]
  __int64 v20; // [xsp+20h] [xbp-10h]
  __int64 v21; // [xsp+28h] [xbp-8h]

  v1 = *(_QWORD **)(result + 160);
  if ( !v1[6] )
  {
    v2 = result;
    if ( (*(_DWORD *)result & 2) != 0 )
    {
      v1[6] = v1 + 27;
      v1[7] = (char *)v1 + 220;
      v17 = ((int)(*(_QWORD *)(result + 112) >> 24) >> 8) | 8;
      *(_WORD *)(v2 + 116) = v17;
      result = BYTE2(v17);
      *(_BYTE *)(v2 + 118) = result;
    }
    else
    {
      v18 = result;
      result = (*(__int64 (__fastcall **)(__int64, __int64))(v1[28] + 104LL))(result, result);
      if ( (_DWORD)result == -1 )
      {
        v11 = v18;
        v12 = *(_QWORD *)(v18 + 160);
        v13 = v12 + 216;
        v14 = v12 + 220;
        v15 = *(_QWORD *)(v12 + 48);
        if ( v15 )
        {
          if ( (*(_QWORD *)(v18 + 112) & 0x800000000LL) == 0 )
          {
            v19 = v12 + 216;
            v20 = v12 + 220;
            v21 = v11;
            free(v15, v3, v4, v5, v6, v7, v8, v9, v10);
            v11 = v21;
            v13 = v19;
            v14 = v20;
            v12 = *(_QWORD *)(v21 + 160);
          }
        }
        *(_QWORD *)(v12 + 48) = v13;
        *(_QWORD *)(v12 + 56) = v14;
        v16 = ((int)(*(_QWORD *)(v11 + 112) >> 24) >> 8) | 8;
        *(_WORD *)(v11 + 116) = ((int)(*(_QWORD *)(v11 + 112) >> 24) >> 8) | 8;
        result = BYTE2(v16);
        *(_BYTE *)(v11 + 118) = result;
      }
    }
  }
  return result;
}
// 434DD4: variable 'v3' is possibly undefined
// 434DD4: variable 'v4' is possibly undefined
// 434DD4: variable 'v5' is possibly undefined
// 434DD4: variable 'v6' is possibly undefined
// 434DD4: variable 'v7' is possibly undefined
// 434DD4: variable 'v8' is possibly undefined
// 434DD4: variable 'v9' is possibly undefined
// 434DD4: variable 'v10' is possibly undefined

//----- (0000000000434E10) ----------------------------------------------------
__int64 __fastcall IO_wdefault_doallocate(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  unsigned __int64 v17; // x0
  double v18; // d0
  double v19; // d1
  double v20; // d2
  double v21; // d3
  double v22; // d4
  double v23; // d5
  double v24; // d6
  double v25; // d7
  __int64 v26; // x2
  unsigned __int64 v27; // x1
  unsigned __int64 v28; // x3
  unsigned __int64 v29; // x0
  __int64 result; // x0
  unsigned int v31; // w1
  unsigned __int64 v32; // [xsp+20h] [xbp+20h]
  unsigned __int64 v33; // [xsp+28h] [xbp+28h]

  v17 = malloc(0x2000LL, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
  if ( !v17 )
    return 0xFFFFFFFFLL;
  v26 = *(_QWORD *)(a1 + 160);
  v27 = v17;
  v28 = v17 + 0x2000;
  v29 = *(_QWORD *)(v26 + 48);
  if ( v29 )
  {
    if ( (*(_QWORD *)(a1 + 112) & 0x800000000LL) == 0 )
    {
      v32 = v28;
      v33 = v27;
      free(v29, v18, v19, v20, v21, v22, v23, v24, v25);
      v26 = *(_QWORD *)(a1 + 160);
      v28 = v32;
      v27 = v33;
    }
  }
  *(_QWORD *)(v26 + 48) = v27;
  *(_QWORD *)(v26 + 56) = v28;
  result = 1LL;
  v31 = ((int)(*(_QWORD *)(a1 + 112) >> 24) >> 8) & 0xFFFFFFF7;
  *(_WORD *)(a1 + 116) = ((int)(*(_QWORD *)(a1 + 112) >> 24) >> 8) & 0xFFF7;
  *(_BYTE *)(a1 + 118) = BYTE2(v31);
  return result;
}
// 434E78: variable 'v18' is possibly undefined
// 434E78: variable 'v19' is possibly undefined
// 434E78: variable 'v20' is possibly undefined
// 434E78: variable 'v21' is possibly undefined
// 434E78: variable 'v22' is possibly undefined
// 434E78: variable 'v23' is possibly undefined
// 434E78: variable 'v24' is possibly undefined
// 434E78: variable 'v25' is possibly undefined

//----- (0000000000434EA0) ----------------------------------------------------
__int64 __fastcall IO_switch_to_wget_mode(unsigned int *a1)
{
  unsigned __int64 *v1; // x1
  unsigned __int64 v3; // x3
  __int64 result; // x0
  unsigned __int64 *v5; // x1
  unsigned int v6; // w0
  unsigned __int64 v7; // x3
  unsigned int v8; // w0

  v1 = (unsigned __int64 *)*((_QWORD *)a1 + 20);
  v3 = v1[4];
  if ( v3 <= v1[3] )
  {
    v8 = *a1;
    if ( (v8 & 0x100) != 0 )
    {
      v1[2] = v1[9];
    }
    else
    {
      v1[2] = v1[6];
      if ( v1[1] < v3 )
      {
        *v1 = v3;
        v1[1] = v3;
        v1[3] = v3;
        v1[5] = v3;
        *a1 = v8 & 0xFFFFF7FF;
        return 0LL;
      }
    }
    *v1 = v3;
    v1[3] = v3;
    v1[5] = v3;
    *a1 = v8 & 0xFFFFF7FF;
    return 0LL;
  }
  result = (*(__int64 (__fastcall **)(unsigned int *, __int64))(v1[28] + 24))(a1, 0xFFFFFFFFLL);
  if ( (_DWORD)result != -1 )
  {
    v5 = (unsigned __int64 *)*((_QWORD *)a1 + 20);
    v6 = *a1;
    v7 = v5[4];
    if ( (*a1 & 0x100) != 0 )
    {
      v5[2] = v5[9];
    }
    else
    {
      v5[2] = v5[6];
      if ( v5[1] < v7 )
        v5[1] = v7;
    }
    *v5 = v7;
    v5[3] = v7;
    v5[5] = v7;
    *a1 = v6 & 0xFFFFF7FF;
    return 0LL;
  }
  return result;
}

//----- (0000000000434F90) ----------------------------------------------------
_QWORD *__fastcall IO_free_wbackup_area(
        unsigned int *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  unsigned int v9; // w2
  unsigned __int64 *v10; // x1
  unsigned __int64 v12; // x0
  _QWORD *result; // x0
  unsigned __int64 v14; // x4
  unsigned __int64 v15; // x2
  unsigned __int64 v16; // x3

  v9 = *a1;
  v10 = (unsigned __int64 *)*((_QWORD *)a1 + 20);
  v12 = v10[8];
  if ( (v9 & 0x100) != 0 )
  {
    v14 = v10[10];
    *a1 = v9 & 0xFFFFFEFF;
    v16 = v10[1];
    v15 = v10[2];
    *v10 = v12;
    v10[1] = v14;
    v10[2] = v12;
    v10[8] = v15;
    v10[10] = v16;
    free(v15, a2, a3, a4, a5, a6, a7, a8, a9);
  }
  else
  {
    free(v12, a2, a3, a4, a5, a6, a7, a8, a9);
  }
  result = (_QWORD *)*((_QWORD *)a1 + 20);
  result[8] = 0LL;
  result[9] = 0LL;
  result[10] = 0LL;
  return result;
}

//----- (000000000043500C) ----------------------------------------------------
__int64 __fastcall _wuflow(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        unsigned __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  int v16; // w1
  unsigned __int64 *v18; // x0
  unsigned int *v19; // x1
  unsigned __int64 v20; // x2
  __int64 v21; // x1
  __int64 v23; // [xsp+28h] [xbp+28h]

  v16 = *(_DWORD *)(a1 + 192);
  if ( v16 < 0 )
    return 0xFFFFFFFFLL;
  if ( !v16 )
  {
    if ( (unsigned int)IO_fwide(a1, 1) != 1 )
      return 0xFFFFFFFFLL;
    if ( !*(_DWORD *)(a1 + 192) )
      IO_fwide(a1, 1);
  }
  if ( (*(_DWORD *)a1 & 0x800) != 0 && (unsigned int)IO_switch_to_wget_mode((unsigned int *)a1) == -1 )
    return 0xFFFFFFFFLL;
  v18 = *(unsigned __int64 **)(a1 + 160);
  v19 = (unsigned int *)*v18;
  v20 = v18[1];
  if ( *v18 < v20 )
    goto LABEL_13;
  if ( (*(_DWORD *)a1 & 0x100) == 0 )
    goto LABEL_6;
  a12 = v18[10];
  *(_DWORD *)a1 &= ~0x100u;
  v19 = (unsigned int *)v18[8];
  v18[10] = v20;
  v20 = v18[2];
  v18[1] = a12;
  v18[2] = (unsigned __int64)v19;
  v18[8] = v20;
  if ( a12 > (unsigned __int64)v19 )
  {
LABEL_13:
    *v18 = (unsigned __int64)(v19 + 1);
    return *v19;
  }
  *v18 = (unsigned __int64)v19;
LABEL_6:
  if ( !*(_QWORD *)(a1 + 96) )
  {
    if ( v18[9] )
      IO_free_wbackup_area((unsigned int *)a1, a2, a3, a4, a5, a6, a7, a8, a9);
    goto LABEL_8;
  }
  if ( (unsigned int)save_for_wbackup(a1, v18[1], a2, a3, a4, a5, a6, a7, a8, a9, v20, a12, a13, a14, a15, a16) )
    return 0xFFFFFFFFLL;
LABEL_8:
  v21 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v21 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v23 = *(_QWORD *)(a1 + 216);
    IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
    v21 = v23;
  }
  return (*(__int64 (__fastcall **)(__int64))(v21 + 40))(a1);
}
// 435058: variable 'a2' is possibly undefined
// 435058: variable 'a3' is possibly undefined
// 435058: variable 'a4' is possibly undefined
// 435058: variable 'a5' is possibly undefined
// 435058: variable 'a6' is possibly undefined
// 435058: variable 'a7' is possibly undefined
// 435058: variable 'a8' is possibly undefined
// 435058: variable 'a9' is possibly undefined
// 435058: variable 'a12' is possibly undefined
// 435058: variable 'a13' is possibly undefined
// 435058: variable 'a14' is possibly undefined
// 435058: variable 'a15' is possibly undefined
// 435058: variable 'a16' is possibly undefined

//----- (000000000043514C) ----------------------------------------------------
__int64 __fastcall _wunderflow(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        unsigned __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  int v16; // w1
  unsigned __int64 *v18; // x0
  unsigned int *v19; // x1
  unsigned __int64 v20; // x2
  __int64 v21; // x1
  __int64 v23; // [xsp+28h] [xbp+28h]

  v16 = *(_DWORD *)(a1 + 192);
  if ( v16 < 0 )
    return 0xFFFFFFFFLL;
  if ( !v16 )
  {
    if ( (unsigned int)IO_fwide(a1, 1) != 1 )
      return 0xFFFFFFFFLL;
    if ( !*(_DWORD *)(a1 + 192) )
      IO_fwide(a1, 1);
  }
  if ( (*(_DWORD *)a1 & 0x800) != 0 && (unsigned int)IO_switch_to_wget_mode((unsigned int *)a1) == -1 )
    return 0xFFFFFFFFLL;
  v18 = *(unsigned __int64 **)(a1 + 160);
  v19 = (unsigned int *)*v18;
  v20 = v18[1];
  if ( *v18 < v20 )
    return *v19;
  if ( (*(_DWORD *)a1 & 0x100) != 0 )
  {
    a12 = v18[10];
    *(_DWORD *)a1 &= ~0x100u;
    v19 = (unsigned int *)v18[8];
    v18[10] = v20;
    v20 = v18[2];
    *v18 = (unsigned __int64)v19;
    v18[1] = a12;
    v18[2] = (unsigned __int64)v19;
    v18[8] = v20;
    if ( a12 > (unsigned __int64)v19 )
      return *v19;
  }
  if ( !*(_QWORD *)(a1 + 96) )
  {
    if ( *(_QWORD *)(a1 + 80) )
      IO_free_wbackup_area((unsigned int *)a1, a2, a3, a4, a5, a6, a7, a8, a9);
    goto LABEL_8;
  }
  if ( (unsigned int)save_for_wbackup(a1, v18[1], a2, a3, a4, a5, a6, a7, a8, a9, v20, a12, a13, a14, a15, a16) )
    return 0xFFFFFFFFLL;
LABEL_8:
  v21 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v21 - (_QWORD)&_io_vtables) > 0x92F )
  {
    v23 = *(_QWORD *)(a1 + 216);
    IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
    v21 = v23;
  }
  return (*(__int64 (__fastcall **)(__int64))(v21 + 32))(a1);
}
// 435198: variable 'a2' is possibly undefined
// 435198: variable 'a3' is possibly undefined
// 435198: variable 'a4' is possibly undefined
// 435198: variable 'a5' is possibly undefined
// 435198: variable 'a6' is possibly undefined
// 435198: variable 'a7' is possibly undefined
// 435198: variable 'a8' is possibly undefined
// 435198: variable 'a9' is possibly undefined
// 435198: variable 'a12' is possibly undefined
// 435198: variable 'a13' is possibly undefined
// 435198: variable 'a14' is possibly undefined
// 435198: variable 'a15' is possibly undefined
// 435198: variable 'a16' is possibly undefined

//----- (0000000000435280) ----------------------------------------------------
unsigned __int64 __fastcall IO_wdefault_xsgetn(
        __int64 a1,
        char *a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  unsigned __int64 v17; // x21
  unsigned __int64 v18; // x22
  __int64 v20; // x0
  _QWORD *v21; // x1
  __int64 v22; // x19
  __int64 v24; // x3

  v17 = a3;
  v18 = a3;
  v20 = *(_QWORD *)(a1 + 160);
  v21 = *(_QWORD **)v20;
  if ( (__int64)(*(_QWORD *)(v20 + 8) - *(_QWORD *)v20) > 0 )
  {
    v22 = (__int64)(*(_QWORD *)(v20 + 8) - *(_QWORD *)v20) >> 2;
    if ( v22 > a3 )
      v22 = a3;
    if ( v22 > 20 )
      goto LABEL_12;
LABEL_5:
    if ( v22 )
    {
      a6 = (unsigned int)(v22 - 1);
      a5 = 4LL * (unsigned int)v22;
      v24 = 0LL;
      do
      {
        *(_DWORD *)&a2[v24] = *(_DWORD *)((char *)v21 + v24);
        v24 += 4LL;
      }
      while ( v24 != a5 );
      a3 = 4LL * (unsigned int)(v22 - 1);
      a2 += a3 + 4;
      a4 = (unsigned __int64)v21 + a3 + 4;
      v18 -= v22;
      *(_QWORD *)v20 = a4;
    }
  }
  if ( !v18 )
    return v17;
  while ( (unsigned int)_wunderflow(a1, a9, a10, a11, a12, a13, a14, a15, a16, (__int64)v21, a3, a4, a5, a6, a7, a8) != -1 )
  {
    v20 = *(_QWORD *)(a1 + 160);
    v21 = *(_QWORD **)v20;
    if ( (__int64)(*(_QWORD *)(v20 + 8) - *(_QWORD *)v20) > 0 )
    {
      v22 = (__int64)(*(_QWORD *)(v20 + 8) - *(_QWORD *)v20) >> 2;
      if ( v22 > v18 )
        v22 = v18;
      if ( v22 <= 20 )
        goto LABEL_5;
LABEL_12:
      a2 = wmempcpy((__int64)a2, (__int64)v21, v22);
      v21 = *(_QWORD **)(a1 + 160);
      v18 -= v22;
      *v21 += 4 * v22;
      if ( !v18 )
        return v17;
    }
  }
  return v17 - v18;
}
// 4352D8: variable 'a9' is possibly undefined
// 4352D8: variable 'a10' is possibly undefined
// 4352D8: variable 'a11' is possibly undefined
// 4352D8: variable 'a12' is possibly undefined
// 4352D8: variable 'a13' is possibly undefined
// 4352D8: variable 'a14' is possibly undefined
// 4352D8: variable 'a15' is possibly undefined
// 4352D8: variable 'a16' is possibly undefined
// 4352D8: variable 'a3' is possibly undefined
// 4352D8: variable 'a4' is possibly undefined
// 4352D8: variable 'a5' is possibly undefined
// 4352D8: variable 'a6' is possibly undefined
// 4352D8: variable 'a7' is possibly undefined
// 4352D8: variable 'a8' is possibly undefined

//----- (00000000004353B0) ----------------------------------------------------
__int64 __fastcall IO_sputbackwc(
        __int64 a1,
        int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  __int64 *v10; // x2
  __int64 v11; // x3
  __int64 result; // x0
  __int64 v14; // x2
  __int64 v15; // [xsp+20h] [xbp+20h]

  v10 = *(__int64 **)(a1 + 160);
  v11 = *v10;
  if ( *v10 > (unsigned __int64)v10[2] && (result = *(unsigned int *)(v11 - 4), (_DWORD)result == a2) )
  {
    *v10 = v11 - 4;
  }
  else
  {
    v14 = *(_QWORD *)(a1 + 216);
    if ( (unsigned __int64)(v14 - (_QWORD)&_io_vtables) > 0x92F )
    {
      v15 = *(_QWORD *)(a1 + 216);
      IO_vtable_check(a3, a4, a5, a6, a7, a8, a9, a10);
      v14 = v15;
    }
    result = (*(__int64 (__fastcall **)(__int64))(v14 + 48))(a1);
  }
  if ( (_DWORD)result != -1 )
    *(_DWORD *)a1 &= ~0x10u;
  return result;
}

//----- (0000000000435448) ----------------------------------------------------
__int64 __fastcall IO_sungetwc(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v9; // x2
  __int64 *v10; // x0
  __int64 v11; // x1
  __int64 v12; // x1
  __int64 result; // x0
  _DWORD *v14; // [xsp+10h] [xbp-10h]
  __int64 v15; // [xsp+10h] [xbp-10h]
  __int64 v16; // [xsp+18h] [xbp-8h]

  v9 = a1;
  v10 = *(__int64 **)(a1 + 160);
  v11 = *v10;
  if ( *v10 > (unsigned __int64)v10[2] )
  {
    *v10 = v11 - 4;
    result = *(unsigned int *)(v11 - 4);
    if ( (_DWORD)result != -1 )
      *(_DWORD *)v9 &= ~0x10u;
  }
  else
  {
    v12 = *(_QWORD *)(v9 + 216);
    if ( (unsigned __int64)(v12 - (_QWORD)&_io_vtables) > 0x92F )
    {
      v15 = *(_QWORD *)(v9 + 216);
      v16 = v9;
      IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
      v12 = v15;
      v9 = v16;
    }
    v14 = (_DWORD *)v9;
    result = (*(__int64 (__fastcall **)(__int64, __int64))(v12 + 48))(v9, 0xFFFFFFFFLL);
    if ( (_DWORD)result != -1 )
      *v14 &= ~0x10u;
  }
  return result;
}

//----- (00000000004354EC) ----------------------------------------------------
__int64 __fastcall IO_adjust_wcolumn(int a1, unsigned __int64 a2, int a3)
{
  unsigned __int64 v3; // x3
  int v4; // t1

  v3 = a2 + 4LL * a3;
  do
  {
    if ( v3 <= a2 )
      return (unsigned int)(a3 + a1);
    v4 = *(_DWORD *)(v3 - 4);
    v3 -= 4LL;
  }
  while ( v4 != 10 );
  return (unsigned int)((__int64)(a2 + 4LL * a3 - v3) >> 2) - 1;
}

//----- (0000000000435524) ----------------------------------------------------
__int64 __fastcall IO_init_wmarker(__int64 a1, __int64 a2)
{
  unsigned int v2; // w3
  _QWORD *v4; // x4
  __int64 v5; // x3
  __int64 result; // x0
  _QWORD *v7; // x4
  __int64 v8; // x3

  v2 = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 8) = a2;
  if ( (v2 & 0x800) != 0 )
  {
    IO_switch_to_wget_mode((unsigned int *)a2);
    v7 = *(_QWORD **)(a2 + 160);
    if ( (*(_DWORD *)a2 & 0x100) != 0 )
      v8 = v7[1];
    else
      v8 = v7[2];
    *(_DWORD *)(a1 + 16) = (*v7 - v8) >> 2;
    result = *(_QWORD *)(a2 + 96);
    *(_QWORD *)a1 = result;
    *(_QWORD *)(a2 + 96) = a1;
  }
  else
  {
    v4 = *(_QWORD **)(a2 + 160);
    if ( (v2 & 0x100) != 0 )
      v5 = v4[1];
    else
      v5 = v4[2];
    *(_DWORD *)(a1 + 16) = (*v4 - v5) >> 2;
    result = *(_QWORD *)(a2 + 96);
    *(_QWORD *)a1 = result;
    *(_QWORD *)(a2 + 96) = a1;
  }
  return result;
}

//----- (00000000004355F0) ----------------------------------------------------
__int64 __fastcall IO_wmarker_delta(__int64 a1)
{
  __int64 v1; // x2
  _QWORD *v2; // x3
  __int64 v3; // x2

  v1 = *(_QWORD *)(a1 + 8);
  if ( !v1 )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD **)(v1 + 160);
  if ( (*(_DWORD *)v1 & 0x100) != 0 )
    v3 = v2[1];
  else
    v3 = v2[2];
  return *(_DWORD *)(a1 + 16) - (unsigned int)((*v2 - v3) >> 2);
}

//----- (0000000000435640) ----------------------------------------------------
__int64 __fastcall IO_seekwmark(int *a1, __int64 a2)
{
  int *v2; // x3
  int v3; // w0
  int v4; // w4
  _QWORD *v5; // x2
  int v6; // w5
  __int64 v7; // x3
  __int64 v9; // x6
  __int64 v10; // x4
  __int64 v11; // x0
  __int64 v12; // x0
  __int64 v13; // x4
  __int64 v14; // x3

  v2 = *(int **)(a2 + 8);
  if ( v2 != a1 )
    return 0xFFFFFFFFLL;
  v3 = *(_DWORD *)(a2 + 16);
  v4 = *v2;
  v5 = (_QWORD *)*((_QWORD *)v2 + 20);
  v6 = *v2 & 0x100;
  if ( v3 < 0 )
  {
    v9 = v5[1];
    if ( !v6 )
    {
      v12 = v5[2];
      *v2 = v4 | 0x100;
      v13 = v5[8];
      v5[8] = v12;
      v14 = v5[10];
      v5[1] = v14;
      v5[2] = v13;
      v3 = *(_DWORD *)(a2 + 16);
      v5[10] = v9;
      v9 = v14;
    }
    *v5 = v9 + 4LL * v3;
    return 0LL;
  }
  else
  {
    if ( v6 )
    {
      *v2 = v4 & 0xFFFFFEFF;
      v10 = v5[10];
      v11 = v5[2];
      v5[10] = v5[1];
      v7 = v5[8];
      v5[1] = v10;
      v5[2] = v7;
      v5[8] = v11;
      v3 = *(_DWORD *)(a2 + 16);
    }
    else
    {
      v7 = v5[2];
    }
    *v5 = v7 + 4LL * v3;
    return 0LL;
  }
}

//----- (00000000004356EC) ----------------------------------------------------
_QWORD *__fastcall IO_unsave_wmarkers(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  _QWORD *result; // x0
  unsigned __int64 *v11; // x2
  unsigned __int64 v12; // x0
  unsigned __int64 v13; // x5
  unsigned __int64 v14; // x3
  unsigned __int64 v15; // x4
  __int64 v16; // [xsp+18h] [xbp+18h]

  if ( *(_QWORD *)(a1 + 96) )
    *(_QWORD *)(a1 + 96) = 0LL;
  result = *(_QWORD **)(a1 + 80);
  if ( result )
  {
    v11 = *(unsigned __int64 **)(a1 + 160);
    v12 = v11[8];
    if ( (*(_DWORD *)a1 & 0x100) != 0 )
    {
      v13 = v11[10];
      *(_DWORD *)a1 &= ~0x100u;
      v15 = v11[1];
      v14 = v11[2];
      *v11 = v12;
      v11[1] = v13;
      v11[2] = v12;
      v11[8] = v14;
      v11[10] = v15;
      v16 = a1;
      free(v14, a2, a3, a4, a5, a6, a7, a8, a9);
    }
    else
    {
      v16 = a1;
      free(v12, a2, a3, a4, a5, a6, a7, a8, a9);
    }
    result = *(_QWORD **)(v16 + 160);
    result[8] = 0LL;
    result[9] = 0LL;
    result[10] = 0LL;
  }
  return result;
}

//----- (00000000004357A0) ----------------------------------------------------
__int64 __fastcall adjust_wide_data(__int64 a1, char a2)
{
  unsigned __int8 v3; // w20
  __int64 *v4; // x21
  int v5; // w0
  int v6; // w0
  _QWORD *v7; // x2
  __int64 v8; // x0
  __int64 v10; // [xsp+38h] [xbp+38h] BYREF

  v3 = a2 ^ 1;
  v4 = *(__int64 **)(a1 + 152);
  v5 = _libio_codecvt_encoding(v4);
  if ( ((v5 > 0) & v3) != 0 )
  {
    v7 = *(_QWORD **)(a1 + 160);
    v8 = v7[1] + 4 * ((*(_QWORD *)(a1 + 8) - *(_QWORD *)(a1 + 24)) / v5);
    v7[1] = v8;
LABEL_6:
    *v7 = v8;
    return 0LL;
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 24);
    while ( 1 )
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 160) + 96LL) = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 88LL);
      v6 = _libio_codecvt_in(
             (__int64)v4,
             *(_QWORD *)(a1 + 160) + 88LL,
             *(_QWORD *)(a1 + 24),
             *(_QWORD *)(a1 + 8),
             &v10,
             *(_QWORD *)(*(_QWORD *)(a1 + 160) + 16LL),
             *(_QWORD *)(*(_QWORD *)(a1 + 160) + 56LL),
             (_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL));
      if ( v6 == 2 )
        break;
      if ( v6 != 1 )
      {
        v7 = *(_QWORD **)(a1 + 160);
        v8 = v7[1];
        goto LABEL_6;
      }
    }
    *(_DWORD *)a1 |= 0x20u;
    return 0xFFFFFFFFLL;
  }
}

//----- (0000000000435880) ----------------------------------------------------
__int64 __fastcall IO_wdo_write(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16,
        char a17)
{
  __int64 v19; // x21
  _BYTE *v20; // x5
  _QWORD *v21; // x23
  char *v22; // x6
  _BYTE *i; // x22
  __int64 v24; // x1
  int v25; // w26
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7
  __int64 result; // x0
  _QWORD *v36; // x2
  __int64 v37; // x1
  int v38; // w4
  unsigned __int64 v39; // x1
  __int64 v40; // [xsp+50h] [xbp+50h] BYREF
  _BYTE *v41; // [xsp+58h] [xbp+58h] BYREF
  _BYTE v42[16]; // [xsp+60h] [xbp+60h] BYREF

  if ( a3 )
  {
    v19 = a3;
    v20 = *(_BYTE **)(a1 + 40);
    v21 = *(_QWORD **)(a1 + 152);
    if ( *(_BYTE **)(a1 + 48) == v20 )
    {
      v39 = *(_QWORD *)(a1 + 32);
      if ( v20 != (_BYTE *)v39 )
      {
        if ( (unsigned int)IO_new_do_write(a1, v39, (__int64)&v20[-v39], a4, a5, a6, a7, a8, a9, a10, a11) == -1 )
          return 0xFFFFFFFFLL;
        v20 = *(_BYTE **)(a1 + 40);
      }
    }
    v22 = *(char **)(a1 + 64);
    if ( (unsigned __int64)(v22 - v20) <= 0xF )
      goto LABEL_13;
LABEL_4:
    for ( i = *(_BYTE **)(a1 + 32); ; i = v42 )
    {
      v24 = *(_QWORD *)(a1 + 160) + 88LL;
      v41 = v20;
      v25 = _libio_codecvt_out(v21, v24, a2, a2 + 4 * v19, &v40, (__int64)v20, (__int64)v22, &v41);
      if ( (unsigned int)IO_new_do_write(a1, (unsigned __int64)i, v41 - i, v26, v27, v28, v29, v30, v31, v32, v33) == -1 )
        break;
      v19 -= (v40 - a2) >> 2;
      if ( v25 )
      {
        if ( v25 != 1 || v40 == a2 )
        {
          if ( v19 )
            result = 0xFFFFFFFFLL;
          else
            result = 0LL;
          goto LABEL_15;
        }
      }
      if ( !v19 )
        goto LABEL_14;
      v20 = *(_BYTE **)(a1 + 40);
      a2 = v40;
      v22 = *(char **)(a1 + 64);
      if ( (unsigned __int64)(v22 - v20) > 0xF )
        goto LABEL_4;
LABEL_13:
      v20 = v42;
      v22 = &a17;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_14:
  result = 0LL;
LABEL_15:
  v36 = *(_QWORD **)(a1 + 160);
  v37 = v36[6];
  *v36 = v37;
  v36[1] = v37;
  v36[2] = v37;
  v36[3] = v37;
  v38 = *(_DWORD *)a1;
  v36[4] = v37;
  if ( (v38 & 0x202) == 0 )
    v37 = v36[7];
  v36[5] = v37;
  return result;
}
// 435904: variable 'v26' is possibly undefined
// 435904: variable 'v27' is possibly undefined
// 435904: variable 'v28' is possibly undefined
// 435904: variable 'v29' is possibly undefined
// 435904: variable 'v30' is possibly undefined
// 435904: variable 'v31' is possibly undefined
// 435904: variable 'v32' is possibly undefined
// 435904: variable 'v33' is possibly undefined

//----- (0000000000435A00) ----------------------------------------------------
__int64 __fastcall IO_wfile_underflow(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        void *a13,
        void *a14,
        void *a15,
        __int64 a16)
{
  int v17; // w0
  unsigned int **v18; // x0
  __int64 v19; // x23
  __int64 v20; // x0
  __int64 v21; // x0
  int *v22; // x20
  unsigned __int64 StatusReg; // x21
  __int64 v24; // x22
  unsigned __int64 v25; // x21
  __int64 v26; // x0
  __int64 v27; // x1
  __int64 v28; // x2
  int v29; // w0
  int *v30; // x1
  __int64 v31; // x1
  int v32; // w0
  int v33; // w1
  double v35; // d0
  double v36; // d1
  double v37; // d2
  double v38; // d3
  double v39; // d4
  double v40; // d5
  double v41; // d6
  double v42; // d7
  _QWORD *v43; // x1
  unsigned __int64 v44; // x20
  __int64 v45; // x0
  __int64 v46; // x25
  __int64 v47; // x0
  __int64 v48; // x1
  __int64 v49; // x1
  int v50; // w0
  char *v51; // x3
  unsigned __int64 v52; // x1
  unsigned int **v53; // x2
  unsigned int *v54; // x5
  unsigned int *v55; // x4
  unsigned __int64 v56; // x25
  unsigned __int64 v57; // x26
  __int64 v58; // x25
  __int64 v59; // x26
  char *v60; // x25
  __int64 (__fastcall *v61)(__int64, __int64 *, unsigned __int64); // x0
  unsigned __int64 v62; // x0
  __int64 *v63; // x1
  __int64 v64; // x5
  __int64 v65; // x6
  int v66; // w0
  unsigned int **v67; // x2
  unsigned int *v68; // x2
  unsigned int **v69; // t2
  __int64 v70; // x1
  __int64 v71; // x2
  unsigned __int64 v72; // x0
  __int64 v73; // x0
  unsigned __int64 v74; // x0
  __int64 v75; // x25
  void *v76; // x20
  __int64 v77; // x1
  __int64 v78; // x2
  __int64 v79; // x3
  void *v80; // x4
  void *v81; // x5
  void *v82; // x6
  int v83; // w0
  char *v84; // [xsp+58h] [xbp+58h] BYREF
  _QWORD v85[2]; // [xsp+60h] [xbp+60h] BYREF

  v17 = *(_DWORD *)a1;
  if ( (v17 & 0x10) != 0 )
    return 0xFFFFFFFFLL;
  if ( (v17 & 4) != 0 )
  {
    *(_DWORD *)a1 = v17 | 0x20;
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 9;
    return 0xFFFFFFFFLL;
  }
  v18 = *(unsigned int ***)(a1 + 160);
  if ( *v18 < v18[1] )
    return **v18;
  v19 = *(_QWORD *)(a1 + 152);
  if ( *(_QWORD *)(a1 + 8) < *(_QWORD *)(a1 + 16) )
  {
    v85[0] = *(_QWORD *)(a1 + 8);
    v18[12] = v18[11];
    v63 = *(__int64 **)(a1 + 160);
    v64 = v63[6];
    v65 = v63[7];
    *v63 = v64;
    v63[2] = v64;
    v66 = _libio_codecvt_in(v19, (__int64)(v63 + 11), *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), v85, v64, v65, v63 + 1);
    *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 8);
    v67 = *(unsigned int ***)(a1 + 160);
    *(_QWORD *)(a1 + 8) = v85[0];
    v69 = v67;
    v68 = *v67;
    if ( v68 < v69[1] )
      return *v68;
    if ( v66 == 2 )
    {
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 84;
      *(_DWORD *)a1 |= 0x20u;
      return 0xFFFFFFFFLL;
    }
    j_memmove();
    v71 = *(_QWORD *)(a1 + 8);
    v70 = *(_QWORD *)(a1 + 16);
    v20 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 24) = v20;
    *(_QWORD *)(a1 + 8) = v20;
    *(_QWORD *)(a1 + 16) = v20 + v70 - v71;
    if ( v20 )
    {
LABEL_6:
      *(_QWORD *)(a1 + 32) = v20;
      *(_QWORD *)(a1 + 40) = v20;
      *(_QWORD *)(a1 + 48) = v20;
      v21 = *(_QWORD *)(a1 + 160);
      if ( *(_QWORD *)(v21 + 48) )
        goto LABEL_7;
      goto LABEL_65;
    }
  }
  else
  {
    v20 = *(_QWORD *)(a1 + 56);
    *(_QWORD *)(a1 + 8) = v20;
    *(_QWORD *)(a1 + 16) = v20;
    *(_QWORD *)(a1 + 24) = v20;
    if ( v20 )
      goto LABEL_6;
  }
  v72 = *(_QWORD *)(a1 + 72);
  if ( v72 )
  {
    if ( v72 != a1 + 119 )
      free(v72, a2, a3, a4, a5, a6, a7, a8, a9);
    *(_DWORD *)a1 &= ~0x100u;
  }
  IO_doallocbuf((int *)a1, a2, a3, a4, a5, a6, a7, a8, a9);
  v73 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a1 + 8) = v73;
  *(_QWORD *)(a1 + 16) = v73;
  *(_QWORD *)(a1 + 24) = v73;
  *(_QWORD *)(a1 + 32) = v73;
  *(_QWORD *)(a1 + 40) = v73;
  *(_QWORD *)(a1 + 48) = v73;
  v21 = *(_QWORD *)(a1 + 160);
  if ( !*(_QWORD *)(v21 + 48) )
  {
LABEL_65:
    v74 = *(_QWORD *)(v21 + 64);
    if ( v74 )
    {
      free(v74, a2, a3, a4, a5, a6, a7, a8, a9);
      *(_DWORD *)a1 &= ~0x100u;
    }
    IO_wdoallocbuf(a1);
  }
LABEL_7:
  if ( (*(_DWORD *)a1 & 0x202) == 0 )
    goto LABEL_25;
  v22 = stdout;
  if ( (*stdout & 0x8000) != 0 )
  {
    if ( (*stdout & 0x288) != 0x280 )
      goto LABEL_25;
    v30 = stdout;
    goto LABEL_70;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v24 = *((_QWORD *)v22 + 17);
  v25 = StatusReg - 1824;
  v26 = *(_QWORD *)(v24 + 8);
  if ( _libc_single_threaded && !v26 )
  {
    v30 = v22;
    *(_DWORD *)v24 = 1;
    *(_QWORD *)(v24 + 8) = v25;
  }
  else if ( v25 == v26 )
  {
    v30 = v22;
    ++*(_DWORD *)(v24 + 4);
  }
  else
  {
    _aarch64_cas4_acq();
    if ( v29 )
      _lll_lock_wait_private((_DWORD *)v24, a2, a3, a4, a5, a6, a7, a8, a9, v27, v28, a12, a13, a14, a15);
    v30 = stdout;
    *(_QWORD *)(*((_QWORD *)v22 + 17) + 8LL) = v25;
  }
  if ( (*v30 & 0x288) == 0x280 )
  {
LABEL_70:
    v75 = *((_QWORD *)v30 + 27);
    if ( (unsigned __int64)(v75 - (_QWORD)&_io_vtables) > 0x92F )
      IO_vtable_check(a2, a3, a4, a5, a6, a7, a8, a9);
    (*(void (__fastcall **)(int *, unsigned int, double, double, double, double, double, double, double, double, __int64, __int64, __int64, __int64, __int64, __int64))(v75 + 0x18))(
      stdout,
      0xFFFFFFFF,
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a9,
      *(_QWORD *)(v75 + 0x18),
      a12,
      (__int64)a13,
      (__int64)a14,
      (__int64)a15,
      a16);
  }
  if ( (*v22 & 0x8000) != 0 )
    goto LABEL_25;
  v31 = *((_QWORD *)v22 + 17);
  v32 = *(_DWORD *)(v31 + 4);
  if ( _libc_single_threaded )
  {
    if ( !v32 )
    {
      *(_QWORD *)(v31 + 8) = 0LL;
      **((_DWORD **)v22 + 17) = 0;
      goto LABEL_25;
    }
    goto LABEL_55;
  }
  if ( v32 )
  {
LABEL_55:
    *(_DWORD *)(v31 + 4) = v32 - 1;
    goto LABEL_25;
  }
  *(_QWORD *)(v31 + 8) = 0LL;
  v76 = (void *)*((_QWORD *)v22 + 17);
  _aarch64_swp4_rel();
  if ( v83 > 1 )
    _lll_lock_wake_private(v76, v77, v78, v79, v80, v81, v82);
LABEL_25:
  IO_switch_to_get_mode((int *)a1, a2, a3, a4, a5, a6, a7, a8, a9);
  v43 = *(_QWORD **)(a1 + 160);
  v44 = 0LL;
  v45 = v43[6];
  *v43 = v45;
  v43[1] = v45;
  v43[2] = v45;
  v43[3] = v45;
  v43[4] = v45;
  v43[5] = v45;
LABEL_26:
  v46 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v46 - (_QWORD)&_io_vtables) > 0x92F )
    goto LABEL_41;
  while ( 1 )
  {
    v47 = (*(__int64 (__fastcall **)(__int64, _QWORD, _QWORD))(v46 + 112))(
            a1,
            *(_QWORD *)(a1 + 16),
            *(_QWORD *)(a1 + 64) - *(_QWORD *)(a1 + 16));
    if ( v47 <= 0 )
      break;
    *(_QWORD *)(a1 + 16) += v47;
    v48 = *(_QWORD *)(a1 + 144);
    if ( v48 != -1 )
      *(_QWORD *)(a1 + 144) = v48 + v47;
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 96LL) = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 88LL);
    v49 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 24) = v49;
    if ( !v44 )
    {
      v50 = _libio_codecvt_in(
              v19,
              *(_QWORD *)(a1 + 160) + 88LL,
              v49,
              *(_QWORD *)(a1 + 16),
              &v84,
              *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL),
              *(_QWORD *)(*(_QWORD *)(a1 + 160) + 56LL),
              (_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL));
      v51 = v84;
LABEL_32:
      v52 = (unsigned __int64)v51;
      v44 = 0LL;
      goto LABEL_33;
    }
    v59 = 16 - v44;
    v60 = (char *)v85 + v44;
    if ( 16 - v44 > v47 )
      v59 = v47;
    v44 += v59;
    v61 = j_memcpy();
    v50 = _libio_codecvt_in(
            v19,
            *(_QWORD *)(a1 + 160) + 88LL,
            (__int64)v85,
            (__int64)v61 + v59,
            &v84,
            *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL),
            *(_QWORD *)(*(_QWORD *)(a1 + 160) + 56LL),
            (_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL));
    v51 = v84;
    if ( !v44 )
      goto LABEL_32;
    v52 = *(_QWORD *)(a1 + 8) + ((v84 - v60) & ~((v84 - v60) >> 63));
LABEL_33:
    v53 = *(unsigned int ***)(a1 + 160);
    v54 = v53[1];
    v55 = v53[6];
    *(_QWORD *)(a1 + 8) = v52;
    if ( v54 != v55 )
      return **v53;
    if ( v50 == 2 )
      goto LABEL_56;
    if ( v50 != 1 )
      _libc_assert_fail(
        (__int64)"status == __codecvt_partial",
        (__int64)"wfileops.c",
        0x121u,
        (__int64)"_IO_wfile_underflow");
    if ( v44 )
    {
      if ( v51 != (char *)v85 )
      {
        v44 -= v51 - (char *)v85;
        j_memmove();
      }
      if ( v44 == 16 )
      {
LABEL_56:
        *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 84;
        *(_DWORD *)a1 |= 0x20u;
        return 0xFFFFFFFFLL;
      }
      v58 = *(_QWORD *)(a1 + 24);
      *(_QWORD *)(a1 + 8) = v58;
      *(_QWORD *)(a1 + 16) = v58;
    }
    else
    {
      v56 = *(_QWORD *)(a1 + 24);
      v57 = *(_QWORD *)(a1 + 16) - v52;
      if ( v56 < v52 )
      {
        j_memmove();
        v62 = *(_QWORD *)(a1 + 16) - v57;
        *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 16) = v62;
        goto LABEL_26;
      }
      if ( v57 > 0xF )
        goto LABEL_56;
      v44 = *(_QWORD *)(a1 + 16) - v52;
      j_memcpy();
      *(_QWORD *)(a1 + 8) = v56;
      *(_QWORD *)(a1 + 16) = v56;
    }
    v46 = *(_QWORD *)(a1 + 216);
    if ( (unsigned __int64)(v46 - (_QWORD)&_io_vtables) > 0x92F )
LABEL_41:
      IO_vtable_check(v35, v36, v37, v38, v39, v40, v41, v42);
  }
  v33 = *(_DWORD *)a1;
  if ( v44 | v47 )
  {
    *(_DWORD *)a1 = v33 | 0x20;
    if ( v44 )
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 84;
  }
  else
  {
    *(_DWORD *)a1 = v33 | 0x10;
    *(_QWORD *)(a1 + 144) = -1LL;
  }
  return 0xFFFFFFFFLL;
}
// 435ACC: variable 'v29' is possibly undefined
// 435FF0: variable 'a2' is possibly undefined
// 435FF0: variable 'a3' is possibly undefined
// 435FF0: variable 'a4' is possibly undefined
// 435FF0: variable 'a5' is possibly undefined
// 435FF0: variable 'a6' is possibly undefined
// 435FF0: variable 'a7' is possibly undefined
// 435FF0: variable 'a8' is possibly undefined
// 435FF0: variable 'a9' is possibly undefined
// 435FF0: variable 'v27' is possibly undefined
// 435FF0: variable 'v28' is possibly undefined
// 435FF0: variable 'a12' is possibly undefined
// 435FF0: variable 'a13' is possibly undefined
// 435FF0: variable 'a14' is possibly undefined
// 435FF0: variable 'a15' is possibly undefined
// 435CB8: variable 'v35' is possibly undefined
// 435CB8: variable 'v36' is possibly undefined
// 435CB8: variable 'v37' is possibly undefined
// 435CB8: variable 'v38' is possibly undefined
// 435CB8: variable 'v39' is possibly undefined
// 435CB8: variable 'v40' is possibly undefined
// 435CB8: variable 'v41' is possibly undefined
// 435CB8: variable 'v42' is possibly undefined
// 435F38: variable 'a16' is possibly undefined
// 435F80: variable 'v83' is possibly undefined
// 435F88: variable 'v77' is possibly undefined
// 435F88: variable 'v78' is possibly undefined
// 435F88: variable 'v79' is possibly undefined
// 435F88: variable 'v80' is possibly undefined
// 435F88: variable 'v81' is possibly undefined
// 435F88: variable 'v82' is possibly undefined
// 4905C0: using guessed type int *stdout;
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000436088) ----------------------------------------------------
__int64 __fastcall IO_wfile_underflow_mmap(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  unsigned int **v10; // x1
  unsigned __int64 v11; // x2
  __int64 v12; // x20
  unsigned int *v13; // x0
  __int64 *v14; // x1
  __int64 v15; // x5
  __int64 v16; // x6
  unsigned int *v17; // x0
  unsigned __int64 v19; // x0
  unsigned __int64 v20; // [xsp+28h] [xbp+28h] BYREF

  if ( (*(_DWORD *)a1 & 4) != 0 )
  {
    *(_DWORD *)a1 |= 0x20u;
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 9;
    return 0xFFFFFFFFLL;
  }
  v10 = *(unsigned int ***)(a1 + 160);
  if ( *v10 < v10[1] )
    return **v10;
  v11 = *(_QWORD *)(a1 + 8);
  v12 = *(_QWORD *)(a1 + 152);
  if ( v11 < *(_QWORD *)(a1 + 16) )
  {
    v13 = v10[6];
    v20 = v11;
    if ( v13 )
      goto LABEL_5;
LABEL_12:
    v19 = (unsigned __int64)v10[8];
    if ( v19 )
    {
      free(v19, a2, a3, a4, a5, a6, a7, a8, a9);
      *(_DWORD *)a1 &= ~0x100u;
    }
    IO_wdoallocbuf(a1);
    v10 = *(unsigned int ***)(a1 + 160);
    goto LABEL_5;
  }
  if ( (unsigned int)IO_file_underflow_mmap(a1, a2, a3, a4, a5, a6, a7, a8, a9) == -1 )
    return 0xFFFFFFFFLL;
  v10 = *(unsigned int ***)(a1 + 160);
  v20 = *(_QWORD *)(a1 + 8);
  if ( !v10[6] )
    goto LABEL_12;
LABEL_5:
  v10[12] = v10[11];
  v14 = *(__int64 **)(a1 + 160);
  v15 = v14[6];
  v16 = v14[7];
  *v14 = v15;
  v14[2] = v15;
  _libio_codecvt_in(v12, (__int64)(v14 + 11), *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), &v20, v15, v16, v14 + 1);
  *(_QWORD *)(a1 + 8) = v20;
  v17 = **(unsigned int ***)(a1 + 160);
  if ( (unsigned __int64)v17 >= *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL) )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 84;
    *(_DWORD *)a1 |= 0x20u;
    return 0xFFFFFFFFLL;
  }
  return *v17;
}
// 43618C: variable 'a2' is possibly undefined
// 43618C: variable 'a3' is possibly undefined
// 43618C: variable 'a4' is possibly undefined
// 43618C: variable 'a5' is possibly undefined
// 43618C: variable 'a6' is possibly undefined
// 43618C: variable 'a7' is possibly undefined
// 43618C: variable 'a8' is possibly undefined
// 43618C: variable 'a9' is possibly undefined

//----- (00000000004361CC) ----------------------------------------------------
__int64 __fastcall IO_wfile_underflow_maybe_mmap(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 result; // x0

  result = IO_file_underflow_maybe_mmap(a1, a2, a3, a4, a5, a6, a7, a8, a9);
  if ( (_DWORD)result != -1 )
    return (*(__int64 (__fastcall **)(__int64))(*(_QWORD *)(*(_QWORD *)(a1 + 160) + 224LL) + 32LL))(a1);
  return result;
}

//----- (0000000000436220) ----------------------------------------------------
__int64 __fastcall IO_wfile_overflow(
        int *a1,
        unsigned int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16,
        char a17)
{
  __int64 v17; // x3
  int v18; // w0
  __int64 v19; // x5
  _QWORD *v20; // x4
  __int64 v21; // x1
  __int64 v22; // x1
  __int64 v23; // x8
  __int64 v24; // x2
  __int64 v25; // x7
  _DWORD *v26; // x0
  _QWORD *v27; // x1
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  int v38; // w0
  int v39; // w0
  char v40; // [xsp+0h] [xbp+0h]
  __int64 v41; // [xsp+10h] [xbp+10h]
  int v42; // [xsp+10h] [xbp+10h]
  __int64 v43; // [xsp+10h] [xbp+10h]
  unsigned int v44; // [xsp+1Ch] [xbp+1Ch]
  unsigned int v45; // [xsp+1Ch] [xbp+1Ch]

  v17 = (__int64)a1;
  v18 = *a1;
  if ( (v18 & 8) != 0 )
  {
    *(_DWORD *)v17 = v18 | 0x20;
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 9;
    return 0xFFFFFFFFLL;
  }
  v19 = a2;
  v20 = *(_QWORD **)(v17 + 160);
  v21 = v20[3];
  if ( (v18 & 0x800) == 0 )
  {
    if ( v21 )
    {
      v22 = *v20;
      v23 = v20[7];
      if ( *v20 == v23 )
      {
        v22 = v20[6];
        v24 = *(_QWORD *)(v17 + 56);
        *(_QWORD *)(v17 + 16) = v24;
        v25 = v22;
        *v20 = v22;
        v20[1] = v22;
        a15 = v24;
      }
      else
      {
        v24 = *(_QWORD *)(v17 + 8);
        a15 = *(_QWORD *)(v17 + 16);
        v25 = v20[1];
      }
      goto LABEL_6;
    }
LABEL_17:
    v41 = v17;
    v44 = v19;
    IO_wdoallocbuf(v17);
    IO_free_wbackup_area((unsigned int *)v41, v30, v31, v32, v33, v34, v35, v36, v37);
    v17 = v41;
    v19 = v44;
    if ( *(_QWORD *)(v41 + 32) )
    {
      v24 = *(_QWORD *)(v41 + 8);
      a15 = *(_QWORD *)(v41 + 16);
    }
    else
    {
      IO_doallocbuf((int *)v41, a3, a4, a5, a6, a7, a8, a9, a10);
      v17 = v41;
      v19 = v44;
      v24 = *(_QWORD *)(v41 + 56);
      *(_QWORD *)(v41 + 16) = v24;
      a15 = v24;
    }
    v20 = *(_QWORD **)(v17 + 160);
    v22 = v20[6];
    v23 = v20[7];
    *v20 = v22;
    v20[1] = v22;
    v18 = *(_DWORD *)v17;
    v20[2] = v22;
    v25 = v22;
LABEL_6:
    v20[2] = v25;
    v20[3] = v22;
    v20[4] = v22;
    v20[5] = v23;
    *v20 = v25;
    a16 = *(_QWORD *)(v17 + 64);
    *(_QWORD *)(v17 + 8) = a15;
    *(_QWORD *)(v17 + 24) = a15;
    *(_QWORD *)(v17 + 32) = v24;
    *(_QWORD *)(v17 + 40) = v24;
    *(_QWORD *)(v17 + 48) = a16;
    *(_DWORD *)v17 = v18 | 0x800;
    if ( (v18 & 0x202) != 0 )
      v20[5] = v22;
    goto LABEL_8;
  }
  if ( !v21 )
    goto LABEL_17;
LABEL_8:
  if ( (_DWORD)v19 != -1 )
  {
    v26 = (_DWORD *)v20[4];
    v27 = v20;
    if ( v26 == (_DWORD *)v20[7] )
    {
      v45 = v19;
      v43 = v17;
      if ( *(int *)(v17 + 192) <= 0 )
      {
        IO_new_do_write(
          v17,
          *(_QWORD *)(v17 + 32),
          *(_QWORD *)(v17 + 40) - *(_QWORD *)(v17 + 32),
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          a9,
          a10);
        v19 = v45;
        v17 = v43;
      }
      else
      {
        IO_wdo_write(
          v17,
          v20[3],
          ((__int64)v26 - v20[3]) >> 2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          a9,
          a10,
          v17,
          (__int64)v20,
          v19,
          a15,
          a16,
          v40);
        v17 = v43;
        v19 = v45;
      }
      v27 = *(_QWORD **)(v17 + 160);
      v26 = (_DWORD *)v27[4];
    }
    v27[4] = v26 + 1;
    *v26 = v19;
    if ( (*(_DWORD *)v17 & 2) == 0 && ((*(_DWORD *)v17 & 0x200LL) == 0 || (_DWORD)v19 != 10) )
      return (unsigned int)v19;
    v42 = v19;
    if ( *(int *)(v17 + 192) <= 0 )
    {
      v39 = IO_new_do_write(
              v17,
              *(_QWORD *)(v17 + 32),
              *(_QWORD *)(v17 + 40) - *(_QWORD *)(v17 + 32),
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              a9,
              a10);
      LODWORD(v19) = v42;
      if ( v39 == -1 )
        return 0xFFFFFFFFLL;
    }
    else
    {
      v38 = IO_wdo_write(
              v17,
              v27[3],
              ((__int64)v26 - v27[3] + 4) >> 2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              a9,
              a10,
              v17,
              (__int64)v20,
              v19,
              a15,
              a16,
              v40);
      LODWORD(v19) = v42;
      if ( v38 == -1 )
        return 0xFFFFFFFFLL;
    }
    return (unsigned int)v19;
  }
  if ( *(int *)(v17 + 192) <= 0 )
    return IO_new_do_write(
             v17,
             *(_QWORD *)(v17 + 32),
             *(_QWORD *)(v17 + 40) - *(_QWORD *)(v17 + 32),
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9,
             a10);
  else
    return IO_wdo_write(
             v17,
             v20[3],
             (__int64)(v20[4] - v20[3]) >> 2,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9,
             a10,
             v17,
             (__int64)v20,
             v19,
             a15,
             a16,
             a17);
}
// 4363E8: conditional instruction was optimized away because w0.4<2u
// 4362F4: variable 'v30' is possibly undefined
// 4362F4: variable 'v31' is possibly undefined
// 4362F4: variable 'v32' is possibly undefined
// 4362F4: variable 'v33' is possibly undefined
// 4362F4: variable 'v34' is possibly undefined
// 4362F4: variable 'v35' is possibly undefined
// 4362F4: variable 'v36' is possibly undefined
// 4362F4: variable 'v37' is possibly undefined
// 436348: variable 'a3' is possibly undefined
// 436348: variable 'a4' is possibly undefined
// 436348: variable 'a5' is possibly undefined
// 436348: variable 'a6' is possibly undefined
// 436348: variable 'a7' is possibly undefined
// 436348: variable 'a8' is possibly undefined
// 436348: variable 'a9' is possibly undefined
// 436348: variable 'a10' is possibly undefined
// 436348: variable 'v20' is possibly undefined
// 436348: variable 'a15' is possibly undefined
// 436348: variable 'a16' is possibly undefined
// 436348: variable 'v40' is possibly undefined

//----- (00000000004364A0) ----------------------------------------------------
__int64 __fastcall IO_wfile_sync(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  _QWORD *v17; // x3
  unsigned __int64 v18; // x1
  unsigned __int64 v19; // x2
  __int64 v20; // x3
  __int64 *v21; // x21
  double v22; // d0
  double v23; // d1
  double v24; // d2
  double v25; // d3
  double v26; // d4
  double v27; // d5
  double v28; // d6
  double v29; // d7
  __int64 v30; // x20
  _QWORD *v32; // x0
  __int64 v33; // x4
  char v34; // [xsp+0h] [xbp+0h]

  v17 = *(_QWORD **)(a1 + 160);
  v18 = v17[3];
  v19 = v17[4];
  if ( v19 <= v18 )
    goto LABEL_5;
  v20 = *(unsigned int *)(a1 + 192);
  if ( (int)v20 <= 0 )
  {
    if ( !(unsigned int)IO_new_do_write(
                          a1,
                          *(_QWORD *)(a1 + 32),
                          *(_QWORD *)(a1 + 40) - *(_QWORD *)(a1 + 32),
                          a2,
                          a3,
                          a4,
                          a5,
                          a6,
                          a7,
                          a8,
                          a9) )
      goto LABEL_4;
    return 0xFFFFFFFFLL;
  }
  if ( (unsigned int)IO_wdo_write(
                       a1,
                       v18,
                       (__int64)(v19 - v18) >> 2,
                       a2,
                       a3,
                       a4,
                       a5,
                       a6,
                       a7,
                       a8,
                       a9,
                       v20,
                       a13,
                       a14,
                       a15,
                       a16,
                       v34) )
    return 0xFFFFFFFFLL;
LABEL_4:
  v17 = *(_QWORD **)(a1 + 160);
LABEL_5:
  if ( *v17 == v17[1] )
  {
LABEL_12:
    *(_QWORD *)(a1 + 144) = -1LL;
    return 0LL;
  }
  v21 = *(__int64 **)(a1 + 152);
  if ( (int)_libio_codecvt_encoding(v21) <= 0 )
  {
    v32 = *(_QWORD **)(a1 + 160);
    v33 = *v32 - v32[2];
    v32[11] = v32[12];
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(a1 + 24)
                        + (int)_libio_codecvt_length(
                                 (__int64)v21,
                                 *(_QWORD *)(a1 + 160) + 88LL,
                                 *(_QWORD *)(a1 + 24),
                                 *(_QWORD *)(a1 + 16),
                                 v33 >> 2);
  }
  v30 = *(_QWORD *)(a1 + 216);
  if ( (unsigned __int64)(v30 - (_QWORD)&_io_vtables) > 0x92F )
    IO_vtable_check(v22, v23, v24, v25, v26, v27, v28, v29);
  if ( (*(__int64 (__fastcall **)(__int64))(v30 + 128))(a1) != -1 )
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL) = **(_QWORD **)(a1 + 160);
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 8);
    goto LABEL_12;
  }
  if ( *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == 29 )
    goto LABEL_12;
  return 0xFFFFFFFFLL;
}
// 4364D4: variable 'v34' is possibly undefined
// 436610: variable 'v22' is possibly undefined
// 436610: variable 'v23' is possibly undefined
// 436610: variable 'v24' is possibly undefined
// 436610: variable 'v25' is possibly undefined
// 436610: variable 'v26' is possibly undefined
// 436610: variable 'v27' is possibly undefined
// 436610: variable 'v28' is possibly undefined
// 436610: variable 'v29' is possibly undefined

//----- (0000000000436620) ----------------------------------------------------
__int64 __fastcall IO_wfile_seekoff(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        int a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  unsigned __int64 *v13; // x0
  unsigned __int64 v16; // x1
  unsigned __int64 v17; // x2
  _BOOL4 v19; // w23
  __int64 v20; // x0
  __int64 v21; // x0
  __int64 *v22; // x22
  int v23; // w0
  __int64 *v24; // x1
  __int64 v25; // x4
  __int64 v26; // x0
  unsigned int v27; // w1
  __int64 v28; // x0
  __int64 v29; // x2
  __int64 v30; // x3
  __int64 v31; // x0
  __int64 v32; // x24
  double v33; // d0
  double v34; // d1
  double v35; // d2
  double v36; // d3
  double v37; // d4
  double v38; // d5
  double v39; // d6
  double v40; // d7
  __int64 v41; // x3
  __int64 v42; // x0
  __int64 v43; // x1
  __int64 v44; // x2
  __int64 v45; // x0
  __int64 v46; // x2
  __int64 v47; // x1
  _QWORD *v48; // x0
  __int64 v49; // x1
  unsigned int v50; // w0
  __int64 result; // x0
  unsigned __int64 v52; // x0
  _QWORD *v53; // x1
  __int64 v54; // x0
  __int64 v55; // x0
  double v56; // d0
  double v57; // d1
  double v58; // d2
  double v59; // d3
  double v60; // d4
  double v61; // d5
  double v62; // d6
  double v63; // d7
  __int64 v64; // x0
  _QWORD *v65; // x2
  __int64 v66; // x1
  __int64 v67; // x1
  unsigned __int64 v68; // x21
  unsigned __int64 v69; // x22
  unsigned int v70; // w1
  int v71; // w23
  bool v72; // cc
  __int64 v73; // x20
  __int64 v74; // x0
  unsigned __int64 v75; // x2
  unsigned __int64 v76; // x20
  unsigned __int64 v77; // x25
  __int64 *v78; // x24
  int v79; // w0
  __int64 v80; // x1
  void *v81; // x4
  void *v82; // x5
  void *v83; // x6
  __int64 v84; // x7
  __int64 v85; // x3
  __int64 v86; // x20
  __int64 v87; // x0
  __int64 v88; // x3
  __int64 v89; // x2
  _QWORD *v91; // x1
  __int64 v92; // x0
  __int64 v93; // x1
  __int64 v94; // x21
  __int64 v95; // x4
  int v96; // w0
  __int64 v97; // x2
  _QWORD *v98; // x22
  __int64 v99; // x2
  void *v100; // x3
  __int64 v101; // x20
  __int64 v102; // x20
  __int64 v103; // x1
  __int64 v104; // x21
  __int64 v105; // x2
  unsigned __int64 v106; // x0
  __int64 v107; // x2
  __int64 v108; // x5
  __int64 v109; // x6
  __int64 v110; // x0
  double v111; // d0
  double v112; // d1
  double v113; // d2
  double v114; // d3
  double v115; // d4
  double v116; // d5
  double v117; // d6
  double v118; // d7
  __int64 v119; // [xsp+58h] [xbp+58h]
  __int64 v120; // [xsp+58h] [xbp+58h]
  __int64 v121; // [xsp+58h] [xbp+58h]
  unsigned __int64 v122; // [xsp+58h] [xbp+58h]
  __int64 v123; // [xsp+58h] [xbp+58h]
  __int64 v124; // [xsp+58h] [xbp+58h]
  __int64 v125; // [xsp+58h] [xbp+58h]
  __int64 v126; // [xsp+58h] [xbp+58h]
  __int64 v127; // [xsp+58h] [xbp+58h]
  unsigned __int64 v128; // [xsp+58h] [xbp+58h]
  __int64 v129; // [xsp+60h] [xbp+60h]
  __int64 v130; // [xsp+60h] [xbp+60h]
  __int64 v131; // [xsp+60h] [xbp+60h]
  __int64 v132; // [xsp+70h] [xbp+70h] BYREF
  __int64 v133; // [xsp+78h] [xbp+78h] BYREF
  _QWORD v134[2]; // [xsp+80h] [xbp+80h] BYREF
  int v135; // [xsp+90h] [xbp+90h]
  __int64 v136; // [xsp+B0h] [xbp+B0h]

  v13 = *(unsigned __int64 **)(a1 + 160);
  if ( a4 )
  {
    v17 = v13[3];
    v16 = v13[4];
    v19 = v13[2] == v13[1] && v17 == v16;
    if ( v17 >= v16 && (*(_DWORD *)a1 & 0x800) == 0 )
    {
LABEL_12:
      if ( v13[6] )
      {
        if ( a3 != 1 )
        {
LABEL_14:
          if ( a3 != 2 )
          {
LABEL_24:
            IO_free_wbackup_area((unsigned int *)a1, a5, a6, a7, a8, a9, a10, a11, a12);
            v26 = *(_QWORD *)(a1 + 144);
            v27 = *(_DWORD *)a1;
            if ( v26 != -1 && *(_QWORD *)(a1 + 24) && (v27 & 0x100) == 0 )
            {
              v88 = *(_QWORD *)(a1 + 56);
              v89 = v26 - (*(_QWORD *)(a1 + 16) - v88);
              if ( v26 > a2 && a2 >= v89 )
              {
                v91 = *(_QWORD **)(a1 + 160);
                *(_QWORD *)(a1 + 24) = v88;
                *(_QWORD *)(a1 + 32) = v88;
                *(_QWORD *)(a1 + 40) = v88;
                *(_QWORD *)(a1 + 48) = v88;
                *(_QWORD *)(a1 + 8) = v88 + a2 - v89;
                v92 = v91[6];
                *v91 = v92;
                v91[1] = v92;
                v91[2] = v92;
                v91[3] = v92;
                v91[4] = v92;
                v91[5] = v92;
                if ( !(unsigned int)adjust_wide_data(a1, 0) )
                {
                  v93 = *(_QWORD *)(a1 + 144);
                  *(_DWORD *)a1 &= ~0x10u;
                  if ( (v93 & 0x8000000000000000LL) == 0 )
                  {
                    v94 = *(_QWORD *)(a1 + 216);
                    if ( (unsigned __int64)(v94 - (_QWORD)&_io_vtables) > 0x92F )
                      IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
                    (*(void (__fastcall **)(__int64))(v94 + 128))(a1);
                  }
                  return a2;
                }
                goto LABEL_46;
              }
            }
            if ( (v27 & 4) != 0 )
              goto LABEL_46;
            v29 = *(_QWORD *)(a1 + 56);
            v28 = *(_QWORD *)(a1 + 64);
            v30 = a2 & ~(v29 - v28);
            v72 = v28 - v29 < v30;
            v31 = *(_QWORD *)(a1 + 216);
            if ( v72 )
              v30 = 0LL;
            if ( (unsigned __int64)(v31 - (_QWORD)&_io_vtables) > 0x92F )
            {
              v125 = *(_QWORD *)(a1 + 216);
              v130 = v30;
              IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
              v31 = v125;
              v30 = v130;
            }
            v119 = v30;
            v32 = (*(__int64 (__fastcall **)(__int64))(v31 + 128))(a1);
            v41 = v119;
            if ( (v32 & 0x8000000000000000LL) == 0 )
            {
              if ( !v119 )
              {
                v46 = 0LL;
                v45 = 0LL;
                goto LABEL_39;
              }
              v42 = *(_QWORD *)(a1 + 216);
              if ( (unsigned __int64)(v42 - (_QWORD)&_io_vtables) > 0x92F )
              {
                v124 = *(_QWORD *)(a1 + 216);
                v129 = v41;
                IO_vtable_check(v33, v34, v35, v36, v37, v38, v39, v40);
                v42 = v124;
                v41 = v129;
              }
              v43 = *(_QWORD *)(a1 + 56);
              v44 = v41;
              if ( !v19 )
                v44 = *(_QWORD *)(a1 + 64) - v43;
              v120 = v41;
              v45 = (*(__int64 (__fastcall **)(__int64, __int64, __int64))(v42 + 112))(a1, v43, v44);
              v46 = v45;
              v41 = v120;
              if ( v120 <= v45 )
              {
LABEL_39:
                v47 = *(_QWORD *)(a1 + 56);
                v121 = v46;
                *(_QWORD *)(a1 + 24) = v47;
                *(_QWORD *)(a1 + 32) = v47;
                *(_QWORD *)(a1 + 8) = v47 + v41;
                *(_QWORD *)(a1 + 16) = v47 + v45;
                v48 = *(_QWORD **)(a1 + 160);
                *(_QWORD *)(a1 + 40) = v47;
                *(_QWORD *)(a1 + 48) = v47;
                v49 = v48[6];
                *v48 = v49;
                v48[1] = v49;
                v48[2] = v49;
                v48[3] = v49;
                v48[4] = v49;
                v48[5] = v49;
                if ( !(unsigned int)adjust_wide_data(a1, 1) )
                {
                  v50 = *(_DWORD *)a1;
                  *(_QWORD *)(a1 + 144) = v121 + v32;
                  *(_DWORD *)a1 = v50 & 0xFFFFFFEF;
                  return a2;
                }
                goto LABEL_46;
              }
              if ( v45 == -1 )
                a2 = v120;
              else
                a2 = v120 - v45;
              a3 = 1;
LABEL_46:
              IO_unsave_markers((_QWORD *)a1, a5, a6, a7, a8, a9, a10, a11, a12);
              v64 = *(_QWORD *)(a1 + 216);
              if ( (unsigned __int64)(v64 - (_QWORD)&_io_vtables) > 0x92F )
              {
                v123 = *(_QWORD *)(a1 + 216);
                IO_vtable_check(v56, v57, v58, v59, v60, v61, v62, v63);
                v64 = v123;
              }
              result = (*(__int64 (__fastcall **)(__int64, __int64, _QWORD))(v64 + 128))(a1, a2, a3);
              if ( result != -1 )
              {
                v65 = *(_QWORD **)(a1 + 160);
                *(_DWORD *)a1 &= ~0x10u;
                v66 = *(_QWORD *)(a1 + 56);
                *(_QWORD *)(a1 + 8) = v66;
                *(_QWORD *)(a1 + 16) = v66;
                *(_QWORD *)(a1 + 24) = v66;
                *(_QWORD *)(a1 + 32) = v66;
                *(_QWORD *)(a1 + 40) = v66;
                *(_QWORD *)(a1 + 48) = v66;
                v67 = v65[6];
                *(_QWORD *)(a1 + 144) = result;
                *v65 = v67;
                v65[1] = v67;
                v65[2] = v67;
                v65[3] = v67;
                v65[4] = v67;
                v65[5] = v67;
              }
              return result;
            }
            return -1LL;
          }
          v20 = *(_QWORD *)(a1 + 216);
          if ( (unsigned __int64)(v20 - (_QWORD)&_io_vtables) > 0x92F )
          {
            v126 = *(_QWORD *)(a1 + 216);
            IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
            v20 = v126;
          }
          if ( (*(unsigned int (__fastcall **)(__int64, _QWORD *))(v20 + 144))(a1, v134) || (v135 & 0xF000) != 0x8000 )
            goto LABEL_46;
          v21 = v136;
LABEL_23:
          a2 += v21;
          a3 = 0;
          goto LABEL_24;
        }
      }
      else
      {
        v52 = v13[2];
        if ( v52 )
        {
          free(v52, a5, a6, a7, a8, a9, a10, a11, a12);
          *(_DWORD *)a1 &= ~0x100u;
        }
        IO_doallocbuf((int *)a1, a5, a6, a7, a8, a9, a10, a11, a12);
        v53 = *(_QWORD **)(a1 + 160);
        v54 = *(_QWORD *)(a1 + 56);
        *(_QWORD *)(a1 + 8) = v54;
        *(_QWORD *)(a1 + 16) = v54;
        *(_QWORD *)(a1 + 24) = v54;
        *(_QWORD *)(a1 + 32) = v54;
        *(_QWORD *)(a1 + 40) = v54;
        *(_QWORD *)(a1 + 48) = v54;
        v55 = v53[6];
        *v53 = v55;
        v53[1] = v55;
        v53[2] = v55;
        v53[3] = v55;
        v53[4] = v55;
        v53[5] = v55;
        if ( a3 != 1 )
          goto LABEL_14;
      }
      v22 = *(__int64 **)(a1 + 152);
      v23 = _libio_codecvt_encoding(v22);
      v24 = *(__int64 **)(a1 + 160);
      v25 = *v24;
      if ( v23 <= 0 )
      {
        v95 = v25 - v24[2];
        v24[11] = v24[12];
        v96 = _libio_codecvt_length(
                (__int64)v22,
                *(_QWORD *)(a1 + 160) + 88LL,
                *(_QWORD *)(a1 + 24),
                *(_QWORD *)(a1 + 16),
                v95 >> 2);
        v97 = *(_QWORD *)(a1 + 24);
        *(_QWORD *)(a1 + 8) = v97 + v96;
        *(_QWORD *)(*(_QWORD *)(a1 + 160) + 8LL) = **(_QWORD **)(a1 + 160);
        a2 -= *(_QWORD *)(a1 + 16) - v97 - v96;
      }
      else
      {
        a2 = a2 - ((v24[1] - v25) >> 2) * v23 - (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8));
      }
      v21 = *(_QWORD *)(a1 + 144);
      if ( v21 == -1 )
        goto LABEL_46;
      goto LABEL_23;
    }
    if ( !(unsigned int)IO_switch_to_wget_mode((unsigned int *)a1) )
    {
      v13 = *(unsigned __int64 **)(a1 + 160);
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  if ( v13[6] )
  {
    v69 = v13[3];
    v68 = v13[4];
    v70 = *(_DWORD *)a1;
    v71 = *(_DWORD *)a1 & 0x1000;
    if ( v71 )
      v72 = v68 > v69;
    else
      v72 = 0;
    if ( v72 )
    {
      v73 = *(_QWORD *)(a1 + 216);
      if ( (unsigned __int64)(v73 - (_QWORD)&_io_vtables) > 0x92F )
        IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
      v74 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(v73 + 128))(a1, 0LL, 2LL);
      if ( v74 == -1 )
        return -1LL;
      v70 = *(_DWORD *)a1;
      *(_QWORD *)(a1 + 144) = v74;
      v13 = *(unsigned __int64 **)(a1 + 160);
    }
    v75 = *v13;
    v76 = v13[1];
    if ( (v70 & 0x100) != 0 )
    {
      if ( v75 < v76 )
        goto LABEL_69;
      v75 = v13[8];
      v76 = v13[10];
      v77 = v75;
    }
    else
    {
      v77 = v13[2];
    }
    v122 = v75;
    v78 = *(__int64 **)(a1 + 152);
    v79 = _libio_codecvt_encoding(v78);
    if ( v68 > v69 )
    {
      v98 = *(_QWORD **)(a1 + 160);
      v99 = v98[3];
      v100 = (void *)v98[4];
      v101 = (__int64)v100 - v99;
      if ( v79 <= 0 )
      {
        v127 = v98[3];
        v131 = v98[4];
        v106 = malloc((__int64)v100 - v99, v80, v99, v100, v81, v82, v83, v84, a5, a6, a7, a8, a9, a10, a11, a12);
        v107 = v127;
        v108 = v106;
        v109 = v106 + v101;
        v110 = v98[12];
        v128 = v108;
        v132 = v108;
        v133 = v107;
        v134[0] = v110;
        if ( (unsigned int)_libio_codecvt_out(v78, (__int64)v134, v107, v131, &v133, v108, v109, &v132) )
        {
          free(v128, v111, v112, v113, v114, v115, v116, v117, v118);
          return 0xFFFFFFFFLL;
        }
        v102 = v132 - v128;
        free(v128, v111, v112, v113, v114, v115, v116, v117, v118);
      }
      else
      {
        v102 = (v101 >> 2) * v79;
      }
      if ( v71 )
        v103 = *(_QWORD *)(a1 + 32);
      else
        v103 = *(_QWORD *)(a1 + 16);
      v86 = *(_QWORD *)(a1 + 40) - v103 + v102;
    }
    else
    {
      v85 = *(_QWORD *)(a1 + 16);
      if ( v79 <= 0 )
      {
        v105 = *(_QWORD *)(a1 + 24);
        v134[0] = *(_QWORD *)(*(_QWORD *)(a1 + 160) + 96LL);
        v86 = (int)_libio_codecvt_length((__int64)v78, (__int64)v134, v105, v85, (__int64)(v122 - v77) >> 2)
            - (*(_QWORD *)(a1 + 16)
             - *(_QWORD *)(a1 + 24));
      }
      else
      {
        v86 = -(v79 * ((__int64)(v76 - v122) >> 2)) - (v85 - *(_QWORD *)(a1 + 8));
      }
    }
  }
  else
  {
    v86 = 0LL;
  }
  v87 = *(_QWORD *)(a1 + 144);
  if ( v87 == -1 )
  {
    v104 = *(_QWORD *)(a1 + 216);
    if ( (unsigned __int64)(v104 - (_QWORD)&_io_vtables) > 0x92F )
      IO_vtable_check(a5, a6, a7, a8, a9, a10, a11, a12);
    v87 = (*(__int64 (__fastcall **)(__int64, _QWORD, __int64))(v104 + 128))(a1, 0LL, 1LL);
    if ( v87 == -1 )
      return -1LL;
  }
  result = v86 + v87;
  if ( result < 0 )
  {
LABEL_69:
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return -1LL;
  }
  return result;
}
// 436C78: variable 'a5' is possibly undefined
// 436C78: variable 'a6' is possibly undefined
// 436C78: variable 'a7' is possibly undefined
// 436C78: variable 'a8' is possibly undefined
// 436C78: variable 'a9' is possibly undefined
// 436C78: variable 'a10' is possibly undefined
// 436C78: variable 'a11' is possibly undefined
// 436C78: variable 'a12' is possibly undefined
// 436C50: variable 'v33' is possibly undefined
// 436C50: variable 'v34' is possibly undefined
// 436C50: variable 'v35' is possibly undefined
// 436C50: variable 'v36' is possibly undefined
// 436C50: variable 'v37' is possibly undefined
// 436C50: variable 'v38' is possibly undefined
// 436C50: variable 'v39' is possibly undefined
// 436C50: variable 'v40' is possibly undefined
// 436C1C: variable 'v56' is possibly undefined
// 436C1C: variable 'v57' is possibly undefined
// 436C1C: variable 'v58' is possibly undefined
// 436C1C: variable 'v59' is possibly undefined
// 436C1C: variable 'v60' is possibly undefined
// 436C1C: variable 'v61' is possibly undefined
// 436C1C: variable 'v62' is possibly undefined
// 436C1C: variable 'v63' is possibly undefined
// 436A40: variable 'v111' is possibly undefined
// 436A40: variable 'v112' is possibly undefined
// 436A40: variable 'v113' is possibly undefined
// 436A40: variable 'v114' is possibly undefined
// 436A40: variable 'v115' is possibly undefined
// 436A40: variable 'v116' is possibly undefined
// 436A40: variable 'v117' is possibly undefined
// 436A40: variable 'v118' is possibly undefined
// 436CCC: variable 'v80' is possibly undefined
// 436CCC: variable 'v81' is possibly undefined
// 436CCC: variable 'v82' is possibly undefined
// 436CCC: variable 'v83' is possibly undefined
// 436CCC: variable 'v84' is possibly undefined

//----- (0000000000436D50) ----------------------------------------------------
unsigned __int64 __fastcall IO_wfile_xsputn(
        __int64 a1,
        unsigned int *a2,
        unsigned __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  __int64 v11; // x5
  __int64 *v12; // x8
  unsigned int *v13; // x7
  unsigned __int64 v14; // x3
  unsigned __int64 v15; // x6
  unsigned __int64 v16; // x4
  int v18; // w10
  unsigned __int64 v19; // x0
  unsigned __int64 v20; // x2
  unsigned __int64 v21; // x0
  __int64 v22; // x4
  __int64 v23; // x0
  __int64 v24; // x1
  __int64 v25; // x2
  unsigned int *v26; // x2
  int v27; // t1
  unsigned __int64 v28; // x2
  __int64 v29; // x1
  char *v30; // x0
  char v31; // [xsp+0h] [xbp+0h]
  __int64 v32; // [xsp+10h] [xbp+10h]
  unsigned __int64 v33; // [xsp+10h] [xbp+10h]
  unsigned __int64 v35; // [xsp+18h] [xbp+18h]
  unsigned __int64 v36; // [xsp+18h] [xbp+18h]
  int v37; // [xsp+24h] [xbp+24h]
  int v38; // [xsp+24h] [xbp+24h]
  unsigned __int64 v39; // [xsp+28h] [xbp+28h]
  __int64 *v40; // [xsp+28h] [xbp+28h]
  unsigned __int64 v41; // [xsp+30h] [xbp+30h]
  __int64 v42; // [xsp+38h] [xbp+38h]

  if ( !a3 )
    return 0LL;
  v11 = a1;
  v12 = *(__int64 **)(a1 + 160);
  v13 = a2;
  v14 = a3;
  v15 = v12[4];
  if ( (*(_DWORD *)a1 & 0xA00) == 0xA00 )
  {
    v26 = &a2[a3];
    v19 = (__int64)(v12[7] - v15) >> 2;
    if ( v14 <= v19 )
    {
      do
      {
        if ( v26 <= a2 )
        {
          v18 = 0;
          goto LABEL_15;
        }
        v27 = *--v26;
      }
      while ( v27 != 10 );
      v18 = 1;
      v19 = v26 - a2 + 1;
    }
    else
    {
      v18 = 0;
    }
  }
  else
  {
    v16 = v12[5];
    if ( v16 <= v15 )
      return IO_wdefault_xsputn(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
    v18 = 0;
    v19 = (__int64)(v16 - v15) >> 2;
  }
  v20 = v14;
  if ( !v19 )
  {
LABEL_8:
    v32 = v11;
    v35 = v20;
    v37 = v18;
    v39 = v14;
    v21 = IO_wdefault_xsputn(v11, v13, v20, a4, a5, a6, a7, a8, a9, a10, a11);
    v11 = v32;
    v14 = v39 + v21 - v35;
    if ( v37 )
      goto LABEL_9;
    return v14;
  }
LABEL_15:
  if ( v19 > v14 )
    v28 = v14;
  else
    v28 = v19;
  if ( v28 > 0x14 )
  {
    v36 = v28;
    v38 = v18;
    v40 = v12;
    v41 = v14;
    v42 = v11;
    v30 = wmempcpy(v12[4], (__int64)a2, v28);
    v28 = v36;
    v11 = v42;
    v12 = v40;
    v14 = v41;
    v18 = v38;
    v13 = &a2[v36];
  }
  else
  {
    v22 = 0LL;
    do
    {
      *(_DWORD *)(v15 + v22 * 4) = a2[v22];
      ++v22;
    }
    while ( v22 != (unsigned int)v28 );
    v29 = 4LL * (unsigned int)(v28 - 1);
    v30 = (char *)(v15 + 4 + v29);
    v13 = (unsigned int *)((char *)v13 + v29 + 4);
  }
  v12[4] = (__int64)v30;
  v20 = v14 - v28;
  if ( v20 )
    goto LABEL_8;
  if ( v18 )
  {
LABEL_9:
    v23 = *(_QWORD *)(v11 + 160);
    v24 = *(_QWORD *)(v23 + 24);
    v25 = *(_QWORD *)(v23 + 32);
    if ( v25 != v24 )
    {
      v33 = v14;
      IO_wdo_write(
        v11,
        v24,
        (v25 - v24) >> 2,
        a4,
        a5,
        a6,
        a7,
        a8,
        a9,
        a10,
        a11,
        v14,
        v22 * 4,
        v11,
        v15,
        (__int64)v13,
        v31);
      return v33;
    }
  }
  return v14;
}
// 436DC8: variable 'a4' is possibly undefined
// 436DC8: variable 'a5' is possibly undefined
// 436DC8: variable 'a6' is possibly undefined
// 436DC8: variable 'a7' is possibly undefined
// 436DC8: variable 'a8' is possibly undefined
// 436DC8: variable 'a9' is possibly undefined
// 436DC8: variable 'a10' is possibly undefined
// 436DC8: variable 'a11' is possibly undefined
// 436E04: variable 'v22' is possibly undefined
// 436E04: variable 'v15' is possibly undefined
// 436E04: variable 'v13' is possibly undefined
// 436E04: variable 'v31' is possibly undefined

//----- (0000000000436F00) ----------------------------------------------------
__int64 __fastcall IO_fwide(__int64 a1, int a2)
{
  __int64 result; // x0
  _QWORD *v4; // x1
  __int64 v5; // x0
  __int64 v6; // x6
  __int64 v7; // x4
  __int64 v8; // x1
  __int64 v9; // [xsp+18h] [xbp-38h]
  _QWORD *v10; // [xsp+20h] [xbp-30h]
  _QWORD *v11; // [xsp+28h] [xbp-28h]
  __int128 v12; // [xsp+30h] [xbp-20h] BYREF
  __int64 v13; // [xsp+40h] [xbp-10h]
  __int64 v14; // [xsp+48h] [xbp-8h]

  result = *(unsigned int *)(a1 + 192);
  if ( a2 < 0 )
  {
    if ( !(_DWORD)result )
    {
      result = 0xFFFFFFFFLL;
      *(_DWORD *)(a1 + 192) = -1;
    }
  }
  else if ( !(_DWORD)result && a2 )
  {
    v4 = *(_QWORD **)(a1 + 160);
    v11 = v4 + 13;
    v5 = v4[1];
    *(_QWORD *)(a1 + 152) = v4 + 13;
    v4[11] = 0LL;
    *v4 = v5;
    v4[4] = v4[3];
    *(_QWORD *)(*(_QWORD *)(a1 + 160) + 96LL) = 0LL;
    v9 = a1;
    v10 = v4;
    _wcsmbs_clone_conv(&v12);
    if ( *((_QWORD *)&v12 + 1) != 1LL )
      _libc_assert_fail((__int64)"fcts.towc_nsteps == 1", (__int64)"iofwide.c", 0x50u, (__int64)"_IO_fwide");
    result = v14;
    if ( v14 != 1 )
      _libc_assert_fail((__int64)"fcts.tomb_nsteps == 1", (__int64)"iofwide.c", 0x51u, (__int64)"_IO_fwide");
    v10[13] = v12;
    v6 = v13;
    v7 = *(_QWORD *)(v9 + 160);
    *((_DWORD *)v11 + 8) = 1;
    v10[16] = 1LL;
    v11[7] = v6;
    v11[5] = v7 + 88;
    *((_DWORD *)v11 + 22) = 1;
    v10[23] = 9LL;
    v8 = *(_QWORD *)(v7 + 224);
    v11[12] = v7 + 88;
    *(_DWORD *)(v9 + 192) = 1;
    *(_QWORD *)(v9 + 216) = v8;
  }
  return result;
}

//----- (0000000000437020) ----------------------------------------------------
__int64 __fastcall _libio_codecvt_out(
        _QWORD *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        _QWORD *a5,
        __int64 a6,
        __int64 a7,
        _QWORD *a8)
{
  _QWORD *v10; // x0
  unsigned __int64 v12; // x8
  int v13; // w0

  v10 = (_QWORD *)a1[7];
  a1[8] = a6;
  a1[9] = a7;
  v12 = v10[5];
  a1[12] = a2;
  if ( *v10 )
    v12 ^= _pointer_chk_guard_local;
  v13 = ((__int64 (*)(void))v12)();
  *a5 = a3;
  *a8 = a1[8];
  if ( v13 == 5 )
    return 1LL;
  if ( v13 <= 5 )
    return 2 * (unsigned int)((v13 & 0xFFFFFFFB) != 0);
  return (unsigned int)(v13 != 7) + 1;
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (00000000004370E8) ----------------------------------------------------
__int64 __fastcall _libio_codecvt_in(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        _QWORD *a5,
        __int64 a6,
        __int64 a7,
        _QWORD *a8)
{
  _QWORD *v10; // x0
  unsigned __int64 v12; // x8
  int v13; // w0

  v10 = *(_QWORD **)a1;
  *(_QWORD *)(a1 + 8) = a6;
  *(_QWORD *)(a1 + 16) = a7;
  v12 = v10[5];
  *(_QWORD *)(a1 + 40) = a2;
  if ( *v10 )
    v12 ^= _pointer_chk_guard_local;
  v13 = ((__int64 (*)(void))v12)();
  *a5 = a3;
  *a8 = *(_QWORD *)(a1 + 8);
  if ( v13 == 5 )
    return 1LL;
  if ( v13 <= 5 )
    return 2 * (unsigned int)((v13 & 0xFFFFFFFB) != 0);
  return (unsigned int)(v13 != 7) + 1;
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (00000000004371B0) ----------------------------------------------------
__int64 __fastcall _libio_codecvt_encoding(__int64 *a1)
{
  __int64 v1; // x1
  __int64 result; // x0

  v1 = *a1;
  if ( *(_DWORD *)(*a1 + 88) )
    return 0xFFFFFFFFLL;
  LODWORD(result) = *(_DWORD *)(v1 + 72);
  if ( (_DWORD)result == *(_DWORD *)(v1 + 76) )
    return (unsigned int)result;
  else
    return 0LL;
}

//----- (00000000004371E0) ----------------------------------------------------
__int64 __fastcall _libio_codecvt_length(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  int v6; // w19
  _QWORD *v7; // x0
  unsigned __int64 v8; // x9
  __int64 v10; // [xsp+0h] [xbp+0h] BYREF
  __int64 v11; // [xsp+20h] [xbp+20h]

  v6 = a3;
  v7 = *(_QWORD **)a1;
  v11 = a3;
  *(_QWORD *)(a1 + 8) = &v10;
  *(_QWORD *)(a1 + 16) = (char *)&v10 + 4 * a5;
  *(_QWORD *)(a1 + 40) = a2;
  v8 = v7[5];
  if ( *v7 )
    v8 ^= _pointer_chk_guard_local;
  ((void (*)(void))v8)();
  return (unsigned int)(v11 - v6);
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000437280) ----------------------------------------------------
__int64 __fastcall _printf_buffer_flush_asprintf(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        void *a12,
        __int64 a13,
        void *a14,
        void *a15,
        __int64 a16)
{
  void *v17; // x4
  unsigned __int64 v18; // x2
  unsigned __int64 v19; // x0
  unsigned __int64 v20; // x20
  __int64 result; // x0
  unsigned __int64 v22; // x2
  __int64 v23; // x3
  unsigned __int64 StatusReg; // x1
  unsigned __int64 v25; // [xsp+20h] [xbp+20h]
  unsigned __int64 v26; // [xsp+20h] [xbp+20h]
  unsigned __int64 v27; // [xsp+28h] [xbp+28h]
  __int64 v28; // [xsp+28h] [xbp+28h]

  v17 = *(void **)a1;
  v18 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  if ( v18 > 0x7FFFFFFE )
  {
    result = 40LL;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    *(_DWORD *)(a1 + 32) = 0;
    *(_DWORD *)(StatusReg + 40) = 75;
    return result;
  }
  v19 = *(_QWORD *)(a1 + 16) - (_QWORD)v17;
  v20 = (v19 + 15 + (v19 >> 1)) & 0xFFFFFFFFFFFFFFF0LL | 8;
  if ( v17 == (void *)(a1 + 40) )
  {
    v27 = v18;
    result = malloc(v20, v19 + 15, v18, a12, v17, a14, a15, a16, a2, a3, a4, a5, a6, a7, a8, a9);
    if ( result )
    {
      v26 = v27;
      v28 = result;
      result = (__int64)j_memcpy();
      v22 = v26;
      v23 = v28;
      goto LABEL_4;
    }
LABEL_9:
    *(_DWORD *)(a1 + 32) = 0;
    return result;
  }
  v25 = v18;
  result = realloc((unsigned __int64)v17, v20, v18, a12, v17, a14, a15, a16, a2, a3, a4, a5, a6, a7, a8, a9);
  v22 = v25;
  v23 = result;
  if ( !result )
    goto LABEL_9;
LABEL_4:
  *(_QWORD *)a1 = v23;
  *(_QWORD *)(a1 + 8) = v23 + v22;
  *(_QWORD *)(a1 + 16) = v23 + v20;
  return result;
}

//----- (0000000000437360) ----------------------------------------------------
__int64 __fastcall _vasprintf_internal(
        unsigned __int64 *a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  __int64 v10; // x2
  void *v11; // x3
  void *v12; // x5
  void *v13; // x6
  __int64 v14; // x7
  unsigned int v15; // w19
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  __int64 v24; // x22
  __int64 v25; // x1
  unsigned __int64 v26; // x0
  double v27; // d0
  double v28; // d1
  double v29; // d2
  double v30; // d3
  double v31; // d4
  double v32; // d5
  double v33; // d6
  double v34; // d7
  unsigned __int64 v35; // x21
  unsigned __int64 v37; // x0
  _BYTE *v38; // [xsp+60h] [xbp+60h] BYREF
  _BYTE *v39; // [xsp+68h] [xbp+68h]
  char *v40; // [xsp+70h] [xbp+70h]
  __int64 v41; // [xsp+78h] [xbp+78h]
  int v42; // [xsp+80h] [xbp+80h]
  _BYTE v43[200]; // [xsp+88h] [xbp+88h] BYREF

  v38 = v43;
  v39 = v43;
  v40 = &a9;
  v41 = 0LL;
  v42 = 5;
  _printf_buffer(&v38);
  v15 = _printf_buffer_done((__int64)&v38);
  if ( (v15 & 0x80000000) == 0 )
  {
    v24 = v39 - v38;
    v25 = v39 - v38 + 1;
    if ( v38 == v43 )
    {
      v37 = malloc(v39 - v38 + 1, v25, v10, v11, v38, v12, v13, v14, v16, v17, v18, v19, v20, v21, v22, v23);
      *a1 = v37;
      v35 = v37;
      if ( v37 )
      {
        j_memcpy();
        goto LABEL_4;
      }
    }
    else
    {
      v26 = realloc((unsigned __int64)v38, v25, v10, v11, v38, v12, v13, v14, v16, v17, v18, v19, v20, v21, v22, v23);
      *a1 = v26;
      v35 = v26;
      if ( v26 )
      {
LABEL_4:
        *(_BYTE *)(v35 + v24) = 0;
        return v15;
      }
      free((unsigned __int64)v38, v27, v28, v29, v30, v31, v32, v33, v34);
    }
    return (unsigned int)-1;
  }
  if ( v38 != v43 )
    free((unsigned __int64)v38, v16, v17, v18, v19, v20, v21, v22, v23);
  *a1 = 0LL;
  return v15;
}
// 4373D0: variable 'v10' is possibly undefined
// 4373D0: variable 'v11' is possibly undefined
// 4373D0: variable 'v12' is possibly undefined
// 4373D0: variable 'v13' is possibly undefined
// 4373D0: variable 'v14' is possibly undefined
// 4373D0: variable 'v16' is possibly undefined
// 4373D0: variable 'v17' is possibly undefined
// 4373D0: variable 'v18' is possibly undefined
// 4373D0: variable 'v19' is possibly undefined
// 4373D0: variable 'v20' is possibly undefined
// 4373D0: variable 'v21' is possibly undefined
// 4373D0: variable 'v22' is possibly undefined
// 4373D0: variable 'v23' is possibly undefined
// 43744C: variable 'v27' is possibly undefined
// 43744C: variable 'v28' is possibly undefined
// 43744C: variable 'v29' is possibly undefined
// 43744C: variable 'v30' is possibly undefined
// 43744C: variable 'v31' is possibly undefined
// 43744C: variable 'v32' is possibly undefined
// 43744C: variable 'v33' is possibly undefined
// 43744C: variable 'v34' is possibly undefined
// 4039F0: using guessed type __int64 __fastcall _printf_buffer(_QWORD);

//----- (0000000000437460) ----------------------------------------------------
__int64 __fastcall vasprintf(
        unsigned __int64 *a1,
        __int64 a2,
        _OWORD *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  __int128 v8; // q31
  char v10; // [xsp+0h] [xbp+0h]
  _OWORD v11[2]; // [xsp+10h] [xbp+10h] BYREF

  v8 = a3[1];
  v11[0] = *a3;
  v11[1] = v8;
  return _vasprintf_internal(a1, a2, (__int64)v11, 0LL, a5, a6, a7, a8, v10);
}
// 43747C: variable 'v10' is possibly undefined

//----- (00000000004374A0) ----------------------------------------------------
_QWORD *__fastcall _printf_buffer_flush_snprintf(_QWORD *result)
{
  _QWORD *v1; // x3
  _QWORD *v2; // x1
  _QWORD *v3; // x2

  v1 = (_QWORD *)*result;
  result[3] += result[1] - *result;
  v2 = result + 5;
  if ( v1 != result + 5 )
  {
    v3 = (_QWORD *)result[2];
    if ( v1 != v3 )
      *((_BYTE *)v3 - 1) = 0;
    result[2] = result + 21;
  }
  *result = v2;
  result[1] = v2;
  return result;
}

//----- (00000000004374E0) ----------------------------------------------------
__int64 __fastcall _printf_buffer_snprintf_init(__int64 result, _BYTE *a2, __int64 a3)
{
  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = a2;
  *(_QWORD *)(result + 16) = &a2[a3];
  *(_QWORD *)(result + 24) = 0LL;
  *(_DWORD *)(result + 32) = 2;
  if ( a3 )
    *a2 = 0;
  return result;
}

//----- (0000000000437500) ----------------------------------------------------
__int64 __fastcall _printf_buffer_snprintf_done(__int64 a1)
{
  _BYTE *v1; // x1

  v1 = *(_BYTE **)(a1 + 8);
  if ( (unsigned __int64)v1 >= *(_QWORD *)(a1 + 16) )
  {
    if ( (unsigned __int64)v1 > *(_QWORD *)a1 )
      *(v1 - 1) = 0;
  }
  else
  {
    *v1 = 0;
  }
  return _printf_buffer_done(a1);
}

//----- (0000000000437528) ----------------------------------------------------
__int64 __fastcall _vsnprintf_internal(_BYTE *a1, __int64 a2)
{
  _BYTE *v3; // [xsp+40h] [xbp+40h] BYREF
  _BYTE *v4; // [xsp+48h] [xbp+48h]
  _BYTE *v5; // [xsp+50h] [xbp+50h]
  __int64 v6; // [xsp+58h] [xbp+58h]
  int v7; // [xsp+60h] [xbp+60h]

  v3 = a1;
  v4 = a1;
  v5 = &a1[a2];
  v6 = 0LL;
  v7 = 2;
  if ( a2 )
    *a1 = 0;
  _printf_buffer(&v3);
  if ( v4 < v5 )
  {
    *v4 = 0;
    return _printf_buffer_done((__int64)&v3);
  }
  if ( v4 <= v3 )
    return _printf_buffer_done((__int64)&v3);
  *(v4 - 1) = 0;
  return _printf_buffer_done((__int64)&v3);
}
// 4039F0: using guessed type __int64 __fastcall _printf_buffer(_QWORD);

//----- (00000000004375B0) ----------------------------------------------------
__int64 __fastcall vsnprintf(_BYTE *a1, __int64 a2, __int64 a3, __int128 *a4)
{
  __int128 v4; // q30
  __int128 v5; // q31
  _OWORD v7[2]; // [xsp+20h] [xbp+20h] BYREF
  __int128 v8; // [xsp+40h] [xbp+40h]
  __int128 v9; // [xsp+50h] [xbp+50h]
  _BYTE *v10; // [xsp+60h] [xbp+60h] BYREF
  _BYTE *v11; // [xsp+68h] [xbp+68h]
  _BYTE *v12; // [xsp+70h] [xbp+70h]
  __int64 v13; // [xsp+78h] [xbp+78h]
  int v14; // [xsp+80h] [xbp+80h]

  v4 = *a4;
  v5 = a4[1];
  v10 = a1;
  v11 = a1;
  v12 = &a1[a2];
  v13 = 0LL;
  v14 = 2;
  v8 = v4;
  v9 = v5;
  if ( a2 )
    *a1 = 0;
  v7[0] = v8;
  v7[1] = v9;
  _printf_buffer((unsigned __int64)&v10, a3, (__int64 *)v7, 0);
  if ( v11 < v12 )
  {
    *v11 = 0;
    return _printf_buffer_done((__int64)&v10);
  }
  if ( v11 <= v10 )
    return _printf_buffer_done((__int64)&v10);
  *(v11 - 1) = 0;
  return _printf_buffer_done((__int64)&v10);
}

//----- (0000000000437660) ----------------------------------------------------
_BYTE *__fastcall fgets_unlocked(
        _BYTE *result,
        int a2,
        int *a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  int v11; // w7
  _BYTE *v12; // x1
  int v13; // w2
  int v15; // [xsp+24h] [xbp-Ch]
  _BYTE *v16; // [xsp+28h] [xbp-8h]

  if ( a2 <= 0 )
    return 0LL;
  if ( a2 == 1 )
  {
    *result = 0;
  }
  else
  {
    v11 = *a3 & 0x20;
    *a3 &= ~0x20u;
    v15 = v11;
    v16 = result;
    v12 = IO_getline(
            (__int64)a3,
            (__int64)result,
            a2 - 1,
            0xAuLL,
            1LL,
            a4,
            a5,
            a6,
            a7,
            a8,
            a9,
            a10,
            a11,
            (__int64)a3,
            result);
    result = 0LL;
    v13 = *a3;
    if ( v12 && ((v13 & 0x20) == 0 || *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) == 11) )
    {
      v12[(_QWORD)v16] = 0;
      result = v16;
      *a3 |= v15;
    }
    else
    {
      *a3 = v15 | v13;
    }
  }
  return result;
}

//----- (0000000000437740) ----------------------------------------------------
bool __fastcall _libc_alloca_cutoff(unsigned __int64 a1)
{
  unsigned __int64 v1; // x1

  v1 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824 + 0x498) >> 2;
  if ( v1 - 1 > 0xFFFF )
    v1 = 0x10000LL;
  return v1 >= a1;
}

//----- (0000000000437780) ----------------------------------------------------
__int64 _syscall_do_cancel()
{
  unsigned __int64 StatusReg; // x20
  int v1; // w19
  int v2; // w0
  bool v3; // zf
  unsigned __int64 v4; // x20

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v1 = *(_DWORD *)(StatusReg - 1560);
  do
  {
    if ( (v1 & 1) != 0 )
      break;
    _aarch64_cas4_acq();
    v3 = v2 == v1;
    v1 = v2;
  }
  while ( !v3 );
  v4 = StatusReg - 1824;
  *(_QWORD *)(v4 + 0x428) = -1LL;
  _aarch64_ldset4_relax();
  return _internal_syscall_cancel(*(_QWORD *)(v4 + 0x100));
}
// 4377B0: variable 'v2' is possibly undefined
// 4377E0: using guessed type __int64 __fastcall _internal_syscall_cancel(_QWORD);

//----- (00000000004377E0) ----------------------------------------------------
__int64 __fastcall _internal_syscall_cancel(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  _DWORD *v7; // x9
  int v8; // w7
  __int64 result; // x0
  __int64 v10; // x0
  _DWORD *v11; // [xsp+18h] [xbp+18h]

  v7 = (_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1560);
  v8 = *v7;
  if ( _libc_single_threaded || (v8 & 1) != 0 || (v8 & 0x10) != 0 )
    return linux_eabi_syscall((signed __int64)a7, a1, a2, a3, a4, a5, a6, a7);
  v11 = v7;
  result = _syscall_cancel_arch(v7, (signed __int64)a7, a1, a2, a3, a4, a5, a6);
  if ( result == -4 && (*v11 & 0x39) == 8 )
  {
    v10 = _syscall_do_cancel();
    return _syscall_cancel(v10);
  }
  return result;
}
// 437870: using guessed type __int64 __fastcall _syscall_cancel(_QWORD);
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000437870) ----------------------------------------------------
__int64 __fastcall _syscall_cancel(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  __int64 result; // x0

  LODWORD(result) = _internal_syscall_cancel(a1, a2, a3, a4, a5, a6, a7);
  if ( (unsigned int)result <= 0xFFFFF000 )
    return (int)result;
  *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
  return -1LL;
}

//----- (00000000004378C0) ----------------------------------------------------
__int64 __fastcall _futex_abstimed_wait64(
        void *a1,
        unsigned int a2,
        unsigned int a3,
        _QWORD *a4,
        int a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        __int64 a14,
        void *a15)
{
  signed __int64 v15; // x0

  if ( !a4 || (*a4 & 0x8000000000000000LL) == 0 )
  {
    if ( a3 > 1 )
      return 22LL;
    v15 = linux_eabi_syscall(
            __NR_futex,
            a1,
            (void *)(int)(((a3 << 8) ^ 0x100 | 0x89) ^ a5),
            (void *)a2,
            a4,
            0LL,
            (void *)0xFFFFFFFFLL,
            a15);
    if ( (int)v15 <= 0 )
    {
      if ( (int)v15 < -22 )
      {
        if ( (_DWORD)v15 == -110 || (_DWORD)v15 == -75 )
          return (unsigned int)-(int)v15;
      }
      else if ( ((0x440801uLL >> ((unsigned __int8)v15 + 22)) & 1) != 0 )
      {
        return (unsigned int)-(int)v15;
      }
    }
    _libc_fatal((__int64)"The futex facility returned an unexpected error code.\n", a6, a7, a8, a9, a10, a11, a12, a13);
  }
  return 110LL;
}

//----- (0000000000437964) ----------------------------------------------------
__int64 __fastcall _futex_abstimed_wait_cancelable64(void *a1, unsigned int a2, unsigned int a3, _QWORD *a4, int a5)
{
  int v5; // w0
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7

  if ( !a4 || (*a4 & 0x8000000000000000LL) == 0 )
  {
    if ( a3 > 1 )
      return 22LL;
    v5 = _internal_syscall_cancel(
           a1,
           (void *)(int)(((a3 << 8) ^ 0x100 | 0x89) ^ a5),
           (void *)a2,
           a4,
           0LL,
           (void *)0xFFFFFFFFLL,
           (void *)0x62);
    if ( v5 <= 0 )
    {
      if ( v5 < -22 )
      {
        if ( v5 == -110 || v5 == -75 )
          return (unsigned int)-v5;
      }
      else if ( ((0x440801uLL >> ((unsigned __int8)v5 + 22)) & 1) != 0 )
      {
        return (unsigned int)-v5;
      }
    }
    _libc_fatal((__int64)"The futex facility returned an unexpected error code.\n", v6, v7, v8, v9, v10, v11, v12, v13);
  }
  return 110LL;
}
// 4379EC: variable 'v6' is possibly undefined
// 4379EC: variable 'v7' is possibly undefined
// 4379EC: variable 'v8' is possibly undefined
// 4379EC: variable 'v9' is possibly undefined
// 4379EC: variable 'v10' is possibly undefined
// 4379EC: variable 'v11' is possibly undefined
// 4379EC: variable 'v12' is possibly undefined
// 4379EC: variable 'v13' is possibly undefined

//----- (0000000000437A08) ----------------------------------------------------
__int64 __fastcall _futex_lock_pi64(
        void *a1,
        int a2,
        void *a3,
        int a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        __int64 a13,
        void *a14,
        void *a15)
{
  signed __int64 v15; // x0

  if ( a2 && a3 )
  {
    v15 = linux_eabi_syscall(__NR_futex, a1, (void *)(a4 ^ 0x8D), 0LL, a3, a3, a14, a15);
    if ( (_DWORD)v15 != -38 )
      goto LABEL_4;
    return 22LL;
  }
  v15 = linux_eabi_syscall(__NR_futex, a1, (void *)(a4 ^ 0x86), 0LL, a3, a3, a14, a15);
  if ( (_DWORD)v15 == -38 )
    return 22LL;
LABEL_4:
  if ( (_DWORD)v15 != -110
    && ((_DWORD)v15 != 0 && (unsigned int)v15 < 0xFFFFFFDD || ((0x981002001uLL >> ((unsigned __int8)v15 + 35)) & 1) == 0) )
  {
    _libc_fatal((__int64)"The futex facility returned an unexpected error code.\n", a5, a6, a7, a8, a9, a10, a11, a12);
  }
  return (unsigned int)-(int)v15;
}

//----- (0000000000437AC0) ----------------------------------------------------
__int64 *__fastcall dl_tunable_set_mutex_spin_count(__int64 *a1)
{
  __int64 v1; // x1
  __int64 *result; // x0

  v1 = *a1;
  result = &qword_491000;
  _mutex_aconf = v1;
  return result;
}
// 491000: using guessed type __int64 qword_491000;
// 491918: using guessed type int _mutex_aconf;

//----- (0000000000437AD0) ----------------------------------------------------
__int64 *__fastcall dl_tunable_set_stack_cache_size(__int64 *a1)
{
  __int64 v1; // x1
  __int64 *result; // x0

  v1 = *a1;
  result = &qword_491000;
  _nptl_stack_cache_maxsize = v1;
  return result;
}
// 491000: using guessed type __int64 qword_491000;
// 491938: using guessed type __int64 _nptl_stack_cache_maxsize;

//----- (0000000000437AE0) ----------------------------------------------------
int *__fastcall dl_tunable_set_stack_hugetlb(__int64 *a1)
{
  __int64 v1; // x1
  int *result; // x0

  v1 = *a1;
  result = &_nptl_stack_hugetlb;
  _nptl_stack_hugetlb = v1;
  return result;
}
// 491940: using guessed type int _nptl_stack_hugetlb;

//----- (0000000000437B00) ----------------------------------------------------
__int64 _pthread_tunables_init()
{
  char *v1; // [xsp+28h] [xbp+28h] BYREF

  _tunable_get_val(25LL, &v1, (__int64 (__fastcall *)(char *))dl_tunable_set_mutex_spin_count);
  _tunable_get_val(27LL, &v1, (__int64 (__fastcall *)(char *))dl_tunable_set_stack_cache_size);
  return _tunable_get_val(28LL, &v1, (__int64 (__fastcall *)(char *))dl_tunable_set_stack_hugetlb);
}

//----- (0000000000437B60) ----------------------------------------------------
__int64 __fastcall _pthread_mutex_lock_full(
        _DWORD *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        void *a13,
        void *a14,
        void *a15)
{
  unsigned __int64 StatusReg; // x20
  unsigned __int64 v16; // x19
  _DWORD *v18; // x24
  int v19; // w27
  int v20; // w1
  unsigned int v21; // w0
  _DWORD *v22; // x23
  unsigned int i; // w22
  unsigned int v24; // w0
  __int64 v25; // x0
  int v26; // w0
  __int64 result; // x0
  unsigned int v28; // w19
  int v29; // w20
  int v30; // w26
  __int64 v31; // x2
  void *v32; // x3
  __int64 v33; // x4
  void *v34; // x5
  __int64 v35; // x6
  __int64 v36; // x7
  double v37; // d0
  double v38; // d1
  double v39; // d2
  double v40; // d3
  double v41; // d4
  double v42; // d5
  double v43; // d6
  double v44; // d7
  unsigned int v45; // w20
  int v46; // w0
  int v47; // w0
  unsigned int v48; // w0
  void *v49; // x4
  void *v50; // x5
  void *v51; // x6
  unsigned __int64 v52; // x0
  int v53; // w0
  int v54; // w23
  unsigned __int64 v55; // x22
  void *v56; // x4
  void *v57; // x5
  void *v58; // x6
  int v59; // w0
  int v60; // w0
  __int64 v61; // x0
  __int64 v62; // x4
  void *v63; // x5
  void *v64; // x6
  double v65; // d0
  double v66; // d1
  double v67; // d2
  double v68; // d3
  double v69; // d4
  double v70; // d5
  double v71; // d6
  double v72; // d7
  int v73; // w0
  int v74; // w19
  int v75; // w0
  int v76; // w0
  int v77; // w0
  __int64 v78; // x0
  unsigned int v79; // w0
  unsigned __int64 v80; // x0
  __int64 v81; // x0
  __int64 v82; // x2
  __int64 v83; // x3
  void *v84; // x4
  void *v85; // x5
  void *v86; // x6
  int v87; // w0
  int v88; // w0
  unsigned __int64 v89; // x0
  int v90; // [xsp+6Ch] [xbp+6Ch] BYREF

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v16 = StatusReg - 1824;
  v18 = a1 + 4;
  v19 = *(_DWORD *)(StatusReg - 1824 + 0xD0);
  v20 = a1[4];
  v21 = v20 & 0x7F;
  if ( v21 > 0x33 )
  {
    if ( v21 - 64 <= 3 )
    {
      v28 = *a1;
      v29 = -1;
      if ( a1[2] == v19 )
      {
        v76 = *v18 & 3;
        if ( v76 == 2 )
          return 35LL;
        if ( v76 == 1 )
        {
          v77 = a1[1];
          if ( v77 == -1 )
            return 11LL;
LABEL_44:
          a1[1] = v77 + 1;
          return 0LL;
        }
      }
      while ( 1 )
      {
        v30 = v28 >> 19;
        if ( (int)(v28 >> 19) < (int)_pthread_current_priority() )
          break;
        result = _pthread_tpp_change_priority(
                   v29,
                   v30,
                   v37,
                   v38,
                   v39,
                   v40,
                   v41,
                   v42,
                   v43,
                   v44,
                   v31,
                   v32,
                   v33,
                   v34,
                   v35,
                   v36);
        if ( (_DWORD)result )
          return result;
        v45 = v28 & 0xFFF80000;
        _aarch64_cas4_acq();
        if ( (v28 & 0xFFF80000) == v46 )
        {
LABEL_25:
          if ( a1[2] )
            _libc_assert_fail(
              (__int64)"mutex->__data.__owner == 0",
              (__int64)"pthread_mutex_lock.c",
              0x25Fu,
              (__int64)"__pthread_mutex_lock_full");
LABEL_26:
          a1[1] = 1;
LABEL_10:
          v26 = a1[3] + 1;
          a1[2] = v19;
          a1[3] = v26;
          return 0LL;
        }
        while ( 1 )
        {
          _aarch64_cas4_acq();
          v28 = v48;
          if ( (v48 & 0xFFF80000) != v45 )
            break;
          if ( v45 == v48
            || (v52 = linux_eabi_syscall(
                        __NR_futex,
                        a1,
                        (void *)((unsigned __int8)~(unsigned __int8)*v18 & 0x80),
                        (void *)(v45 | 2),
                        0LL,
                        v49,
                        v50,
                        v51),
                v52 <= 0xFFFFFFFFFFFFF000LL)
            || (_DWORD)v52 == -11 )
          {
            _aarch64_cas4_acq();
            if ( v45 == v47 )
              goto LABEL_25;
          }
          else
          {
            if ( (_DWORD)v52 != -4 )
              goto LABEL_90;
            _aarch64_cas4_acq();
            if ( v45 == v53 )
              goto LABEL_25;
          }
        }
        v29 = v30;
      }
      if ( v29 != -1 )
      {
        _pthread_tpp_change_priority(v29, -1, v37, v38, v39, v40, v41, v42, v43, v44, v31, v32, v33, v34, v35, v36);
        return 22LL;
      }
    }
    return 22LL;
  }
  if ( v21 > 0x2F )
  {
LABEL_29:
    v54 = *v18 & 3;
    if ( (*v18 & 0x10) != 0 )
    {
      v55 = (unsigned __int64)(a1 + 8);
      *(_QWORD *)(v16 + 0xF0) = (unsigned __int64)(a1 + 8) | 1;
      if ( v19 != (*a1 & 0x3FFFFFFF) )
      {
LABEL_31:
        _aarch64_cas4_acq();
        if ( !v59 )
        {
LABEL_47:
          if ( a1[2] == 2147483646 )
          {
            a1[1] = 0;
            v89 = linux_eabi_syscall(__NR_futex, a1, (void *)7, 0LL, 0LL, v56, v57, v58);
            if ( v89 <= 0xFFFFFFFFFFFFF000LL
              || (_DWORD)v89 == -110
              || (unsigned int)v89 > 0xFFFFFFD9 && ((0x2C08000009uLL >> ((unsigned __int8)v89 + 38)) & 1) != 0 )
            {
LABEL_73:
              result = 131LL;
              *(_QWORD *)(v16 + 0xF0) = 0LL;
              return result;
            }
LABEL_90:
            _libc_fatal(
              (__int64)"The futex facility returned an unexpected error code.\n",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              a9);
          }
          a1[1] = 1;
          *(_QWORD *)((*(_QWORD *)(v16 + 0xE0) & 0xFFFFFFFFFFFFFFFELL) - 8) = v55;
          v78 = *(_QWORD *)(v16 + 0xE0);
          *((_QWORD *)a1 + 3) = StatusReg - 1600;
          *((_QWORD *)a1 + 4) = v78;
          *(_QWORD *)(v16 + 0xE0) = v55 | 1;
          *(_QWORD *)(v16 + 0xF0) = 0LL;
          goto LABEL_10;
        }
        v60 = _futex_lock_pi64(a1, 0, 0LL, 128, a2, a3, a4, a5, a6, a7, a8, a9, (__int64)v56, v57, v58);
        if ( (v60 & 0xFFFFFFDF) != 3 )
        {
          if ( (*a1 & 0x40000000) != 0 )
          {
            _aarch64_ldclr4_acq();
            *(_QWORD *)(a1 + 1) = 0x7FFFFFFF00000001LL;
            *(_QWORD *)((*(_QWORD *)(v16 + 0xE0) & 0xFFFFFFFFFFFFFFFELL) - 8) = v55;
            v61 = *(_QWORD *)(v16 + 0xE0);
            *((_QWORD *)a1 + 3) = StatusReg - 1600;
            *((_QWORD *)a1 + 4) = v61;
            *(_QWORD *)(v16 + 0xE0) = v55 | 1;
LABEL_35:
            result = 130LL;
            *(_QWORD *)(v16 + 0xF0) = 0LL;
            return result;
          }
          goto LABEL_47;
        }
        if ( v60 != 35 )
          _libc_assert_fail(
            (__int64)"e != ESRCH || !robust",
            (__int64)"pthread_mutex_lock.c",
            0x1C2u,
            (__int64)"__pthread_mutex_lock_full");
        v74 = 128;
        goto LABEL_61;
      }
      if ( v54 != 2 )
      {
        if ( v54 != 1 )
          goto LABEL_31;
LABEL_76:
        *(_QWORD *)(v16 + 0xF0) = 0LL;
        v88 = a1[1];
        if ( v88 == -1 )
          return 11LL;
        a1[1] = v88 + 1;
        return 0LL;
      }
LABEL_87:
      result = 35LL;
      *(_QWORD *)(v16 + 0xF0) = 0LL;
      return result;
    }
    if ( v19 == (*a1 & 0x3FFFFFFF) )
    {
      if ( v54 == 2 )
        goto LABEL_87;
      if ( v54 == 1 )
        goto LABEL_76;
    }
    _aarch64_cas4_acq();
    if ( !v73 )
      goto LABEL_26;
    v74 = *v18 & 0x80;
    v75 = _futex_lock_pi64(a1, 0, 0LL, v74, v65, v66, v67, v68, v69, v70, v71, v72, v62, v63, v64);
    if ( (v75 & 0xFFFFFFDF) != 3 )
    {
      if ( (*a1 & 0x40000000) != 0 )
        _libc_assert_fail(
          (__int64)"robust || (oldval & FUTEX_OWNER_DIED) == 0",
          (__int64)"pthread_mutex_lock.c",
          0x1CCu,
          (__int64)"__pthread_mutex_lock_full");
      goto LABEL_26;
    }
    if ( v75 != 35 )
    {
      while ( 1 )
      {
LABEL_62:
        v90 = 0;
        _futex_abstimed_wait64(&v90, 0, 0, 0LL, v74, a2, a3, a4, a5, a6, a7, a8, a9, (__int64)v57, v58);
      }
    }
LABEL_61:
    if ( (unsigned int)(v54 - 1) <= 1 )
      _libc_assert_fail(
        (__int64)"e != EDEADLK || (kind != PTHREAD_MUTEX_ERRORCHECK_NP && kind != PTHREAD_MUTEX_RECURSIVE_NP)",
        (__int64)"pthread_mutex_lock.c",
        0x1BDu,
        (__int64)"__pthread_mutex_lock_full");
    goto LABEL_62;
  }
  if ( v21 > 0x13 )
  {
    if ( v21 - 32 > 3 )
      return 22LL;
    goto LABEL_29;
  }
  if ( (v20 & 0x70) == 0 )
    return 22LL;
  v22 = a1 + 8;
  *(_QWORD *)(v16 + 0xF0) = a1 + 8;
  for ( i = *a1; ; i = *a1 )
  {
    while ( 1 )
    {
      if ( !i )
      {
        _aarch64_cas4_acq();
        i = v24;
        if ( !v24 )
        {
          if ( a1[2] != 2147483646 )
          {
            a1[1] = 1;
            *(_QWORD *)((*(_QWORD *)(v16 + 0xE0) & 0xFFFFFFFFFFFFFFFELL) - 8) = v22;
            v25 = *(_QWORD *)(v16 + 0xE0);
            *((_QWORD *)a1 + 3) = StatusReg - 1600;
            *((_QWORD *)a1 + 4) = v25;
            *(_QWORD *)(v16 + 0xE0) = v22;
            *(_QWORD *)(v16 + 0xF0) = 0LL;
            goto LABEL_10;
          }
          a1[1] = 0;
          _aarch64_swp4_rel();
          if ( v87 > 1 )
            _lll_lock_wake(a1, 128, v82, v83, v84, v85, v86);
          goto LABEL_73;
        }
      }
      if ( (i & 0x40000000) == 0 )
        break;
      _aarch64_cas4_acq();
      if ( i == v79 )
      {
        *(_QWORD *)(a1 + 1) = 0x7FFFFFFF00000001LL;
        *(_QWORD *)((*(_QWORD *)(v16 + 0xE0) & 0xFFFFFFFFFFFFFFFELL) - 8) = v22;
        v81 = *(_QWORD *)(v16 + 0xE0);
        *((_QWORD *)a1 + 3) = StatusReg - 1600;
        *((_QWORD *)a1 + 4) = v81;
        *(_QWORD *)(v16 + 0xE0) = v22;
        goto LABEL_35;
      }
LABEL_51:
      i = v79;
    }
    if ( (i & 0x3FFFFFFF) == v19 )
    {
      if ( (*v18 & 0x7F) == 0x12 )
      {
        *(_QWORD *)(v16 + 0xF0) = 0LL;
        return 35LL;
      }
      if ( (*v18 & 0x7F) == 0x11 )
        break;
    }
    if ( (i & 0x80000000) == 0 )
    {
      _aarch64_cas4_acq();
      if ( i != v79 )
        goto LABEL_51;
      i |= 0x80000000;
    }
    v80 = linux_eabi_syscall(__NR_futex, a1, 0LL, (void *)i, 0LL, a13, a14, a15);
    if ( v80 > 0xFFFFFFFFFFFFF000LL && (_DWORD)v80 != -11 && (_DWORD)v80 != -4 )
      goto LABEL_90;
  }
  *(_QWORD *)(v16 + 0xF0) = 0LL;
  v77 = a1[1];
  if ( v77 != -1 )
    goto LABEL_44;
  return 11LL;
}
// 437BDC: variable 'v24' is possibly undefined
// 437C88: variable 'v37' is possibly undefined
// 437C88: variable 'v38' is possibly undefined
// 437C88: variable 'v39' is possibly undefined
// 437C88: variable 'v40' is possibly undefined
// 437C88: variable 'v41' is possibly undefined
// 437C88: variable 'v42' is possibly undefined
// 437C88: variable 'v43' is possibly undefined
// 437C88: variable 'v44' is possibly undefined
// 437C88: variable 'v31' is possibly undefined
// 437C88: variable 'v32' is possibly undefined
// 437C88: variable 'v33' is possibly undefined
// 437C88: variable 'v34' is possibly undefined
// 437C88: variable 'v35' is possibly undefined
// 437C88: variable 'v36' is possibly undefined
// 437CAC: variable 'v46' is possibly undefined
// 437CD0: variable 'v47' is possibly undefined
// 437CE4: variable 'v48' is possibly undefined
// 437D18: variable 'v49' is possibly undefined
// 437D18: variable 'v50' is possibly undefined
// 437D18: variable 'v51' is possibly undefined
// 437D48: variable 'v53' is possibly undefined
// 437DB0: variable 'v59' is possibly undefined
// 437DC4: variable 'a2' is possibly undefined
// 437DC4: variable 'a3' is possibly undefined
// 437DC4: variable 'a4' is possibly undefined
// 437DC4: variable 'a5' is possibly undefined
// 437DC4: variable 'a6' is possibly undefined
// 437DC4: variable 'a7' is possibly undefined
// 437DC4: variable 'a8' is possibly undefined
// 437DC4: variable 'a9' is possibly undefined
// 437DC4: variable 'v56' is possibly undefined
// 437DC4: variable 'v57' is possibly undefined
// 437DC4: variable 'v58' is possibly undefined
// 437E40: variable 'v73' is possibly undefined
// 437E5C: variable 'v65' is possibly undefined
// 437E5C: variable 'v66' is possibly undefined
// 437E5C: variable 'v67' is possibly undefined
// 437E5C: variable 'v68' is possibly undefined
// 437E5C: variable 'v69' is possibly undefined
// 437E5C: variable 'v70' is possibly undefined
// 437E5C: variable 'v71' is possibly undefined
// 437E5C: variable 'v72' is possibly undefined
// 437E5C: variable 'v62' is possibly undefined
// 437E5C: variable 'v63' is possibly undefined
// 437E5C: variable 'v64' is possibly undefined
// 437F3C: variable 'v79' is possibly undefined
// 437F90: variable 'a13' is possibly undefined
// 437F90: variable 'a14' is possibly undefined
// 437F90: variable 'a15' is possibly undefined
// 438078: variable 'v87' is possibly undefined
// 43815C: variable 'v82' is possibly undefined
// 43815C: variable 'v83' is possibly undefined
// 43815C: variable 'v84' is possibly undefined
// 43815C: variable 'v85' is possibly undefined
// 43815C: variable 'v86' is possibly undefined
// 4381E0: using guessed type __int64 pthread_mutex_lock(void);

//----- (00000000004381E0) ----------------------------------------------------
__int64 __fastcall pthread_mutex_lock(
        _DWORD *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        void *a14,
        void *a15)
{
  _DWORD *v15; // x4
  __int64 v16; // x1
  _DWORD *v17; // x2
  int v18; // w19
  __int64 v19; // x3
  void *v20; // x4
  void *v21; // x5
  void *v22; // x6
  double v23; // d0
  double v24; // d1
  double v25; // d2
  double v26; // d3
  double v27; // d4
  double v28; // d5
  double v29; // d6
  double v30; // d7
  int v31; // w0
  unsigned __int64 v32; // x3
  int v33; // w0
  unsigned __int64 StatusReg; // x3
  int v36; // w1
  int v37; // w0
  int v38; // w19
  void *v39; // x4
  void *v40; // x5
  void *v41; // x6
  double v42; // d0
  double v43; // d1
  double v44; // d2
  double v45; // d3
  double v46; // d4
  double v47; // d5
  double v48; // d6
  double v49; // d7
  int v50; // w0
  _DWORD *v51; // x4
  int v52; // w0
  int v53; // w1
  int v54; // w0
  int v55; // w19
  int v56; // w3
  int v57; // w0
  __int64 v58; // x3
  void *v59; // x5
  void *v60; // x6
  double v61; // d0
  double v62; // d1
  double v63; // d2
  double v64; // d3
  double v65; // d4
  double v66; // d5
  double v67; // d6
  double v68; // d7
  int v69; // w0
  _DWORD *v73; // [xsp+28h] [xbp-18h]
  _DWORD *v74; // [xsp+28h] [xbp-18h]
  __int64 v75; // [xsp+30h] [xbp-10h]
  _DWORD *v76; // [xsp+30h] [xbp-10h]
  _DWORD *v77; // [xsp+30h] [xbp-10h]
  _DWORD *v78; // [xsp+30h] [xbp-10h]
  int v79; // [xsp+3Ch] [xbp-4h]

  v15 = a1 + 4;
  v16 = (unsigned int)a1[4];
  if ( (v16 & 0x7C) != 0 )
    return _pthread_mutex_lock_full(a1, a2, a3, a4, a5, a6, a7, a8, a9, v16, a11, a12, v15, a14, a15);
  v17 = a1;
  if ( (v16 & 0x17F) == 0 )
    goto LABEL_3;
  if ( (*v15 & 0x7F) == 1 )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v36 = a1[2];
    v32 = StatusReg - 1824;
    if ( v36 != *(_DWORD *)(v32 + 0xD0) )
    {
      v38 = *v15 & 0x80;
      if ( v38 || !_libc_single_threaded || *a1 )
      {
        v75 = v32;
        _aarch64_cas4_acq();
        v17 = a1;
        v32 = v75;
        if ( v50 )
        {
          _lll_lock_wait(a1, v38, v42, v43, v44, v45, v46, v47, v48, v49, (__int64)a1, v75, v39, v40, v41);
          v17 = a1;
          v32 = v75;
        }
        v36 = a1[2];
      }
      else
      {
        *a1 = 1;
      }
      if ( v36 )
        _libc_assert_fail(
          (__int64)"mutex->__data.__owner == 0",
          (__int64)"pthread_mutex_lock.c",
          0x82u,
          (__int64)"___pthread_mutex_lock");
      v17[1] = 1;
      goto LABEL_8;
    }
    v37 = a1[1];
    if ( v37 != -1 )
    {
      v17[1] = v37 + 1;
      return 0LL;
    }
    return 11LL;
  }
  else
  {
    if ( (*v15 & 0x7F) == 3 )
    {
      v76 = a1 + 4;
      _aarch64_cas4_acq();
      v17 = a1;
      v51 = v76;
      if ( v52 )
      {
        v54 = 2 * (a1[5] + 5);
        if ( v54 > (__int16)_mutex_aconf )
          v54 = (__int16)_mutex_aconf;
        v55 = v54;
        if ( v54 <= 1 )
        {
          v55 = 1;
LABEL_43:
          v74 = v17;
          v78 = v51;
          _aarch64_cas4_acq();
          v17 = v74;
          if ( v69 )
          {
            _lll_lock_wait(v74, *v78 & 0x80, v61, v62, v63, v64, v65, v66, v67, v68, (__int64)v74, v58, v78, v59, v60);
            v17 = v74;
          }
          v56 = v55;
        }
        else
        {
          v56 = 1;
          while ( 1 )
          {
            if ( !*v17 )
            {
              v73 = v17;
              v77 = v51;
              v79 = v56;
              _aarch64_cas4_acq();
              v17 = v73;
              v51 = v77;
              v56 = v79;
              if ( !v57 )
                break;
            }
            if ( ++v56 == v55 )
              goto LABEL_43;
          }
        }
        v17[5] += (v56 - v17[5]) / 8;
      }
      if ( v17[2] )
        _libc_assert_fail(
          (__int64)"mutex->__data.__owner == 0",
          (__int64)"pthread_mutex_lock.c",
          0xA7u,
          (__int64)"___pthread_mutex_lock");
      goto LABEL_7;
    }
    v53 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824 + 0xD0);
    if ( (*v15 & 0x7F) != 2 )
      _libc_assert_fail(
        (__int64)"PTHREAD_MUTEX_TYPE (mutex) == PTHREAD_MUTEX_ERRORCHECK_NP",
        (__int64)"pthread_mutex_lock.c",
        0xACu,
        (__int64)"___pthread_mutex_lock");
    if ( v53 != a1[2] )
    {
LABEL_3:
      v18 = *v15 & 0x80;
      if ( v18 || !_libc_single_threaded || *a1 )
      {
        _aarch64_cas4_acq();
        v17 = a1;
        if ( v31 )
        {
          _lll_lock_wait(a1, v18, v23, v24, v25, v26, v27, v28, v29, v30, (__int64)a1, v19, v20, v21, v22);
          v17 = a1;
        }
      }
      else
      {
        *a1 = 1;
      }
      if ( v17[2] )
        _libc_assert_fail(
          (__int64)"mutex->__data.__owner == 0",
          (__int64)"pthread_mutex_lock.c",
          0x5Eu,
          (__int64)"___pthread_mutex_lock");
LABEL_7:
      v32 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
LABEL_8:
      v33 = v17[3] + 1;
      v17[2] = *(_DWORD *)(v32 + 208);
      v17[3] = v33;
      return 0LL;
    }
    return 35LL;
  }
}
// 4381E0: could not find valid save-restore pair for x19
// 43822C: variable 'v31' is possibly undefined
// 4382D0: variable 'v23' is possibly undefined
// 4382D0: variable 'v24' is possibly undefined
// 4382D0: variable 'v25' is possibly undefined
// 4382D0: variable 'v26' is possibly undefined
// 4382D0: variable 'v27' is possibly undefined
// 4382D0: variable 'v28' is possibly undefined
// 4382D0: variable 'v29' is possibly undefined
// 4382D0: variable 'v30' is possibly undefined
// 4382D0: variable 'v19' is possibly undefined
// 4382D0: variable 'v20' is possibly undefined
// 4382D0: variable 'v21' is possibly undefined
// 4382D0: variable 'v22' is possibly undefined
// 438330: variable 'v50' is possibly undefined
// 4383A4: variable 'v42' is possibly undefined
// 4383A4: variable 'v43' is possibly undefined
// 4383A4: variable 'v44' is possibly undefined
// 4383A4: variable 'v45' is possibly undefined
// 4383A4: variable 'v46' is possibly undefined
// 4383A4: variable 'v47' is possibly undefined
// 4383A4: variable 'v48' is possibly undefined
// 4383A4: variable 'v49' is possibly undefined
// 4383A4: variable 'v39' is possibly undefined
// 4383A4: variable 'v40' is possibly undefined
// 4383A4: variable 'v41' is possibly undefined
// 438360: variable 'v52' is possibly undefined
// 438434: variable 'v57' is possibly undefined
// 438478: variable 'v69' is possibly undefined
// 4384B4: variable 'v61' is possibly undefined
// 4384B4: variable 'v62' is possibly undefined
// 4384B4: variable 'v63' is possibly undefined
// 4384B4: variable 'v64' is possibly undefined
// 4384B4: variable 'v65' is possibly undefined
// 4384B4: variable 'v66' is possibly undefined
// 4384B4: variable 'v67' is possibly undefined
// 4384B4: variable 'v68' is possibly undefined
// 4384B4: variable 'v58' is possibly undefined
// 4384B4: variable 'v59' is possibly undefined
// 4384B4: variable 'v60' is possibly undefined
// 438520: using guessed type __int64 _pthread_mutex_unlock_full(void);
// 490F08: using guessed type char _libc_single_threaded;
// 491918: using guessed type int _mutex_aconf;

//----- (0000000000438520) ----------------------------------------------------
__int64 __fastcall _pthread_mutex_unlock_full(
        __int64 a1,
        int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  __int64 v10; // x2
  _QWORD *v11; // x4
  int v12; // w0
  unsigned int v13; // w3
  __int64 result; // x0
  unsigned __int64 v15; // x4
  bool v16; // zf
  int v17; // w5
  __int64 v18; // x0
  void *v19; // x5
  void *v20; // x6
  int v21; // w0
  int v22; // w0
  int v23; // w5
  int v24; // w3
  int v25; // w0
  unsigned __int64 v26; // x3
  unsigned int v27; // w0
  void *v28; // x6
  __int64 v29; // x7
  unsigned __int64 v30; // x0
  _DWORD *StatusReg; // x5
  unsigned __int64 v32; // x6
  int v33; // w0
  int v34; // w3
  int v35; // w19
  int v36; // w3
  int v37; // w0
  int v38; // w7
  int v39; // w3
  int v40; // w0
  bool v41; // zf
  __int64 v42; // x0
  unsigned __int64 v43; // x0
  int v44; // w0
  int v45; // w0
  unsigned __int64 v46; // x0
  void *v47; // [xsp+20h] [xbp+20h]
  int v48; // [xsp+20h] [xbp+20h]
  int v49; // [xsp+20h] [xbp+20h]
  _QWORD *v50; // [xsp+28h] [xbp+28h]
  int v51; // [xsp+28h] [xbp+28h]
  __int64 v52; // [xsp+28h] [xbp+28h]
  void *v53; // [xsp+30h] [xbp+30h]
  _DWORD *v54; // [xsp+30h] [xbp+30h]
  _DWORD *v55; // [xsp+38h] [xbp+38h]
  _QWORD *v56; // [xsp+38h] [xbp+38h]

  v10 = a1;
  v11 = (_QWORD *)(a1 + 16);
  v12 = *(_DWORD *)(a1 + 16);
  v13 = v12 & 0x7F;
  if ( v13 > 0x33 )
  {
    if ( v13 == 66 )
    {
      if ( *(_DWORD *)(v10 + 8) != *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824 + 0xD0)
        || (*(_DWORD *)v10 & 0x7FFFF) == 0 )
      {
        return 1LL;
      }
    }
    else if ( v13 > 0x42 )
    {
      if ( v13 != 67 )
        return 22LL;
    }
    else if ( v13 != 64 )
    {
      if ( v13 != 65 )
        return 22LL;
      if ( *(_DWORD *)(v10 + 8) != *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824 + 0xD0) )
        return 1LL;
      v22 = *(_DWORD *)(v10 + 4) - 1;
      *(_DWORD *)(v10 + 4) = v22;
      if ( v22 )
        return 0LL;
    }
    *(_DWORD *)(v10 + 8) = 0;
    if ( a2 )
      --*(_DWORD *)(v10 + 12);
    LODWORD(v26) = *(_DWORD *)v10;
    do
    {
      v48 = v26;
      v51 = v26 & 0xFFF80000;
      v53 = (void *)v10;
      v55 = v11;
      _aarch64_cas4_rel();
      v10 = (__int64)v53;
      v11 = v55;
      v26 = v27;
    }
    while ( v27 != v48 );
    if ( (v27 & 0x7FFFE) == 0 )
      return _pthread_tpp_change_priority(
               v51 >> 19,
               -1,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               v10,
               (void *)v26,
               (__int64)v55,
               (void *)(unsigned int)v51,
               (__int64)v28,
               v29);
    v26 = 0LL;
    v10 = 1LL;
    v30 = linux_eabi_syscall(
            __NR_futex,
            v53,
            (void *)(*v55 & 0x80 ^ 0x81u),
            (void *)1,
            0LL,
            v55,
            (void *)(unsigned int)v51,
            v28);
    if ( v30 <= 0xFFFFFFFFFFFFF000LL || (((_DWORD)v30 + 22) & 0xFFFFFFF7) == 0 )
      return _pthread_tpp_change_priority(
               v51 >> 19,
               -1,
               a3,
               a4,
               a5,
               a6,
               a7,
               a8,
               a9,
               a10,
               v10,
               (void *)v26,
               (__int64)v55,
               (void *)(unsigned int)v51,
               (__int64)v28,
               v29);
    goto LABEL_76;
  }
  if ( (v12 & 0x60) == 0 )
  {
    if ( v13 == 17 )
    {
      v15 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
      v23 = *(_DWORD *)(v10 + 8);
      v24 = *(_DWORD *)(v15 + 0xD0);
      if ( (*(_DWORD *)v10 & 0x3FFFFFFF) == v24 && v23 == 0x7FFFFFFF )
      {
        v17 = 2147483646;
        v44 = *(_DWORD *)(v10 + 4) - 1;
        *(_DWORD *)(v10 + 4) = v44;
        if ( v44 )
          return 131LL;
      }
      else
      {
        if ( v24 != v23 )
          return 1LL;
        v25 = *(_DWORD *)(v10 + 4) - 1;
        *(_DWORD *)(v10 + 4) = v25;
        if ( v25 )
          return 0LL;
        v17 = 0;
      }
    }
    else
    {
      if ( v13 > 0x11 )
      {
        if ( v13 - 18 > 1 )
          return 22LL;
      }
      else if ( v13 != 16 )
      {
        return 22LL;
      }
      v15 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
      result = 1LL;
      if ( *(_DWORD *)v10 )
        v16 = (*(_DWORD *)v10 & 0x3FFFFFFF) == *(_DWORD *)(v15 + 0xD0);
      else
        v16 = 0;
      if ( !v16 )
        return result;
      if ( *(_DWORD *)(v10 + 8) == 0x7FFFFFFF )
        v17 = 2147483646;
      else
        v17 = 0;
    }
    *(_QWORD *)(v15 + 0xF0) = v10 + 32;
    v18 = *(_QWORD *)(v10 + 24);
    *(_QWORD *)((*(_QWORD *)(v10 + 32) & 0xFFFFFFFFFFFFFFFELL) - 8) = v18;
    *(_QWORD *)(v18 & 0xFFFFFFFFFFFFFFFELL) = *(_QWORD *)(v10 + 32);
    *(_DWORD *)(v10 + 8) = v17;
    *(_QWORD *)(v10 + 24) = 0LL;
    *(_QWORD *)(v10 + 32) = 0LL;
    if ( a2 )
      --*(_DWORD *)(v10 + 12);
    v47 = (void *)v10;
    v50 = (_QWORD *)v15;
    _aarch64_swp4_rel();
    if ( v21 < 0 )
    {
      v43 = linux_eabi_syscall(__NR_futex, v47, (void *)1, (void *)1, 0LL, v50, v19, v20);
      if ( v43 > 0xFFFFFFFFFFFFF000LL && (((_DWORD)v43 + 22) & 0xFFFFFFF7) != 0 )
        goto LABEL_76;
    }
    v50[30] = 0LL;
    return 0LL;
  }
  result = 1LL;
  if ( ((1LL << v13) & 0xD000D00000000LL) != 0 )
  {
    StatusReg = (_DWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v32 = (unsigned int)*(StatusReg - 404);
    if ( *(_DWORD *)v10 )
      v41 = (*(_DWORD *)v10 & 0x3FFFFFFF) == (_DWORD)v32;
    else
      v41 = 0;
    if ( !v41 )
      return result;
    v34 = 0;
    if ( (*(_DWORD *)v11 & 0x10) == 0 )
      goto LABEL_69;
    v32 = *(unsigned int *)(v10 + 8);
    if ( (_DWORD)v32 != 0x7FFFFFFF )
      goto LABEL_69;
    goto LABEL_82;
  }
  if ( v13 == 49 )
  {
    StatusReg = (_DWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v32 = (unsigned __int64)(StatusReg - 456);
    v38 = *(_DWORD *)(v10 + 8);
    v39 = *(StatusReg - 404);
    if ( (*(_DWORD *)v10 & 0x3FFFFFFF) == v39 && v38 == 0x7FFFFFFF )
    {
      v45 = *(_DWORD *)(v10 + 4) - 1;
      *(_DWORD *)(v10 + 4) = v45;
      if ( !v45 )
      {
LABEL_82:
        v34 = 2147483646;
LABEL_69:
        if ( (*(_DWORD *)v11 & 0x10) == 0 )
          goto LABEL_46;
        v32 = (unsigned __int64)(StatusReg - 456);
LABEL_71:
        *(_QWORD *)(v32 + 0xF0) = (v10 + 32) | 1;
        v42 = *(_QWORD *)(v10 + 24);
        *(_QWORD *)((*(_QWORD *)(v10 + 32) & 0xFFFFFFFFFFFFFFFELL) - 8) = v42;
        v32 = *(_QWORD *)(v10 + 32);
        *(_QWORD *)(v42 & 0xFFFFFFFFFFFFFFFELL) = v32;
        *(_QWORD *)(v10 + 24) = 0LL;
        *(_QWORD *)(v10 + 32) = 0LL;
LABEL_46:
        *(_DWORD *)(v10 + 8) = v34;
        if ( a2 )
          --*(_DWORD *)(v10 + 12);
        v35 = 128;
        if ( (*(_DWORD *)v11 & 0x10) == 0 )
          v35 = *(_DWORD *)v11 & 0x80;
        v36 = *(_DWORD *)v10;
        while ( (v36 & 0x80000000) == 0 )
        {
          v11 = StatusReg - 456;
          if ( *(StatusReg - 404) != v36 )
            break;
          v49 = v36;
          v52 = v10;
          v54 = StatusReg;
          v56 = StatusReg - 456;
          _aarch64_cas4_rel();
          v11 = v56;
          v10 = v52;
          StatusReg = v54;
          v36 = v37;
          if ( v37 == v49 )
            goto LABEL_54;
        }
        v46 = linux_eabi_syscall(__NR_futex, (void *)v10, (void *)(v35 ^ 0x87u), 0LL, 0LL, v11, StatusReg, (void *)v32);
        v11 = StatusReg - 456;
        if ( v46 <= 0xFFFFFFFFFFFFF000LL )
          goto LABEL_54;
        if ( (_DWORD)v46 == -110
          || (unsigned int)v46 > 0xFFFFFFD9 && ((0x2C08000009uLL >> ((unsigned __int8)v46 + 38)) & 1) != 0 )
        {
          v11 = StatusReg - 456;
LABEL_54:
          result = 0LL;
          v11[30] = 0LL;
          return result;
        }
LABEL_76:
        _libc_fatal((__int64)"The futex facility returned an unexpected error code.\n", a3, a4, a5, a6, a7, a8, a9, a10);
      }
      return 131LL;
    }
    if ( v38 == v39 )
    {
      v40 = *(_DWORD *)(v10 + 4) - 1;
      *(_DWORD *)(v10 + 4) = v40;
      if ( v40 )
        return 0LL;
      v34 = 0;
      goto LABEL_71;
    }
    return 1LL;
  }
  if ( v13 != 33 )
    return 22LL;
  StatusReg = (_DWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v32 = *(unsigned int *)(v10 + 8);
  if ( (_DWORD)v32 == *(StatusReg - 404) )
  {
    v33 = *(_DWORD *)(v10 + 4) - 1;
    *(_DWORD *)(v10 + 4) = v33;
    if ( !v33 )
    {
      v34 = 0;
      goto LABEL_46;
    }
    return 0LL;
  }
  return result;
}
// 438614: variable 'v21' is possibly undefined
// 4386FC: variable 'v27' is possibly undefined
// 438730: variable 'v28' is possibly undefined
// 438748: variable 'a3' is possibly undefined
// 438748: variable 'a4' is possibly undefined
// 438748: variable 'a5' is possibly undefined
// 438748: variable 'a6' is possibly undefined
// 438748: variable 'a7' is possibly undefined
// 438748: variable 'a8' is possibly undefined
// 438748: variable 'a9' is possibly undefined
// 438748: variable 'a10' is possibly undefined
// 438748: variable 'v29' is possibly undefined
// 4387DC: variable 'v37' is possibly undefined
// 438914: variable 'v19' is possibly undefined
// 438914: variable 'v20' is possibly undefined
// 4389B4: variable 'v32' is possibly undefined

//----- (0000000000438A00) ----------------------------------------------------
__int64 __fastcall _pthread_mutex_unlock_usercnt(
        int *a1,
        int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  int *v10; // x4
  int v12; // w3
  int v13; // w19
  __int64 v15; // x2
  __int64 v16; // x3
  void *v17; // x4
  void *v18; // x5
  void *v19; // x6
  int v20; // w0
  int v21; // w19
  __int64 v22; // x2
  __int64 v23; // x3
  void *v24; // x4
  void *v25; // x5
  void *v26; // x6
  int v27; // w0
  int v28; // w0
  int *v29; // [xsp+28h] [xbp-8h]

  v10 = a1 + 4;
  if ( (a1[4] & 0x7C) != 0 )
    return _pthread_mutex_unlock_full((__int64)a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  v12 = a1[4] & 0x17F;
  if ( !v12 )
    goto LABEL_3;
  if ( v12 == 256 )
  {
    v21 = *v10;
    _aarch64_swp4_rel();
    if ( v27 > 1 )
      _lll_lock_wake(a1, v21 & 0x80, v22, v23, v24, v25, v26);
    return 0LL;
  }
  if ( (*v10 & 0x7F) == 1 )
  {
    if ( a1[2] == *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824 + 0xD0) )
    {
      v28 = a1[1] - 1;
      a1[1] = v28;
      if ( v28 )
        return 0LL;
LABEL_3:
      a1[2] = 0;
      if ( a2 )
        --a1[3];
      v13 = *v10 & 0x80;
      if ( v13 || !_libc_single_threaded )
      {
        v29 = a1;
        _aarch64_swp4_rel();
        if ( v20 > 1 )
          _lll_lock_wake(v29, v13, v15, v16, v17, v18, v19);
      }
      else
      {
        *a1 = 0;
      }
      return 0LL;
    }
    return 1LL;
  }
  if ( (*v10 & 0x7F) == 3 )
    goto LABEL_3;
  if ( v12 != 2 )
    _libc_assert_fail(
      (__int64)"type == PTHREAD_MUTEX_ERRORCHECK_NP",
      (__int64)"pthread_mutex_unlock.c",
      0x62u,
      (__int64)"__pthread_mutex_unlock_usercnt");
  if ( a1[2] != *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824 + 0xD0) )
    return 1LL;
  if ( *a1 )
    goto LABEL_3;
  return 1LL;
}
// 438A78: variable 'v20' is possibly undefined
// 438AC0: variable 'v27' is possibly undefined
// 438ACC: variable 'v22' is possibly undefined
// 438ACC: variable 'v23' is possibly undefined
// 438ACC: variable 'v24' is possibly undefined
// 438ACC: variable 'v25' is possibly undefined
// 438ACC: variable 'v26' is possibly undefined
// 438AE0: variable 'v15' is possibly undefined
// 438AE0: variable 'v16' is possibly undefined
// 438AE0: variable 'v17' is possibly undefined
// 438AE0: variable 'v18' is possibly undefined
// 438AE0: variable 'v19' is possibly undefined
// 438BA0: using guessed type __int64 pthread_mutex_unlock(void);
// 490F08: using guessed type char _libc_single_threaded;

//----- (0000000000438BA0) ----------------------------------------------------
__int64 __fastcall pthread_mutex_unlock(
        int *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  return _pthread_mutex_unlock_usercnt(a1, 1, a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (0000000000438BC0) ----------------------------------------------------
__int64 __fastcall _pthread_cleanup_combined_routine_voidptr(__int64 a1)
{
  __int64 result; // x0
  __int64 v3; // [xsp+18h] [xbp+18h]

  result = *(unsigned int *)(a1 + 16);
  if ( (_DWORD)result )
  {
    v3 = a1;
    result = (*(__int64 (__fastcall **)(_QWORD))a1)(*(_QWORD *)(a1 + 8));
    *(_DWORD *)(v3 + 16) = 0;
  }
  return result;
}

//----- (0000000000438C00) ----------------------------------------------------
unsigned __int64 __fastcall clear_once_control(
        _DWORD *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        void *a13,
        void *a14,
        void *a15)
{
  unsigned __int64 result; // x0

  *a1 = 0;
  result = linux_eabi_syscall(__NR_futex, a1, (void *)0x81, (void *)0x7FFFFFFF, 0LL, a13, a14, a15);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    result = (unsigned int)(result + 22);
    if ( (result & 0xFFFFFFF7) != 0 )
      _libc_fatal((__int64)"The futex facility returned an unexpected error code.\n", a2, a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

//----- (0000000000438C44) ----------------------------------------------------
void __fastcall _pthread_once_slow_isra_0(unsigned int *a1, void *a2)
{
  unsigned int *v2; // x4
  unsigned int v4; // w3
  unsigned int v5; // w0
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7
  unsigned __int64 v14; // x0
  _QWORD *v15; // x0
  unsigned int *v16; // t2
  void *v17; // x5
  void *v18; // x6
  unsigned __int64 v19; // x0
  unsigned int v20; // [xsp+20h] [xbp-60h]
  unsigned int *v21; // [xsp+28h] [xbp-58h]
  void *v22; // [xsp+30h] [xbp-50h]
  unsigned int v23; // [xsp+3Ch] [xbp-44h]
  _QWORD v24[2]; // [xsp+48h] [xbp-38h] BYREF
  int v25; // [xsp+58h] [xbp-28h]
  _DWORD v26[9]; // [xsp+5Ch] [xbp-24h] BYREF

  v2 = a1;
  v4 = atomic_load(a1);
  if ( (v4 & 2) != 0 )
    return;
  while ( 1 )
  {
    v20 = v4;
    v21 = v2;
    v22 = a2;
    v23 = _fork_generation | 1;
    _aarch64_cas4_acq();
    v2 = v21;
    a2 = v22;
    v4 = v5;
    if ( v5 != v20 )
      goto LABEL_6;
    if ( ((unsigned __int8)v5 & (v23 == v5)) == 0 )
      break;
    v14 = linux_eabi_syscall(__NR_futex, v21, (void *)0x80, (void *)v23, 0LL, v21, v22, (void *)v23);
    if ( v14 > 0xFFFFFFFFFFFFF000LL && (_DWORD)v14 != -11 && (_DWORD)v14 != -4 )
      goto LABEL_10;
    v4 = atomic_load(v21);
LABEL_6:
    if ( (v4 & 2) != 0 )
      return;
  }
  memset(v26, 0, sizeof(v26));
  v24[0] = clear_once_control;
  v24[1] = v21;
  v25 = 1;
  v15 = pthread_cleanup_push(&v26[1], (__int64)_pthread_cleanup_combined_routine_voidptr, (__int64)v24);
  ((void (__fastcall *)(_QWORD *))v22)(v15);
  pthread_cleanup_pop((__int64)&v26[1], 0);
  v16 = v21;
  atomic_store(2u, v21);
  v19 = linux_eabi_syscall(__NR_futex, v16, (void *)0x81, (void *)0x7FFFFFFF, 0LL, v16, v17, v18);
  if ( v19 > 0xFFFFFFFFFFFFF000LL && (((_DWORD)v19 + 22) & 0xFFFFFFF7) != 0 )
LABEL_10:
    _libc_fatal((__int64)"The futex facility returned an unexpected error code.\n", v6, v7, v8, v9, v10, v11, v12, v13);
}
// 438C98: variable 'v5' is possibly undefined
// 438D00: variable 'v6' is possibly undefined
// 438D00: variable 'v7' is possibly undefined
// 438D00: variable 'v8' is possibly undefined
// 438D00: variable 'v9' is possibly undefined
// 438D00: variable 'v10' is possibly undefined
// 438D00: variable 'v11' is possibly undefined
// 438D00: variable 'v12' is possibly undefined
// 438D00: variable 'v13' is possibly undefined
// 438D74: variable 'v17' is possibly undefined
// 438D74: variable 'v18' is possibly undefined
// 496F90: using guessed type __int64 _fork_generation;

//----- (0000000000438D90) ----------------------------------------------------
void __fastcall __noreturn sub_438D90(
        _Unwind_Exception *exc,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        int a9,
        int a10,
        int a11,
        int a12,
        int a13,
        int a14,
        int a15,
        int a16,
        int a17,
        void (__fastcall *a18)(__int64),
        __int64 a19,
        int a20,
        char a21)
{
  if ( a20 )
  {
    a18(a19);
    pthread_cleanup_pop((__int64)&a21, 0);
  }
  Unwind_Resume(exc);
}

//----- (0000000000438DC0) ----------------------------------------------------
__int64 __fastcall pthread_once(unsigned int *a1, void *a2)
{
  char v2; // w2

  v2 = atomic_load(a1);
  if ( (v2 & 2) == 0 )
    _pthread_once_slow_isra_0(a1, a2);
  return 0LL;
}

//----- (0000000000438E00) ----------------------------------------------------
unsigned __int64 pthread_self()
{
  return _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
}

//----- (0000000000438E40) ----------------------------------------------------
__int64 __fastcall _syscall_cancel_arch(
        _DWORD *a1,
        signed __int64 a2,
        void *a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7,
        void *a8)
{
  if ( (*a1 & 8) != 0 )
    return _syscall_do_cancel();
  else
    return linux_eabi_syscall(a2, a3, a4, a5, a6, a7, a8, a7);
}

//----- (0000000000438E80) ----------------------------------------------------
unsigned __int64 _init_sched_fifo_prio()
{
  unsigned __int64 result; // x0

  _sched_fifo_max_prio = sched_get_priority_max(1);
  result = sched_get_priority_min(1);
  _sched_fifo_min_prio = result;
  return result;
}
// 49191C: using guessed type int _sched_fifo_max_prio;
// 491920: using guessed type int _sched_fifo_min_prio;

//----- (0000000000438EC0) ----------------------------------------------------
__int64 __fastcall _pthread_tpp_change_priority(
        int a1,
        int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        void *a12,
        __int64 a13,
        void *a14,
        __int64 a15,
        __int64 a16)
{
  unsigned __int64 StatusReg; // x21
  unsigned __int64 v17; // x24
  int8x16_t *(__fastcall *v20)(int8x16_t *, unsigned __int8, unsigned __int64); // x20
  __int64 v21; // x2
  __int64 v22; // x4
  int v25; // w22
  char *v26; // x0
  int v27; // w1
  char *v28; // x1
  int v29; // w0
  __int64 v30; // x1
  __int64 v31; // x2
  __int64 v32; // x3
  void *v33; // x4
  void *v34; // x5
  void *v35; // x6
  double v36; // d0
  double v37; // d1
  double v38; // d2
  double v39; // d3
  double v40; // d4
  double v41; // d5
  double v42; // d6
  double v43; // d7
  int v44; // w0
  int v45; // w0
  int v46; // w0
  unsigned int v47; // w20
  __int64 v48; // x1
  __int64 v49; // x2
  __int64 v50; // x3
  void *v51; // x4
  void *v52; // x5
  void *v53; // x6
  int v54; // w0
  char *v56; // x1
  int v57; // w0
  char *v59; // x0
  int v62; // w0
  int v63; // w2
  int v64; // w0
  int v66; // [xsp+40h] [xbp+40h]
  int v67; // [xsp+4Ch] [xbp+4Ch]
  struct sched_param v68; // [xsp+58h] [xbp+58h] BYREF

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v17 = StatusReg - 1824;
  v20 = *(int8x16_t *(__fastcall **)(int8x16_t *, unsigned __int8, unsigned __int64))(StatusReg - 1824 + 0x4B0);
  v21 = (unsigned int)_sched_fifo_min_prio;
  v22 = (unsigned int)_sched_fifo_max_prio;
  if ( !v20 )
  {
    if ( _sched_fifo_min_prio == -1 || _sched_fifo_max_prio == -1 )
    {
      _sched_fifo_max_prio = sched_get_priority_max(1);
      _sched_fifo_min_prio = sched_get_priority_min(1);
      v21 = (unsigned int)_sched_fifo_min_prio;
      v22 = (unsigned int)_sched_fifo_max_prio;
    }
    v66 = v22;
    v67 = v21;
    v20 = calloc(4 * ((int)v22 - (int)v21 + 2LL), 1uLL, v21, a12, a3, a4, a5, a6, a7, a8, a9, a10, v22, a14, a15, a16);
    if ( !v20 )
      return 12;
    LODWORD(v21) = v67;
    LODWORD(v22) = v66;
    *(_DWORD *)v20 = v67 - 1;
    *(_QWORD *)(v17 + 0x4B0) = v20;
  }
  if ( a2 == -1 )
  {
    if ( a1 == -1 )
      return 0;
    if ( (int)v21 <= a1 && (int)v22 >= a1 )
    {
      v25 = *(_DWORD *)v20;
LABEL_28:
      v56 = (char *)v20 + 4 * (a1 - (int)v21);
      v57 = *((_DWORD *)v56 + 1) - 1;
      *((_DWORD *)v56 + 1) = v57;
      if ( v57 )
        return 0;
      if ( a1 != v25 || a2 >= a1 )
        return 0;
      goto LABEL_34;
    }
LABEL_68:
    _libc_assert_fail(
      (__int64)"previous_prio == -1 || (previous_prio >= fifo_min_prio && previous_prio <= fifo_max_prio)",
      (__int64)"tpp.c",
      0x56u,
      (__int64)"__pthread_tpp_change_priority");
  }
  if ( (int)v21 > a2 || (int)v22 < a2 )
    _libc_assert_fail(
      (__int64)"new_prio == -1 || (new_prio >= fifo_min_prio && new_prio <= fifo_max_prio)",
      (__int64)"tpp.c",
      0x53u,
      (__int64)"__pthread_tpp_change_priority");
  if ( a1 != -1 && ((int)v21 > a1 || (int)v22 < a1) )
    goto LABEL_68;
  v25 = *(_DWORD *)v20;
  v26 = (char *)v20 + 4 * (unsigned int)(a2 - v21);
  v27 = *((_DWORD *)v26 + 1);
  if ( v27 == -1 )
    return 11;
  *((_DWORD *)v26 + 1) = v27 + 1;
  if ( a2 <= v25 )
  {
    if ( a1 == -1 )
      return 0;
    goto LABEL_28;
  }
  if ( a1 != -1 )
  {
    v28 = (char *)v20 + 4 * (a1 - (int)v21);
    v29 = *((_DWORD *)v28 + 1) - 1;
    *((_DWORD *)v28 + 1) = v29;
    if ( !v29 && a2 < a1 && a1 == v25 )
    {
LABEL_34:
      a2 = a1 - 1;
      if ( (int)v21 > a1 - 1 )
        goto LABEL_16;
      v59 = (char *)v20 + 4 * (a2 - (int)v21);
      do
      {
        if ( *((_DWORD *)v59 + 1) )
          break;
        --a2;
        v59 -= 4;
      }
      while ( (int)v21 <= a2 );
      if ( a2 != v25 )
        goto LABEL_16;
      return 0;
    }
  }
LABEL_16:
  _aarch64_cas4_acq();
  if ( v44 )
    _lll_lock_wait_private(
      (_DWORD *)(StatusReg - 776),
      v36,
      v37,
      v38,
      v39,
      v40,
      v41,
      v42,
      v43,
      v30,
      v31,
      v32,
      v33,
      v34,
      v35);
  *(_DWORD *)v20 = a2;
  v45 = *(_DWORD *)(v17 + 0x10C);
  if ( (v45 & 0x20) != 0 )
  {
    if ( (v45 & 0x40) != 0 )
      goto LABEL_20;
  }
  else
  {
    v62 = sched_getparam(*(_DWORD *)(v17 + 0xD0), (struct sched_param *)(StatusReg - 752));
    v63 = *(_DWORD *)(v17 + 0x10C) & 0x40;
    if ( v62 )
    {
      v47 = *(_DWORD *)(StatusReg + 40);
      if ( v63 )
      {
        if ( v47 )
          goto LABEL_24;
        goto LABEL_20;
      }
      goto LABEL_59;
    }
    *(_DWORD *)(v17 + 0x10C) |= 0x20u;
    if ( v63 )
      goto LABEL_20;
  }
  v47 = 0;
LABEL_59:
  v64 = sched_getscheduler(*(_DWORD *)(v17 + 0xD0));
  *(_DWORD *)(v17 + 0x434) = v64;
  if ( v64 == -1 )
  {
    v47 = *(_DWORD *)(StatusReg + 40);
    if ( v47 )
      goto LABEL_24;
  }
  else
  {
    *(_DWORD *)(v17 + 0x10C) |= 0x40u;
    if ( v47 )
      goto LABEL_24;
  }
LABEL_20:
  v46 = *(_DWORD *)(v17 + 0x430);
  v68.__sched_priority = v46;
  if ( v46 >= a2 )
  {
    if ( v46 >= v25 )
      goto LABEL_23;
  }
  else
  {
    v68.__sched_priority = a2;
  }
  if ( (sched_setscheduler(*(_DWORD *)(v17 + 0xD0), *(_DWORD *)(v17 + 0x434), &v68) & 0x80000000) == 0 )
  {
LABEL_23:
    v47 = 0;
    goto LABEL_24;
  }
  v47 = *(_DWORD *)(StatusReg + 40);
LABEL_24:
  _aarch64_swp4_rel();
  if ( v54 > 1 )
    _lll_lock_wake_private((void *)(StatusReg - 776), v48, v49, v50, v51, v52, v53);
  return v47;
}
// 438F80: variable 'v44' is possibly undefined
// 4391A8: variable 'v36' is possibly undefined
// 4391A8: variable 'v37' is possibly undefined
// 4391A8: variable 'v38' is possibly undefined
// 4391A8: variable 'v39' is possibly undefined
// 4391A8: variable 'v40' is possibly undefined
// 4391A8: variable 'v41' is possibly undefined
// 4391A8: variable 'v42' is possibly undefined
// 4391A8: variable 'v43' is possibly undefined
// 4391A8: variable 'v30' is possibly undefined
// 4391A8: variable 'v31' is possibly undefined
// 4391A8: variable 'v32' is possibly undefined
// 4391A8: variable 'v33' is possibly undefined
// 4391A8: variable 'v34' is possibly undefined
// 4391A8: variable 'v35' is possibly undefined
// 438FD0: variable 'v54' is possibly undefined
// 43919C: variable 'v48' is possibly undefined
// 43919C: variable 'v49' is possibly undefined
// 43919C: variable 'v50' is possibly undefined
// 43919C: variable 'v51' is possibly undefined
// 43919C: variable 'v52' is possibly undefined
// 43919C: variable 'v53' is possibly undefined
// 43909C: variable 'a12' is possibly undefined
// 43909C: variable 'a3' is possibly undefined
// 43909C: variable 'a4' is possibly undefined
// 43909C: variable 'a5' is possibly undefined
// 43909C: variable 'a6' is possibly undefined
// 43909C: variable 'a7' is possibly undefined
// 43909C: variable 'a8' is possibly undefined
// 43909C: variable 'a9' is possibly undefined
// 43909C: variable 'a10' is possibly undefined
// 43909C: variable 'a14' is possibly undefined
// 43909C: variable 'a15' is possibly undefined
// 43909C: variable 'a16' is possibly undefined
// 49191C: using guessed type int _sched_fifo_max_prio;
// 491920: using guessed type int _sched_fifo_min_prio;

//----- (0000000000439208) ----------------------------------------------------
__int64 _pthread_current_priority()
{
  unsigned __int64 StatusReg; // x20
  _DWORD *v1; // x19
  __int64 v2; // x1
  __int64 v3; // x2
  __int64 v4; // x3
  void *v5; // x4
  void *v6; // x5
  void *v7; // x6
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  int v16; // w0
  int v17; // w0
  unsigned int v18; // w19
  __int64 v19; // x1
  __int64 v20; // x2
  __int64 v21; // x3
  void *v22; // x4
  void *v23; // x5
  void *v24; // x6
  int v25; // w0
  int v27; // w0
  int v28; // w2
  int v29; // w0
  int v30; // w0

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v1 = (_DWORD *)(StatusReg - 1824);
  if ( (*(_DWORD *)(StatusReg - 1824 + 0x10C) & 0x60) == 0x60 )
    return (unsigned int)v1[268];
  _aarch64_cas4_acq();
  if ( v16 )
    _lll_lock_wait_private((_DWORD *)(StatusReg - 776), v8, v9, v10, v11, v12, v13, v14, v15, v2, v3, v4, v5, v6, v7);
  v17 = v1[67];
  if ( (v17 & 0x20) == 0 )
  {
    v27 = sched_getparam(v1[52], (struct sched_param *)(StatusReg - 752));
    v28 = v1[67] & 0x40;
    if ( v27 )
    {
      if ( !v28 )
      {
        v30 = sched_getscheduler(v1[52]);
        v1[269] = v30;
        if ( v30 != -1 )
        {
          v1[67] |= 0x40u;
          v18 = -1;
          goto LABEL_7;
        }
      }
      goto LABEL_13;
    }
    v1[67] |= 0x20u;
    if ( v28 )
      goto LABEL_6;
LABEL_12:
    v29 = sched_getscheduler(v1[52]);
    v1[269] = v29;
    if ( v29 != -1 )
    {
      v1[67] |= 0x40u;
      goto LABEL_6;
    }
LABEL_13:
    v18 = -1;
    goto LABEL_7;
  }
  if ( (v17 & 0x40) == 0 )
    goto LABEL_12;
LABEL_6:
  v18 = v1[268];
LABEL_7:
  _aarch64_swp4_rel();
  if ( v25 > 1 )
    _lll_lock_wake_private((void *)(StatusReg - 776), v19, v20, v21, v22, v23, v24);
  return v18;
}
// 43923C: variable 'v16' is possibly undefined
// 43930C: variable 'v8' is possibly undefined
// 43930C: variable 'v9' is possibly undefined
// 43930C: variable 'v10' is possibly undefined
// 43930C: variable 'v11' is possibly undefined
// 43930C: variable 'v12' is possibly undefined
// 43930C: variable 'v13' is possibly undefined
// 43930C: variable 'v14' is possibly undefined
// 43930C: variable 'v15' is possibly undefined
// 43930C: variable 'v2' is possibly undefined
// 43930C: variable 'v3' is possibly undefined
// 43930C: variable 'v4' is possibly undefined
// 43930C: variable 'v5' is possibly undefined
// 43930C: variable 'v6' is possibly undefined
// 43930C: variable 'v7' is possibly undefined
// 439260: variable 'v25' is possibly undefined
// 439300: variable 'v19' is possibly undefined
// 439300: variable 'v20' is possibly undefined
// 439300: variable 'v21' is possibly undefined
// 439300: variable 'v22' is possibly undefined
// 439300: variable 'v23' is possibly undefined
// 439300: variable 'v24' is possibly undefined

//----- (0000000000439340) ----------------------------------------------------
__int64 __fastcall argz_add_sep(unsigned __int64 *a1, _QWORD *a2, unsigned __int8 *a3, int a4)
{
  unsigned __int64 (__fastcall *v8)(__int64); // x0
  __int64 v9; // x2
  void *v10; // x4
  void *v11; // x5
  void *v12; // x6
  __int64 v13; // x7
  double v14; // d0
  double v15; // d1
  double v16; // d2
  double v17; // d3
  double v18; // d4
  double v19; // d5
  double v20; // d6
  double v21; // d7
  unsigned __int64 v23; // x0
  void *v24; // x3
  _BYTE *v25; // x4
  int v26; // w2
  void *v27; // [xsp+38h] [xbp+38h]

  v8 = strlen();
  if ( v8 )
  {
    v27 = (char *)v8 + 1;
    v23 = realloc(*a1, (unsigned __int64)v27 + *a2, v9, v27, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21);
    *a1 = v23;
    if ( !v23 )
      return 12LL;
    v24 = v27;
    v25 = (_BYTE *)(v23 + *a2);
    while ( 1 )
    {
      while ( 1 )
      {
        v26 = *a3;
        if ( v26 == a4 )
          break;
        *v25++ = v26;
LABEL_7:
        ++a3;
        if ( !v26 )
          goto LABEL_12;
      }
      if ( *a1 >= (unsigned __int64)v25 || !*(v25 - 1) )
      {
        v24 = (char *)v24 - 1;
        goto LABEL_7;
      }
      *v25++ = 0;
      if ( !*a3++ )
      {
LABEL_12:
        *a2 += v24;
        return 0LL;
      }
    }
  }
  return 0LL;
}
// 439394: variable 'v9' is possibly undefined
// 439394: variable 'v10' is possibly undefined
// 439394: variable 'v11' is possibly undefined
// 439394: variable 'v12' is possibly undefined
// 439394: variable 'v13' is possibly undefined
// 439394: variable 'v14' is possibly undefined
// 439394: variable 'v15' is possibly undefined
// 439394: variable 'v16' is possibly undefined
// 439394: variable 'v17' is possibly undefined
// 439394: variable 'v18' is possibly undefined
// 439394: variable 'v19' is possibly undefined
// 439394: variable 'v20' is possibly undefined
// 439394: variable 'v21' is possibly undefined

//----- (0000000000439420) ----------------------------------------------------
__int64 __fastcall argz_create_sep(unsigned __int8 *a1, int a2, unsigned __int64 *a3, _QWORD *a4)
{
  unsigned __int64 (__fastcall *v8)(__int64); // x0
  __int64 v9; // x2
  void *v10; // x3
  void *v11; // x4
  void *v12; // x5
  void *v13; // x6
  __int64 v14; // x7
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  char *v23; // x1
  __int64 result; // x0
  unsigned __int64 v25; // x0
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7
  _BYTE *v34; // x4
  int v35; // w5
  char *v36; // [xsp+38h] [xbp+38h]

  v8 = strlen();
  if ( !v8 )
  {
    v23 = 0LL;
    *a3 = 0LL;
    goto LABEL_3;
  }
  v36 = (char *)v8 + 1;
  v25 = malloc((__int64)v8 + 1, (__int64)v8 + 1, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20, v21, v22);
  *a3 = v25;
  if ( !v25 )
    return 12LL;
  v23 = v36;
  v34 = (_BYTE *)v25;
  do
  {
    while ( 1 )
    {
      v35 = *a1;
      if ( v35 == a2 )
        break;
      *v34++ = v35;
LABEL_8:
      ++a1;
      if ( !v35 )
        goto LABEL_13;
    }
    if ( v25 >= (unsigned __int64)v34 || !*(v34 - 1) )
    {
      --v23;
      goto LABEL_8;
    }
    *v34++ = 0;
    ++a1;
  }
  while ( v35 );
LABEL_13:
  if ( !v23 )
  {
    free(v25, v26, v27, v28, v29, v30, v31, v32, v33);
    v23 = 0LL;
    *a3 = 0LL;
  }
LABEL_3:
  result = 0LL;
  *a4 = v23;
  return result;
}
// 439474: variable 'v9' is possibly undefined
// 439474: variable 'v10' is possibly undefined
// 439474: variable 'v11' is possibly undefined
// 439474: variable 'v12' is possibly undefined
// 439474: variable 'v13' is possibly undefined
// 439474: variable 'v14' is possibly undefined
// 439474: variable 'v15' is possibly undefined
// 439474: variable 'v16' is possibly undefined
// 439474: variable 'v17' is possibly undefined
// 439474: variable 'v18' is possibly undefined
// 439474: variable 'v19' is possibly undefined
// 439474: variable 'v20' is possibly undefined
// 439474: variable 'v21' is possibly undefined
// 439474: variable 'v22' is possibly undefined
// 4394C8: variable 'v26' is possibly undefined
// 4394C8: variable 'v27' is possibly undefined
// 4394C8: variable 'v28' is possibly undefined
// 4394C8: variable 'v29' is possibly undefined
// 4394C8: variable 'v30' is possibly undefined
// 4394C8: variable 'v31' is possibly undefined
// 4394C8: variable 'v32' is possibly undefined
// 4394C8: variable 'v33' is possibly undefined

//----- (0000000000439500) ----------------------------------------------------
unsigned __int64 (__fastcall *memchr())(__int64 a1, unsigned int a2, unsigned __int64 a3)
{
  unsigned __int64 (__fastcall *result)(__int64, unsigned int, unsigned __int64); // x0

  result = _memchr_generic;
  if ( (dl_aarch64_cpu_features & 0xFFFFFFFFFF00FFF0LL) == 0x50000000 )
    return (unsigned __int64 (__fastcall *)(__int64, unsigned int, unsigned __int64))_memchr_nosimd;
  return result;
}
// 496CC8: using guessed type __int64 dl_aarch64_cpu_features;

//----- (0000000000439540) ----------------------------------------------------
char *__fastcall stpcpy(_QWORD *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x4
  unsigned __int64 v3; // x2
  int8x16_t v4; // q0
  unsigned __int64 v5; // d2
  unsigned __int64 v6; // x4
  __int128 v7; // q1
  __int64 v9; // x7
  unsigned __int64 v10; // x5
  int v11; // w7
  int8x16_t *v12; // x3
  int8x16_t v13; // q0
  int16x8_t v14; // q1
  int8x16_t v15; // t1
  _OWORD *v16; // x3

  v2 = vshrn_n_s16(vceqzq_s8(*(int8x16_t *)(a2 & 0xFFFFFFFFFFFFFFF0LL)), 4uLL).n64_u64[0] >> (4 * (unsigned __int8)a2);
  if ( v2 )
  {
    v6 = __clz(__rbit64(v2)) >> 2;
LABEL_6:
    if ( (v6 & 8) != 0 )
    {
      v9 = *(_QWORD *)(a2 + v6 - 7);
      *a1 = *(_QWORD *)a2;
      *(_QWORD *)((char *)a1 + v6 - 7) = v9;
      return (char *)a1 + v6;
    }
    else
    {
      v10 = v6 - 3;
      if ( v6 < 3 )
      {
        if ( v6 )
          *(_WORD *)a1 = *(_WORD *)a2;
        *((_BYTE *)a1 + v6) = 0;
        return (char *)a1 + v6;
      }
      else
      {
        v11 = *(_DWORD *)(a2 + v10);
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)((char *)a1 + v10) = v11;
        return (char *)a1 + v6;
      }
    }
  }
  v3 = (a2 & 0xFFFFFFFFFFFFFFF0LL) + 16;
  v4 = *(int8x16_t *)((a2 & 0xFFFFFFFFFFFFFFF0LL) + 0x10);
  v5 = vshrn_n_s16(vceqzq_s8(v4), 4uLL).n64_u64[0];
  if ( v5 )
  {
    v6 = v3 - a2 + (__clz(__rbit64(v5)) >> 2);
    if ( (v6 & 0x10) != 0 )
    {
      v7 = *(_OWORD *)(a2 + v6 - 15);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)((char *)a1 + v6 - 15) = v7;
      return (char *)a1 + v6;
    }
    goto LABEL_6;
  }
  v12 = (int8x16_t *)(v3 - (a2 - (_QWORD)a1));
  *(_OWORD *)a1 = *(_OWORD *)a2;
  while ( 1 )
  {
    *v12 = v4;
    v12 += 2;
    v13 = *(int8x16_t *)(v3 + 16);
    v14 = vceqzq_s8(v13);
    if ( vpmaxq_u8(v14, v14).n128_u64[0] )
      break;
    v12[-1] = v13;
    v15 = *(int8x16_t *)(v3 + 32);
    v3 += 32LL;
    v4 = v15;
    v14 = vceqzq_s8(v15);
    if ( vpmaxq_u8(v14, v14).n128_u64[0] )
    {
      ++v12;
      break;
    }
  }
  v16 = (_OWORD *)((char *)v12[-2].n128_u64 + (__clz(__rbit64(vshrn_n_s16(v14, 4uLL).n64_u64[0])) >> 2) + 1);
  *v16 = *(_OWORD *)((char *)v16 + a2 - (_QWORD)a1);
  return (char *)v16 + 15;
}

//----- (00000000004396A0) ----------------------------------------------------
__int64 __fastcall strcasecmp_l(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x6
  __int64 v4; // x3
  int v5; // w5
  unsigned int v6; // w2

  if ( a1 == a2 )
    return 0LL;
  v3 = *(_QWORD *)(a3 + 112);
  v4 = 0LL;
  do
  {
    v5 = *(unsigned __int8 *)(a1 + v4);
    v6 = *(_DWORD *)(v3 + 4LL * *(unsigned __int8 *)(a1 + v4)) - *(_DWORD *)(v3 + 4LL * *(unsigned __int8 *)(a2 + v4));
    if ( v6 )
      break;
    ++v4;
  }
  while ( v5 );
  return v6;
}

//----- (0000000000439700) ----------------------------------------------------
__int64 __fastcall strchr(__int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // x2
  int8x16_t v3; // q0
  int8x16_t v4; // q4
  unsigned __int64 v5; // x1
  unsigned __int64 v6; // x1
  __int64 result; // x0
  int8x16_t v8; // q1
  int8x16_t v9; // q3
  int8x16_t v10; // q2
  int8x16_t v11; // t1
  unsigned __int64 v12; // x1

  v2 = a1 & 0xFFFFFFFFFFFFFFF0LL;
  v3 = vdupq_n_s8(a2);
  v4.n128_u64[0] = 0x3333333333333333LL;
  v4.n128_u64[1] = 0x3333333333333333LL;
  v5 = vshrn_n_s16(
         vbslq_s8(
           v4,
           vceqq_s8(*(int8x16_t *)(a1 & 0xFFFFFFFFFFFFFFF0LL), v3),
           vceqzq_s8(*(int8x16_t *)(a1 & 0xFFFFFFFFFFFFFFF0LL))),
         4uLL).n64_u64[0] >> (4 * (unsigned __int8)a1);
  if ( v5 )
  {
    v6 = __clz(__rbit64(v5));
    result = a1 + (v6 >> 2);
    if ( (v6 & 2) != 0 )
      return 0LL;
  }
  else
  {
    while ( 1 )
    {
      v8 = *(int8x16_t *)(v2 + 16);
      v9 = vceqq_s8(v8, v3);
      v10 = vcgeq_u8(v9, v8);
      if ( vpmaxq_u8(v10, v10).n128_u64[0] )
        break;
      v11 = *(int8x16_t *)(v2 + 32);
      v2 += 32LL;
      v9 = vceqq_s8(v11, v3);
      v10 = vcgeq_u8(v9, v11);
      if ( vpmaxq_u8(v10, v10).n128_u64[0] )
      {
        v2 -= 16LL;
        break;
      }
    }
    v12 = __clz(__rbit64(vshrn_n_s16(vbslq_s8(v4, v9, v10), 4uLL).n64_u64[0]));
    result = v2 + 16 + (v12 >> 2);
    if ( (v12 & 2) != 0 )
      return 0LL;
  }
  return result;
}

//----- (00000000004397C0) ----------------------------------------------------
unsigned __int64 __fastcall strcmp(unsigned __int64 *a1, unsigned __int64 a2)
{
  unsigned __int64 v2; // x10
  unsigned __int64 v3; // x3
  unsigned __int64 v4; // x2
  unsigned __int64 v5; // t1
  unsigned __int64 v7; // x6
  char v8; // w9
  _QWORD *v10; // x0
  __int64 v11; // x3
  __int64 v12; // t1
  unsigned __int64 v13; // x6
  __int64 v14; // x2
  unsigned int v15; // t1
  __int64 v16; // x3
  unsigned int v17; // t1
  __int64 v19; // x9
  _QWORD *v20; // x1
  char *v21; // x1
  __int64 v22; // t1
  unsigned __int64 v23; // x7
  unsigned __int64 v24; // x4
  signed __int64 v25; // x5
  unsigned __int64 v26; // t1
  bool v27; // zf
  __int64 v28; // x9

  v2 = a2 - (_QWORD)a1;
  if ( ((a2 - (_QWORD)a1) & 7) == 0 )
  {
    if ( ((unsigned __int8)a1 & 7) != 0 )
    {
      v10 = (_QWORD *)((unsigned __int64)a1 & 0xFFFFFFFFFFFFFFF8LL);
      v11 = *(_QWORD *)((char *)v10 + v2);
      v12 = *v10;
      a1 = v10 + 1;
      v13 = 0xFFFFFFFFFFFFFFFFLL >> (-8 * (unsigned __int8)a2);
      v4 = v12 | v13;
      v3 = v11 | v13;
      goto LABEL_4;
    }
    do
    {
      v3 = *(unsigned __int64 *)((char *)a1 + v2);
      v5 = *a1++;
      v4 = v5;
LABEL_4:
      ;
    }
    while ( ((v4 - 0x101010101010101LL) & ~(v4 | 0x7F7F7F7F7F7F7F7FLL)) == 0 && v4 == v3 );
    v7 = v4 ^ v3 | (v4 - 0x101010101010101LL) & ~(v4 | 0x7F7F7F7F7F7F7F7FLL);
    goto LABEL_9;
  }
  if ( ((unsigned __int8)a1 & 7) == 0 )
  {
LABEL_18:
    v19 = -8LL * a2;
    v20 = (_QWORD *)(a2 & 0xFFFFFFFFFFFFFFF8LL);
    v22 = *v20;
    v21 = (char *)(v20 + 1);
    v23 = v22 | (0x101010101010101uLL >> v19);
    v24 = (v23 - 0x101010101010101LL) & ~(v23 | 0x7F7F7F7F7F7F7F7FLL);
    if ( v24 )
      goto LABEL_25;
    v25 = v21 - (char *)a1;
    do
    {
      v23 = *(unsigned __int64 *)((char *)a1 + v25);
      v3 = *(unsigned __int64 *)((char *)a1 + v2);
      v26 = *a1++;
      v4 = v26;
      v24 = (v23 - 0x101010101010101LL) & ~(v23 | 0x7F7F7F7F7F7F7F7FLL);
      if ( v24 )
        v27 = 0;
      else
        v27 = v4 == v3;
    }
    while ( v27 );
    v7 = v4 ^ v3 | (v24 << v19);
    if ( !v7 )
    {
LABEL_25:
      v4 = *a1;
      v28 = -v19;
      v3 = v23 >> v28;
      v7 = *a1 ^ (v23 >> v28) | (v24 >> v28);
    }
LABEL_9:
    v8 = __clz(bswap64(v7));
    return (bswap64(v4) << v8 >> 56) - (bswap64(v3) << v8 >> 56);
  }
  while ( 1 )
  {
    v15 = *(unsigned __int8 *)a1;
    a1 = (unsigned __int64 *)((char *)a1 + 1);
    v14 = v15;
    v17 = *(unsigned __int8 *)a2++;
    v16 = v17;
    if ( !(_DWORD)v14 || (_DWORD)v14 != (_DWORD)v16 )
      return v14 - v16;
    if ( ((unsigned __int8)a1 & 7) == 0 )
      goto LABEL_18;
  }
}

//----- (0000000000439900) ----------------------------------------------------
long double __fastcall strcpy(_QWORD *a1, unsigned __int64 a2)
{
  long double result; // q0
  unsigned __int64 v3; // x4
  unsigned __int64 v4; // x2
  unsigned __int64 v5; // d2
  unsigned __int64 v6; // x4
  __int128 v7; // q1
  __int64 v8; // x7
  unsigned __int64 v9; // x5
  int v10; // w7
  long double *v11; // x3
  int8x16_t v12; // q0
  int16x8_t v13; // q1
  long double v14; // t1
  long double *v15; // x3

  result = *(long double *)(a2 & 0xFFFFFFFFFFFFFFF0LL);
  v3 = vshrn_n_s16(vceqzq_s8(*(int8x16_t *)&result), 4uLL).n64_u64[0] >> (4 * (unsigned __int8)a2);
  if ( v3 )
  {
    v6 = __clz(__rbit64(v3)) >> 2;
LABEL_6:
    if ( (v6 & 8) != 0 )
    {
      v8 = *(_QWORD *)(a2 + v6 - 7);
      *a1 = *(_QWORD *)a2;
      *(_QWORD *)((char *)a1 + v6 - 7) = v8;
    }
    else
    {
      v9 = v6 - 3;
      if ( v6 < 3 )
      {
        if ( v6 )
          *(_WORD *)a1 = *(_WORD *)a2;
        *((_BYTE *)a1 + v6) = 0;
      }
      else
      {
        v10 = *(_DWORD *)(a2 + v9);
        *(_DWORD *)a1 = *(_DWORD *)a2;
        *(_DWORD *)((char *)a1 + v9) = v10;
      }
    }
    return result;
  }
  v4 = (a2 & 0xFFFFFFFFFFFFFFF0LL) + 16;
  result = *(long double *)((a2 & 0xFFFFFFFFFFFFFFF0LL) + 0x10);
  v5 = vshrn_n_s16(vceqzq_s8(*(int8x16_t *)&result), 4uLL).n64_u64[0];
  if ( v5 )
  {
    v6 = v4 - a2 + (__clz(__rbit64(v5)) >> 2);
    if ( (v6 & 0x10) != 0 )
    {
      result = *(long double *)a2;
      v7 = *(_OWORD *)(a2 + v6 - 15);
      *(_OWORD *)a1 = *(_OWORD *)a2;
      *(_OWORD *)((char *)a1 + v6 - 15) = v7;
      return result;
    }
    goto LABEL_6;
  }
  v11 = (long double *)(v4 - (a2 - (_QWORD)a1));
  *(_OWORD *)a1 = *(_OWORD *)a2;
  while ( 1 )
  {
    *v11 = result;
    v11 += 2;
    v12 = *(int8x16_t *)(v4 + 16);
    v13 = vceqzq_s8(v12);
    if ( vpmaxq_u8(v13, v13).n128_u64[0] )
      break;
    *(v11 - 1) = *(long double *)&v12;
    v14 = *(long double *)(v4 + 32);
    v4 += 32LL;
    result = v14;
    v13 = vceqzq_s8(*(int8x16_t *)&v14);
    if ( vpmaxq_u8(v13, v13).n128_u64[0] )
    {
      ++v11;
      break;
    }
  }
  v15 = (long double *)((char *)v11 + (__clz(__rbit64(vshrn_n_s16(v13, 4uLL).n64_u64[0])) >> 2) - 31);
  result = *(long double *)((char *)v15 + a2 - (_QWORD)a1);
  *v15 = result;
  return result;
}

//----- (0000000000439A40) ----------------------------------------------------
unsigned __int64 __fastcall strcspn(__int64 a1, unsigned __int8 *a2)
{
  unsigned int v2; // t1
  __int64 v3; // x1
  unsigned __int8 *v4; // x1
  unsigned int v5; // t1
  int v6; // w6
  int v7; // w5
  int v8; // w4
  unsigned __int8 *v9; // x1
  __int64 v10; // x0
  _OWORD v12[16]; // [xsp+20h] [xbp+20h] BYREF

  if ( !*a2 || !a2[1] )
    return strchrnul(a1, *a2) - a1;
  memset(v12, 0, sizeof(v12));
  do
  {
    v2 = *a2++;
    *((_BYTE *)v12 + v2) = 1;
  }
  while ( v2 );
  v3 = 0LL;
  if ( !*((_BYTE *)v12 + *(unsigned __int8 *)a1) )
  {
    v3 = 1LL;
    if ( !*((_BYTE *)v12 + *(unsigned __int8 *)(a1 + 1)) )
    {
      v3 = 2LL;
      if ( !*((_BYTE *)v12 + *(unsigned __int8 *)(a1 + 2)) )
      {
        v3 = 3LL;
        if ( !*((_BYTE *)v12 + *(unsigned __int8 *)(a1 + 3)) )
        {
          v4 = (unsigned __int8 *)(a1 & 0xFFFFFFFFFFFFFFFCLL);
          do
          {
            v5 = v4[4];
            v4 += 4;
            v6 = *((unsigned __int8 *)v12 + v5);
            v7 = *((unsigned __int8 *)v12 + v4[2]);
            v8 = *((unsigned __int8 *)v12 + v4[1]) | v6;
          }
          while ( !((unsigned __int8)(*((_BYTE *)v12 + v4[1]) | v6) | (unsigned __int8)(v7 | *((_BYTE *)v12 + v4[3]))) );
          v9 = &v4[-a1];
          v10 = (__int64)&v9[-v6 + 1];
          v3 = (__int64)&v9[-v7 + 3];
          if ( v8 )
            return v10;
        }
      }
    }
  }
  return v3;
}

//----- (0000000000439B60) ----------------------------------------------------
__int64 (__fastcall *strdup())(__int64 result, __int64 *a2, unsigned __int64 a3)
{
  unsigned __int64 (__fastcall *v0)(__int64); // x0
  __int64 v1; // x1
  void *v2; // x3
  void *v3; // x4
  void *v4; // x5
  void *v5; // x6
  __int64 v6; // x7
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  __int64 (__fastcall *result)(__int64, __int64 *, unsigned __int64); // x0

  v0 = strlen();
  result = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))malloc(
                                                                           (__int64)v0 + 1,
                                                                           v1,
                                                                           (__int64)v0 + 1,
                                                                           v2,
                                                                           v3,
                                                                           v4,
                                                                           v5,
                                                                           v6,
                                                                           v7,
                                                                           v8,
                                                                           v9,
                                                                           v10,
                                                                           v11,
                                                                           v12,
                                                                           v13,
                                                                           v14);
  if ( result )
    return j_memcpy();
  return result;
}
// 439B80: variable 'v1' is possibly undefined
// 439B80: variable 'v2' is possibly undefined
// 439B80: variable 'v3' is possibly undefined
// 439B80: variable 'v4' is possibly undefined
// 439B80: variable 'v5' is possibly undefined
// 439B80: variable 'v6' is possibly undefined
// 439B80: variable 'v7' is possibly undefined
// 439B80: variable 'v8' is possibly undefined
// 439B80: variable 'v9' is possibly undefined
// 439B80: variable 'v10' is possibly undefined
// 439B80: variable 'v11' is possibly undefined
// 439B80: variable 'v12' is possibly undefined
// 439B80: variable 'v13' is possibly undefined
// 439B80: variable 'v14' is possibly undefined

//----- (0000000000439BE4) ----------------------------------------------------
unsigned __int64 __fastcall strncmp(unsigned __int64 a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x13
  unsigned __int64 v4; // x3
  unsigned __int64 v5; // t1
  unsigned __int64 v6; // x4
  unsigned __int64 v7; // t1
  bool v8; // cc
  unsigned __int64 v9; // x6
  __int64 v10; // x14
  __int64 v11; // x5
  bool v12; // zf
  unsigned __int64 v13; // x7
  unsigned __int64 v14; // x12
  unsigned __int64 result; // x0
  __int64 *v16; // x0
  __int64 *v17; // x1
  __int64 v18; // x3
  __int64 v19; // t1
  __int64 v20; // x4
  __int64 v21; // t1
  unsigned __int64 v22; // x9
  __int64 v23; // x3
  unsigned int v24; // t1
  __int64 v25; // x4
  unsigned int v26; // t1
  bool v27; // cf
  unsigned __int64 v29; // x13
  unsigned int v30; // t1
  unsigned int v31; // t1
  __int64 v33; // x12
  unsigned __int64 *v34; // x1
  unsigned __int64 *v35; // x0
  unsigned __int64 v36; // t1
  unsigned __int64 *v37; // x1
  unsigned __int64 v38; // x8
  unsigned __int64 v39; // x9
  __int64 v40; // x13
  unsigned __int64 v41; // x15
  unsigned __int64 v42; // x14
  unsigned __int64 v43; // t1
  unsigned __int64 v44; // x6
  __int64 v45; // x5
  __int64 v46; // x10
  unsigned __int64 v47; // x6
  unsigned __int64 v49; // t1

  if ( !a3 )
    return 0LL;
  v3 = a1 & 7;
  if ( ((a1 ^ a2) & 7) != 0 )
  {
    if ( a3 >= 0x10 )
    {
      if ( (a1 & 7) == 0 )
      {
LABEL_37:
        v33 = 8 * a2;
        v34 = (unsigned __int64 *)(a2 & 0xFFFFFFFFFFFFFFF0LL);
        v36 = *(_QWORD *)a1;
        v35 = (unsigned __int64 *)(a1 + 8);
        v4 = v36;
        v38 = *v34;
        v39 = v34[1];
        v37 = v34 + 2;
        v40 = -1LL << -(char)v33;
        v41 = -v33 & 0x3F;
        if ( (v33 & 0x40) != 0 )
          goto LABEL_43;
        while ( 1 )
        {
          v8 = a3 > 8;
          a3 -= 8LL;
          v6 = (v38 >> v33) | (v39 << v41);
          v9 = v4 ^ v6;
          v42 = v8 ? v4 ^ v6 : -1LL;
          v11 = (v4 - 0x101010101010101LL) & ~(v4 | 0x7F7F7F7F7F7F7F7FLL);
          if ( v42 | v11 )
            goto LABEL_12;
          v43 = *v35++;
          v4 = v43;
LABEL_43:
          v6 = v39 >> v33;
          v44 = (v39 >> v33) ^ v4;
          v45 = (v4 - 0x101010101010101LL) & ~(v4 | 0x7F7F7F7F7F7F7F7FLL);
          v13 = (v44 | v45) & ~v40;
          if ( a3 <= v41 >> 3 )
            v46 = -1LL;
          else
            v46 = (v44 | v45) & ~v40;
          if ( v46 )
            goto LABEL_13;
          v38 = *v37;
          v39 = v37[1];
          v37 += 2;
          v6 = v38 << v41;
          v47 = (v38 << v41) ^ v4;
          v13 = (v47 | v45) & v40;
          if ( a3 <= 8 ? -1LL : (v47 | v45) & v40 )
            goto LABEL_13;
          v49 = *v35++;
          v4 = v49;
          a3 -= 8LL;
        }
      }
      v29 = -(__int64)v3 & 7;
      a3 -= v29;
      while ( 1 )
      {
        v30 = *(unsigned __int8 *)a1++;
        v23 = v30;
        v31 = *(unsigned __int8 *)a2++;
        v25 = v31;
        if ( !(_DWORD)v23 || (_DWORD)v23 != (_DWORD)v25 )
          break;
        v8 = v29-- > 1;
        if ( !v8 )
          goto LABEL_37;
      }
    }
    else
    {
      do
      {
        v24 = *(unsigned __int8 *)a1++;
        v23 = v24;
        v26 = *(unsigned __int8 *)a2++;
        v25 = v26;
        v8 = a3-- > 1;
        v27 = v8 && (_DWORD)v23 != 0;
      }
      while ( v27 && (_DWORD)v23 == (_DWORD)v25 );
    }
    return v23 - v25;
  }
  if ( (a1 & 7) != 0 )
  {
    v16 = (__int64 *)(a1 & 0xFFFFFFFFFFFFFFF8LL);
    v17 = (__int64 *)(a2 & 0xFFFFFFFFFFFFFFF8LL);
    v19 = *v16;
    a1 = (unsigned __int64)(v16 + 1);
    v18 = v19;
    v21 = *v17;
    a2 = (unsigned __int64)(v17 + 1);
    v20 = v21;
    v22 = 0xFFFFFFFFFFFFFFFFLL >> (-8 * (unsigned __int8)v3);
    v27 = __CFADD__(a3, v3);
    a3 += v3;
    if ( v27 )
      a3 = -1LL;
    v4 = v18 | v22;
    v6 = v20 | v22;
    goto LABEL_5;
  }
  do
  {
    v5 = *(_QWORD *)a1;
    a1 += 8LL;
    v4 = v5;
    v7 = *(_QWORD *)a2;
    a2 += 8LL;
    v6 = v7;
LABEL_5:
    v8 = a3 > 8;
    a3 -= 8LL;
    v9 = v4 ^ v6;
    if ( v8 )
      v10 = v4 ^ v6;
    else
      v10 = -1LL;
    v11 = (v4 - 0x101010101010101LL) & ~(v4 | 0x7F7F7F7F7F7F7F7FLL);
    if ( v11 )
      v12 = 0;
    else
      v12 = v10 == 0;
  }
  while ( v12 );
LABEL_12:
  v13 = v9 | v11;
  a3 += 8LL;
LABEL_13:
  v14 = __clz(bswap64(v13));
  result = (bswap64(v4) << v14 >> 56) - (bswap64(v6) << v14 >> 56);
  if ( a3 <= v14 >> 3 )
    return 0LL;
  return result;
}

//----- (0000000000439E00) ----------------------------------------------------
unsigned __int64 __fastcall strrchr(
        __int64 a1,
        unsigned int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        unsigned __int64 a7)
{
  unsigned __int64 v7; // x2
  int8x16_t v8; // q0
  int8x16_t v9; // q4
  __int64 v10; // x4
  unsigned __int64 v11; // x3
  unsigned __int64 v12; // x5
  int8x16_t v13; // q1
  int8x16_t v14; // q3
  uint8x16_t v15; // q2
  int8x16_t v16; // t1
  uint8x16_t v17; // q2
  unsigned __int64 result; // x0
  int8x16_t *v19; // x2
  unsigned __int128 v20; // q4
  int8x16_t v21; // q1
  uint8x16_t v22; // q2
  unsigned __int64 v23; // d5
  unsigned __int64 v24; // x5

  v7 = a1 & 0xFFFFFFFFFFFFFFF0LL;
  v8 = vdupq_n_s8(a2);
  v9.n128_u64[0] = 0x3333333333333333LL;
  v9.n128_u64[1] = 0x3333333333333333LL;
  v10 = 4 * a1;
  v11 = vshrn_n_s16(
          vbslq_s8(
            v9,
            vceqq_s8(*(int8x16_t *)(a1 & 0xFFFFFFFFFFFFFFF0LL), v8),
            vceqzq_s8(*(int8x16_t *)(a1 & 0xFFFFFFFFFFFFFFF0LL))),
          4uLL).n64_u64[0] >> (4 * (unsigned __int8)a1) << (4 * (unsigned __int8)a1);
  v12 = v11 & 0xCCCCCCCCCCCCCCCCLL;
  if ( (v11 & 0xCCCCCCCCCCCCCCCCLL) != 0 )
    goto LABEL_7;
  if ( v11 )
    goto LABEL_9;
  while ( 1 )
  {
    v13 = *(int8x16_t *)(v7 + 16);
    v14 = vceqq_s8(v13, v8);
    v15 = vcgeq_u8(v14, v13);
    if ( vpmaxq_u8(v15, v15).n128_u64[0] )
      break;
    v16 = *(int8x16_t *)(v7 + 32);
    v7 += 32LL;
    v13 = v16;
    v14 = vceqq_s8(v16, v8);
    v17 = vcgeq_u8(v14, v16);
    if ( vpmaxq_u8(v17, v17).n128_u64[0] )
    {
      v7 -= 16LL;
      break;
    }
  }
  v7 += 16LL;
  v11 = vshrn_n_s16(vbslq_s8(v9, v14, vceqzq_s8(v13)), 4uLL).n64_u64[0];
  v12 = v11 & 0xCCCCCCCCCCCCCCCCLL;
  if ( (v11 & 0xCCCCCCCCCCCCCCCCLL) != 0 )
  {
LABEL_7:
    result = v7 + 15 - (__clz(v11 & 0x3333333333333333LL & (v12 - 1)) >> 2);
    if ( (v11 & 0x3333333333333333LL & (v12 - 1)) == 0 )
      return 0LL;
  }
  else
  {
LABEL_9:
    v19 = (int8x16_t *)(v7 + 16);
    v20 = *(_OWORD *)&v9 & __PAIR128__(0xFF0FFF0FFF0FFF0FLL, 0xFF0FFF0FFF0FFF0FLL);
    do
    {
      if ( v11 )
      {
        v10 = (__int64)v19;
        a7 = v11;
      }
      v21 = *v19++;
      v22 = vbslq_s8((int8x16_t)v20, vceqq_s8(v21, v8), vceqzq_s8(v21));
      v11 = vpmaxq_u8(v22, v22).n128_u64[0];
    }
    while ( (v11 & 0xCCCCCCCCCCCCCCCCLL) == 0 );
    v23 = vpaddq_s8(
            (int8x16_t)(*(_OWORD *)&v22 & __PAIR128__(0xF0FFF0FFF0FFF0FFLL, 0xF0FFF0FFF0FFF0FFLL)),
            (int8x16_t)(*(_OWORD *)&v22 & __PAIR128__(0xF0FFF0FFF0FFF0FFLL, 0xF0FFF0FFF0FFF0FFLL))).n128_u64[0];
    v24 = (v23 & 0xCCCCCCCCCCCCCCCCLL) - 1;
    if ( (v23 & 0x3333333333333333LL & v24) != 0 )
    {
      a7 = v23 & 0x3333333333333333LL & v24;
      v10 = (__int64)v19;
    }
    return v10 - 1 - (__clz(a7) >> 2);
  }
  return result;
}

//----- (0000000000439F20) ----------------------------------------------------
__int64 __fastcall strsep(__int64 *a1, unsigned __int8 *a2)
{
  unsigned __int64 v2; // x0
  __int64 v4; // [xsp+10h] [xbp+10h]

  if ( !*a1 )
    return 0LL;
  v4 = *a1;
  v2 = strcspn(*a1, a2);
  if ( *(_BYTE *)(v4 + v2) )
  {
    *(_BYTE *)(v4 + v2) = 0;
    *a1 = v4 + v2 + 1;
  }
  else
  {
    *a1 = 0LL;
  }
  return v4;
}

//----- (0000000000439F80) ----------------------------------------------------
_BYTE *__fastcall strtok_r(_BYTE *a1, unsigned __int8 *a2, _BYTE **a3)
{
  _BYTE *v3; // x3
  _BYTE *v6; // x4
  unsigned __int64 v7; // x0
  _BYTE *v8; // x3
  _BYTE *v10; // [xsp+28h] [xbp+28h]

  v3 = a1;
  if ( !a1 )
    v3 = *a3;
  if ( !*v3 )
    goto LABEL_9;
  v6 = &v3[strspn((unsigned __int64)v3, a2)];
  if ( !*v6 )
  {
    v3 = v6;
LABEL_9:
    *a3 = v3;
    return 0LL;
  }
  v10 = v6;
  v7 = strcspn((__int64)v6, a2);
  v8 = &v10[v7];
  if ( v10[v7] )
  {
    ++v8;
    v10[v7] = 0;
  }
  *a3 = v8;
  return v10;
}

//----- (000000000043A040) ----------------------------------------------------
unsigned __int64 __fastcall _memchr_generic(__int64 a1, unsigned int a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // x3
  int8x16_t v4; // q0
  unsigned __int64 v5; // x5
  unsigned __int64 v6; // x5
  unsigned __int64 result; // x0
  unsigned __int64 v8; // x7
  unsigned __int64 v9; // x4
  int8x16_t v10; // t1
  int16x8_t v11; // q2
  bool v12; // cf
  unsigned __int64 v13; // x4
  unsigned __int64 v14; // x5

  v3 = a1 & 0xFFFFFFFFFFFFFFF0LL;
  if ( !a3 )
    return 0LL;
  v4 = vdupq_n_s8(a2);
  v5 = vshrn_n_s16(vceqq_s8(*(int8x16_t *)v3, v4), 4uLL).n64_u64[0] >> (4 * (unsigned __int8)a1);
  if ( v5 )
  {
    v6 = __clz(__rbit64(v5));
    result = a1 + (v6 >> 2);
    if ( a3 <= v6 >> 2 )
      return 0LL;
    return result;
  }
  v8 = v3 - a1 + 17;
  v9 = a3 - v8;
  if ( a3 < v8 )
    return 0LL;
  if ( (v9 & 0x10) == 0 )
    goto LABEL_10;
  v3 -= 16LL;
  while ( 1 )
  {
    v10 = *(int8x16_t *)(v3 + 32);
    v3 += 32LL;
    v11 = vceqq_s8(v10, v4);
    if ( vpmaxq_u8(v11, v11).n128_u64[0] )
      break;
LABEL_10:
    v11 = vceqq_s8(*(int8x16_t *)(v3 + 16), v4);
    v12 = v9 >= 0x20;
    v9 -= 32LL;
    if ( !v12 || vpmaxq_u8(v11, v11).n128_u64[0] )
    {
      v3 += 16LL;
      break;
    }
  }
  v13 = a3 - (v3 - a1);
  v14 = __clz(__rbit64(vshrn_n_s16(v11, 4uLL).n64_u64[0]));
  result = v3 + (v14 >> 2);
  if ( v13 <= v14 >> 2 )
    return 0LL;
  return result;
}

//----- (000000000043A140) ----------------------------------------------------
char *__fastcall _memchr_nosimd(__int64 a1, unsigned __int8 a2, __int64 a3)
{
  __int64 *v3; // x6
  __int64 v4; // x1
  __int64 v5; // x7
  unsigned __int64 v6; // x8
  __int64 v7; // x11
  __int64 v8; // x4
  __int64 v9; // x12
  __int64 v10; // x11
  bool v11; // zf
  __int64 v12; // x9
  __int64 v13; // x11
  __int64 v14; // x12
  unsigned __int64 v15; // x13
  unsigned __int64 v16; // x14
  __int64 *v18; // x0
  unsigned __int64 v19; // x13
  char *result; // x0
  bool v21; // nf

  if ( !a3 )
    return 0LL;
  v3 = (__int64 *)(a1 & 0xFFFFFFFFFFFFFFF0LL);
  v4 = 0x101010101010101LL * a2;
  v5 = a1 + a3;
  v6 = (a1 + a3 + 15) & 0xFFFFFFFFFFFFFFF0LL;
  if ( (a1 & 0xF) == 0 )
    goto LABEL_14;
  v7 = *v3;
  v3 += 2;
  v8 = -1LL << (8 * (unsigned __int8)a1);
  v9 = *(_QWORD *)((a1 & 0xFFFFFFFFFFFFFFF0LL) + 8) ^ v4;
  if ( (a1 & 8) != 0 )
    v10 = -1LL;
  else
    v10 = v7 ^ v4 | ~v8;
  if ( (a1 & 8) != 0 )
    v9 |= ~v8;
  v11 = a3 > 0 && v3 == (__int64 *)v6;
  if ( v11 )
    v12 = 0LL;
  else
    v12 = -1LL;
  while ( 1 )
  {
    v15 = (v10 - 0x101010101010101LL) & ~(v10 | 0x7F7F7F7F7F7F7F7FLL);
    v16 = (v9 - 0x101010101010101LL) & ~(v9 | 0x7F7F7F7F7F7F7F7FLL);
    if ( v11 || (v15 | v16) != 0 )
      break;
LABEL_14:
    v13 = *v3;
    v14 = v3[1];
    v3 += 2;
    v12 = (__int64)v3 - v6;
    v11 = v3 == (__int64 *)v6;
    v10 = v13 ^ v4;
    v9 = v14 ^ v4;
  }
  if ( !v15 )
  {
    if ( v16 )
    {
      v18 = v3 - 1;
      v19 = bswap64(v16);
      goto LABEL_23;
    }
    return 0LL;
  }
  v18 = v3 - 2;
  v19 = bswap64(v15);
LABEL_23:
  result = (char *)v18 + (__clz(v19) >> 3);
  if ( v12 )
    v21 = 1;
  else
    v21 = (__int64)&result[-v5] < 0;
  if ( !v21 )
    return 0LL;
  return result;
}

//----- (000000000043A220) ----------------------------------------------------
__int64 __fastcall wcslen(_DWORD *a1)
{
  __int64 result; // x0

  if ( !*a1 )
    return 0LL;
  result = 0LL;
  while ( 1 )
  {
    if ( !a1[result + 1] )
      return ++result;
    if ( !a1[result + 2] )
    {
      result += 2LL;
      return result;
    }
    if ( !a1[result + 3] )
      break;
    result += 4LL;
    if ( !a1[result] )
      return result;
  }
  result += 3LL;
  return result;
}

//----- (000000000043A2A0) ----------------------------------------------------
unsigned __int64 __fastcall wcsnlen(_DWORD *a1, unsigned __int64 a2)
{
  _DWORD *v4; // x0
  __int64 v5; // x19

  v4 = wmemchr(a1, 0, a2);
  v5 = v4 - a1;
  if ( v4 )
    return v5;
  else
    return a2;
}

//----- (000000000043A2E0) ----------------------------------------------------
_DWORD *__fastcall wmemchr(_DWORD *a1, int a2, unsigned __int64 a3)
{
  _DWORD *result; // x0
  _DWORD *v5; // x3
  int v6; // t1

  if ( a3 > 3 )
  {
    while ( 1 )
    {
      if ( *a1 == a2 )
        return a1;
      if ( a1[1] == a2 )
        return a1 + 1;
      if ( a1[2] == a2 )
        return a1 + 2;
      if ( a1[3] == a2 )
        return a1 + 3;
      a3 -= 4LL;
      a1 += 4;
      if ( a3 <= 3 )
        goto LABEL_10;
    }
  }
  else
  {
LABEL_10:
    result = 0LL;
    if ( a3 )
    {
      result = a1;
      if ( *a1 != a2 )
      {
        result = 0LL;
        if ( a3 != 1 )
        {
          if ( a1[1] == a2 )
          {
            return a1 + 1;
          }
          else if ( a3 != 2 )
          {
            v6 = a1[2];
            v5 = a1 + 2;
            if ( v6 == a2 )
              return v5;
            else
              return 0LL;
          }
        }
      }
    }
  }
  return result;
}

//----- (000000000043A3A0) ----------------------------------------------------
__int64 (__fastcall *wmemcpy())(__int64 result, __int64 *a2, unsigned __int64 a3)
{
  return j_memcpy();
}

//----- (000000000043A3C0) ----------------------------------------------------
long double (__fastcall *wmemmove())(__int64 a1, __int64 a2, unsigned __int64 a3, long double result)
{
  return j_memmove();
}

//----- (000000000043A3E0) ----------------------------------------------------
char *__fastcall wmempcpy(__int64 a1, __int64 a2, __int64 a3)
{
  return (char *)j_memcpy() + 4 * a3;
}

//----- (000000000043A420) ----------------------------------------------------
unsigned __int64 __fastcall closedir(
        int *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  int v9; // w19

  if ( a1 )
  {
    v9 = *a1;
    free((unsigned __int64)a1, a2, a3, a4, a5, a6, a7, a8, a9);
    return _close_nocancel(v9);
  }
  else
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return 0xFFFFFFFFLL;
  }
}

//----- (000000000043A480) ----------------------------------------------------
unsigned __int64 __fastcall getdents64(int a1, void *a2, unsigned __int64 a3, __int64 a4, void *a5, void *a6, void *a7)
{
  unsigned __int64 result; // x0

  if ( a3 > 0x7FFFFFFF )
    a3 = 0x7FFFFFFFLL;
  result = linux_eabi_syscall(__NR_getdents64, (void *)a1, a2, (void *)a3, (void *)0x7FFFFFFF, a5, a6, a7);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
    return -1LL;
  }
  return result;
}

//----- (000000000043A4C0) ----------------------------------------------------
unsigned __int64 __fastcall opendir_tail(int a1)
{
  __int64 v2; // x2
  void *v3; // x3
  void *v4; // x4
  void *v5; // x5
  void *v6; // x6
  __int64 v7; // x7
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  __int64 v16; // x20
  __int64 v17; // x0
  unsigned __int64 result; // x0
  char v19; // [xsp+20h] [xbp+20h] BYREF
  int v20; // [xsp+30h] [xbp+30h]
  unsigned int v21; // [xsp+58h] [xbp+58h]

  if ( a1 < 0 )
    return 0LL;
  if ( (fstat64(a1, (struct stat *)&v19) & 0x80000000) == 0 )
  {
    if ( (v20 & 0xF000) == 0x4000 )
    {
      if ( v21 <= 0xFFFFF )
      {
        if ( v21 <= 0x8000 )
        {
          v17 = 32816LL;
          v16 = 0x8000LL;
        }
        else
        {
          v16 = (int)v21;
          v17 = (int)v21 + 48LL;
        }
      }
      else
      {
        v16 = 0x100000LL;
        v17 = 1048624LL;
      }
      result = malloc(v17, 0xFFFFFLL, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
      if ( result )
      {
        *(_DWORD *)result = a1;
        *(_DWORD *)(result + 4) = 0;
        *(_QWORD *)(result + 8) = v16;
        *(_QWORD *)(result + 16) = 0LL;
        *(_QWORD *)(result + 24) = 0LL;
        *(_QWORD *)(result + 32) = 0LL;
        *(_DWORD *)(result + 40) = 0;
        return result;
      }
    }
    else
    {
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 20;
    }
  }
  _close_nocancel(a1);
  return 0LL;
}
// 43A50C: variable 'v2' is possibly undefined
// 43A50C: variable 'v3' is possibly undefined
// 43A50C: variable 'v4' is possibly undefined
// 43A50C: variable 'v5' is possibly undefined
// 43A50C: variable 'v6' is possibly undefined
// 43A50C: variable 'v7' is possibly undefined
// 43A50C: variable 'v8' is possibly undefined
// 43A50C: variable 'v9' is possibly undefined
// 43A50C: variable 'v10' is possibly undefined
// 43A50C: variable 'v11' is possibly undefined
// 43A50C: variable 'v12' is possibly undefined
// 43A50C: variable 'v13' is possibly undefined
// 43A50C: variable 'v14' is possibly undefined
// 43A50C: variable 'v15' is possibly undefined

//----- (000000000043A584) ----------------------------------------------------
unsigned __int64 __fastcall _opendirat(int a1, const char *a2)
{
  int v2; // w0

  if ( *a2 )
  {
    v2 = _openat_nocancel(a1, a2, 542720);
    return opendir_tail(v2);
  }
  else
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 2;
    return 0LL;
  }
}

//----- (000000000043A5C4) ----------------------------------------------------
unsigned __int64 __fastcall opendir(const char *a1)
{
  int v1; // w0

  if ( *a1 )
  {
    v1 = _open_nocancel(a1, 542720);
    return opendir_tail(v1);
  }
  else
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 2;
    return 0LL;
  }
}

//----- (000000000043A604) ----------------------------------------------------
unsigned __int64 __fastcall _alloc_dir(
        int a1,
        char a2,
        __int64 a3,
        unsigned int *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  int v17; // w21
  __int64 v18; // x1
  __int64 v19; // x19
  __int64 v20; // x0
  unsigned __int64 result; // x0
  int v22; // w0
  char v23; // [xsp+0h] [xbp+0h]
  unsigned int *v24; // [xsp+38h] [xbp+38h]

  v17 = a2 & 1;
  if ( (a2 & 1) == 0 )
  {
    v24 = a4;
    v22 = _fcntl64_nocancel(a1, 2, (void *)1, (__int64)a4, (__int64)a5, (__int64)a6, (__int64)a7, a8, v23);
    a4 = v24;
    if ( v22 < 0 )
      return 0LL;
  }
  v18 = a4[14];
  if ( (unsigned int)v18 <= 0xFFFFF )
  {
    if ( (unsigned int)v18 <= 0x8000 )
    {
      v20 = 32816LL;
      v19 = 0x8000LL;
    }
    else
    {
      v19 = (int)v18;
      v20 = (int)v18 + 48LL;
    }
  }
  else
  {
    v19 = 0x100000LL;
    v20 = 1048624LL;
  }
  result = malloc(v20, v18, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
  if ( result )
  {
    *(_DWORD *)result = a1;
    *(_DWORD *)(result + 4) = 0;
    *(_QWORD *)(result + 8) = v19;
    *(_QWORD *)(result + 16) = 0LL;
    *(_QWORD *)(result + 24) = 0LL;
    *(_QWORD *)(result + 32) = 0LL;
    *(_DWORD *)(result + 40) = 0;
  }
  else
  {
    if ( !v17 )
      return 0LL;
    _close_nocancel(a1);
    return 0LL;
  }
  return result;
}
// 43A63C: variable 'a3' is possibly undefined
// 43A63C: variable 'a5' is possibly undefined
// 43A63C: variable 'a6' is possibly undefined
// 43A63C: variable 'a7' is possibly undefined
// 43A63C: variable 'a8' is possibly undefined
// 43A63C: variable 'a9' is possibly undefined
// 43A63C: variable 'a10' is possibly undefined
// 43A63C: variable 'a11' is possibly undefined
// 43A63C: variable 'a12' is possibly undefined
// 43A63C: variable 'a13' is possibly undefined
// 43A63C: variable 'a14' is possibly undefined
// 43A63C: variable 'a15' is possibly undefined
// 43A63C: variable 'a16' is possibly undefined
// 43A684: variable 'v23' is possibly undefined

//----- (000000000043A6C0) ----------------------------------------------------
__int64 __fastcall readdir64(__int64 a1)
{
  __int64 v2; // x1
  __int64 v3; // x2
  __int64 v4; // x3
  void *v5; // x4
  void *v6; // x5
  void *v7; // x6
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  int v16; // w0
  unsigned __int64 v17; // x0
  __int64 v18; // x20
  __int64 v19; // x1
  __int64 v20; // x2
  __int64 v21; // x3
  void *v22; // x4
  void *v23; // x5
  void *v24; // x6
  int v25; // w0
  _DWORD *StatusReg; // x4
  int v28; // w22
  signed __int64 v29; // x0
  _DWORD *v30; // [xsp+30h] [xbp+30h]

  _aarch64_cas4_acq();
  if ( v16 )
    _lll_lock_wait_private((_DWORD *)(a1 + 4), v8, v9, v10, v11, v12, v13, v14, v15, v2, v3, v4, v5, v6, v7);
  v17 = *(_QWORD *)(a1 + 24);
  if ( v17 < *(_QWORD *)(a1 + 16) )
  {
    v18 = a1 + v17 + 48;
LABEL_5:
    *(_QWORD *)(a1 + 24) = *(unsigned __int16 *)(v18 + 16) + v17;
    *(_QWORD *)(a1 + 32) = *(_QWORD *)(v18 + 8);
    goto LABEL_6;
  }
  StatusReg = (_DWORD *)_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v18 = a1 + 48;
  v28 = StatusReg[10];
  v30 = StatusReg;
  v29 = getdents64(*(_DWORD *)a1, (void *)(a1 + 48), *(_QWORD *)(a1 + 8), 40LL, StatusReg, v6, v7);
  if ( v29 > 0 )
  {
    *(_QWORD *)(a1 + 16) = v29;
    v17 = 0LL;
    goto LABEL_5;
  }
  if ( !v29 || v30[10] == 2 )
    v30[10] = v28;
  v18 = 0LL;
LABEL_6:
  _aarch64_swp4_rel();
  if ( v25 > 1 )
    _lll_lock_wake_private((void *)(a1 + 4), v19, v20, v21, v22, v23, v24);
  return v18;
}
// 43A6E0: variable 'v16' is possibly undefined
// 43A77C: variable 'v8' is possibly undefined
// 43A77C: variable 'v9' is possibly undefined
// 43A77C: variable 'v10' is possibly undefined
// 43A77C: variable 'v11' is possibly undefined
// 43A77C: variable 'v12' is possibly undefined
// 43A77C: variable 'v13' is possibly undefined
// 43A77C: variable 'v14' is possibly undefined
// 43A77C: variable 'v15' is possibly undefined
// 43A77C: variable 'v2' is possibly undefined
// 43A77C: variable 'v3' is possibly undefined
// 43A77C: variable 'v4' is possibly undefined
// 43A77C: variable 'v5' is possibly undefined
// 43A77C: variable 'v6' is possibly undefined
// 43A77C: variable 'v7' is possibly undefined
// 43A71C: variable 'v25' is possibly undefined
// 43A788: variable 'v19' is possibly undefined
// 43A788: variable 'v20' is possibly undefined
// 43A788: variable 'v21' is possibly undefined
// 43A788: variable 'v22' is possibly undefined
// 43A788: variable 'v23' is possibly undefined
// 43A788: variable 'v24' is possibly undefined

//----- (000000000043A7C0) ----------------------------------------------------
unsigned __int64 __fastcall _sched_cpucount(unsigned __int64 result, int8x8_t *a2)
{
  int8x8_t *v2; // x4
  int8x8_t v3; // t1
  int8x8_t v4; // d31

  if ( !(result >> 3) )
    return 0LL;
  v2 = &a2[result >> 3];
  LODWORD(result) = 0;
  do
  {
    v3.n64_u64[0] = a2->n64_u64[0];
    ++a2;
    v4.n64_u64[0] = vcnt_s8(v3).n64_u64[0];
    v4.n64_u8[0] = vaddv_s8(v4);
    if ( v3.n64_u64[0] )
      result = (unsigned int)(result + v4.n64_u32[0]);
    else
      result = (unsigned int)result;
  }
  while ( v2 != a2 );
  return result;
}

//----- (000000000043A840) ----------------------------------------------------
unsigned __int64 __fastcall sched_getparam(__pid_t a1, struct sched_param *a2)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_sched_getparam, a1, a2);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
    return _syscall_error(result);
  return result;
}

//----- (000000000043A880) ----------------------------------------------------
unsigned __int64 __fastcall sched_getscheduler(__pid_t a1)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_sched_getscheduler, a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
    return _syscall_error(result);
  return result;
}

//----- (000000000043A8C0) ----------------------------------------------------
unsigned __int64 __fastcall sched_get_priority_max(int a1)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_sched_get_priority_max, a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
    return _syscall_error(result);
  return result;
}

//----- (000000000043A900) ----------------------------------------------------
unsigned __int64 __fastcall sched_get_priority_min(int a1)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_sched_get_priority_min, a1);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
    return _syscall_error(result);
  return result;
}

//----- (000000000043A940) ----------------------------------------------------
unsigned __int64 __fastcall sched_setscheduler(__pid_t a1, int a2, const struct sched_param *a3)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_sched_setscheduler, a1, a2, a3);
  if ( result >= 0xFFFFFFFFFFFFF001LL )
    return _syscall_error(result);
  return result;
}

//----- (000000000043A960) ----------------------------------------------------
__int64 __fastcall sysconf(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  __int64 v8; // x3
  int v9; // w1
  __int64 result; // x0
  __int64 v11; // x0
  int v12; // w19
  int v13; // w3
  unsigned __int64 v14; // x4
  unsigned __int64 v15; // x0
  bool v16; // zf
  int v17; // w0
  __int64 v18; // x0
  unsigned int v19; // w0
  __int64 v20; // x0
  __int64 v21; // x1
  __int64 v22; // x0
  int v24; // [xsp+20h] [xbp-40h]
  __int64 v25; // [xsp+20h] [xbp-40h]
  _DWORD *v27; // [xsp+28h] [xbp-38h]
  int v28; // [xsp+28h] [xbp-38h]
  int8x16_t *v29; // [xsp+38h] [xbp-28h] BYREF
  struct rlimit64 v30; // [xsp+40h] [xbp-20h] BYREF

  if ( a1 == 187 )
    return 4 << (_ReadStatusReg(ARM64_SYSREG(3, 3, 0, 0, 1)) & 0xF);
  if ( a1 == 190 )
    return 4 << (((unsigned int)_ReadStatusReg(ARM64_SYSREG(3, 3, 0, 0, 1)) >> 16) & 0xF);
  v8 = (unsigned int)a1;
  if ( a1 > 139 )
  {
    switch ( a1 )
    {
      case 249:
        result = dl_minsigstacksize;
        if ( !dl_minsigstacksize )
          _libc_assert_fail(
            (__int64)"GLRO(dl_minsigstacksize) != 0",
            (__int64)"../sysdeps/unix/sysv/linux/sysconf.c",
            0x57u,
            (__int64)"linux_sysconf");
        break;
      case 250:
        if ( !dl_minsigstacksize )
          _libc_assert_fail(
            (__int64)"minsigstacksize != 0",
            (__int64)"../sysdeps/unix/sysv/linux/sysconf-sigstksz.h",
            0x19u,
            (__int64)"sysconf_sigstksz");
        result = 4 * dl_minsigstacksize;
        if ( dl_minsigstacksize <= 5119 )
          return 20480LL;
        break;
      case 149:
        return 200809LL;
      default:
        if ( a1 <= 178 )
          goto LABEL_70;
        v19 = a1 - 179;
        if ( v19 > 0x47 )
          goto LABEL_41;
        switch ( v19 )
        {
          case 0u:
          case 2u:
          case 3u:
          case 4u:
          case 5u:
          case 0x3Au:
          case 0x3Bu:
          case 0x3Du:
          case 0x3Fu:
          case 0x40u:
          case 0x41u:
          case 0x42u:
          case 0x43u:
            return -1LL;
          case 1u:
LABEL_65:
            result = 64LL;
            break;
          case 6u:
          case 7u:
          case 8u:
          case 9u:
          case 0xAu:
          case 0xBu:
          case 0xCu:
          case 0xDu:
          case 0xEu:
          case 0xFu:
          case 0x10u:
          case 0x11u:
          case 0x12u:
          case 0x13u:
          case 0x14u:
LABEL_64:
            result = 0LL;
            break;
          case 0x38u:
          case 0x39u:
            return 200809LL;
          case 0x3Cu:
            return 1LL;
          default:
            goto LABEL_41;
        }
        break;
    }
  }
  else
  {
    if ( a1 > 137 )
      return 200809LL;
    switch ( a1 )
    {
      case 3:
        v12 = _open_nocancel("/proc/sys/kernel/ngroups_max", 0x80000);
        if ( v12 == -1 )
          return 0x10000LL;
        v13 = a1;
        break;
      case 34:
        if ( !(unsigned int)getrlimit64(__RLIMIT_SIGPENDING, &v30) )
          return v30.rlim_cur;
        v17 = _open_nocancel("/proc/sys/kernel/rtsig-max", 0x80000);
        v13 = a1;
        v12 = v17;
        if ( v17 == -1 )
          return -1LL;
        break;
      case 0:
        v9 = getrlimit64(RLIMIT_STACK, &v30);
        result = 0x20000LL;
        if ( !v9 && v30.rlim_cur > 0x7FFFF )
        {
          result = v30.rlim_cur >> 2;
          if ( v30.rlim_cur >> 2 > 0x600000 )
            return 6291456LL;
        }
        return result;
      default:
        if ( a1 <= 90 )
        {
          if ( a1 > 70 )
          {
            v11 = (unsigned int)(a1 - 72);
            switch ( (int)v11 )
            {
              case 0:
                goto LABEL_57;
              case 1:
              case 18:
                result = 4LL;
                break;
              case 2:
                result = 1024LL;
                break;
              case 3:
                result = dl_minsigstacksize;
                if ( !dl_minsigstacksize )
                  _libc_assert_fail(
                    (__int64)"pthread_stack_min != 0",
                    (__int64)"../sysdeps/unix/sysv/linux/sysconf-pthread_stack_min.h",
                    0x1Au,
                    (__int64)"__get_pthread_stack_min");
                if ( dl_minsigstacksize < 0x20000 )
                  result = 0x20000LL;
                break;
              case 4:
                return -1LL;
              case 5:
              case 6:
              case 7:
              case 8:
              case 9:
              case 10:
                return 200809LL;
              case 11:
                result = (int)get_nprocs_conf(v11, a2, a3, v8, a5, a6, a7, a8);
                break;
              case 12:
                result = (int)get_nprocs(v11, a2, a3, v8, a5, a6, a7, a8);
                break;
              case 13:
                result = get_phys_pages();
                break;
              case 14:
                result = get_avphys_pages();
                break;
              case 15:
                goto LABEL_51;
              case 16:
                result = 0x2000LL;
                break;
              case 17:
                result = 700LL;
                break;
              default:
                result = 256LL;
                break;
            }
            return result;
          }
          if ( a1 > 45 )
          {
            v20 = 1LL << ((unsigned __int8)a1 - 46);
            if ( (v20 & 0x1FBF98) != 0 )
              return -1LL;
            if ( (v20 & 0x600067) == 0 )
            {
              v21 = v20 & 0x1FFC000;
              result = 1024LL;
              if ( (v21 & 0xFFFFFFFFFF807FFFLL) != 0 )
                return result;
              goto LABEL_41;
            }
            return 200809LL;
          }
          if ( (a1 & 0x80000000) == 0 )
            goto LABEL_69;
LABEL_41:
          *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
          return -1LL;
        }
        if ( a1 <= 124 )
        {
          if ( a1 > 100 )
          {
            result = 8LL;
            switch ( (int)v8 )
            {
              case 'f':
              case 's':
LABEL_52:
                result = 255LL;
                break;
              case 'g':
                goto LABEL_64;
              case 'h':
              case 'y':
              case 'z':
              case '{':
              case '|':
LABEL_51:
                result = 0x7FFFFFFFLL;
                break;
              case 'i':
                result = 0xFFFFFFFF80000000LL;
                break;
              case 'j':
                goto LABEL_65;
              case 'k':
LABEL_57:
                result = 32LL;
                break;
              case 'l':
LABEL_66:
                result = 16LL;
                break;
              case 'm':
LABEL_54:
                result = 20LL;
                break;
              case 'n':
              case 'q':
LABEL_53:
                result = 0x7FFFLL;
                break;
              case 'o':
                result = 127LL;
                break;
              case 'p':
                result = -128LL;
                break;
              case 'r':
                result = -32768LL;
                break;
              case 't':
                result = 0xFFFFFFFFLL;
                break;
              case 'u':
                return -1LL;
              case 'v':
                result = 0xFFFFLL;
                break;
              case 'w':
                result = 4096LL;
                break;
              case 'x':
LABEL_60:
                result = 2048LL;
                break;
              default:
                return result;
            }
            return result;
          }
          v22 = 1LL << ((unsigned __int8)a1 - 91);
          if ( (v22 & 0x38D) == 0 )
          {
            if ( (v22 & 0x30) != 0 )
              return 200809LL;
            if ( (v22 & 0x42) != 0 )
              return -1LL;
            goto LABEL_41;
          }
          return 1LL;
        }
LABEL_70:
        v18 = 1LL << ((unsigned __int8)a1 - 125);
        if ( (v18 & 0x1FFF7A8FFFEE0BLL) != 0 )
          return -1LL;
        if ( (v18 & 0x8430001180LL) != 0 )
          return 200809LL;
        if ( (v18 & 0x20000140000074LL) == 0 )
          goto LABEL_41;
        return 1LL;
    }
    v14 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40;
    while ( 1 )
    {
      v24 = v13;
      v27 = (_DWORD *)v14;
      v15 = _read_nocancel(v12, &v30, 0x1FuLL);
      v13 = v24;
      if ( v15 != -1LL )
        break;
      v14 = (unsigned __int64)v27;
      if ( *v27 != 4 )
      {
        _close_nocancel(v12);
        LODWORD(v8) = v24;
        goto LABEL_69;
      }
    }
    v25 = v15;
    v28 = v13;
    _close_nocancel(v12);
    LODWORD(v8) = v28;
    if ( v25 <= 0
      || (*((_BYTE *)&v30.rlim_cur + v25) = 0,
          result = _isoc23_strtoll((int8x16_t *)&v30, &v29, 10),
          LODWORD(v8) = v28,
          v29 == (int8x16_t *)&v30)
      || (v29->n128_u8[0] ? (v16 = v29->n128_u8[0] == 10) : (v16 = 1), !v16) )
    {
LABEL_69:
      switch ( (int)v8 )
      {
        case 0:
        case 6:
        case 23:
        case 24:
        case 27:
        case 32:
        case 34:
        case 35:
          return -1LL;
        case 1:
          result = _get_child_max();
          break;
        case 2:
          result = (int)_getclktck();
          break;
        case 3:
          return 0x10000LL;
        case 4:
          result = (int)getdtablesize();
          break;
        case 5:
          goto LABEL_66;
        case 7:
        case 8:
          return 1LL;
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
        case 20:
        case 21:
        case 22:
        case 29:
          return 200809LL;
        case 25:
          goto LABEL_54;
        case 26:
        case 33:
          goto LABEL_51;
        case 28:
          result = 0x8000LL;
          break;
        case 30:
          result = (int)getpagesize();
          break;
        case 31:
        case 42:
          goto LABEL_57;
        case 36:
        case 38:
          result = 99LL;
          break;
        case 37:
        case 43:
        case 45:
          goto LABEL_60;
        case 39:
          result = 1000LL;
          break;
        case 40:
          goto LABEL_52;
        case 44:
          goto LABEL_53;
        default:
          goto LABEL_41;
      }
    }
  }
  return result;
}
// 490F18: using guessed type __int64 dl_minsigstacksize;

//----- (000000000043AF20) ----------------------------------------------------
unsigned __int64 __fastcall getcwd(
        unsigned __int64 a1,
        size_t a2,
        __int64 a3,
        void *a4,
        void *a5,
        void *a6,
        void *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  int v16; // w0
  unsigned __int64 v17; // x28
  char *v18; // x0
  unsigned __int64 v19; // x19
  double v20; // d0
  double v21; // d1
  double v22; // d2
  double v23; // d3
  double v24; // d4
  double v25; // d5
  double v26; // d6
  double v27; // d7
  __int64 v28; // x26
  unsigned int v29; // w3
  bool v30; // zf
  int v31; // w0
  unsigned __int64 StatusReg; // x22
  int *v33; // x23
  int v34; // w24
  int v35; // w0
  double v36; // d0
  double v37; // d1
  double v38; // d2
  double v39; // d3
  double v40; // d4
  double v41; // d5
  double v42; // d6
  double v43; // d7
  __int64 v44; // x19
  int v45; // w20
  _BOOL4 v46; // w27
  __int64 v47; // x0
  void *v49; // x3
  void *v50; // x4
  void *v51; // x5
  void *v52; // x6
  __int64 v53; // x7
  unsigned __int64 (__fastcall *v54)(__int64); // x26
  __int64 v55; // x2
  unsigned __int64 v56; // x20
  unsigned __int64 v57; // x3
  __int64 (__fastcall *v58)(__int64, __int64 *, unsigned __int64); // x0
  double v59; // d0
  double v60; // d1
  double v61; // d2
  double v62; // d3
  double v63; // d4
  double v64; // d5
  double v65; // d6
  double v66; // d7
  int v68; // w0
  int v70; // w19
  bool v71; // zf
  bool v72; // zf
  __int64 v73; // x1
  __int64 v74; // x2
  void *v75; // x3
  void *v76; // x4
  void *v77; // x5
  void *v78; // x6
  __int64 v79; // x7
  double v80; // d0
  double v81; // d1
  double v82; // d2
  double v83; // d3
  double v84; // d4
  double v85; // d5
  double v86; // d6
  double v87; // d7
  unsigned __int64 v88; // x19
  __int64 v89; // x2
  void *v90; // x3
  void *v91; // x4
  void *v92; // x5
  void *v93; // x6
  __int64 v94; // x7
  unsigned __int64 v95; // x0
  double v96; // d0
  double v97; // d1
  double v98; // d2
  double v99; // d3
  double v100; // d4
  double v101; // d5
  double v102; // d6
  double v103; // d7
  __int128 v104; // [xsp+60h] [xbp+60h]
  size_t v105; // [xsp+70h] [xbp+70h]
  __int64 v106; // [xsp+70h] [xbp+70h]
  unsigned __int64 v107; // [xsp+78h] [xbp+78h]
  unsigned __int64 v108; // [xsp+80h] [xbp+80h]
  int v109; // [xsp+94h] [xbp+94h]
  char *v110; // [xsp+98h] [xbp+98h]
  __int64 v111; // [xsp+A0h] [xbp+A0h]
  __int64 v112; // [xsp+A8h] [xbp+A8h]
  __int64 v113; // [xsp+B0h] [xbp+B0h]
  __int64 v114; // [xsp+B8h] [xbp+B8h]
  __int64 v115; // [xsp+C0h] [xbp+C0h] BYREF
  __int64 v116; // [xsp+C8h] [xbp+C8h]
  int v117; // [xsp+D0h] [xbp+D0h]

  *(_QWORD *)&v104 = a1;
  *((_QWORD *)&v104 + 1) = a2;
  if ( a2 )
  {
    v17 = a1;
    if ( a1 )
      goto LABEL_7;
  }
  else
  {
    if ( a1 )
      goto LABEL_67;
    v16 = getpagesize();
    if ( v16 < 4096 )
      v16 = 4096;
    a2 = v16;
  }
  v105 = a2;
  v17 = malloc(a2, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
  a2 = v105;
  if ( !v17 )
    return 0LL;
LABEL_7:
  v18 = linux_eabi_syscall(__NR_getcwd, (char *)v17, a2);
  if ( (unsigned __int64)v18 > 0xFFFFFFFFFFFFF000LL )
  {
    v68 = -(int)v18;
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = v68;
  }
  else
  {
    if ( (int)v18 > 0 )
    {
      if ( *(_BYTE *)v17 == 47 )
      {
        if ( v104 == 0 )
          *(_QWORD *)&v104 = realloc(
                               v17,
                               (int)v18,
                               *((__int64 *)&v104 + 1),
                               a4,
                               a5,
                               a6,
                               a7,
                               a8,
                               a9,
                               a10,
                               a11,
                               a12,
                               a13,
                               a14,
                               a15,
                               a16);
        if ( (_QWORD)v104 )
          return v104;
        return v17;
      }
      goto LABEL_10;
    }
    if ( !(_DWORD)v18 )
      goto LABEL_10;
    v68 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  }
  if ( v68 != 36 )
  {
    if ( v68 == 34 && v104 == 0 )
      _libc_assert_fail(
        (__int64)"errno != ERANGE || buf != NULL || size != 0",
        (__int64)"../sysdeps/unix/sysv/linux/getcwd.c",
        0x7Bu,
        (__int64)"__getcwd");
    if ( (_QWORD)v104 )
      return 0LL;
    goto LABEL_64;
  }
LABEL_10:
  if ( v104 != 0 )
  {
    if ( *((_QWORD *)&v104 + 1) != 1LL )
    {
      if ( *((_QWORD *)&v104 + 1) )
      {
        v107 = v17;
        v108 = *((_QWORD *)&v104 + 1);
        goto LABEL_14;
      }
LABEL_67:
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
      return 0LL;
    }
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 34;
    if ( (_QWORD)v104 )
      return 0LL;
LABEL_64:
    free(v17, a9, a10, a11, a12, a13, a14, a15, a16);
    return 0LL;
  }
  free(v17, a9, a10, a11, a12, a13, a14, a15, a16);
  v17 = malloc(4096LL, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82, v83, v84, v85, v86, v87);
  if ( !v17 )
    return 0LL;
  v107 = 0LL;
  v108 = 4096LL;
LABEL_14:
  v19 = v17 + v108;
  *(_BYTE *)(v17 + v108 - 1) = 0;
  if ( (lstat64(".", (struct stat *)&v115) & 0x80000000) != 0
    || (v28 = v116, v106 = v115, (lstat64("/", (struct stat *)&v115) & 0x80000000) != 0) )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v70 = *(_DWORD *)(StatusReg + 40);
    goto LABEL_81;
  }
  v110 = (char *)(v19 - 1);
  v114 = v116;
  v113 = v115;
  v30 = v28 == v116 && v106 == v115;
  v31 = !v30;
  v109 = v31;
  if ( v30 )
  {
LABEL_116:
    if ( v110 == (char *)(v17 + v108 - 1) )
      *--v110 = 47;
    v88 = v19 - (_QWORD)v110;
    j_memmove();
    if ( *((_QWORD *)&v104 + 1) )
    {
      if ( v107 )
      {
        return v107;
      }
      else if ( !(v17 | (unsigned __int64)v104) )
      {
        goto LABEL_87;
      }
    }
    else if ( v88 < v108 )
    {
      v95 = realloc(v17, v88, v89, v90, v91, v92, v93, v94, v20, v21, v22, v23, v24, v25, v26, v27);
      if ( v95 )
        return v95;
    }
    else if ( !v17 )
    {
      return 0LL;
    }
    return v17;
  }
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v33 = 0LL;
  v34 = -100;
  while ( 2 )
  {
    v35 = openat64(v34, "..", 0, v29);
    v34 = v35;
    if ( v35 < 0 )
    {
      v70 = *(_DWORD *)(StatusReg + 40);
      if ( v33 )
LABEL_80:
        closedir(v33, v20, v21, v22, v23, v24, v25, v26, v27);
      goto LABEL_81;
    }
    if ( (unsigned int)fstat64(v35, (struct stat *)&v115) )
    {
      v70 = *(_DWORD *)(StatusReg + 40);
      if ( v33 )
        closedir(v33, v36, v37, v38, v39, v40, v41, v42, v43);
      goto LABEL_109;
    }
    if ( v33 && (unsigned int)closedir(v33, v36, v37, v38, v39, v40, v41, v42, v43)
      || (v44 = v115, v111 = v115, v112 = v116, (v33 = (int *)fdopendir(v34)) == 0LL) )
    {
      v70 = *(_DWORD *)(StatusReg + 40);
LABEL_109:
      _close_nocancel(v34);
      goto LABEL_81;
    }
    v45 = v109;
    v46 = v44 != v106;
    do
    {
      do
      {
LABEL_30:
        while ( 1 )
        {
          *(_DWORD *)(StatusReg + 40) = 0;
          v47 = readdir64((__int64)v33);
          if ( !v47 )
            break;
          while ( *(_BYTE *)(v47 + 19) == 46 )
          {
            if ( !*(_BYTE *)(v47 + 20) )
              goto LABEL_30;
            if ( *(_BYTE *)(v47 + 20) != 46 || *(_BYTE *)(v47 + 21) )
              break;
            *(_DWORD *)(StatusReg + 40) = 0;
            v47 = readdir64((__int64)v33);
            if ( !v47 )
              goto LABEL_72;
          }
          if ( !v45 )
            goto LABEL_39;
          if ( v46 || *(_QWORD *)v47 == v28 )
          {
            v45 = 1;
            goto LABEL_39;
          }
        }
LABEL_72:
        v70 = *(_DWORD *)(StatusReg + 40);
        if ( v70 )
          v71 = 1;
        else
          v71 = v45 == 0;
        if ( v71 )
          goto LABEL_77;
        rewinddir((__int64)v33);
        v47 = readdir64((__int64)v33);
        if ( !v47 )
        {
          v70 = *(_DWORD *)(StatusReg + 40);
LABEL_77:
          if ( v70 )
            goto LABEL_80;
          v70 = 2;
LABEL_79:
          *(_DWORD *)(StatusReg + 40) = v70;
          goto LABEL_80;
        }
        v45 = 0;
      }
      while ( *(_BYTE *)(v47 + 19) == 46
           && (!*(_BYTE *)(v47 + 20) || *(_BYTE *)(v47 + 20) == 46 && !*(_BYTE *)(v47 + 21)) );
LABEL_39:
      ;
    }
    while ( (unsigned int)fstatat64(v34, (const char *)(v47 + 19), (struct stat *)&v115, 256)
         || (v117 & 0xF000) != 0x4000
         || v115 != v106
         || v116 != v28 );
    v54 = strlen();
    if ( &v110[-v17] > (char *)v54 )
      goto LABEL_51;
    if ( *((_QWORD *)&v104 + 1) )
    {
      v70 = 34;
      goto LABEL_79;
    }
    if ( v108 < (unsigned __int64)v54 )
      v55 = (__int64)v54;
    else
      v55 = v108;
    v56 = v108 + v55;
    if ( __CFADD__(v108, v55)
      || (v57 = realloc(v17, v108 + v55, v55, v49, v50, v51, v52, v53, v20, v21, v22, v23, v24, v25, v26, v27)) == 0 )
    {
      *(_DWORD *)(StatusReg + 40) = 12;
      closedir(v33, v20, v21, v22, v23, v24, v25, v26, v27);
      if ( !v107 )
        free(v17, v96, v97, v98, v99, v100, v101, v102, v103);
      *(_DWORD *)(StatusReg + 40) = 12;
    }
    else
    {
      v108 = v56;
      v17 = v57;
      j_memcpy();
LABEL_51:
      v58 = j_memcpy();
      v29 = (unsigned int)v58;
      v110 = (char *)v58 - 1;
      *((_BYTE *)v58 - 1) = 47;
      if ( v113 != v111 || v114 != v112 )
      {
        v28 = v112;
        v106 = v111;
        continue;
      }
      if ( !(unsigned int)closedir(v33, v59, v60, v61, v62, v63, v64, v65, v66) )
      {
        v19 = v17 + v108;
        goto LABEL_116;
      }
      v70 = *(_DWORD *)(StatusReg + 40);
LABEL_81:
      if ( !v107 )
        free(v17, v20, v21, v22, v23, v24, v25, v26, v27);
      *(_DWORD *)(StatusReg + 40) = v70;
      if ( *((_QWORD *)&v104 + 1) )
        v72 = (_QWORD)v104 != 0LL;
      else
        v72 = 1;
      if ( !v72 )
LABEL_87:
        free(v107, v20, v21, v22, v23, v24, v25, v26, v27);
    }
    return 0LL;
  }
}
// 43AF20: could not find valid save-restore pair for x21
// 43AF20: could not find valid save-restore pair for x22
// 43AF54: variable 'a3' is possibly undefined
// 43AF54: variable 'a4' is possibly undefined
// 43AF54: variable 'a5' is possibly undefined
// 43AF54: variable 'a6' is possibly undefined
// 43AF54: variable 'a7' is possibly undefined
// 43AF54: variable 'a8' is possibly undefined
// 43AF54: variable 'a9' is possibly undefined
// 43AF54: variable 'a10' is possibly undefined
// 43AF54: variable 'a11' is possibly undefined
// 43AF54: variable 'a12' is possibly undefined
// 43AF54: variable 'a13' is possibly undefined
// 43AF54: variable 'a14' is possibly undefined
// 43AF54: variable 'a15' is possibly undefined
// 43AF54: variable 'a16' is possibly undefined
// 43B054: variable 'v29' is possibly undefined
// 43B074: variable 'v36' is possibly undefined
// 43B074: variable 'v37' is possibly undefined
// 43B074: variable 'v38' is possibly undefined
// 43B074: variable 'v39' is possibly undefined
// 43B074: variable 'v40' is possibly undefined
// 43B074: variable 'v41' is possibly undefined
// 43B074: variable 'v42' is possibly undefined
// 43B074: variable 'v43' is possibly undefined
// 43B164: variable 'v49' is possibly undefined
// 43B164: variable 'v50' is possibly undefined
// 43B164: variable 'v51' is possibly undefined
// 43B164: variable 'v52' is possibly undefined
// 43B164: variable 'v53' is possibly undefined
// 43B164: variable 'v20' is possibly undefined
// 43B164: variable 'v21' is possibly undefined
// 43B164: variable 'v22' is possibly undefined
// 43B164: variable 'v23' is possibly undefined
// 43B164: variable 'v24' is possibly undefined
// 43B164: variable 'v25' is possibly undefined
// 43B164: variable 'v26' is possibly undefined
// 43B164: variable 'v27' is possibly undefined
// 43B344: variable 'v73' is possibly undefined
// 43B344: variable 'v74' is possibly undefined
// 43B344: variable 'v75' is possibly undefined
// 43B344: variable 'v76' is possibly undefined
// 43B344: variable 'v77' is possibly undefined
// 43B344: variable 'v78' is possibly undefined
// 43B344: variable 'v79' is possibly undefined
// 43B344: variable 'v80' is possibly undefined
// 43B344: variable 'v81' is possibly undefined
// 43B344: variable 'v82' is possibly undefined
// 43B344: variable 'v83' is possibly undefined
// 43B344: variable 'v84' is possibly undefined
// 43B344: variable 'v85' is possibly undefined
// 43B344: variable 'v86' is possibly undefined
// 43B344: variable 'v87' is possibly undefined
// 43B468: variable 'v59' is possibly undefined
// 43B468: variable 'v60' is possibly undefined
// 43B468: variable 'v61' is possibly undefined
// 43B468: variable 'v62' is possibly undefined
// 43B468: variable 'v63' is possibly undefined
// 43B468: variable 'v64' is possibly undefined
// 43B468: variable 'v65' is possibly undefined
// 43B468: variable 'v66' is possibly undefined
// 43B4F4: variable 'v89' is possibly undefined
// 43B4F4: variable 'v90' is possibly undefined
// 43B4F4: variable 'v91' is possibly undefined
// 43B4F4: variable 'v92' is possibly undefined
// 43B4F4: variable 'v93' is possibly undefined
// 43B4F4: variable 'v94' is possibly undefined
// 43B5B8: variable 'v96' is possibly undefined
// 43B5B8: variable 'v97' is possibly undefined
// 43B5B8: variable 'v98' is possibly undefined
// 43B5B8: variable 'v99' is possibly undefined
// 43B5B8: variable 'v100' is possibly undefined
// 43B5B8: variable 'v101' is possibly undefined
// 43B5B8: variable 'v102' is possibly undefined
// 43B5B8: variable 'v103' is possibly undefined

//----- (000000000043B5C0) ----------------------------------------------------
bool __fastcall isatty(int a1)
{
  char v2; // [xsp+10h] [xbp+10h] BYREF

  return (unsigned int)tcgetattr(a1, (__int64)&v2) == 0;
}

//----- (000000000043B5E0) ----------------------------------------------------
__int64 __fastcall lstat64(const char *a1, struct stat *a2)
{
  return fstatat64(-100, a1, a2, 256);
}

//----- (000000000043B600) ----------------------------------------------------
__int64 __fastcall openat64(int a1, void *a2, int a3, unsigned int a4)
{
  if ( (a3 & 0x40) != 0 || (a3 & ((a3 & 0x40) + 4210688)) == 0x404000 )
    return _syscall_cancel((void *)a1, a2, (void *)a3, (void *)a4, 0LL, 0LL, (void *)0x38);
  else
    return _syscall_cancel((void *)a1, a2, (void *)a3, 0LL, 0LL, 0LL, (void *)0x38);
}

//----- (000000000043B6A0) ----------------------------------------------------
__int64 __fastcall stat64(const char *a1, struct stat *a2)
{
  return fstatat64(-100, a1, a2, 0);
}

//----- (000000000043B6C0) ----------------------------------------------------
unsigned __int64 __fastcall _fcntl64_nocancel(
        int a1,
        int a2,
        void *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  unsigned __int64 result; // x0
  int v10; // [xsp+8h] [xbp-38h] BYREF
  unsigned int v11; // [xsp+Ch] [xbp-34h]
  char *v12; // [xsp+10h] [xbp-30h]
  char *v13; // [xsp+18h] [xbp-28h]
  char *v14; // [xsp+20h] [xbp-20h]
  int v15; // [xsp+28h] [xbp-18h]
  int v16; // [xsp+2Ch] [xbp-14h]
  char v17; // [xsp+30h] [xbp-10h] BYREF
  void *v18; // [xsp+38h] [xbp-8h]

  v12 = &a9;
  v13 = &a9;
  v14 = &v17;
  v15 = -8;
  v16 = 0;
  v18 = a3;
  if ( a2 != 9 )
  {
    result = linux_eabi_syscall(__NR_fcntl, a1, a2, a3);
    if ( result <= 0xFFFFFFFFFFFFF000LL )
      return result;
LABEL_8:
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
    return 0xFFFFFFFFLL;
  }
  LODWORD(result) = linux_eabi_syscall(__NR_fcntl, a1, 16, &v10);
  if ( (unsigned int)result > 0xFFFFF000 )
    goto LABEL_8;
  if ( v10 == 2 )
    return -v11;
  else
    return v11;
}

//----- (000000000043B760) ----------------------------------------------------
unsigned __int64 __fastcall _fcntl64_nocancel_adjusted(int a1, int a2, void *a3)
{
  unsigned __int64 result; // x0
  int v4; // [xsp+8h] [xbp-8h] BYREF
  unsigned int v5; // [xsp+Ch] [xbp-4h]

  if ( a2 != 9 )
  {
    result = linux_eabi_syscall(__NR_fcntl, a1, a2, a3);
    if ( result <= 0xFFFFFFFFFFFFF000LL )
      return result;
LABEL_8:
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
    return 0xFFFFFFFFLL;
  }
  LODWORD(result) = linux_eabi_syscall(__NR_fcntl, a1, 16, &v4);
  if ( (unsigned int)result > 0xFFFFF000 )
    goto LABEL_8;
  if ( v4 == 2 )
    return -v5;
  else
    return v5;
}

//----- (000000000043B800) ----------------------------------------------------
unsigned __int64 __fastcall _openat_nocancel(int a1, const char *a2, int a3)
{
  unsigned __int64 result; // x0

  if ( (a3 & 0x40) == 0 && (a3 & ((a3 & 0x40) + 4210688)) != 0x404000 )
  {
    result = linux_eabi_syscall(__NR_openat, a1, a2, a3);
    if ( result <= 0xFFFFFFFFFFFFF000LL )
      return result;
LABEL_6:
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
    return 0xFFFFFFFFLL;
  }
  result = linux_eabi_syscall(__NR_openat, a1, a2, a3);
  if ( result > 0xFFFFFFFFFFFFF000LL )
    goto LABEL_6;
  return result;
}

//----- (000000000043B8A0) ----------------------------------------------------
unsigned __int64 __fastcall _pread64_nocancel(int a1, void *a2, size_t a3, __off64_t a4)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_pread64, a1, a2, a3, a4);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
    return -1LL;
  }
  return result;
}

//----- (000000000043B8E0) ----------------------------------------------------
unsigned __int64 __fastcall tcgetattr(int a1, __int64 a2)
{
  unsigned __int64 result; // x0
  __int128 v3; // q31
  __int64 v4; // x5
  __int128 v5; // [xsp+0h] [xbp-30h] BYREF
  char v6; // [xsp+10h] [xbp-20h]
  __int64 v7; // [xsp+11h] [xbp-1Fh]
  _BYTE v8[11]; // [xsp+19h] [xbp-17h]

  result = linux_eabi_syscall(__NR_ioctl, a1, 0x5401uLL, &v5);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
    return 0xFFFFFFFFLL;
  }
  else if ( !(_DWORD)result )
  {
    v3 = v5;
    *(_BYTE *)(a2 + 16) = v6;
    *(_OWORD *)a2 = v3;
    *(_DWORD *)(a2 + 52) = WORD4(v3) & 0x100F;
    *(_DWORD *)(a2 + 56) = WORD4(v3) & 0x100F;
    v4 = *(_QWORD *)v8;
    *(_QWORD *)(a2 + 17) = v7;
    *(_QWORD *)(a2 + 25) = v4;
    *(_DWORD *)(a2 + 32) = *(_DWORD *)&v8[7];
    *(_QWORD *)(a2 + 36) = 0LL;
    *(_DWORD *)(a2 + 44) = 0;
    *(_BYTE *)(a2 + 48) = 0;
  }
  return result;
}

//----- (000000000043B980) ----------------------------------------------------
unsigned __int64 __fastcall getrlimit64(enum __rlimit_resource a1, struct rlimit64 *a2)
{
  unsigned __int64 result; // x0

  result = linux_eabi_syscall(__NR_prlimit64, 0, a1, 0LL, a2);
  if ( result > 0xFFFFFFFFFFFFF000LL )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -(int)result;
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (000000000043B9C0) ----------------------------------------------------
__int64 _getclktck()
{
  if ( dl_clktck )
    return (unsigned int)dl_clktck;
  else
    return 100LL;
}
// 496C00: using guessed type int dl_clktck;

//----- (000000000043B9E0) ----------------------------------------------------
__int64 getdtablesize()
{
  struct rlimit64 v1; // [xsp+10h] [xbp+10h] BYREF

  if ( (getrlimit64(RLIMIT_NOFILE, &v1) & 0x80000000) != 0LL )
    return 256LL;
  else
    return LODWORD(v1.rlim_cur);
}

//----- (000000000043BA20) ----------------------------------------------------
__int64 __fastcall trecurse(__int64 a1, void (__fastcall *a2)(__int64, __int64, _QWORD), unsigned int a3)
{
  unsigned __int64 v6; // x0
  __int64 v7; // x0

  if ( *(_QWORD *)(a1 + 8) > 1uLL || *(_QWORD *)(a1 + 16) )
  {
    a2(a1, 0LL, a3);
    v6 = *(_QWORD *)(a1 + 8);
    if ( v6 > 1 )
    {
      trecurse(v6 & 0xFFFFFFFFFFFFFFFELL, a2, a3 + 1);
      a2(a1, 1LL, a3);
      v7 = *(_QWORD *)(a1 + 16);
      if ( !v7 )
        return ((__int64 (__fastcall *)(__int64, __int64, _QWORD))a2)(a1, 2LL, a3);
    }
    else
    {
      a2(a1, 1LL, a3);
      v7 = *(_QWORD *)(a1 + 16);
      if ( !v7 )
        return ((__int64 (__fastcall *)(__int64, __int64, _QWORD))a2)(a1, 2LL, a3);
    }
    trecurse(v7, a2, a3 + 1);
    return ((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))a2)(a1, 2LL, a3);
  }
  return ((__int64 (*)(void))a2)();
}

//----- (000000000043BB00) ----------------------------------------------------
__int64 __fastcall trecurse_r(__int64 a1, void (__fastcall *a2)(__int64, __int64, __int64), __int64 a3)
{
  unsigned __int64 v6; // x0
  __int64 v7; // x0

  if ( *(_QWORD *)(a1 + 8) > 1uLL || *(_QWORD *)(a1 + 16) )
  {
    a2(a1, 0LL, a3);
    v6 = *(_QWORD *)(a1 + 8);
    if ( v6 > 1 )
    {
      trecurse_r(v6 & 0xFFFFFFFFFFFFFFFELL, a2, a3);
      a2(a1, 1LL, a3);
      v7 = *(_QWORD *)(a1 + 16);
      if ( !v7 )
        return ((__int64 (__fastcall *)(__int64, __int64, __int64))a2)(a1, 2LL, a3);
    }
    else
    {
      a2(a1, 1LL, a3);
      v7 = *(_QWORD *)(a1 + 16);
      if ( !v7 )
        return ((__int64 (__fastcall *)(__int64, __int64, __int64))a2)(a1, 2LL, a3);
    }
    trecurse_r(v7, a2, a3);
    return ((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))a2)(a1, 2LL, a3);
  }
  return ((__int64 (*)(void))a2)();
}

//----- (000000000043BBE0) ----------------------------------------------------
void __fastcall tdestroy_recurse(_QWORD *a1, void (__fastcall *a2)(_QWORD))
{
  unsigned __int64 v4; // x0
  __int64 v5; // x0
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7

  v4 = a1[1];
  if ( v4 > 1 )
    tdestroy_recurse(v4 & 0xFFFFFFFFFFFFFFFELL);
  v5 = a1[2];
  if ( v5 )
    tdestroy_recurse(v5);
  a2(*a1);
  free((unsigned __int64)a1, v6, v7, v8, v9, v10, v11, v12, v13);
}
// 43BC44: variable 'v6' is possibly undefined
// 43BC44: variable 'v7' is possibly undefined
// 43BC44: variable 'v8' is possibly undefined
// 43BC44: variable 'v9' is possibly undefined
// 43BC44: variable 'v10' is possibly undefined
// 43BC44: variable 'v11' is possibly undefined
// 43BC44: variable 'v12' is possibly undefined
// 43BC44: variable 'v13' is possibly undefined

//----- (000000000043BC48) ----------------------------------------------------
unsigned __int64 __fastcall maybe_split_for_insert_isra_0(
        __int64 a1,
        _QWORD *a2,
        unsigned __int64 *a3,
        int a4,
        int a5,
        int a6)
{
  unsigned __int64 result; // x0
  unsigned __int64 v7; // x6
  __int64 v8; // x7
  unsigned __int64 v9; // x8
  bool v10; // cc
  unsigned __int64 v11; // x1
  __int64 v12; // x5
  unsigned __int64 v13; // x6
  __int64 v14; // x4
  __int64 v15; // x0

  result = a1 & 0xFFFFFFFFFFFFFFFELL;
  v7 = *(_QWORD *)(result + 8);
  v8 = *(_QWORD *)(result + 16);
  v9 = v7 & 0xFFFFFFFFFFFFFFFELL;
  if ( a6 == 1 )
  {
    *(_QWORD *)(result + 8) = v7 | 1;
    if ( v8 )
      *(_QWORD *)(v8 + 8) &= ~1uLL;
    if ( v7 > 1 )
      *(_QWORD *)(v9 + 8) &= ~1uLL;
  }
  else
  {
    if ( v8 )
      v10 = v7 > 1;
    else
      v10 = 0;
    if ( !v10 || (*(_QWORD *)(v8 + 8) & 1) == 0 || (*(_QWORD *)(v9 + 8) & 1) == 0 )
      return result;
    *(_QWORD *)(result + 8) = v7 | 1;
    *(_QWORD *)(v8 + 8) &= ~1uLL;
    *(_QWORD *)(v9 + 8) &= ~1uLL;
  }
  if ( a2 )
  {
    v11 = *a2 & 0xFFFFFFFFFFFFFFFELL;
    v12 = *(_QWORD *)(v11 + 8);
    if ( (v12 & 1) != 0 )
    {
      v13 = *a3 & 0xFFFFFFFFFFFFFFFELL;
      if ( a4 > 0 == a5 > 0 )
      {
        *a3 = *a3 & 1 | v11;
        *(_QWORD *)(v11 + 8) = v12 & 0xFFFFFFFFFFFFFFFELL;
        *(_QWORD *)(v13 + 8) |= 1uLL;
        if ( a4 < 0 )
        {
          result = *(_QWORD *)(v11 + 16) | 1LL;
          *(_QWORD *)(v13 + 8) = result;
          *(_QWORD *)(v11 + 16) = v13;
        }
        else
        {
          v15 = *(_QWORD *)(v11 + 8);
          *(_QWORD *)(v13 + 16) = v15 & 0xFFFFFFFFFFFFFFFELL;
          result = v15 & 1 | v13;
          *(_QWORD *)(v11 + 8) = result;
        }
      }
      else
      {
        *(_QWORD *)(v11 + 8) = v12 | 1;
        *(_QWORD *)(v13 + 8) |= 1uLL;
        *(_QWORD *)(result + 8) &= ~1uLL;
        v14 = v8 & 1;
        if ( a4 < 0 )
        {
          *(_QWORD *)(v11 + 8) = *(_QWORD *)(v11 + 8) & 1LL | v8;
          *(_QWORD *)(result + 16) = v11 | v14;
          *(_QWORD *)(v13 + 16) = v9;
          *(_QWORD *)(result + 8) = v13;
        }
        else
        {
          *(_QWORD *)(v11 + 16) = v9;
          *(_QWORD *)(result + 8) = v11;
          *(_QWORD *)(v13 + 8) = *(_QWORD *)(v13 + 8) & 1LL | v8;
          *(_QWORD *)(result + 16) = v13 | v14;
        }
        result |= *a3 & 1;
        *a3 = result;
      }
    }
  }
  return result;
}

//----- (000000000043BDE0) ----------------------------------------------------
_QWORD *__fastcall tsearch(
        __int64 a1,
        __int64 *a2,
        __int64 (__fastcall *a3)(__int64, _QWORD),
        void *a4,
        void *a5,
        void *a6,
        __int64 *a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  __int64 *v16; // x21
  unsigned __int64 v18; // x19
  int v20; // w27
  int v21; // w23
  unsigned __int64 *v22; // x25
  __int64 *v23; // x22
  _QWORD *v24; // x19
  int v25; // w20
  unsigned __int64 v26; // x0
  unsigned __int64 v28; // x0
  unsigned __int64 v29; // x19
  __int64 *v30; // [xsp+68h] [xbp+68h]

  if ( !a2 )
    return 0LL;
  v16 = a2;
  v18 = *a2;
  if ( (unsigned __int64)*a2 > 1 )
  {
    a2 = (__int64 *)(v18 & 0xFFFFFFFFFFFFFFFELL);
    *(_QWORD *)((v18 & 0xFFFFFFFFFFFFFFFELL) + 8) &= ~1uLL;
  }
  v20 = 0;
  v21 = 0;
  v22 = 0LL;
  v23 = 0LL;
  while ( v18 > 1 )
  {
    v24 = (_QWORD *)(v18 & 0xFFFFFFFFFFFFFFFELL);
    v25 = a3(a1, *v24);
    if ( !v25 )
      return v24;
    maybe_split_for_insert_isra_0(*v16, v23, v22, v21, v20, 0);
    if ( v25 < 0 )
    {
      a7 = v24 + 1;
      if ( v24[1] <= 1uLL )
      {
LABEL_11:
        v30 = a7;
        v26 = malloc(24LL, (__int64)a2, (__int64)a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
        v24 = (_QWORD *)v26;
        if ( !v26 )
          return 0LL;
        *v30 = v26 | *v30 & 1;
        *(_QWORD *)v26 = a1;
        *(_OWORD *)(v26 + 8) = xmmword_45B7D0;
        if ( v16 != v30 )
        {
          maybe_split_for_insert_isra_0(*v30, v16, (unsigned __int64 *)v23, v25, v21, 1);
          return v24;
        }
        return v24;
      }
    }
    else
    {
      a7 = v24 + 2;
      if ( v24[2] <= 1uLL )
        goto LABEL_11;
    }
    v18 = *a7;
    v20 = v21;
    v22 = (unsigned __int64 *)v23;
    v21 = v25;
    v23 = v16;
    v16 = a7;
  }
  v28 = malloc(24LL, (__int64)a2, (__int64)a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
  v29 = v28;
  if ( !v28 )
    return 0LL;
  *v16 = v28 | *v16 & 1;
  *(_QWORD *)v28 = a1;
  *(_OWORD *)(v28 + 8) = xmmword_45B7D0;
  return (_QWORD *)v29;
}
// 43BEBC: variable 'a2' is possibly undefined
// 43BEBC: variable 'a3' is possibly undefined
// 43BEBC: variable 'a4' is possibly undefined
// 43BEBC: variable 'a5' is possibly undefined
// 43BEBC: variable 'a6' is possibly undefined
// 43BEBC: variable 'a8' is possibly undefined
// 43BEBC: variable 'a9' is possibly undefined
// 43BEBC: variable 'a10' is possibly undefined
// 43BEBC: variable 'a11' is possibly undefined
// 43BEBC: variable 'a12' is possibly undefined
// 43BEBC: variable 'a13' is possibly undefined
// 43BEBC: variable 'a14' is possibly undefined
// 43BEBC: variable 'a15' is possibly undefined
// 43BEBC: variable 'a16' is possibly undefined
// 45B7D0: using guessed type __int128 xmmword_45B7D0;

//----- (000000000043BFC0) ----------------------------------------------------
_QWORD *__fastcall tfind(__int64 a1, unsigned __int64 *a2, __int64 (__fastcall *a3)(__int64, _QWORD))
{
  unsigned __int64 v3; // x19
  unsigned __int64 *v6; // x1
  unsigned __int64 *v7; // x19
  _QWORD *v8; // x19
  int v9; // w0

  if ( !a2 )
    return 0LL;
  v3 = *a2;
  if ( *a2 <= 1 )
    return 0LL;
  while ( 1 )
  {
    v8 = (_QWORD *)(v3 & 0xFFFFFFFFFFFFFFFELL);
    v9 = a3(a1, *v8);
    if ( !v9 )
      break;
    v6 = v8 + 1;
    v7 = v8 + 2;
    if ( v9 < 0 )
      v7 = v6;
    v3 = *v7;
    if ( v3 <= 1 )
      return 0LL;
  }
  return v8;
}

//----- (000000000043C048) ----------------------------------------------------
_QWORD *__fastcall tdelete(__int64 a1, unsigned __int64 *a2, __int64 (__fastcall *a3)(__int64, _QWORD))
{
  unsigned __int64 *v3; // x21
  _QWORD *v4; // x19
  __int64 (__fastcall *v7)(__int64, __int64 *, unsigned __int64); // x26
  __int64 v8; // x20
  int v9; // w23
  int i; // w0
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7
  _QWORD *v19; // x2
  int v20; // w22
  unsigned int v22; // w22
  _QWORD *v23; // x25
  unsigned __int64 v24; // x2
  unsigned __int64 v25; // x3
  bool v26; // cc
  unsigned __int64 *v27; // x24
  __int64 j; // x20
  unsigned __int64 v29; // x0
  _QWORD *v30; // x0
  unsigned __int64 v31; // x0
  unsigned __int64 v32; // x1
  unsigned __int64 v33; // x4
  unsigned int v34; // w4
  unsigned __int64 *v35; // x6
  unsigned __int64 v36; // x3
  unsigned __int64 v37; // x5
  unsigned __int64 v38; // x2
  unsigned __int64 v39; // x1
  __int64 v40; // x7
  unsigned __int64 v41; // x3
  __int64 v42; // x4
  __int64 v43; // x1
  __int64 v44; // x7
  __int64 v45; // x8
  unsigned __int64 v46; // x1
  __int64 v47; // x1
  unsigned __int64 v48; // x7
  __int64 v49; // x1
  unsigned __int64 v50; // x1
  unsigned __int64 v51; // x1
  unsigned __int64 v52; // x2
  __int64 v53; // x2
  unsigned __int64 v54; // x7
  __int64 v55; // x4
  __int64 v56; // x7
  __int64 v57; // x2
  unsigned __int64 v58; // x4
  __int64 v59; // x2
  __int64 v60; // x2
  __int64 v61; // x3
  unsigned __int64 v62; // x2
  __int64 v63; // x2
  __int64 v64; // [xsp+0h] [xbp-140h] BYREF

  if ( !a2 )
    return 0LL;
  v3 = a2;
  if ( *a2 <= 1 )
    return 0LL;
  v4 = (_QWORD *)(*a2 & 0xFFFFFFFFFFFFFFFELL);
  v7 = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))&v64;
  v8 = 0LL;
  v9 = 40;
  for ( i = a3(a1, *v4); ; i = a3(a1, *v19) )
  {
    v20 = i;
    if ( !i )
      break;
    if ( v9 == (_DWORD)v8 )
    {
      v9 += 20;
      v7 = j_memcpy();
    }
    *((_QWORD *)v7 + (unsigned int)v8) = v3;
    v4 = (_QWORD *)(*v3 & 0xFFFFFFFFFFFFFFFELL);
    if ( v20 < 0 )
    {
      v3 = v4 + 1;
      ++v8;
      v19 = (_QWORD *)(v4[1] & 0xFFFFFFFFFFFFFFFELL);
      if ( !v19 )
        return 0LL;
    }
    else
    {
      v19 = (_QWORD *)v4[2];
      v3 = v4 + 2;
      ++v8;
      if ( !v19 )
        return 0LL;
    }
  }
  v22 = v8;
  v23 = (_QWORD *)(*v3 & 0xFFFFFFFFFFFFFFFELL);
  v24 = v23[1];
  v25 = v23[2];
  if ( v25 )
    v26 = v24 > 1;
  else
    v26 = 0;
  if ( v26 )
  {
    v27 = v23 + 2;
    for ( j = 8LL * (unsigned int)v8; ; j += 8LL )
    {
      if ( v9 == v22 )
      {
        v9 += 20;
        ++v22;
        v7 = j_memcpy();
        v31 = *v27;
        *(_QWORD *)((char *)v7 + j) = v3;
        v30 = (_QWORD *)(v31 & 0xFFFFFFFFFFFFFFFELL);
        v24 = v30[1];
        if ( v24 <= 1 )
        {
LABEL_22:
          v25 = v30[2];
          v32 = v25;
          goto LABEL_23;
        }
      }
      else
      {
        v29 = *v27;
        *(_QWORD *)((char *)v7 + j) = v3;
        ++v22;
        v30 = (_QWORD *)(v29 & 0xFFFFFFFFFFFFFFFELL);
        v24 = v30[1];
        if ( v24 <= 1 )
          goto LABEL_22;
      }
      v3 = v27;
      v27 = v30 + 1;
    }
  }
  if ( v24 <= 1 )
  {
    v32 = v23[2];
  }
  else
  {
    v25 = v24 & 0xFFFFFFFFFFFFFFFELL;
    v32 = v24 & 0xFFFFFFFFFFFFFFFELL;
  }
  if ( !(_DWORD)v8 )
  {
    *v3 = *v3 & 1 | v25;
    v30 = v23;
    if ( (v24 & 1) != 0 )
      goto LABEL_39;
    goto LABEL_45;
  }
  v30 = (_QWORD *)(*v3 & 0xFFFFFFFFFFFFFFFELL);
LABEL_23:
  v33 = **((_QWORD **)v7 + v22 - 1) & 0xFFFFFFFFFFFFFFFELL;
  if ( v30 == *(_QWORD **)(v33 + 16) )
  {
    *(_QWORD *)(v33 + 16) = v25;
    if ( v23 == v30 )
    {
      if ( (v24 & 1) == 0 )
        goto LABEL_27;
      goto LABEL_39;
    }
  }
  else
  {
    *(_QWORD *)(v33 + 8) = *(_QWORD *)(v33 + 8) & 1LL | v25;
    v24 = v30[1];
    if ( v23 == v30 )
      goto LABEL_26;
  }
  *v23 = *v30;
LABEL_26:
  if ( (v24 & 1) != 0 )
    goto LABEL_39;
  while ( 1 )
  {
LABEL_27:
    if ( v32 && (*(_QWORD *)(v32 + 8) & 1) != 0 )
      goto LABEL_46;
    v34 = v22;
    v35 = (unsigned __int64 *)*((_QWORD *)v7 + v22 - 1);
    v36 = *v35;
    v37 = *v35 & 0xFFFFFFFFFFFFFFFELL;
    v38 = *(_QWORD *)(v37 + 8) & 0xFFFFFFFFFFFFFFFELL;
    if ( v38 == v32 )
      break;
    v39 = *(_QWORD *)(v38 + 8);
    if ( (v39 & 1) != 0 )
    {
      v40 = *(_QWORD *)(v38 + 16);
      *(_QWORD *)(v38 + 8) = v39 & 0xFFFFFFFFFFFFFFFELL;
      *(_QWORD *)(v37 + 8) = v40 | 1;
      *(_QWORD *)(v38 + 16) = v37;
      *v35 = v36 & 1 | v38;
      v35 = (unsigned __int64 *)(v38 + 16);
      v38 = v40 & 0xFFFFFFFFFFFFFFFELL;
      ++v22;
      *((_QWORD *)v7 + v34) = v35;
      v39 = *(_QWORD *)((v40 & 0xFFFFFFFFFFFFFFFELL) + 8);
    }
    v41 = *(_QWORD *)(v38 + 16);
    if ( v41 && (*(_QWORD *)(v41 + 8) & 1) != 0 )
    {
      v42 = *(_QWORD *)(v37 + 8) & 1LL;
      if ( v39 <= 1 )
        goto LABEL_35;
      v48 = v39 & 0xFFFFFFFFFFFFFFFELL;
LABEL_50:
      if ( (*(_QWORD *)(v48 + 8) & 1) != 0 )
      {
        v49 = v39 | 1;
        if ( !v42 )
          v49 = v48;
        *(_QWORD *)(v38 + 8) = v49;
        *(_QWORD *)(v37 + 8) &= ~1uLL;
        *(_QWORD *)((*(_QWORD *)(v38 + 8) & 0xFFFFFFFFFFFFFFFELL) + 8) &= ~1uLL;
        *(_QWORD *)(v37 + 8) = *(_QWORD *)(v37 + 8) & 1LL | v41;
        v50 = *v35;
        *(_QWORD *)(v38 + 16) = v37;
        *v35 = v38 | v50 & 1;
        free((unsigned __int64)v30, v11, v12, v13, v14, v15, v16, v17, v18);
        return v4;
      }
LABEL_35:
      v43 = *(_QWORD *)(v41 + 8);
      v44 = *(_QWORD *)(v41 + 16);
      v45 = v43 | 1;
      v46 = v43 & 0xFFFFFFFFFFFFFFFELL;
      if ( v42 )
        v46 = v45;
      *(_QWORD *)(v41 + 8) = v46;
      *(_QWORD *)(v37 + 8) = *(_QWORD *)(v37 + 8) & 1LL | v44;
      v47 = *(_QWORD *)(v41 + 8);
      *(_QWORD *)(v38 + 16) = v47 & 0xFFFFFFFFFFFFFFFELL;
      *(_QWORD *)(v41 + 8) = v38 | v47 & 1;
      *(_QWORD *)(v41 + 16) = v37;
      goto LABEL_38;
    }
    if ( v39 > 1 )
    {
      v48 = v39 & 0xFFFFFFFFFFFFFFFELL;
      if ( (*(_QWORD *)((v39 & 0xFFFFFFFFFFFFFFFELL) + 8) & 1) != 0 )
      {
        v42 = *(_QWORD *)(v37 + 8) & 1LL;
        goto LABEL_50;
      }
    }
    *(_QWORD *)(v38 + 8) = v39 | 1;
LABEL_55:
    if ( !--v22 )
    {
      v23 = v30;
      v32 = v37;
LABEL_45:
      v30 = v23;
      if ( v32 )
      {
LABEL_46:
        *(_QWORD *)(v32 + 8) &= ~1uLL;
        free((unsigned __int64)v30, v11, v12, v13, v14, v15, v16, v17, v18);
        return v4;
      }
LABEL_39:
      free((unsigned __int64)v30, v11, v12, v13, v14, v15, v16, v17, v18);
      return v4;
    }
    v32 = v37;
  }
  v51 = *(_QWORD *)(v37 + 16);
  v52 = *(_QWORD *)(v51 + 8);
  if ( (v52 & 1) != 0 )
  {
    *(_QWORD *)(v51 + 8) = v52 & 0xFFFFFFFFFFFFFFFELL;
    ++v22;
    *(_QWORD *)(v37 + 8) |= 1uLL;
    v53 = *(_QWORD *)(v51 + 8);
    v54 = v53 & 0xFFFFFFFFFFFFFFFELL;
    *(_QWORD *)(v37 + 16) = v53 & 0xFFFFFFFFFFFFFFFELL;
    *(_QWORD *)(v51 + 8) = v53 & 1 | v37;
    *v35 = v36 & 1 | v51;
    v35 = (unsigned __int64 *)(v51 + 8);
    v52 = *(_QWORD *)((v53 & 0xFFFFFFFFFFFFFFFELL) + 8);
    v51 = v54;
    *((_QWORD *)v7 + v34) = v35;
  }
  if ( v52 <= 1 || (v41 = v52 & 0xFFFFFFFFFFFFFFFELL, (*(_QWORD *)((v52 & 0xFFFFFFFFFFFFFFFELL) + 8) & 1) == 0) )
  {
    v55 = *(_QWORD *)(v51 + 16);
    if ( v55 && (*(_QWORD *)(v55 + 8) & 1) != 0 )
    {
      v56 = *(_QWORD *)(v37 + 8) & 1LL;
      goto LABEL_68;
    }
    *(_QWORD *)(v51 + 8) = v52 | 1;
    goto LABEL_55;
  }
  v55 = *(_QWORD *)(v51 + 16);
  v56 = *(_QWORD *)(v37 + 8) & 1LL;
  if ( !v55 )
    goto LABEL_62;
LABEL_68:
  if ( (*(_QWORD *)(v55 + 8) & 1) == 0 )
  {
    v41 = v52 & 0xFFFFFFFFFFFFFFFELL;
LABEL_62:
    v57 = *(_QWORD *)(v41 + 8);
    v58 = v57 & 0xFFFFFFFFFFFFFFFELL;
    v59 = v57 | 1;
    if ( !v56 )
      v59 = v58;
    *(_QWORD *)(v41 + 8) = v59;
    v60 = *(_QWORD *)(v51 + 8);
    *(_QWORD *)(v37 + 16) = v58;
    *(_QWORD *)(v51 + 8) = v60 & 1 | *(_QWORD *)(v41 + 16);
    *(_QWORD *)(v41 + 8) = *(_QWORD *)(v41 + 8) & 1LL | v37;
    *(_QWORD *)(v41 + 16) = v51;
LABEL_38:
    *v35 = *v35 & 1 | v41;
    *(_QWORD *)(v37 + 8) &= ~1uLL;
    goto LABEL_39;
  }
  v61 = v52 | 1;
  v62 = v52 & 0xFFFFFFFFFFFFFFFELL;
  if ( v56 )
    v62 = v61;
  *(_QWORD *)(v51 + 8) = v62;
  *(_QWORD *)(v37 + 8) &= ~1uLL;
  *(_QWORD *)(v55 + 8) &= ~1uLL;
  v63 = *(_QWORD *)(v51 + 8);
  *(_QWORD *)(v37 + 16) = v63 & 0xFFFFFFFFFFFFFFFELL;
  *(_QWORD *)(v51 + 8) = v63 & 1 | v37;
  *v35 = v51 | *v35 & 1;
  free((unsigned __int64)v30, v11, v12, v13, v14, v15, v16, v17, v18);
  return v4;
}
// 43C310: variable 'v11' is possibly undefined
// 43C310: variable 'v12' is possibly undefined
// 43C310: variable 'v13' is possibly undefined
// 43C310: variable 'v14' is possibly undefined
// 43C310: variable 'v15' is possibly undefined
// 43C310: variable 'v16' is possibly undefined
// 43C310: variable 'v17' is possibly undefined
// 43C310: variable 'v18' is possibly undefined

//----- (000000000043C5A0) ----------------------------------------------------
__int64 __fastcall twalk(__int64 result, void (__fastcall *a2)(__int64, __int64, _QWORD))
{
  bool v2; // zf

  if ( result )
    v2 = a2 == 0LL;
  else
    v2 = 1;
  if ( !v2 )
    return trecurse(result, a2, 0);
  return result;
}

//----- (000000000043C5C0) ----------------------------------------------------
__int64 __fastcall twalk_r(__int64 a1, void (__fastcall *a2)(__int64, __int64, __int64), __int64 a3)
{
  bool v3; // zf

  if ( a1 )
    v3 = a2 == 0LL;
  else
    v3 = 1;
  if ( !v3 )
    return trecurse_r(a1, a2, a3);
  return a1;
}

//----- (000000000043C5E0) ----------------------------------------------------
void __fastcall tdestroy(_QWORD *a1, void (__fastcall *a2)(_QWORD))
{
  if ( a1 )
    tdestroy_recurse(a1, a2);
}

//----- (000000000043C600) ----------------------------------------------------
void __fastcall _init_misc(
        __int64 a1,
        __int64 *a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        unsigned __int64 a7)
{
  unsigned __int64 v7; // x0
  __int64 *v8; // x3
  __int64 v9; // [xsp+10h] [xbp+10h]

  if ( a2 && *a2 )
  {
    v9 = *a2;
    v7 = strrchr(*a2, 0x2Fu, (__int64)a2, *a2, a5, a6, a7);
    v8 = (__int64 *)v9;
    if ( v7 )
      v8 = (__int64 *)(v7 + 1);
    program_invocation_short_name[0] = v8;
    program_invocation_name = (__int64 *)*a2;
  }
}
// 491928: using guessed type __int64 *program_invocation_short_name[2];
// 491930: using guessed type __int64 *program_invocation_name;

//----- (000000000043C660) ----------------------------------------------------
void __fastcall __noreturn fatal_error(unsigned int a1, const char *a2, const char *a3, const char *a4)
{
  const char *v4; // x6
  const char *v5; // x7
  const char *v7; // x19
  const char *v8; // x20
  int v9; // w1
  const char *v10; // x4
  unsigned __int64 *v11; // x0
  const char *v12; // [xsp+30h] [xbp+30h]
  const char *v13; // [xsp+38h] [xbp+38h]
  char v14; // [xsp+40h] [xbp+40h] BYREF

  v4 = (const char *)&qword_454610;
  v5 = (const char *)&qword_454610;
  v7 = "error while loading shared libraries";
  v8 = (const char *)program_invocation_short_name[0];
  if ( !program_invocation_short_name[0] )
    v8 = "<program name unknown>";
  v9 = *(unsigned __int8 *)a2;
  if ( a3 )
    v7 = a3;
  if ( v9 )
    v10 = ": ";
  else
    v10 = (const char *)&qword_454610;
  if ( a1 )
  {
    v12 = v10;
    v13 = a4;
    v11 = strerror_r(a1, &v14, 1024LL);
    v4 = ": ";
    v10 = v12;
    a4 = v13;
    v5 = (const char *)v11;
  }
  dl_fatal_printf("%s: %s: %s%s%s%s%s\n", v8, v7, a2, v10, a4, v4, v5);
}
// 454610: using guessed type __int64 qword_454610;
// 491928: using guessed type __int64 *program_invocation_short_name[2];

//----- (000000000043C708) ----------------------------------------------------
void __fastcall __noreturn dl_signal_exception(unsigned int a1, const char **a2, const char *a3)
{
  __int64 v3; // x3
  const char **v5; // x0
  const char *v6; // x6
  const char *v7; // x7
  const char *v8; // x1

  v3 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 40);
  if ( v3 )
  {
    v5 = *(const char ***)v3;
    v6 = *a2;
    v7 = a2[1];
    v8 = a2[2];
    *v5 = v6;
    v5[1] = v7;
    v5[2] = v8;
    **(_DWORD **)(v3 + 8) = a1;
    _longjmp((struct __jmp_buf_tag *)(v3 + 16), 1);
  }
  fatal_error(a1, *a2, a3, a2[1]);
}

//----- (000000000043C750) ----------------------------------------------------
void __fastcall __noreturn dl_signal_error(unsigned int a1, __int64 a2, const char *a3, const char *a4)
{
  unsigned __int64 StatusReg; // x0
  __int64 v6; // x20
  const char *v7; // x5

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  if ( !a4 )
    a4 = "DYNAMIC LINKER BUG!!!";
  v6 = *(_QWORD *)(StatusReg - 40);
  if ( v6 )
  {
    dl_exception_create(*(__int64 (__fastcall ***)(__int64, __int64 *, unsigned __int64))v6, a2);
    **(_DWORD **)(v6 + 8) = a1;
    _longjmp((struct __jmp_buf_tag *)(v6 + 16), 1);
  }
  v7 = (const char *)a2;
  if ( !a2 )
    v7 = (const char *)&qword_454610;
  fatal_error(a1, v7, a3, a4);
}
// 454610: using guessed type __int64 qword_454610;

//----- (000000000043C7C0) ----------------------------------------------------
__int64 __fastcall dl_catch_exception(
        _QWORD *a1,
        void (__fastcall *a2)(__int64),
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  unsigned __int64 v8; // x1
  __int64 v9; // x2
  __int64 v11; // [xsp+0h] [xbp+0h]
  __int64 v13; // [xsp+18h] [xbp+18h]
  unsigned __int64 StatusReg; // [xsp+30h] [xbp+30h]
  unsigned int v17; // [xsp+4Ch] [xbp+4Ch] BYREF
  _QWORD v18[2]; // [xsp+50h] [xbp+50h] BYREF
  char v19; // [xsp+60h] [xbp+60h] BYREF

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v8 = StatusReg - 1824;
  v9 = *(_QWORD *)(StatusReg - 1824 + 0x6F8);
  v13 = v9;
  if ( a1 )
  {
    v18[0] = a1;
    v18[1] = &v17;
    *(_QWORD *)(v8 + 0x6F8) = v18;
    if ( (unsigned int)_sigsetjmp((__int64)&v19, 0, v9, a4, a5, a6, a7, a8, v11) )
    {
      *(_QWORD *)(StatusReg - 40) = v13;
      return v17;
    }
    a2(a3);
    *(_QWORD *)(StatusReg - 40) = v13;
    *a1 = 0LL;
    a1[1] = 0LL;
    a1[2] = 0LL;
  }
  else
  {
    *(_QWORD *)(v8 + 0x6F8) = 0LL;
    a2(a3);
    *(_QWORD *)(StatusReg - 40) = v13;
  }
  return 0LL;
}
// 43C804: variable 'v11' is possibly undefined

//----- (000000000043C868) ----------------------------------------------------
__int64 __fastcall dl_catch_error(
        _QWORD *a1,
        _QWORD *a2,
        bool *a3,
        void (__fastcall *a4)(__int64),
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  __int64 result; // x0
  __int64 v12; // x1
  __int64 v13; // x2
  __int64 v14; // [xsp+38h] [xbp+38h] BYREF
  __int64 v15; // [xsp+40h] [xbp+40h]
  __int64 v16; // [xsp+48h] [xbp+48h]

  result = dl_catch_exception(&v14, a4, a5, (__int64)a4, a5, a6, a7, a8);
  *a1 = v14;
  v12 = v15;
  v13 = v16;
  *a2 = v15;
  *a3 = v13 == v12;
  return result;
}

//----- (000000000043C8C0) ----------------------------------------------------
void __noreturn length_mismatch()
{
  dl_fatal_printf("Fatal error: length accounting in _dl_exception_create_format\n");
}

//----- (000000000043C8E0) ----------------------------------------------------
void __fastcall dl_error_free(
        unsigned __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  if ( (char *)a1 != "out of memory" )
    free(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

//----- (000000000043C900) ----------------------------------------------------
__int64 (__fastcall *__fastcall dl_exception_create(
        __int64 (__fastcall **a1)(__int64 result, __int64 *a2, unsigned __int64 a3),
        __int64 a2))(__int64 result, __int64 *a2, unsigned __int64 a3)
{
  __int64 v3; // x23
  unsigned __int64 (__fastcall *v4)(__int64); // x0
  __int64 v5; // x1
  __int64 v6; // x2
  void *v7; // x3
  void *v8; // x4
  void *v9; // x5
  void *v10; // x6
  __int64 v11; // x7
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  unsigned __int64 v20; // x20
  __int64 (__fastcall *result)(__int64, __int64 *, unsigned __int64); // x0
  const char *v22; // x1

  if ( a2 )
    v3 = (__int64)strlen() + 1;
  else
    v3 = 1LL;
  v4 = strlen();
  v20 = malloc((__int64)v4 + v3 + 1, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19);
  if ( v20 )
  {
    j_memcpy();
    result = j_memcpy();
    v22 = (const char *)v20;
  }
  else
  {
    result = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))&qword_454610;
    v22 = "out of memory";
  }
  *a1 = result;
  a1[1] = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))v22;
  a1[2] = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))v20;
  return result;
}
// 43C940: variable 'v5' is possibly undefined
// 43C940: variable 'v6' is possibly undefined
// 43C940: variable 'v7' is possibly undefined
// 43C940: variable 'v8' is possibly undefined
// 43C940: variable 'v9' is possibly undefined
// 43C940: variable 'v10' is possibly undefined
// 43C940: variable 'v11' is possibly undefined
// 43C940: variable 'v12' is possibly undefined
// 43C940: variable 'v13' is possibly undefined
// 43C940: variable 'v14' is possibly undefined
// 43C940: variable 'v15' is possibly undefined
// 43C940: variable 'v16' is possibly undefined
// 43C940: variable 'v17' is possibly undefined
// 43C940: variable 'v18' is possibly undefined
// 43C940: variable 'v19' is possibly undefined
// 454610: using guessed type __int64 qword_454610;

//----- (000000000043C9AC) ----------------------------------------------------
__int64 (__fastcall *dl_exception_create_format(
        __int64 (__fastcall **a1)(__int64 result, __int64 *a2, unsigned __int64 a3),
        __int64 a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        ...))(__int64 result, __int64 *a2, unsigned __int64 a3)
{
  void *v11; // x3
  void *v12; // x4
  void *v13; // x5
  void *v14; // x6
  __int64 v15; // x7
  unsigned __int8 *v16; // x21
  unsigned __int64 (__fastcall *v18)(__int64); // x0
  __int64 v19; // x25
  __int64 v20; // x22
  int v21; // w0
  __int64 v22; // x19
  unsigned int v23; // w0
  int v24; // w1
  unsigned __int64 v25; // x0
  _BYTE *v26; // x19
  _BYTE *v27; // x22
  int v28; // w3
  unsigned __int8 *v29; // x20
  unsigned int v30; // w0
  __int64 (__fastcall *result)(__int64, __int64 *, unsigned __int64); // x0
  int v32; // w1
  char *v33; // x0
  int gr_offs; // w1
  unsigned __int64 (__fastcall *v35)(__int64); // x21
  int v36; // w1
  unsigned __int64 *stack; // x0
  gcc_va_list va; // [xsp+50h] [xbp+50h] BYREF
  void *vars0; // [xsp+78h] [xbp+78h]
  void *vars8; // [xsp+80h] [xbp+80h]
  void *vars10; // [xsp+88h] [xbp+88h]
  void *vars18; // [xsp+90h] [xbp+90h]
  __int64 vars20; // [xsp+98h] [xbp+98h]
  char v44; // [xsp+A0h] [xbp+A0h] BYREF

  va_start(va, a11);
  vars0 = va_arg(va, void *);
  v11 = vars0;
  vars8 = va_arg(va, void *);
  v12 = vars8;
  vars10 = va_arg(va, void *);
  v13 = vars10;
  vars18 = va_arg(va, void *);
  v14 = vars18;
  vars20 = va_arg(va, _QWORD);
  v15 = vars20;
  va_end(va);
  v16 = (unsigned __int8 *)a3;
  if ( a2 )
  {
    v18 = strlen();
    v19 = (__int64)v18 + 1;
    v20 = (__int64)v18 + 2;
  }
  else
  {
    v20 = 2LL;
    v19 = 1LL;
  }
  va_start(va, a11);
  va[0].__gr_offs = -40;
  v21 = *v16;
  if ( !*v16 )
  {
LABEL_16:
    v25 = malloc(v20, a2, a3, v11, v12, v13, v14, v15, a4, a5, a6, a7, a8, a9, a10, a11);
    v26 = (_BYTE *)v25;
    if ( !v25 )
      goto LABEL_60;
    a1[1] = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))v25;
    a1[2] = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))v25;
    v27 = (_BYTE *)(v25 + v20);
    v28 = *v16;
    va_end(va);
    va_start(va, a11);
    va[0].__gr_offs = -40;
    if ( !*v16 )
    {
LABEL_28:
      if ( v27 == v26 || (*v26 = 0, v27 - (v26 + 1) != v19) )
LABEL_65:
        length_mismatch();
      result = j_memcpy();
      *a1 = result;
      return result;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v28 != 37 )
        {
          if ( v27 == v26 )
            goto LABEL_65;
          v29 = v16;
          *v26++ = v28;
          goto LABEL_21;
        }
        v30 = v16[1];
        v29 = v16 + 1;
        if ( v30 != 115 )
          break;
        gr_offs = va[0].__gr_offs;
        if ( (va[0].__gr_offs & 0x80000000) == 0 || (va[0].__gr_offs += 8, gr_offs + 8 > 0) )
          va[0].__stack = (void *)(((unsigned __int64)va[0].__stack + 15) & 0xFFFFFFFFFFFFFFF8LL);
        v35 = strlen();
        if ( v27 - v26 < (unsigned __int64)v35 )
          goto LABEL_65;
        v26 = (char *)v35 + (_QWORD)j_memcpy();
LABEL_21:
        v28 = v29[1];
        v16 = v29 + 1;
        if ( !v29[1] )
          goto LABEL_28;
      }
      if ( v30 > 0x73 )
        break;
      if ( v30 != 37 )
      {
        if ( v30 != 108 )
LABEL_52:
          dl_fatal_printf("Fatal error: invalid format in exception string\n");
LABEL_45:
        if ( v16[2] != 120 )
          goto LABEL_52;
        v36 = va[0].__gr_offs;
        stack = (unsigned __int64 *)va[0].__stack;
        if ( va[0].__gr_offs < 0 && (va[0].__gr_offs += 8, v36 + 8 <= 0) )
          stack = (unsigned __int64 *)(&v44 + v36);
        else
          va[0].__stack = (void *)(((unsigned __int64)va[0].__stack + 15) & 0xFFFFFFFFFFFFFFF8LL);
        if ( (_BYTE *)itoa_word(*stack, (__int64)(v26 + 16), 0x10u, 0) != v26 )
          memset();
        v29 = v16 + 2;
        v26 += 16;
        goto LABEL_21;
      }
      if ( v27 == v26 )
        goto LABEL_65;
      *v26++ = 37;
      v16 += 2;
      v28 = v29[1];
      if ( !v29[1] )
        goto LABEL_28;
    }
    if ( v30 == 120 )
    {
      v32 = va[0].__gr_offs;
      v33 = (char *)va[0].__stack;
      if ( va[0].__gr_offs < 0 && (va[0].__gr_offs += 8, v32 + 8 <= 0) )
        v33 = &v44 + v32;
      else
        va[0].__stack = (void *)(((unsigned __int64)va[0].__stack + 11) & 0xFFFFFFFFFFFFFFF8LL);
      if ( (_BYTE *)itoa_word(*(unsigned int *)v33, (__int64)(v26 + 8), 0x10u, 0) != v26 )
        memset();
      v26 += 8;
      goto LABEL_21;
    }
    if ( v30 != 122 )
      goto LABEL_52;
    goto LABEL_45;
  }
  a2 = (__int64)v16;
  do
  {
    while ( 1 )
    {
      v22 = a2 + 1;
      if ( v21 == 37 )
        break;
      ++v20;
      v22 = a2;
LABEL_6:
      v21 = *(unsigned __int8 *)(v22 + 1);
      a2 = v22 + 1;
      if ( !*(_BYTE *)(v22 + 1) )
        goto LABEL_15;
    }
    v23 = *(unsigned __int8 *)(a2 + 1);
    if ( v23 == 120 )
      goto LABEL_33;
    if ( v23 > 0x78 )
    {
      if ( v23 != 122 )
      {
LABEL_59:
        ++v20;
        goto LABEL_6;
      }
LABEL_32:
      if ( *(_BYTE *)(a2 + 2) == 120 )
      {
        v20 += 16LL;
        v22 = a2 + 2;
        goto LABEL_6;
      }
LABEL_33:
      v20 += 8LL;
      goto LABEL_6;
    }
    if ( v23 == 108 )
      goto LABEL_32;
    if ( v23 != 115 )
      goto LABEL_59;
    v24 = va[0].__gr_offs;
    if ( (va[0].__gr_offs & 0x80000000) == 0 || (va[0].__gr_offs += 8, v24 + 8 > 0) )
      va[0].__stack = (void *)(((unsigned __int64)va[0].__stack + 15) & 0xFFFFFFFFFFFFFFF8LL);
    v20 += (__int64)strlen();
    v21 = *(unsigned __int8 *)(v22 + 1);
    a2 = v22 + 1;
  }
  while ( *(_BYTE *)(v22 + 1) );
LABEL_15:
  if ( (v20 & 0x8000000000000000LL) == 0 )
    goto LABEL_16;
LABEL_60:
  result = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))&qword_454610;
  *a1 = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))&qword_454610;
  a1[1] = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))"out of memory";
  a1[2] = 0LL;
  return result;
}
// 43CA90: variable 'a2' is possibly undefined
// 43CA90: variable 'a3' is possibly undefined
// 43CA90: variable 'v11' is possibly undefined
// 43CA90: variable 'v12' is possibly undefined
// 43CA90: variable 'v13' is possibly undefined
// 43CA90: variable 'v14' is possibly undefined
// 43CA90: variable 'v15' is possibly undefined
// 43CA90: variable 'a4' is possibly undefined
// 43CA90: variable 'a5' is possibly undefined
// 43CA90: variable 'a6' is possibly undefined
// 43CA90: variable 'a7' is possibly undefined
// 43CA90: variable 'a8' is possibly undefined
// 43CA90: variable 'a9' is possibly undefined
// 43CA90: variable 'a10' is possibly undefined
// 43CA90: variable 'a11' is possibly undefined
// 454610: using guessed type __int64 qword_454610;

//----- (000000000043CD6C) ----------------------------------------------------
void __fastcall dl_exception_free(
        _QWORD *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  free(a1[2], a2, a3, a4, a5, a6, a7, a8, a9);
  *a1 = 0LL;
  a1[1] = 0LL;
  a1[2] = 0LL;
}

//----- (000000000043CDA0) ----------------------------------------------------
unsigned __int64 __fastcall dl_make_stack_executable(_QWORD *a1)
{
  unsigned __int64 result; // x0

  result = mprotect((void *)(*a1 & -dl_pagesize), dl_pagesize, 16777223);
  if ( (_DWORD)result )
    return *(unsigned int *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);
  *a1 = 0LL;
  dl_stack_flags |= 1u;
  return result;
}
// 490F10: using guessed type __int64 dl_pagesize;
// 490F28: using guessed type int dl_stack_flags;

//----- (000000000043CE20) ----------------------------------------------------
unsigned int *__fastcall check_match(
        unsigned __int64 a1,
        unsigned int *a2,
        __int64 a3,
        char a4,
        unsigned __int8 a5,
        unsigned int *a6,
        unsigned int a7,
        __int64 a8,
        __int64 a9,
        unsigned int **a10,
        _DWORD *a11)
{
  int v11; // w8
  int v12; // w9
  int v14; // w0
  __int64 v15; // x0
  __int16 v16; // w3
  __int64 v17; // x6
  int v18; // w4
  int v22; // w0
  unsigned int *v24; // [xsp+20h] [xbp+20h]
  __int64 v25; // [xsp+20h] [xbp+20h]
  __int64 v26; // [xsp+28h] [xbp+28h]
  __int16 v27; // [xsp+28h] [xbp+28h]
  unsigned int v28; // [xsp+34h] [xbp+34h]
  int v29; // [xsp+34h] [xbp+34h]
  unsigned int *v30; // [xsp+38h] [xbp+38h]

  v11 = *((unsigned __int16 *)a6 + 3);
  v12 = a6[1] & 0xF;
  if ( !*((_QWORD *)a6 + 1) && v12 != 6 && v11 != 65521 )
    return 0LL;
  if ( (v11 == 0) & a5 | (-1128 >> v12) & 1 )
    return 0LL;
  if ( a6 == a2
    || (v24 = a6,
        v26 = a3,
        v28 = a7,
        v14 = strcmp((unsigned __int64 *)(a8 + *a6), a1),
        a6 = v24,
        a3 = v26,
        a7 = v28,
        !v14) )
  {
    v15 = *(_QWORD *)(a9 + 904);
    if ( a3 )
    {
      if ( !v15 )
        return a6;
      v16 = *(_WORD *)(v15 + 2LL * a7);
      v17 = *(_QWORD *)(a9 + 816);
      v18 = *(_DWORD *)(v17 + 24LL * (v16 & 0x7FFF) + 8);
      if ( v18 == *(_DWORD *)(a3 + 8) )
      {
        v25 = a3;
        v27 = v16;
        v29 = *(_DWORD *)(v17 + 24LL * (v16 & 0x7FFF) + 8);
        v30 = a6;
        v22 = strcmp(*(unsigned __int64 **)(v17 + 24LL * (v16 & 0x7FFF)), *(_QWORD *)a3);
        a3 = v25;
        a6 = v30;
        v16 = v27;
        v18 = v29;
        if ( !v22 )
          return a6;
      }
      if ( !(v18 | *(_DWORD *)(a3 + 12)) && v16 >= 0 )
        return a6;
    }
    else
    {
      if ( !v15 || (*(_WORD *)(v15 + 2LL * a7) & 0x7FFF) < ((a4 & 2) == 0LL) + 2 )
        return a6;
      if ( (*(_WORD *)(v15 + 2LL * a7) & 0x8000) == 0 && !(*a11)++ )
        *a10 = a6;
    }
  }
  return 0LL;
}

//----- (000000000043CFA0) ----------------------------------------------------
__int64 __fastcall do_lookup_x(
        const char *a1,
        unsigned int a2,
        unsigned __int64 *a3,
        __int64 a4,
        unsigned int **a5,
        void **a6,
        __int64 a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16,
        char a17,
        __int64 a18,
        unsigned __int8 a19,
        __int64 a20)
{
  __int64 v22; // x13
  unsigned __int64 v23; // x18
  __int64 *v25; // x8
  int v26; // w12
  _BOOL4 v28; // w20
  _QWORD *v29; // x6
  unsigned int v30; // w3
  __int64 v31; // x0
  __int64 v32; // x7
  __int64 v33; // x21
  __int64 v34; // x2
  __int64 v35; // x25
  unsigned __int64 v36; // x2
  __int64 v37; // x22
  const char *v38; // x2
  unsigned __int64 v39; // x0
  __int64 v40; // x20
  unsigned int v41; // w22
  unsigned int *v42; // x0
  __int64 v43; // x2
  unsigned int *v44; // x3
  int v45; // w0
  __int64 v46; // x1
  bool v47; // zf
  int v48; // w0
  unsigned int v50; // w14
  __int64 v51; // x26
  unsigned int v52; // w23
  int *v53; // x20
  int v54; // w24
  unsigned int *v55; // x0
  unsigned int v56; // w20
  __int64 **v57; // x27
  __int64 v58; // x2
  void *v59; // x5
  double v60; // d0
  double v61; // d1
  double v62; // d2
  double v63; // d3
  double v64; // d4
  double v65; // d5
  double v66; // d6
  double v67; // d7
  __int64 v68; // x4
  __int64 *v69; // x8
  __int64 **v70; // x23
  unsigned __int64 v71; // x28
  __int64 *v72; // x23
  unsigned __int64 v73; // x21
  unsigned __int64 v74; // x26
  unsigned __int64 v75; // x28
  __int64 v76; // x25
  __int64 v77; // x22
  __int64 *v78; // x26
  unsigned __int64 *v79; // x0
  __int128 v80; // q31
  __int64 v81; // x4
  __int64 v82; // x7
  unsigned __int64 v83; // x28
  __int64 *v84; // x8
  __int64 v85; // x26
  __int64 v86; // x13
  __int64 v87; // x21
  int v88; // w12
  unsigned int *v89; // x3
  unsigned __int64 v90; // x25
  int8x16_t *(__fastcall *v91)(int8x16_t *, unsigned __int8, unsigned __int64); // x6
  __int64 v92; // x7
  char *v93; // x0
  char *v94; // x0
  unsigned __int64 v95; // x2
  unsigned __int64 v96; // x0
  __int64 v97; // x2
  __int64 v98; // x0
  unsigned int v99; // t1
  unsigned __int64 v100; // x19
  __int64 v101; // x2
  void *v102; // x3
  __int64 v103; // x4
  void *v104; // x5
  __int64 v105; // x6
  __int64 v106; // x7
  double v107; // d0
  double v108; // d1
  double v109; // d2
  double v110; // d3
  double v111; // d4
  double v112; // d5
  double v113; // d6
  double v114; // d7
  int8x16_t *(__fastcall *v115)(int8x16_t *, unsigned __int8, unsigned __int64); // x23
  unsigned __int64 v116; // x24
  unsigned int *v117; // x5
  __int64 v118; // x15
  __int64 v119; // x18
  __int64 v120; // x21
  unsigned __int64 v121; // x9
  unsigned __int64 v122; // x0
  char *v123; // x1
  __int64 **v124; // x25
  int8x16_t *(__fastcall *v125)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  unsigned int *v127; // [xsp+88h] [xbp+68h]
  unsigned int *v128; // [xsp+88h] [xbp+68h]
  unsigned int *v129; // [xsp+88h] [xbp+68h]
  unsigned int *v131; // [xsp+90h] [xbp+70h]
  __int64 v132; // [xsp+90h] [xbp+70h]
  __int64 v133; // [xsp+90h] [xbp+70h]
  __int64 v134; // [xsp+98h] [xbp+78h]
  __int64 v135; // [xsp+98h] [xbp+78h]
  __int64 v136; // [xsp+98h] [xbp+78h]
  __int64 *v139; // [xsp+B0h] [xbp+90h]
  int v140; // [xsp+B0h] [xbp+90h]
  __int64 v141; // [xsp+B0h] [xbp+90h]
  _QWORD *v142; // [xsp+B8h] [xbp+98h]
  _QWORD *v143; // [xsp+B8h] [xbp+98h]
  _QWORD *v144; // [xsp+B8h] [xbp+98h]
  int v145; // [xsp+B8h] [xbp+98h]
  __int64 v146; // [xsp+B8h] [xbp+98h]
  _QWORD *v147; // [xsp+B8h] [xbp+98h]
  __int64 *v148; // [xsp+B8h] [xbp+98h]
  __int64 v149; // [xsp+C0h] [xbp+A0h]
  _BOOL4 v150; // [xsp+C0h] [xbp+A0h]
  _QWORD *v151; // [xsp+C0h] [xbp+A0h]
  __int64 v152; // [xsp+C0h] [xbp+A0h]
  __int64 v153; // [xsp+C0h] [xbp+A0h]
  __int64 v154; // [xsp+C0h] [xbp+A0h]
  unsigned __int64 v155; // [xsp+C0h] [xbp+A0h]
  _BOOL4 v156; // [xsp+C8h] [xbp+A8h]
  unsigned int *v157; // [xsp+C8h] [xbp+A8h]
  __int64 *v158; // [xsp+C8h] [xbp+A8h]
  int v159; // [xsp+D0h] [xbp+B0h]
  __int64 v160; // [xsp+D0h] [xbp+B0h]
  unsigned __int64 v161; // [xsp+D0h] [xbp+B0h]
  int v162; // [xsp+D0h] [xbp+B0h]
  __int64 *v163; // [xsp+D8h] [xbp+B8h]
  unsigned __int64 v164; // [xsp+D8h] [xbp+B8h]
  __int64 *v165; // [xsp+D8h] [xbp+B8h]
  __int64 *v166; // [xsp+D8h] [xbp+B8h]
  int v167; // [xsp+D8h] [xbp+B8h]
  int v168; // [xsp+E0h] [xbp+C0h]
  unsigned int *v169; // [xsp+E0h] [xbp+C0h]
  __int64 *v170; // [xsp+E0h] [xbp+C0h]
  unsigned int *v171; // [xsp+E0h] [xbp+C0h]
  __int64 *v172; // [xsp+E8h] [xbp+C8h]
  int v173; // [xsp+F4h] [xbp+D4h] BYREF
  unsigned int *v174; // [xsp+F8h] [xbp+D8h] BYREF
  __int64 v175; // [xsp+108h] [xbp+E8h]
  __int64 v176; // [xsp+108h] [xbp+E8h]
  __int64 v177; // [xsp+108h] [xbp+E8h]
  __int64 v178; // [xsp+108h] [xbp+E8h]
  __int64 v179; // [xsp+118h] [xbp+F8h]
  __int64 v180; // [xsp+118h] [xbp+F8h]
  __int64 v181; // [xsp+118h] [xbp+F8h]
  __int64 v182; // [xsp+118h] [xbp+F8h]
  __int64 v183; // [xsp+118h] [xbp+F8h]

  v22 = a20;
  v23 = *((unsigned int *)a6 + 2);
  v25 = &dl_debug_mask;
  v26 = a19 & 2;
  v28 = a20 == 0;
  v29 = *a6;
  while ( 1 )
  {
    v37 = *(_QWORD *)(v29[a7] + 40LL);
    if ( v37 == a18
      || v26 && (*(_WORD *)(v37 + 868) & 3LL) == 0
      || (*(_BYTE *)(v37 + 870) & 4) != 0 && (!v22 || (*(_BYTE *)(v22 + 870) & 4) == 0) )
    {
      goto LABEL_7;
    }
    if ( (*(_DWORD *)v25 & 8) != 0 )
    {
      v38 = *(const char **)(v37 + 8);
      if ( !*v38 )
      {
        v38 = (const char *)program_invocation_short_name[0];
        if ( !program_invocation_short_name[0] )
          v38 = "<main program>";
      }
      v142 = v29;
      v149 = a7;
      v159 = v26;
      v163 = v25;
      v175 = a18;
      v179 = v22;
      dl_debug_printf("symbol=%s;  lookup in file=%s [%lu]\n", a1, v38, *(_QWORD *)(v37 + 48));
      v25 = v163;
      a18 = v175;
      v22 = v179;
      v29 = v142;
      a7 = v149;
      v26 = v159;
    }
    v30 = *(_DWORD *)(v37 + 828);
    if ( !v30 )
      goto LABEL_7;
    v31 = *(_QWORD *)(v37 + 112);
    v173 = 0;
    v174 = 0LL;
    v32 = 0LL;
    v33 = *(_QWORD *)(v31 + 8);
    if ( (*(_BYTE *)(v37 + 870) & 0x20) != 0 )
    {
      v32 = *(_QWORD *)v37;
      v33 += *(_QWORD *)v37;
    }
    v34 = *(_QWORD *)(v37 + 840);
    v35 = v32 + *(_QWORD *)(*(_QWORD *)(v37 + 104) + 8LL);
    if ( v34 )
    {
      v36 = *(_QWORD *)(v34 + 8LL * (*(_DWORD *)(v37 + 832) & (a2 >> 6) & 0x3FFFFFF));
      if ( ((unsigned int)(v36 >> (a2 >> *(_DWORD *)(v37 + 836))) & (unsigned int)(v36 >> a2) & 1) == 0 )
        goto LABEL_7;
      v43 = *(_QWORD *)(v37 + 848);
      v50 = *(_DWORD *)(v43 + 4LL * (a2 % v30));
      if ( !v50 )
        goto LABEL_7;
      v51 = *(_QWORD *)(v37 + 856);
      v52 = a2;
      v151 = v29;
      v156 = v28;
      v53 = (int *)(v51 + 4LL * v50);
      v160 = a7;
      v164 = v23;
      v168 = v26;
      v172 = v25;
      v176 = a18;
      v180 = v22;
      do
      {
        v54 = *v53;
        if ( !((*v53 ^ v52) >> 1) )
        {
          v55 = check_match(
                  (unsigned __int64)a1,
                  (unsigned int *)a4,
                  a8,
                  a17,
                  a19,
                  (unsigned int *)(v33 + 24LL * (unsigned int)(((unsigned __int64)v53 - v51) >> 2)),
                  ((unsigned __int64)v53 - v51) >> 2,
                  v35,
                  v37,
                  &v174,
                  &v173);
          if ( v55 )
          {
            v29 = v151;
            v44 = v55;
            v28 = v156;
            a2 = v52;
            goto LABEL_27;
          }
        }
        ++v53;
      }
      while ( (v54 & 1) == 0 );
      v29 = v151;
      a2 = v52;
      v28 = v156;
LABEL_65:
      v25 = v172;
      a18 = v176;
      v22 = v180;
      a7 = v160;
      v23 = v164;
      v26 = v168;
      if ( v173 != 1 )
        goto LABEL_7;
      v44 = v174;
      if ( !v174 )
        goto LABEL_7;
    }
    else
    {
      if ( *a3 == 0xFFFFFFFF )
      {
        v95 = *(unsigned __int8 *)a1;
        v39 = 0LL;
        if ( *a1 )
        {
          if ( a1[1] )
          {
            v95 = *((unsigned __int8 *)a1 + 1) + 16 * v95;
            if ( a1[2] )
            {
              v95 = *((unsigned __int8 *)a1 + 2) + 16 * v95;
              if ( a1[3] )
              {
                v95 = *((unsigned __int8 *)a1 + 3) + 16 * v95;
                if ( a1[4] )
                {
                  v96 = *((unsigned __int8 *)a1 + 4) + 16 * v95;
                  v97 = *((unsigned __int8 *)a1 + 5);
                  if ( a1[5] )
                  {
                    a6 = (void **)(a1 + 5);
                    do
                    {
                      v98 = v97 + 16 * v96;
                      v99 = *((unsigned __int8 *)a6 + 1);
                      a6 = (void **)((char *)a6 + 1);
                      v97 = v99;
                      v96 = v98 ^ ((unsigned __int64)((unsigned int)v98 & 0xF0000000) >> 24);
                    }
                    while ( v99 );
                  }
                  v95 = v96 & 0xFFFFFFF;
                }
              }
            }
          }
          v39 = 4 * (v95 % v30);
        }
        *a3 = v95;
      }
      else
      {
        v39 = 4 * (*a3 % v30);
      }
      if ( !*(_DWORD *)(*(_QWORD *)(v37 + 856) + v39) )
        goto LABEL_7;
      v143 = v29;
      v150 = v28;
      v40 = v37;
      v41 = *(_DWORD *)(*(_QWORD *)(v37 + 856) + v39);
      v160 = a7;
      v164 = v23;
      v168 = v26;
      v172 = v25;
      v176 = a18;
      v180 = v22;
      while ( 1 )
      {
        v42 = check_match(
                (unsigned __int64)a1,
                (unsigned int *)a4,
                a8,
                a17,
                a19,
                (unsigned int *)(v33 + 24LL * v41),
                v41,
                v35,
                v40,
                &v174,
                &v173);
        if ( v42 )
          break;
        v41 = *(_DWORD *)(*(_QWORD *)(v40 + 848) + 4LL * v41);
        if ( !v41 )
        {
          v29 = v143;
          v37 = v40;
          v28 = v150;
          goto LABEL_65;
        }
      }
      v29 = v143;
      v37 = v40;
      v44 = v42;
      v28 = v150;
LABEL_27:
      a7 = v160;
      v23 = v164;
      v25 = v172;
      a18 = v176;
      v22 = v180;
      v26 = v168;
    }
    v45 = *((_BYTE *)v44 + 5) & 3;
    v46 = (unsigned int)(v45 - 1);
    if ( (unsigned int)v46 <= 1 )
      goto LABEL_7;
    v47 = !v28 && v45 == 3;
    if ( v47 && (*(_WORD *)(v22 + 868) & 3LL) == 0 )
    {
      if ( v26 )
      {
        v147 = v29;
        v154 = a7;
        v162 = v26;
        v166 = v25;
        v171 = v44;
        v178 = a18;
        v183 = v22;
        dl_error_printf(
          "warning: copy relocation against non-copyable protected symbol `%s' in `%s'\n",
          a1,
          *(const char **)(v37 + 8));
        v29 = v147;
        a7 = v154;
        v25 = v166;
        v44 = v171;
        a18 = v178;
        v22 = v183;
        v26 = v162;
      }
      else
      {
        if ( (a19 & 1) == 0 )
          goto LABEL_33;
        v46 = a4;
        if ( !*(_QWORD *)(a4 + 8) || *(_WORD *)(a4 + 6) )
          goto LABEL_33;
        v144 = v29;
        v152 = a7;
        v165 = v25;
        v169 = v44;
        v177 = a18;
        v181 = v22;
        dl_error_printf(
          "warning: direct reference to protected function `%s' in `%s' may break pointer equality\n",
          a1,
          *(const char **)(v37 + 8));
        a18 = v177;
        v22 = v181;
        v29 = v144;
        a7 = v152;
        v25 = v165;
        v44 = v169;
        v26 = 0;
      }
      if ( (*(_DWORD *)(v37 + 876) & 1) != 0 )
        dl_signal_error(0, *(_QWORD *)(v37 + 8), a1, "error due to GNU_PROPERTY_1_NEEDED_INDIRECT_EXTERN_ACCESS");
    }
LABEL_33:
    v48 = *((unsigned __int8 *)v44 + 4) >> 4;
    if ( v48 != 2 )
      break;
    if ( !dl_dynamic_weak )
    {
LABEL_36:
      *a5 = v44;
      a5[1] = (unsigned int *)v37;
      return 1LL;
    }
    if ( !*a5 )
    {
      *a5 = v44;
      a5[1] = (unsigned int *)v37;
    }
LABEL_7:
    if ( v23 <= ++a7 )
      return 0LL;
  }
  if ( v48 != 10 )
  {
    if ( v48 == 1 )
      goto LABEL_36;
    goto LABEL_7;
  }
  v139 = v25;
  v134 = *(_QWORD *)(v37 + 48);
  v145 = v26;
  v56 = a2;
  v157 = v44;
  v182 = v22;
  v57 = &(&dl_ns)[21 * v134 + 5];
  pthread_mutex_lock(v57, a9, a10, a11, a12, a13, a14, a15, a16, v46, v43, (__int64)v44, v134, a6, v29);
  v68 = v134;
  v69 = v139;
  v70 = &(&dl_ns)[21 * v134];
  if ( !v70[11] )
  {
    v125 = calloc(0x20uLL, 0x1FuLL, v58, v157, v60, v61, v62, v63, v64, v65, v66, v67, v134, v59, 0LL, v35);
    v91 = v125;
    if ( v125 )
    {
      v83 = 31LL;
      v70[11] = (__int64 *)v125;
      v70[12] = (__int64 *)31;
      v89 = v157;
      v82 = v35;
      v81 = v134;
      v70[14] = (__int64 *)free;
      v88 = v145;
      v84 = v139;
      v86 = v182;
      v90 = a2 % 0x1FuLL;
      v85 = a2
          - (a2 / 29LL
           + 4 * (((((unsigned __int128)a2 * 0x469EE58469EE5847LL) >> 64) & 0xFFFFFFFFFFFFFFF8LL) - a2 / 29LL))
          + 1;
      v87 = 32 * v85;
      goto LABEL_69;
    }
LABEL_120:
    pthread_mutex_unlock((int *)v57, v60, v61, v62, v63, v64, v65, v66, v67);
    dl_fatal_printf("out of memory\n");
  }
  v71 = (unsigned __int64)v70[12];
  v72 = v70[11];
  v131 = v157;
  v135 = v37;
  v73 = v71;
  v140 = v145;
  v146 = v35;
  v153 = v68;
  v170 = v69;
  v74 = a2 % (v71 - 2);
  v75 = a2 % v71;
  v161 = v75;
  v76 = v74 + 1;
  v77 = 32 * (v74 + 1);
  while ( 2 )
  {
    v78 = &v72[4 * v75];
LABEL_58:
    v79 = (unsigned __int64 *)v78[1];
    if ( a2 == *(_DWORD *)v78 )
    {
      if ( !(unsigned int)strcmp(v79, (unsigned __int64)a1) )
      {
        if ( v140 )
        {
          *(_QWORD *)&v80 = v157;
          *((_QWORD *)&v80 + 1) = v135;
        }
        else
        {
          v80 = *((_OWORD *)v78 + 1);
        }
        *(_OWORD *)a5 = v80;
        pthread_mutex_unlock((int *)v57, v60, v61, v62, v63, v64, v65, v66, v67);
        return 1LL;
      }
LABEL_57:
      v75 += v76;
      v78 = (__int64 *)((char *)v78 + v77);
      if ( v73 <= v75 )
      {
        v75 -= v73;
        continue;
      }
      goto LABEL_58;
    }
    break;
  }
  if ( v79 )
    goto LABEL_57;
  v82 = v146;
  v81 = v153;
  v83 = v73;
  v84 = v170;
  v85 = v76;
  v86 = v182;
  v87 = v77;
  v88 = v140;
  v89 = v157;
  v37 = v135;
  v90 = v161;
  v91 = (int8x16_t *(__fastcall *)(int8x16_t *, unsigned __int8, unsigned __int64))v72;
  if ( 3 * v83 <= 4 * (__int64)(&dl_ns)[21 * v153 + 13] )
  {
    v136 = v146;
    v141 = v153;
    v148 = v72;
    v155 = a2;
    v158 = v72;
    v167 = v88;
    v100 = dl_higher_prime_number(v83 + 1);
    v115 = calloc(0x20uLL, v100, v101, v102, v107, v108, v109, v110, v111, v112, v113, v114, v103, v104, v105, v106);
    if ( v115 )
    {
      v116 = v100 - 2;
      v117 = (unsigned int *)v158;
      if ( v83 )
      {
        do
        {
          v118 = *((_QWORD *)v117 + 1);
          if ( v118 )
          {
            v120 = *((_QWORD *)v117 + 2);
            v119 = *((_QWORD *)v117 + 3);
            v121 = *v117 % v116 + 1;
            v122 = *v117 % v100;
LABEL_106:
            v123 = (char *)v115 + 32 * v122;
            while ( *((_QWORD *)v123 + 1) )
            {
              v122 += v121;
              v123 += 32 * v121;
              if ( v100 <= v122 )
              {
                v122 -= v100;
                goto LABEL_106;
              }
            }
            *(_DWORD *)v123 = *v117;
            *((_QWORD *)v123 + 1) = v118;
            *((_QWORD *)v123 + 2) = v120;
            *((_QWORD *)v123 + 3) = v119;
          }
          v117 += 8;
        }
        while ( v117 != (unsigned int *)&v148[4 * v83] );
      }
      v83 = v100;
      v124 = &(&dl_ns)[21 * v141];
      ((void (__fastcall *)(__int64 *))v124[14])(v148);
      v124[11] = (__int64 *)v115;
      v124[12] = (__int64 *)v100;
      v91 = v115;
      v88 = v167;
      v81 = v141;
      v89 = v131;
      v82 = v136;
      v124[14] = (__int64 *)free;
      v85 = v155 % v116 + 1;
      v84 = v170;
      v87 = 32 * v85;
      v86 = v182;
      v90 = v155 % v100;
      goto LABEL_69;
    }
    goto LABEL_120;
  }
LABEL_69:
  v92 = v82 + *v89;
  if ( v88 )
  {
LABEL_70:
    v93 = (char *)v91 + 32 * v90;
    while ( *((_QWORD *)v93 + 1) )
    {
      v90 += v85;
      v93 += v87;
      if ( v83 <= v90 )
      {
        v90 -= v83;
        goto LABEL_70;
      }
    }
    *(_DWORD *)v93 = v56;
    *((_QWORD *)v93 + 1) = v92;
    *((_QWORD *)v93 + 2) = a4;
    *((_QWORD *)v93 + 3) = v86;
  }
  else
  {
LABEL_76:
    v94 = (char *)v91 + 32 * v90;
    while ( *((_QWORD *)v94 + 1) )
    {
      v90 += v85;
      v94 += v87;
      if ( v83 <= v90 )
      {
        v90 -= v83;
        goto LABEL_76;
      }
    }
    *((_QWORD *)v94 + 1) = v92;
    *((_QWORD *)v94 + 2) = v89;
    *(_DWORD *)v94 = v56;
    *((_QWORD *)v94 + 3) = v37;
    if ( (*(_WORD *)(v37 + 868) & 3) == 2 && (*(_BYTE *)(v37 + 871) & 1) == 0 )
    {
      if ( (a17 & 8) != 0 )
      {
        if ( (*(_BYTE *)(v37 + 872) & 1) == 0 )
        {
          if ( (*(_DWORD *)v84 & 4) != 0 )
          {
            v129 = v89;
            v133 = v81;
            dl_debug_printf(
              "marking %s [%lu] as NODELETE due to unique symbol\n",
              *(const char **)(v37 + 8),
              *(_QWORD *)(v37 + 48));
            v89 = v129;
            v81 = v133;
          }
          *(_BYTE *)(v37 + 872) = 1;
        }
      }
      else
      {
        if ( (*(_DWORD *)v84 & 4) != 0 )
        {
          v128 = v89;
          v132 = v81;
          dl_debug_printf(
            "marking %s [%lu] as NODELETE due to unique symbol\n",
            *(const char **)(v37 + 8),
            *(_QWORD *)(v37 + 48));
          v89 = v128;
          v81 = v132;
        }
        *(_BYTE *)(v37 + 871) = 1;
      }
    }
  }
  v127 = v89;
  (&dl_ns)[21 * v81 + 13] = (__int64 *)((char *)(&dl_ns)[21 * v81 + 13] + 1);
  pthread_mutex_unlock((int *)v57, v60, v61, v62, v63, v64, v65, v66, v67);
  *a5 = v127;
  a5[1] = (unsigned int *)v37;
  return 1LL;
}
// 43D3FC: variable 'a9' is possibly undefined
// 43D3FC: variable 'a10' is possibly undefined
// 43D3FC: variable 'a11' is possibly undefined
// 43D3FC: variable 'a12' is possibly undefined
// 43D3FC: variable 'a13' is possibly undefined
// 43D3FC: variable 'a14' is possibly undefined
// 43D3FC: variable 'a15' is possibly undefined
// 43D3FC: variable 'a16' is possibly undefined
// 43D3FC: variable 'v46' is possibly undefined
// 43D3FC: variable 'v43' is possibly undefined
// 43D3FC: variable 'a6' is possibly undefined
// 43D4C0: variable 'v60' is possibly undefined
// 43D4C0: variable 'v61' is possibly undefined
// 43D4C0: variable 'v62' is possibly undefined
// 43D4C0: variable 'v63' is possibly undefined
// 43D4C0: variable 'v64' is possibly undefined
// 43D4C0: variable 'v65' is possibly undefined
// 43D4C0: variable 'v66' is possibly undefined
// 43D4C0: variable 'v67' is possibly undefined
// 43D764: variable 'v101' is possibly undefined
// 43D764: variable 'v102' is possibly undefined
// 43D764: variable 'v107' is possibly undefined
// 43D764: variable 'v108' is possibly undefined
// 43D764: variable 'v109' is possibly undefined
// 43D764: variable 'v110' is possibly undefined
// 43D764: variable 'v111' is possibly undefined
// 43D764: variable 'v112' is possibly undefined
// 43D764: variable 'v113' is possibly undefined
// 43D764: variable 'v114' is possibly undefined
// 43D764: variable 'v103' is possibly undefined
// 43D764: variable 'v104' is possibly undefined
// 43D764: variable 'v105' is possibly undefined
// 43D764: variable 'v106' is possibly undefined
// 43D8B0: variable 'v58' is possibly undefined
// 43D8B0: variable 'v59' is possibly undefined
// 4914A8: using guessed type __int64 *dl_ns;
// 491928: using guessed type __int64 *program_invocation_short_name[2];
// 496C20: using guessed type __int64 dl_debug_mask;
// 496C50: using guessed type int dl_dynamic_weak;

//----- (000000000043D9AC) ----------------------------------------------------
__int64 __fastcall dl_lookup_symbol_x(
        const char *a1,
        __int64 a2,
        __int64 *a3,
        void ***a4,
        const char **a5,
        int a6,
        char a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  int v23; // w2
  const char *v24; // x4
  unsigned int v25; // w28
  int v26; // w3
  int v27; // w0
  int v28; // t1
  void **v29; // x5
  void *v30; // x6
  void ***v31; // x27
  __int64 v32; // x9
  unsigned int *v33; // x10
  void **v34; // t1
  int v35; // w0
  unsigned int *v36; // x2
  __int64 v37; // x3
  int v38; // w27
  void ***v40; // x27
  __int64 v41; // x4
  void **v42; // t1
  int v43; // w0
  _QWORD *v44; // x2
  const char *v45; // x1
  const char *v46; // x3
  const char *v47; // x5
  __int64 v48; // x9
  __int64 v49; // x1
  unsigned int *v50; // x4
  __int64 *v51; // x11
  __int64 v52; // x0
  unsigned int v53; // w7
  unsigned int *v54; // x0
  int v55; // w26
  __int64 v56; // x2
  unsigned int *v57; // x3
  void *v58; // x5
  void *v59; // x6
  double v60; // d0
  double v61; // d1
  double v62; // d2
  double v63; // d3
  double v64; // d4
  double v65; // d5
  double v66; // d6
  double v67; // d7
  __int64 v68; // x9
  unsigned int *v69; // x10
  __int64 v70; // x7
  __int64 v71; // x28
  void *v72; // x4
  __int64 *v73; // x0
  bool v74; // zf
  bool v75; // zf
  __int64 v76; // x1
  unsigned int v77; // w0
  int v78; // w20
  __int64 v79; // x1
  __int64 v80; // x2
  void *v81; // x3
  void *v82; // x4
  void *v83; // x5
  void *v84; // x6
  _DWORD *v85; // x21
  unsigned int v86; // w7
  __int64 v87; // x25
  __int64 v88; // x7
  unsigned __int64 v89; // x0
  const char *v90; // x3
  const char *v91; // x1
  __int64 v92; // x2
  const char *v93; // x1
  const char *v94; // x3
  __int64 v95; // x1
  __int64 v96; // x2
  __int64 v97; // x3
  void *v98; // x5
  void *v99; // x6
  double v100; // d0
  double v101; // d1
  double v102; // d2
  double v103; // d3
  double v104; // d4
  double v105; // d5
  double v106; // d6
  double v107; // d7
  int v108; // w0
  signed __int64 v109; // x0
  __int64 *v110; // x0
  bool v111; // zf
  __int64 v112; // x1
  __int64 v113; // x26
  unsigned int *v114; // x0
  __int64 *v115; // x1
  __int64 *v116; // x4
  char *v117; // x4
  __int64 v118; // t1
  unsigned int *v119; // [xsp+88h] [xbp+68h]
  __int64 v120; // [xsp+88h] [xbp+68h]
  unsigned int *v121; // [xsp+88h] [xbp+68h]
  int v122; // [xsp+88h] [xbp+68h]
  unsigned int *v123; // [xsp+88h] [xbp+68h]
  unsigned int *v124; // [xsp+88h] [xbp+68h]
  unsigned int *v125; // [xsp+88h] [xbp+68h]
  __int64 v126; // [xsp+90h] [xbp+70h]
  unsigned int *v127; // [xsp+90h] [xbp+70h]
  __int64 v128; // [xsp+90h] [xbp+70h]
  __int64 v129; // [xsp+90h] [xbp+70h]
  __int64 v130; // [xsp+90h] [xbp+70h]
  __int64 v131; // [xsp+90h] [xbp+70h]
  unsigned int v132; // [xsp+90h] [xbp+70h]
  __int64 v133; // [xsp+90h] [xbp+70h]
  unsigned int *v134; // [xsp+90h] [xbp+70h]
  unsigned int *v136; // [xsp+98h] [xbp+78h]
  __int64 v137; // [xsp+98h] [xbp+78h]
  __int64 v138; // [xsp+A0h] [xbp+80h]
  unsigned int v139; // [xsp+A0h] [xbp+80h]
  __int64 v140; // [xsp+A0h] [xbp+80h]
  unsigned __int64 StatusReg; // [xsp+A0h] [xbp+80h]
  unsigned int *v142; // [xsp+A8h] [xbp+88h]
  unsigned int *v143; // [xsp+A8h] [xbp+88h]
  __int64 v144; // [xsp+B0h] [xbp+90h]
  __int64 *v145; // [xsp+B0h] [xbp+90h]
  unsigned int v146; // [xsp+BCh] [xbp+9Ch]
  unsigned int *v147; // [xsp+C0h] [xbp+A0h]
  __int64 v148; // [xsp+C8h] [xbp+A8h]
  unsigned __int64 v149; // [xsp+D8h] [xbp+B8h] BYREF
  unsigned int *v150; // [xsp+E0h] [xbp+C0h] BYREF
  __int64 v151; // [xsp+E8h] [xbp+C8h]
  unsigned int *v152; // [xsp+F0h] [xbp+D0h] BYREF
  __int64 v153; // [xsp+F8h] [xbp+D8h]
  __int64 (__fastcall *v154[3])(__int64, __int64 *, unsigned __int64); // [xsp+108h] [xbp+E8h] BYREF

  while ( 1 )
  {
    v23 = *(unsigned __int8 *)a1;
    if ( *a1 )
    {
      v24 = a1;
      v25 = 5381;
      while ( v24[1] )
      {
        v26 = 32 * v23;
        v27 = *((unsigned __int8 *)v24 + 1) + v23;
        v28 = *((unsigned __int8 *)v24 + 2);
        v24 += 2;
        v23 = v28;
        v25 = v27 + v26 + 1089 * v25;
        if ( !v28 )
          goto LABEL_5;
      }
      v149 = 0xFFFFFFFFLL;
      v25 += v23 + 32 * v25;
      if ( a5 )
        goto LABEL_6;
    }
    else
    {
      v25 = 5381;
LABEL_5:
      v149 = 0xFFFFFFFFLL;
      if ( a5 )
      {
LABEL_6:
        if ( (a7 & 2) != 0 )
          _libc_assert_fail(
            (__int64)"version == NULL || !(flags & DL_LOOKUP_RETURN_NEWEST)",
            (__int64)"dl-lookup.c",
            0x301u,
            (__int64)"_dl_lookup_symbol_x");
        if ( a8 )
        {
LABEL_40:
          v126 = 0LL;
          v29 = *a4;
          v44 = **a4;
          if ( *v44 == a8 )
            goto LABEL_10;
          do
            ++v126;
          while ( v44[v126] != a8 );
        }
        else
        {
          v126 = 0LL;
          v29 = *a4;
        }
        if ( !v29 )
          goto LABEL_43;
        goto LABEL_10;
      }
    }
    if ( a8 )
      goto LABEL_40;
    v29 = *a4;
    if ( !*a4 )
      goto LABEL_43;
    v126 = 0LL;
LABEL_10:
    v30 = (void *)v126;
    v31 = a4;
    v32 = 0LL;
    v33 = 0LL;
    do
    {
      v150 = v33;
      v151 = v32;
      v35 = do_lookup_x(
              a1,
              v25,
              &v149,
              *a3,
              &v150,
              v29,
              (__int64)v30,
              (__int64)a5,
              a9,
              a10,
              a11,
              a12,
              a13,
              a14,
              a15,
              a16,
              a7,
              a8,
              a6,
              a2);
      v33 = v150;
      v32 = v151;
      if ( v35 )
        break;
      v34 = v31[1];
      ++v31;
      v29 = v34;
      v30 = 0LL;
    }
    while ( v34 );
    if ( !v150 )
    {
LABEL_43:
      if ( *a3 && *(unsigned __int8 *)(*a3 + 4) >> 4 == 2 || (dl_debug_mask & 0x100) != 0 )
      {
        v33 = 0LL;
        v32 = 0LL;
        goto LABEL_20;
      }
      if ( a2 )
      {
        v115 = *(__int64 **)(a2 + 8);
        if ( !a5 )
        {
          v116 = &qword_454610;
LABEL_154:
          if ( *(_BYTE *)v115 )
            goto LABEL_155;
          goto LABEL_160;
        }
        if ( *a5 )
        {
          v116 = (__int64 *)", version ";
          goto LABEL_154;
        }
LABEL_162:
        v116 = (__int64 *)", version ";
        goto LABEL_154;
      }
      if ( a5 )
      {
        if ( !*a5 )
        {
          v115 = &qword_454610;
          goto LABEL_162;
        }
        v116 = (__int64 *)", version ";
      }
      else
      {
        v116 = &qword_454610;
      }
LABEL_160:
      v115 = program_invocation_short_name[0];
      if ( !program_invocation_short_name[0] )
        v115 = (__int64 *)"<main program>";
LABEL_155:
      dl_exception_create_format(
        v154,
        (__int64)v115,
        (__int64)"undefined symbol: %s%s%s",
        a9,
        a10,
        a11,
        a12,
        a13,
        a14,
        a15,
        a16,
        a1,
        v116);
      dl_signal_exception(0, (const char **)v154, "symbol lookup error");
    }
    v37 = *a3;
    if ( *a3 )
    {
      v38 = 0;
      if ( (*(_BYTE *)(v37 + 5) & 3) == 3 )
      {
        if ( a6 == 1 )
        {
          v38 = 1;
          if ( a2 != v151 )
            v33 = (unsigned int *)*a3;
          v32 = a2;
          goto LABEL_17;
        }
        v40 = a4;
        v29 = *a4;
        if ( *a4 )
        {
          v41 = 0LL;
          v36 = 0LL;
          while ( 1 )
          {
            v152 = v36;
            v153 = v41;
            v119 = v33;
            v138 = v32;
            v43 = do_lookup_x(
                    a1,
                    v25,
                    &v149,
                    v37,
                    &v152,
                    v29,
                    v126,
                    (__int64)a5,
                    a9,
                    a10,
                    a11,
                    a12,
                    a13,
                    a14,
                    a15,
                    a16,
                    a7,
                    a8,
                    1u,
                    0LL);
            v33 = v119;
            v32 = v138;
            v36 = v152;
            v41 = v153;
            if ( v43 )
              break;
            v42 = v40[1];
            ++v40;
            v29 = v42;
            if ( !v42 )
              break;
            v37 = *a3;
            v126 = 0LL;
          }
          if ( v152 && v153 != a2 )
          {
            v33 = (unsigned int *)*a3;
            v32 = a2;
          }
        }
        v38 = 1;
      }
    }
    else
    {
      v38 = 0;
    }
    if ( (*(_WORD *)(v32 + 868) & 3) != 2 )
      goto LABEL_17;
    v49 = (a7 & 1) == 0;
    if ( (v32 == a2) | (unsigned int)v49 )
      goto LABEL_17;
    if ( (*(_BYTE *)(v32 + 871) & 1) != 0 )
      goto LABEL_17;
    v122 = a7 & 8;
    if ( (a7 & 8) != 0 && (*(_BYTE *)(v32 + 872) & 1) != 0 )
      goto LABEL_17;
    v50 = *(unsigned int **)(a2 + 1040);
    __dmb(0xBu);
    v51 = *(__int64 **)(a2 + 1032);
    if ( v51 )
    {
      v52 = *v51;
      if ( *v51 )
        break;
    }
LABEL_65:
    if ( v50 )
    {
      v53 = *v50;
      if ( *v50 )
      {
        v54 = v50;
        v36 = &v50[2 * v53];
        do
        {
          v49 = *((_QWORD *)v54 + 1);
          if ( v32 == v49 )
            goto LABEL_17;
          v54 += 2;
        }
        while ( v54 != v36 );
      }
    }
    else
    {
      v53 = 0;
    }
    v129 = *(_QWORD *)(v32 + 1208);
    v55 = a7 & 4;
    if ( (a7 & 4) == 0 )
    {
      v139 = v53;
      v142 = v33;
      v144 = v32;
      pthread_mutex_lock(
        dl_load_lock,
        a9,
        a10,
        a11,
        a12,
        a13,
        a14,
        a15,
        a16,
        v49,
        (__int64)v36,
        v37,
        (__int64)v50,
        v29,
        v30);
      v69 = v142;
      v68 = v144;
      v70 = v139;
      v71 = v144;
      goto LABEL_72;
    }
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v143 = v50;
    v145 = v51;
    v146 = v53;
    v147 = v33;
    v148 = v32;
    _aarch64_swp4_rel();
    if ( v108 == 2 )
    {
      v95 = 129LL;
      v96 = 1LL;
      v97 = 0LL;
      v109 = linux_eabi_syscall(__NR_futex, (void *)(StatusReg - 1820), (void *)0x81, (void *)1, 0LL, v143, v98, v99);
    }
    pthread_mutex_lock(
      dl_load_lock,
      v100,
      v101,
      v102,
      v103,
      v104,
      v105,
      v106,
      v107,
      v95,
      v96,
      v97,
      (__int64)v143,
      v98,
      v99);
    v70 = v146;
    v69 = v147;
    v68 = v148;
    v110 = *(__int64 **)(a2 + 1032);
    v71 = v148;
    if ( v110 )
      v111 = v145 == v110;
    else
      v111 = 1;
    if ( v111 || (v112 = *v110) == 0 )
    {
LABEL_143:
      v114 = *(unsigned int **)(a2 + 1040);
      if ( v114 )
      {
        v56 = *v114;
        if ( v143 != v114 )
        {
          if ( (_DWORD)v56 )
          {
            v57 = &v114[2 * (unsigned int)v56];
            do
            {
              v112 = *((_QWORD *)v114 + 1);
              if ( v148 == v112 )
                goto LABEL_141;
              v114 += 2;
            }
            while ( v114 != v57 );
            v70 = (unsigned int)v56;
          }
          else
          {
            v70 = 0LL;
          }
          goto LABEL_72;
        }
        if ( v146 < (unsigned int)v56 )
        {
          v117 = (char *)&v143[2 * v146];
          do
          {
            v118 = *((_QWORD *)v117 + 1);
            v117 += 8;
            v112 = v118;
            if ( v148 == v118 )
              goto LABEL_141;
            v70 = (unsigned int)(v70 + 1);
          }
          while ( (_DWORD)v70 != (_DWORD)v56 );
        }
      }
LABEL_72:
      v72 = *(void **)(a2 + 48);
      v73 = (&dl_ns)[21 * (_QWORD)v72];
      if ( v73 )
        v74 = v73 == (__int64 *)v71;
      else
        v74 = 1;
      if ( !v74 )
      {
        do
        {
          v73 = (__int64 *)v73[3];
          if ( v73 )
            v75 = v73 == (__int64 *)v71;
          else
            v75 = 1;
        }
        while ( !v75 );
      }
      if ( v73 )
      {
        v76 = v129;
        if ( v129 == *(_QWORD *)(v71 + 1208) )
        {
          if ( (*(_BYTE *)(v71 + 871) & 1) != 0 || (a7 & 8) != 0 && (*(_BYTE *)(v71 + 872) & 1) != 0 )
          {
            v124 = v69;
            v131 = v68;
            pthread_mutex_unlock(dl_load_lock, v60, v61, v62, v63, v64, v65, v66, v67);
            v33 = v124;
            v32 = v131;
            if ( (a7 & 4) == 0 )
              goto LABEL_17;
LABEL_92:
            *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1820) = 1;
            __dmb(0xBu);
            goto LABEL_17;
          }
          if ( (*(_WORD *)(a2 + 868) & 3) == 2 )
          {
            v77 = *(_DWORD *)(a2 + 1048);
            if ( v77 > (unsigned int)v70 )
            {
              *(_QWORD *)(*(_QWORD *)(a2 + 1040) + 8LL * (unsigned int)v70 + 8) = v71;
              __dmb(0xBu);
              **(_DWORD **)(a2 + 1040) = v70 + 1;
LABEL_89:
              if ( (dl_debug_mask & 0x40) != 0 )
              {
                v93 = *(const char **)(v71 + 8);
                if ( !*v93 )
                {
                  v93 = (const char *)program_invocation_short_name[0];
                  if ( !program_invocation_short_name[0] )
                    v93 = "<main program>";
                }
                v94 = *(const char **)(a2 + 8);
                if ( !*v94 )
                {
                  v94 = (const char *)program_invocation_short_name[0];
                  if ( !program_invocation_short_name[0] )
                    v94 = "<main program>";
                }
                v123 = v69;
                v130 = v68;
                dl_debug_printf(
                  "\nfile=%s [%lu];  needed by %s [%lu] (relocation dependency)\n\n",
                  v93,
                  *(_QWORD *)(v71 + 48),
                  v94,
                  *(_QWORD *)(a2 + 48));
              }
              else
              {
                v123 = v69;
                v130 = v68;
              }
LABEL_91:
              pthread_mutex_unlock(dl_load_lock, v60, v61, v62, v63, v64, v65, v66, v67);
              v33 = v123;
              v32 = v130;
              if ( !v55 )
                goto LABEL_17;
              goto LABEL_92;
            }
            v78 = 2 * v77;
            if ( !v77 )
              v78 = 10;
            v132 = v70;
            v136 = v69;
            v140 = v68;
            v85 = (_DWORD *)malloc(
                              8LL * (unsigned int)(v78 + 1),
                              v76,
                              v56,
                              v57,
                              v72,
                              v58,
                              v59,
                              v70,
                              v60,
                              v61,
                              v62,
                              v63,
                              v64,
                              v65,
                              v66,
                              v67);
            v69 = v136;
            v68 = v140;
            v86 = v132;
            if ( v85 )
            {
              if ( v132 )
              {
                v87 = v132;
                j_memcpy();
                v86 = v132;
                v69 = v136;
                v68 = v140;
              }
              else
              {
                v87 = 0LL;
              }
              v88 = v86 + 1;
              *(_QWORD *)&v85[2 * v87 + 2] = v71;
              *v85 = v88;
              __dmb(0xBu);
              v89 = *(_QWORD *)(a2 + 1040);
              *(_QWORD *)(a2 + 1040) = v85;
              *(_DWORD *)(a2 + 1048) = v78;
              if ( v89 )
              {
                v125 = v69;
                v133 = v68;
                dl_scope_free(v89, v60, v61, v62, v63, v64, v65, v66, v67, v79, v80, v81, v82, v83, v84, v88);
                v69 = v125;
                v68 = v133;
              }
              goto LABEL_89;
            }
            if ( (dl_debug_mask & 4) == 0 )
              goto LABEL_111;
            if ( !v122 || (*(_BYTE *)(v71 + 872) & 1) == 0 )
            {
              dl_debug_printf(
                "marking %s [%lu] as NODELETE due to memory allocation failure\n",
                *(const char **)(v71 + 8),
                *(_QWORD *)(v71 + 48));
              v69 = v136;
              v68 = v140;
              goto LABEL_111;
            }
          }
          else
          {
            if ( (dl_debug_mask & 4) == 0 )
              goto LABEL_111;
            if ( (a7 & 8) == 0 || (*(_BYTE *)(v71 + 872) & 1) == 0 )
            {
              v90 = *(const char **)(a2 + 8);
              v91 = *(const char **)(v71 + 8);
              v92 = *(_QWORD *)(v71 + 48);
              v134 = v69;
              v137 = v68;
              if ( *v90 )
                dl_debug_printf("marking %s [%lu] as NODELETE due to reference from %s [%lu]\n", v91, v92, v90, v72);
              else
                dl_debug_printf("marking %s [%lu] as NODELETE due to reference from main program\n", v91, v92);
              v69 = v134;
              v68 = v137;
LABEL_111:
              if ( !v122 )
              {
                *(_BYTE *)(v71 + 871) = 1;
                v123 = v69;
                v130 = v68;
                goto LABEL_91;
              }
            }
          }
          *(_BYTE *)(v71 + 872) = 1;
          v123 = v69;
          v130 = v68;
          goto LABEL_91;
        }
      }
      pthread_mutex_unlock(dl_load_lock, v60, v61, v62, v63, v64, v65, v66, v67);
      if ( (a7 & 4) != 0 )
      {
        *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1820) = 1;
        __dmb(0xBu);
        goto LABEL_99;
      }
    }
    else
    {
      LODWORD(v56) = 0;
      while ( v148 != v112 )
      {
        v56 = (unsigned int)(v56 + 1);
        v112 = v110[(unsigned int)v56];
        if ( !v112 )
          goto LABEL_143;
      }
LABEL_141:
      v113 = *(_QWORD *)(v112 + 1208);
      pthread_mutex_unlock(dl_load_lock, v60, v61, v62, v63, v64, v65, v66, v67);
      *(_DWORD *)(StatusReg - 1820) = 1;
      __dmb(0xBu);
      if ( v129 == v113 )
      {
        v33 = v147;
        v32 = v148;
        goto LABEL_17;
      }
LABEL_99:
      a4 = *(void ****)(a2 + 976);
    }
  }
  LODWORD(v49) = 0;
  while ( v32 != v52 )
  {
    v49 = (unsigned int)(v49 + 1);
    v52 = v51[(unsigned int)v49];
    if ( !v52 )
      goto LABEL_65;
  }
LABEL_17:
  if ( !*(_DWORD *)(v32 + 1052) )
    *(_DWORD *)(v32 + 1052) = 1;
  if ( (dl_debug_mask & 4) != 0 )
  {
    v45 = *(const char **)(a2 + 8);
    if ( !*v45 )
    {
      v45 = (const char *)program_invocation_short_name[0];
      if ( !program_invocation_short_name[0] )
        v45 = "<main program>";
    }
    v46 = *(const char **)(v32 + 8);
    if ( !*v46 )
    {
      v46 = (const char *)program_invocation_short_name[0];
      if ( !program_invocation_short_name[0] )
        v46 = "<main program>";
    }
    v47 = "normal";
    if ( v38 )
      v47 = "protected";
    v120 = v32;
    v127 = v33;
    dl_debug_printf(
      "binding file %s [%lu] to %s [%lu]: %s symbol `%s'",
      v45,
      *(_QWORD *)(a2 + 48),
      v46,
      *(_QWORD *)(v32 + 48),
      v47,
      a1);
    v48 = v120;
    v121 = v127;
    v128 = v48;
    if ( a5 )
      dl_debug_printf_c(" [%s]\n", *a5);
    else
      dl_debug_printf_c((unsigned __int8 *)"\n");
    v33 = v121;
    v32 = v128;
  }
LABEL_20:
  *a3 = (__int64)v33;
  return v32;
}
// 43DA98: variable 'a9' is possibly undefined
// 43DA98: variable 'a10' is possibly undefined
// 43DA98: variable 'a11' is possibly undefined
// 43DA98: variable 'a12' is possibly undefined
// 43DA98: variable 'a13' is possibly undefined
// 43DA98: variable 'a14' is possibly undefined
// 43DA98: variable 'a15' is possibly undefined
// 43DA98: variable 'a16' is possibly undefined
// 43DDC4: variable 'v36' is possibly undefined
// 43DDC4: variable 'v37' is possibly undefined
// 43DDC4: variable 'v29' is possibly undefined
// 43DDC4: variable 'v30' is possibly undefined
// 43DE88: variable 'v60' is possibly undefined
// 43DE88: variable 'v61' is possibly undefined
// 43DE88: variable 'v62' is possibly undefined
// 43DE88: variable 'v63' is possibly undefined
// 43DE88: variable 'v64' is possibly undefined
// 43DE88: variable 'v65' is possibly undefined
// 43DE88: variable 'v66' is possibly undefined
// 43DE88: variable 'v67' is possibly undefined
// 43DF60: variable 'v56' is possibly undefined
// 43DF60: variable 'v57' is possibly undefined
// 43DF60: variable 'v58' is possibly undefined
// 43DF60: variable 'v59' is possibly undefined
// 43DFA4: variable 'v79' is possibly undefined
// 43DFA4: variable 'v80' is possibly undefined
// 43DFA4: variable 'v81' is possibly undefined
// 43DFA4: variable 'v82' is possibly undefined
// 43DFA4: variable 'v83' is possibly undefined
// 43DFA4: variable 'v84' is possibly undefined
// 43E12C: variable 'v108' is possibly undefined
// 43E144: variable 'v98' is possibly undefined
// 43E144: variable 'v99' is possibly undefined
// 43E15C: variable 'v100' is possibly undefined
// 43E15C: variable 'v101' is possibly undefined
// 43E15C: variable 'v102' is possibly undefined
// 43E15C: variable 'v103' is possibly undefined
// 43E15C: variable 'v104' is possibly undefined
// 43E15C: variable 'v105' is possibly undefined
// 43E15C: variable 'v106' is possibly undefined
// 43E15C: variable 'v107' is possibly undefined
// 43E15C: variable 'v95' is possibly undefined
// 43E15C: variable 'v96' is possibly undefined
// 43E15C: variable 'v97' is possibly undefined
// 43E380: using guessed type __int64 dl_try_allocate_static_tls(void);
// 454610: using guessed type __int64 qword_454610;
// 490F90: using guessed type int dl_load_lock[12];
// 4914A8: using guessed type __int64 *dl_ns;
// 491928: using guessed type __int64 *program_invocation_short_name[2];
// 496C20: using guessed type __int64 dl_debug_mask;

//----- (000000000043E380) ----------------------------------------------------
__int64 __fastcall dl_try_allocate_static_tls(__int64 a1, char a2)
{
  unsigned __int64 v2; // x3
  __int64 v3; // x2
  unsigned __int64 v4; // x3
  __int64 v5; // x1

  if ( *(_QWORD *)(a1 + 1168) == -1LL )
    return 0xFFFFFFFFLL;
  v2 = *(_QWORD *)(a1 + 1152);
  if ( v2 > dl_tls_static_align )
    return 0xFFFFFFFFLL;
  v3 = ((v2 - *(_QWORD *)(a1 + 1160) + dl_tls_static_used - 1) & -(__int64)v2) + *(_QWORD *)(a1 + 1160);
  v4 = v3 + *(_QWORD *)(a1 + 1144);
  if ( dl_tls_static_size < v4 )
    return 0xFFFFFFFFLL;
  if ( (a2 & 1) != 0 )
  {
    if ( dl_tls_static_optional >= v4 - dl_tls_static_used )
    {
      dl_tls_static_optional = dl_tls_static_used + dl_tls_static_optional - v4;
      goto LABEL_7;
    }
    return 0xFFFFFFFFLL;
  }
LABEL_7:
  v5 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 1160) = dl_tls_static_used;
  *(_QWORD *)(a1 + 1168) = v3;
  dl_tls_static_used = v4;
  if ( (*(_WORD *)(v5 + 868) & 8) != 0 )
    dl_init_static_tls();
  else
    *(_WORD *)(a1 + 868) |= 0x8000u;
  return 0LL;
}
// 4921F8: using guessed type __int64 dl_tls_static_align;
// 492200: using guessed type __int64 dl_tls_static_size;
// 492610: using guessed type __int64 dl_tls_static_optional;
// 492620: using guessed type __int64 dl_tls_static_used;

//----- (000000000043E460) ----------------------------------------------------
void __fastcall dl_allocate_static_tls(__int64 a1)
{
  unsigned __int64 v1; // x3
  __int64 v2; // x6
  __int64 v3; // x2
  unsigned __int64 v4; // x3
  __int64 v5; // x2

  if ( *(_QWORD *)(a1 + 1168) == -1LL
    || (v1 = *(_QWORD *)(a1 + 1152), v1 > dl_tls_static_align)
    || (v2 = dl_tls_static_used,
        v3 = ((dl_tls_static_used - 1 + v1 - *(_QWORD *)(a1 + 1160)) & -(__int64)v1) + *(_QWORD *)(a1 + 1160),
        v4 = v3 + *(_QWORD *)(a1 + 1144),
        v4 > dl_tls_static_size) )
  {
    dl_signal_error(0, *(_QWORD *)(a1 + 8), 0LL, "cannot allocate memory in static TLS block");
  }
  *(_QWORD *)(a1 + 1168) = v3;
  v5 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(a1 + 1160) = v2;
  dl_tls_static_used = v4;
  if ( (*(_WORD *)(v5 + 868) & 8) != 0 )
    dl_init_static_tls();
  else
    *(_WORD *)(a1 + 868) |= 0x8000u;
}
// 4921F8: using guessed type __int64 dl_tls_static_align;
// 492200: using guessed type __int64 dl_tls_static_size;
// 492620: using guessed type __int64 dl_tls_static_used;

//----- (000000000043E520) ----------------------------------------------------
unsigned __int64 __fastcall dl_protect_relro(unsigned __int64 result)
{
  __int64 v1; // x1
  __int64 v2; // x3
  __int64 v3; // x4
  __int64 v4; // x1
  unsigned __int64 v5; // x19

  v1 = *(_QWORD *)(result + 1200);
  if ( v1 )
  {
    v2 = *(_QWORD *)result + *(_QWORD *)(result + 1192);
    v3 = v2 & -dl_pagesize;
    v4 = (v1 + v2) & -dl_pagesize;
    if ( v3 != v4 )
    {
      v5 = result;
      result = mprotect((void *)(v2 & -dl_pagesize), v4 - v3, 1);
      if ( (result & 0x80000000) != 0 )
        dl_signal_error(
          *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40),
          *(_QWORD *)(v5 + 8),
          0LL,
          "cannot apply additional memory protection after relocation");
    }
  }
  return result;
}
// 490F10: using guessed type __int64 dl_pagesize;

//----- (000000000043E5B0) ----------------------------------------------------
void __fastcall __noreturn dl_reloc_bad_type(__int64 a1, unsigned int a2, int a3)
{
  unsigned __int64 v4; // x19
  char *v5; // x0
  char v6; // w2
  __int64 v7; // x1
  _QWORD v8[5]; // [xsp+38h] [xbp+38h] BYREF

  v4 = a2;
  v5 = stpcpy(v8, (unsigned __int64)&msg_0[38 * a3]);
  if ( (unsigned int)v4 > 0xFF )
  {
    v5 += 6;
    *(v5 - 6) = itoa_lower_digits[(unsigned int)v4 >> 28];
    *(v5 - 5) = itoa_lower_digits[(v4 >> 24) & 0xF];
    *(v5 - 4) = itoa_lower_digits[(v4 >> 20) & 0xF];
    *(v5 - 3) = itoa_lower_digits[(v4 >> 16) & 0xF];
    *(v5 - 2) = itoa_lower_digits[(unsigned __int16)v4 >> 12];
    *(v5 - 1) = itoa_lower_digits[(v4 >> 8) & 0xF];
  }
  v5[2] = 0;
  v6 = itoa_lower_digits[(unsigned __int8)v4 >> 4];
  v5[1] = itoa_lower_digits[v4 & 0xF];
  v7 = *(_QWORD *)(a1 + 8);
  *v5 = v6;
  dl_signal_error(0, v7, 0LL, (const char *)v8);
}

//----- (000000000043E680) ----------------------------------------------------
unsigned __int64 __fastcall dl_relocate_object_no_relro(
        __int64 a1,
        void ***a2,
        int a3,
        int a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  int v16; // w19
  int v17; // w22
  __int64 v19; // x26
  __int64 (__fastcall *v20)(__int64); // x28
  __int64 *v21; // x6
  __int64 v22; // x1
  __int64 *v23; // x23
  __int64 v24; // x4
  int v25; // w0
  char *v26; // x1
  char *v27; // x2
  char *v28; // x5
  __int64 v29; // x4
  unsigned __int64 v30; // x0
  unsigned __int64 v31; // x0
  _QWORD *v32; // x1
  __int64 v33; // x3
  __int64 v34; // x1
  __int64 v35; // x2
  __int64 v36; // x2
  __int64 v37; // x0
  __int64 v38; // x5
  __int64 (__fastcall *v39)(__int64); // x5
  __int64 *v40; // x27
  __int64 v41; // x23
  int v42; // w26
  __int64 *v43; // x0
  __int64 v44; // x22
  unsigned __int64 v45; // x24
  __int64 *v46; // x21
  __int64 (__fastcall *v47)(__int64); // x22
  unsigned __int64 v48; // x1
  __int64 (__fastcall **v49)(__int64); // x20
  __int64 (__fastcall *v50)(__int64); // x0
  __int64 v51; // x1
  unsigned __int64 v52; // x1
  unsigned __int64 v53; // x0
  int8x16_t *(__fastcall *v54)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  unsigned __int64 result; // x0
  __int64 v56; // x2
  __int64 v57; // x0
  __int64 v58; // x20
  __int64 v59; // x28
  __int64 *v60; // x23
  __int64 *v61; // x26
  __int64 v62; // x1
  unsigned __int64 v63; // x27
  __int64 (__fastcall **v64)(__int64); // x19
  unsigned int *v65; // x21
  __int16 v66; // w0
  unsigned int v67; // w1
  int v68; // w5
  char v69; // w3
  __int64 v70; // x2
  __int64 v71; // x4
  __int64 v72; // x0
  __int64 v73; // x1
  const char *v74; // x0
  __int64 v75; // x0
  __int64 v76; // x2
  int v77; // w2
  __int64 *v78; // x5
  int v79; // w1
  bool v80; // zf
  __int64 v81; // x1
  __int64 v82; // x0
  __int64 v83; // x2
  __int64 *v84; // x0
  __int64 v85; // x4
  unsigned int *v86; // x2
  unsigned int v87; // w3
  char *v88; // x0
  __int64 v89; // x1
  const char *v90; // x0
  __int64 v91; // x0
  __int64 v92; // x0
  unsigned int *v93; // x0
  char v94; // w2
  __int64 v95; // x1
  __int64 v96; // x0
  const char *v97; // x0
  _QWORD *v98; // x1
  __int64 (__fastcall *v99)(__int64, __int64 *); // x2
  __int64 (__fastcall *v100)(__int64); // x2
  __int64 *v101; // x1
  const char *v102; // x3
  __int64 v103; // x1
  __int64 v104; // x0
  __int64 v105; // x1
  unsigned __int64 v106; // x2
  unsigned __int64 v107; // x0
  __int64 v108; // x2
  const char *v109; // x2
  const char *v110; // x1
  bool v111; // cf
  int v112; // w0
  void (__fastcall *v113)(__int64, __int64 *); // x2
  bool v114; // zf
  __int64 v115; // x1
  __int64 v116; // x0
  __int64 v117; // x1
  __int64 v118; // x26
  __int64 *v119; // x23
  __int64 *v120; // x19
  __int64 v121; // x0
  __int64 v122; // x21
  __int64 (__fastcall **v123)(__int64); // x28
  unsigned int v124; // w20
  unsigned int *v125; // x27
  unsigned int v126; // w1
  int v127; // w5
  __int64 v128; // x14
  char v129; // w2
  __int64 v130; // x0
  __int64 v131; // x1
  __int64 v132; // x0
  __int64 v133; // x2
  __int64 (__fastcall *v134)(__int64); // x5
  int v135; // w1
  bool v136; // zf
  __int64 v137; // x1
  __int64 v138; // x0
  __int64 (__fastcall *v139)(__int64); // x2
  __int64 *v140; // x1
  const char *v141; // x3
  __int64 v142; // x0
  __int64 v143; // x1
  __int64 v144; // x0
  __int64 v145; // x1
  unsigned __int64 v146; // x2
  unsigned __int64 v147; // x0
  __int64 v148; // x2
  const char *v149; // x2
  const char *v150; // x1
  int v151; // w1
  bool v152; // cf
  unsigned __int64 v153; // x1
  unsigned int v154; // w2
  unsigned __int64 i; // x20
  unsigned __int64 v156; // x3
  __int64 v157; // x0
  size_t v158; // x1
  void *v159; // x0
  __int64 v160; // x2
  const char *v161; // x1
  const char *v162; // x2
  bool v163; // zf
  __int64 (__fastcall *v164)(__int64); // x2
  const char *v165; // x1
  const char *v166; // x3
  _QWORD v167[2]; // [xsp+0h] [xbp-20h] BYREF
  int v168; // [xsp+10h] [xbp-10h]
  __int64 (__fastcall *v169)(__int64); // [xsp+18h] [xbp-8h]
  __int64 v170; // [xsp+80h] [xbp+60h]
  __int64 *v171; // [xsp+88h] [xbp+68h]
  __int64 *v172; // [xsp+90h] [xbp+70h]
  __int64 *v173; // [xsp+98h] [xbp+78h]
  __int64 (__fastcall *v174)(_QWORD); // [xsp+A0h] [xbp+80h]
  __int64 (__fastcall *v175)(__int64); // [xsp+A8h] [xbp+88h]
  __int64 (__fastcall *v176)(__int64); // [xsp+B0h] [xbp+90h]
  __int64 (__fastcall *v177)(__int64); // [xsp+B8h] [xbp+98h]
  __int64 (__fastcall *v178)(__int64); // [xsp+C0h] [xbp+A0h]
  __int64 *v179; // [xsp+C8h] [xbp+A8h]
  int v180; // [xsp+D0h] [xbp+B0h]
  int v181; // [xsp+D4h] [xbp+B4h]
  __int64 *v182; // [xsp+D8h] [xbp+B8h]
  void ***v183; // [xsp+E0h] [xbp+C0h]
  __int64 *v184; // [xsp+E8h] [xbp+C8h]
  unsigned int *v185; // [xsp+F0h] [xbp+D0h] BYREF
  __int64 v186; // [xsp+F8h] [xbp+D8h] BYREF
  __int64 v187; // [xsp+100h] [xbp+E0h]
  __int64 v188; // [xsp+108h] [xbp+E8h]
  __int128 v189; // [xsp+110h] [xbp+F0h] BYREF
  __int128 v190; // [xsp+120h] [xbp+100h]
  __int128 v191; // [xsp+130h] [xbp+110h]
  __int128 v192; // [xsp+140h] [xbp+120h]

  v16 = a4;
  v17 = a3 & 1;
  v19 = a1;
  v183 = a2;
  if ( !a4 )
    v17 = (unsigned __int8)v17 & (*(_QWORD *)(a1 + 256) == 0LL);
  if ( (dl_debug_mask & 0x20) != 0 )
  {
    v161 = *(const char **)(a1 + 8);
    if ( !*v161 )
    {
      v161 = (const char *)program_invocation_short_name[0];
      if ( !program_invocation_short_name[0] )
        v161 = "<main program>";
    }
    v162 = (const char *)&qword_454610;
    if ( v17 )
      v162 = " (lazy)";
    dl_debug_printf("\nrelocation processing: %s%s\n", v161, v162);
  }
  v20 = *(__int64 (__fastcall **)(__int64))(v19 + 240);
  if ( v20 )
  {
    v153 = *(_QWORD *)(v19 + 752);
    v154 = *(unsigned __int16 *)(v19 + 768);
    v20 = 0LL;
    for ( i = v153; i < v153 + 56LL * v154; i += 56LL )
    {
      if ( *(_DWORD *)i == 1 )
      {
        v156 = *(unsigned int *)(i + 4);
        if ( (v156 & 2) == 0 )
        {
          v157 = *(_QWORD *)(i + 16);
          v158 = ((v157 + *(_QWORD *)(i + 40) + dl_pagesize - 1) & -dl_pagesize) - (v157 & -dl_pagesize);
          v159 = (void *)((v157 & -dl_pagesize) + *(_QWORD *)v19);
          v167[0] = v159;
          v167[1] = v158;
          v160 = (v156 >> 2) & 1;
          if ( (v156 & 1) != 0 )
            LODWORD(v160) = v160 | 4;
          v168 = v160;
          if ( (mprotect(v159, v158, (unsigned int)v160 | 2) & 0x80000000) != 0 )
          {
            v166 = "cannot make segment writable for relocation";
            goto LABEL_382;
          }
          v153 = *(_QWORD *)(v19 + 752);
          v169 = v20;
          v154 = *(unsigned __int16 *)(v19 + 768);
          v20 = (__int64 (__fastcall *)(__int64))v167;
        }
      }
    }
  }
  v21 = *(__int64 **)(v19 + 248);
  v181 = a3 & 0x2000000;
  if ( ((v21 != 0LL) & (unsigned __int8)v17) != 0 )
  {
    v116 = *(_QWORD *)(*(_QWORD *)(v19 + 88) + 8LL);
    if ( (*(_BYTE *)(v19 + 870) & 0x20) != 0 )
      v116 += *(_QWORD *)v19;
    v117 = *(_QWORD *)(v116 + 8);
    if ( v117 )
      *(_QWORD *)(v19 + 1072) = *(_QWORD *)v19 + v117;
    *(_QWORD *)(v116 + 8) = v19;
    *(_QWORD *)(v116 + 16) = dl_runtime_resolve;
  }
  v22 = *(_QWORD *)(v19 + 352);
  v23 = *(__int64 **)v19;
  v24 = *(_BYTE *)(v19 + 870) & 0x20;
  v25 = *(_BYTE *)(v19 + 870) & 0x20;
  if ( v22 )
  {
    v26 = *(char **)(v22 + 8);
    v27 = (char *)v23 + (_QWORD)v26;
    if ( (*(_BYTE *)(v19 + 870) & 0x20) == 0 )
      v27 = v26;
    v28 = &v27[*(_QWORD *)(*(_QWORD *)(v19 + 344) + 8LL)];
    if ( v27 < v28 )
    {
      v29 = 0LL;
      do
      {
        while ( 1 )
        {
          v30 = *(_QWORD *)v27;
          if ( (*(_QWORD *)v27 & 1) != 0 )
            break;
          v27 += 8;
          v29 = (__int64)v23 + v30 + 8;
          *(__int64 *)((char *)v23 + v30) += (__int64)v23;
          if ( v28 <= v27 )
            goto LABEL_20;
        }
        v31 = v30 >> 1;
        v32 = (_QWORD *)v29;
        if ( v31 )
        {
          while ( (v31 & 1) == 0 )
          {
            v31 >>= 1;
            ++v32;
LABEL_17:
            ;
          }
          v31 >>= 1;
          *v32 += v23;
          if ( v31 )
          {
            ++v32;
            goto LABEL_17;
          }
        }
        v27 += 8;
        v29 += 504LL;
      }
      while ( v28 > v27 );
LABEL_20:
      v23 = *(__int64 **)v19;
      v24 = *(_BYTE *)(v19 + 870) & 0x20;
      v25 = *(_BYTE *)(v19 + 870) & 0x20;
    }
  }
  v33 = 0LL;
  v34 = *(_QWORD *)(v19 + 120);
  v189 = 0u;
  v190 = 0u;
  v191 = 0u;
  v192 = 0u;
  if ( v34 )
  {
    v34 = *(_QWORD *)(v34 + 8);
    v33 = 0LL;
    if ( v34 )
    {
      if ( v25 )
        v34 += (__int64)v23;
      v33 = *(_QWORD *)(*(_QWORD *)(v19 + 128) + 8LL);
      v35 = *(_QWORD *)(v19 + 464);
      *(_QWORD *)&v189 = v34;
      *((_QWORD *)&v189 + 1) = v33;
      if ( v35 )
        *(_QWORD *)&v190 = *(_QWORD *)(v35 + 8);
    }
  }
  if ( !*(_QWORD *)(v19 + 224) )
    goto LABEL_35;
  v80 = v25 == 0;
  v36 = v21[1];
  v37 = *(_QWORD *)(*(_QWORD *)(v19 + 80) + 8LL);
  if ( !v80 )
    v36 += (__int64)v23;
  if ( !v34 )
    v34 = v36;
  v21 = (__int64 *)(v37 + v36);
  v38 = v34 + v33;
  *(_QWORD *)&v189 = v34;
  if ( v34 + v33 == v37 + v36 )
  {
    v33 -= v37;
    *((_QWORD *)&v189 + 1) = v33;
    v38 = v33 + v34;
    if ( v17 )
      goto LABEL_34;
  }
  else if ( v17 )
  {
    goto LABEL_34;
  }
  if ( v36 == v38 )
  {
    *((_QWORD *)&v189 + 1) = v37 + v33;
    goto LABEL_35;
  }
LABEL_34:
  *(_QWORD *)&v191 = v36;
  *((_QWORD *)&v191 + 1) = v37;
  DWORD2(v192) = v17;
LABEL_35:
  v39 = (__int64 (__fastcall *)(__int64))&v189;
  v40 = v23;
  v41 = v19;
  v42 = 0;
  v182 = (__int64 *)&v185;
  while ( 1 )
  {
    v43 = *(__int64 **)v39;
    v44 = *(_QWORD *)(*(_QWORD *)(v41 + 112) + 8LL);
    v45 = *(_QWORD *)v39 + *((_QWORD *)v39 + 1);
    v46 = (__int64 *)(*(_QWORD *)v39 + 24LL * *((_QWORD *)v39 + 2));
    if ( (_DWORD)v24 )
      v44 += (__int64)v40;
    if ( *((_DWORD *)v39 + 6) )
    {
      v47 = v39;
      if ( (unsigned __int64)v46 >= v45 )
        goto LABEL_49;
      while ( 1 )
      {
        v48 = v46[1];
        v49 = (__int64 (__fastcall **)(__int64))((char *)v40 + *v46);
        if ( (_DWORD)v48 != 1026 )
          break;
        if ( *(_QWORD *)(v41 + 408) )
        {
          v33 = HIDWORD(v48);
          v21 = 0LL;
          v92 = *(_QWORD *)(*(_QWORD *)(v41 + 112) + 8LL);
          if ( (*(_BYTE *)(v41 + 870) & 0x20) != 0 )
          {
            v21 = *(__int64 **)v41;
            v92 += *(_QWORD *)v41;
          }
          v93 = (unsigned int *)(v92 + 24LL * HIDWORD(v48));
          v94 = *((_BYTE *)v93 + 5);
          if ( v94 < 0 )
          {
            v24 = *(_QWORD *)(v41 + 536);
            if ( v24 )
              v24 = *(_QWORD *)(v41 + 816) + 24LL * (*(_WORD *)((_BYTE *)v21 + 2 * v33 + *(_QWORD *)(v24 + 8)) & 0x7FFF);
            v185 = v93;
            v33 = *((unsigned __int8 *)v93 + 4);
            if ( (unsigned int)v33 >> 4 && (v94 & 3u) - 1 > 1 )
            {
              if ( v93 == *(unsigned int **)(v41 + 1096) && *(_DWORD *)(v41 + 1104) == 1 )
              {
                v93 = *(unsigned int **)(v41 + 1120);
                v185 = v93;
                v98 = *(_QWORD **)(v41 + 1112);
              }
              else
              {
                v95 = *(_QWORD *)(*(_QWORD *)(v41 + 104) + 8LL);
                *(_QWORD *)(v41 + 1096) = v93;
                v96 = *v93;
                *(_DWORD *)(v41 + 1104) = 1;
                v97 = (char *)v21 + v95 + v96;
                if ( v24 && !*(_DWORD *)(v24 + 8) )
                  v24 = 0LL;
                v98 = (_QWORD *)dl_lookup_symbol_x(
                                  v97,
                                  v41,
                                  (__int64 *)&v185,
                                  v183,
                                  (const char **)v24,
                                  1,
                                  9,
                                  0LL,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  a9,
                                  a10,
                                  a11,
                                  a12);
                v93 = v185;
                *(_QWORD *)(v41 + 1112) = v98;
                *(_QWORD *)(v41 + 1120) = v93;
              }
              v99 = 0LL;
              if ( !v93 )
                goto LABEL_144;
              LOBYTE(v33) = *((_BYTE *)v93 + 4);
            }
            else
            {
              v98 = (_QWORD *)v41;
            }
            v24 = *((unsigned __int16 *)v93 + 3);
            v33 &= 0xFu;
            v99 = (__int64 (__fastcall *)(__int64, __int64 *))*((_QWORD *)v93 + 1);
            if ( (_DWORD)v24 == 65521 )
            {
              if ( (_DWORD)v33 != 10 )
              {
LABEL_144:
                *v49 = (__int64 (__fastcall *)(__int64))((char *)v99 + v46[2]);
                goto LABEL_42;
              }
            }
            else
            {
              if ( *((_WORD *)v93 + 3) )
                v163 = (_DWORD)v33 == 10;
              else
                v163 = 0;
              v99 = (__int64 (__fastcall *)(__int64, __int64 *))((char *)v99 + *v98);
              if ( !v163 )
                goto LABEL_144;
            }
            if ( !v181 )
            {
              v186 = 24LL;
              v188 = dl_hwcap2;
              v187 = dl_hwcap;
              v99 = (__int64 (__fastcall *)(__int64, __int64 *))v99(dl_hwcap | 0x4000000000000000LL, &v186);
            }
            goto LABEL_144;
          }
        }
        v50 = *(__int64 (__fastcall **)(__int64))(v41 + 1072);
        if ( v50 )
        {
          *v49 = v50;
LABEL_47:
          v46 += 3;
          if ( v45 <= (unsigned __int64)v46 )
          {
LABEL_48:
            v39 = v47;
            goto LABEL_49;
          }
        }
        else
        {
          *v49 = (__int64 (__fastcall *)(__int64))((char *)v40 + (_QWORD)*v49);
LABEL_42:
          v46 += 3;
          if ( v45 <= (unsigned __int64)v46 )
            goto LABEL_48;
        }
      }
      if ( (_DWORD)v48 != 1031 )
      {
        if ( (_DWORD)v48 != 1032 )
          dl_reloc_bad_type(v41, v48, 1);
        v164 = (__int64 (__fastcall *)(__int64))(*(_QWORD *)v41 + v46[2]);
        if ( !v181 )
        {
          v186 = 24LL;
          v188 = dl_hwcap2;
          v187 = dl_hwcap;
          v164 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *))v164)(
                                                    dl_hwcap | 0x4000000000000000LL,
                                                    &v186);
        }
        *v49 = v164;
        goto LABEL_42;
      }
      v83 = *(_QWORD *)(*(_QWORD *)(v41 + 112) + 8LL);
      v84 = 0LL;
      if ( (*(_BYTE *)(v41 + 870) & 0x20) != 0 )
      {
        v84 = *(__int64 **)v41;
        v83 += *(_QWORD *)v41;
      }
      v85 = *(_QWORD *)(v41 + 536);
      v86 = (unsigned int *)(v83 + 24LL * HIDWORD(v48));
      if ( v85 )
        v85 = *(_QWORD *)(v41 + 816)
            + 24LL * (*(_WORD *)((_BYTE *)v84 + 2 * HIDWORD(v48) + *(_QWORD *)(v85 + 8)) & 0x7FFF);
      v185 = v86;
      v87 = *((unsigned __int8 *)v86 + 4);
      if ( !(v87 >> 4) || (*((_BYTE *)v86 + 5) & 3u) - 1 <= 1 )
      {
        v24 = v41;
        goto LABEL_191;
      }
      if ( v86 == *(unsigned int **)(v41 + 1096) && (v33 = *(unsigned int *)(v41 + 1104), (_DWORD)v33 == 1) )
      {
        v86 = *(unsigned int **)(v41 + 1120);
        v185 = v86;
        v24 = *(_QWORD *)(v41 + 1112);
        if ( v86 )
        {
LABEL_190:
          LOBYTE(v87) = *((_BYTE *)v86 + 4);
LABEL_191:
          v112 = *((unsigned __int16 *)v86 + 3);
          v33 = v87 & 0xF;
          v113 = (void (__fastcall *)(__int64, __int64 *))*((_QWORD *)v86 + 1);
          if ( v112 == 65521 )
          {
            if ( (_DWORD)v33 != 10 )
              goto LABEL_196;
          }
          else
          {
            if ( v112 )
              v114 = (_DWORD)v33 == 10;
            else
              v114 = 0;
            if ( !v114 )
            {
LABEL_196:
              v115 = *(_QWORD *)(v24 + 1168);
              if ( (unsigned __int64)(v115 + 1) <= 1 )
              {
                v184 = (__int64 *)v24;
                dl_allocate_static_tls(v24);
                v24 = (__int64)v184;
                v115 = v184[146];
              }
              v49[1] = (__int64 (__fastcall *)(__int64))(*((_QWORD *)v185 + 1) + v46[2] + v115);
              *v49 = dl_tlsdesc_return;
              goto LABEL_42;
            }
            v113 = (void (__fastcall *)(__int64, __int64 *))((char *)v113 + *(_QWORD *)v24);
          }
          if ( v181 )
            goto LABEL_196;
          v186 = 24LL;
          v184 = (__int64 *)v24;
          v188 = dl_hwcap2;
          v187 = dl_hwcap;
          v113(dl_hwcap | 0x4000000000000000LL, &v186);
          v24 = (__int64)v184;
          if ( v185 )
            goto LABEL_196;
        }
      }
      else
      {
        v88 = (char *)v84 + *(_QWORD *)(*(_QWORD *)(v41 + 104) + 8LL);
        v89 = *v86;
        *(_QWORD *)(v41 + 1096) = v86;
        *(_DWORD *)(v41 + 1104) = 1;
        v90 = &v88[v89];
        if ( v85 && !*(_DWORD *)(v85 + 8) )
          v85 = 0LL;
        v91 = dl_lookup_symbol_x(
                v90,
                v41,
                (__int64 *)&v185,
                v183,
                (const char **)v85,
                1,
                9,
                0LL,
                a5,
                a6,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12);
        *(_QWORD *)(v41 + 1112) = v91;
        v86 = v185;
        *(_QWORD *)(v41 + 1120) = v185;
        v24 = v91;
        if ( v86 )
          goto LABEL_190;
      }
      v49[1] = (__int64 (__fastcall *)(__int64))v46[2];
      *v49 = dl_tlsdesc_undefweak;
      goto LABEL_47;
    }
    while ( v46 > v43 )
    {
      v56 = *v43;
      v43 += 3;
      *(__int64 *)((char *)v40 + v56) = (__int64)v40 + *(v43 - 1);
    }
    v57 = *(_QWORD *)(v41 + 536);
    if ( !v57 )
      break;
    v58 = *(_QWORD *)(v57 + 8);
    if ( (*(_BYTE *)(v41 + 870) & 0x20) != 0 )
      v58 += *(_QWORD *)v41;
    if ( (unsigned __int64)v46 >= v45 )
      goto LABEL_49;
    v179 = &dl_hwcap;
    v175 = v20;
    v176 = v39;
    v59 = v41;
    v60 = v46;
    v180 = v42;
    v61 = v40;
    LODWORD(v174) = v16;
    v178 = (__int64 (__fastcall *)(__int64))&dl_hwcap2;
    v177 = dl_tlsdesc_return;
    do
    {
      v62 = *v60;
      v63 = v60[1];
      LODWORD(v184) = v63;
      v24 = *(_QWORD *)(v59 + 816);
      v64 = (__int64 (__fastcall **)(__int64))((char *)v61 + v62);
      v65 = (unsigned int *)(v44 + 24LL * HIDWORD(v63));
      v66 = *(_WORD *)(v58 + 2 * HIDWORD(v63));
      v185 = v65;
      if ( (_DWORD)v63 == 1027 )
      {
        *(__int64 *)((char *)v61 + v62) = *(_QWORD *)v59 + v60[2];
        goto LABEL_101;
      }
      if ( !(_DWORD)v63 )
        goto LABEL_101;
      v67 = *((unsigned __int8 *)v65 + 4);
      if ( v67 >> 4 && (*((_BYTE *)v65 + 5) & 3u) - 1 > 1 )
      {
        if ( v65 != *(unsigned int **)(v59 + 1096) )
        {
          v68 = 1;
          if ( (unsigned int)v63 != 1026LL )
          {
            if ( (unsigned int)v63 > 0x402uLL )
              v68 = (unsigned __int64)(unsigned int)v63 - 1028 <= 3;
            else
              v68 = 2 * ((unsigned int)v63 == 1024LL);
          }
          goto LABEL_73;
        }
        v77 = *(_DWORD *)(v59 + 1104);
        if ( (unsigned int)v63 == 1026LL )
        {
          v68 = 1;
          if ( v77 == 1 )
          {
LABEL_88:
            v76 = *(_QWORD *)(v59 + 1120);
            v185 = (unsigned int *)v76;
            v33 = *(_QWORD *)(v59 + 1112);
            if ( !v76 )
              goto LABEL_81;
            goto LABEL_89;
          }
LABEL_73:
          v69 = *(_BYTE *)(v59 + 870);
          v70 = *(_QWORD *)(*(_QWORD *)(v59 + 104) + 8LL);
          v71 = v24 + 24LL * (v66 & 0x7FFF);
          v72 = *v65;
          v73 = 0LL;
          *(_QWORD *)(v59 + 1096) = v65;
          *(_DWORD *)(v59 + 1104) = v68;
          if ( (v69 & 0x20) != 0 )
            v73 = *(_QWORD *)v59;
          v74 = (const char *)(v72 + v70 + v73);
          if ( v71 && !*(_DWORD *)(v71 + 8) )
            v71 = 0LL;
          v75 = dl_lookup_symbol_x(
                  v74,
                  v59,
                  v182,
                  v183,
                  (const char **)v71,
                  v68,
                  9,
                  0LL,
                  a5,
                  a6,
                  a7,
                  a8,
                  a9,
                  a10,
                  a11,
                  a12);
          *(_QWORD *)(v59 + 1112) = v75;
          v76 = (__int64)v185;
          *(_QWORD *)(v59 + 1120) = v185;
          v33 = v75;
          if ( !v76 )
          {
LABEL_79:
            if ( (_DWORD)v63 == 1029 )
              goto LABEL_101;
            if ( (unsigned int)v63 <= 0x405 )
            {
LABEL_81:
              if ( (unsigned int)v63 > 0x402 )
                goto LABEL_109;
              if ( (unsigned int)v63 > 0x400 )
                goto LABEL_168;
              if ( (unsigned int)v63 <= 0x102 )
              {
                if ( (unsigned int)v63 <= 0x100 )
                  goto LABEL_85;
LABEL_168:
                v78 = 0LL;
LABEL_100:
                *v64 = (__int64 (__fastcall *)(__int64))((char *)v78 + v60[2]);
                goto LABEL_101;
              }
              if ( (_DWORD)v63 != 1024 )
                goto LABEL_85;
              goto LABEL_101;
            }
LABEL_146:
            if ( (_DWORD)v63 == 1031 )
              goto LABEL_209;
            if ( (_DWORD)v63 == 1032 )
            {
LABEL_148:
              v100 = (__int64 (__fastcall *)(__int64))(*(_QWORD *)v59 + v60[2]);
              if ( !v181 )
              {
                v24 = (__int64)v178;
                v21 = v179;
                v101 = &v186;
                goto LABEL_150;
              }
              goto LABEL_151;
            }
            if ( (_DWORD)v63 != 1030 )
LABEL_85:
              dl_reloc_bad_type(v59, (unsigned int)v184, 0);
            goto LABEL_101;
          }
        }
        else
        {
          if ( (unsigned int)v63 <= 0x402uLL )
          {
            if ( (unsigned int)v63 == 1024LL )
            {
              v68 = 2;
              if ( v77 == 2 )
                goto LABEL_88;
            }
            else
            {
              v68 = 0;
              if ( !v77 )
                goto LABEL_88;
            }
            goto LABEL_73;
          }
          if ( (unsigned __int64)(unsigned int)v63 - 1028 > 3 )
          {
            v68 = 0;
            if ( v77 )
              goto LABEL_73;
            v76 = *(_QWORD *)(v59 + 1120);
            v185 = (unsigned int *)v76;
            if ( !v76 )
              goto LABEL_146;
            v33 = *(_QWORD *)(v59 + 1112);
          }
          else
          {
            v68 = 1;
            if ( v77 != 1 )
              goto LABEL_73;
            v76 = *(_QWORD *)(v59 + 1120);
            v185 = (unsigned int *)v76;
            v33 = *(_QWORD *)(v59 + 1112);
            if ( !v76 )
              goto LABEL_79;
          }
        }
LABEL_89:
        v24 = *(unsigned __int16 *)(v76 + 6);
        v78 = *(__int64 **)(v76 + 8);
        v79 = *(_BYTE *)(v76 + 4) & 0xF;
        if ( (_DWORD)v24 == 65521 )
          goto LABEL_105;
        goto LABEL_90;
      }
      v33 = v59;
      v79 = v67 & 0xF;
      v24 = *((unsigned __int16 *)v65 + 3);
      v78 = (__int64 *)*((_QWORD *)v65 + 1);
      if ( (_DWORD)v24 == 65521 )
      {
LABEL_105:
        if ( v79 != 10 )
          goto LABEL_106;
        goto LABEL_169;
      }
LABEL_90:
      if ( (_DWORD)v24 )
        v80 = v79 == 10;
      else
        v80 = 0;
      v78 = (__int64 *)((char *)v78 + *(_QWORD *)v33);
      if ( !v80 )
      {
        if ( (_DWORD)v63 == 1029 )
          goto LABEL_156;
        if ( (unsigned int)v63 <= 0x405 )
        {
          if ( (unsigned int)v63 > 0x402 )
            goto LABEL_110;
LABEL_97:
          if ( (unsigned int)v63 > 0x400 )
            goto LABEL_100;
          if ( (unsigned int)v63 <= 0x102 )
            goto LABEL_99;
          if ( (_DWORD)v63 != 1024 )
            goto LABEL_85;
          v105 = (__int64)v185;
LABEL_160:
          v106 = *(_QWORD *)(v105 + 16);
          v107 = *((_QWORD *)v65 + 2);
          if ( v106 > v107 || ((_DWORD)dl_verbose ? (v111 = v106 >= v107) : (v111 = 1), !v111) )
          {
            v108 = *(_QWORD *)(*(_QWORD *)(v59 + 104) + 8LL);
            if ( (*(_BYTE *)(v59 + 870) & 0x20) != 0 )
              v108 += *(_QWORD *)v59;
            v184 = v78;
            v109 = (const char *)(v108 + *v65);
            v110 = (const char *)program_invocation_short_name[0];
            if ( !program_invocation_short_name[0] )
              v110 = "<program name unknown>";
            dl_error_printf("%s: Symbol `%s' has different size in shared object, consider re-linking\n", v110, v109);
          }
          j_memcpy();
          goto LABEL_101;
        }
        goto LABEL_111;
      }
LABEL_169:
      if ( v181 )
      {
LABEL_106:
        if ( (_DWORD)v63 == 1029 )
          goto LABEL_156;
        if ( (unsigned int)v63 <= 0x405 )
        {
          if ( (unsigned int)v63 > 0x402 )
            goto LABEL_109;
          goto LABEL_97;
        }
LABEL_111:
        if ( (_DWORD)v63 != 1031 )
        {
          if ( (_DWORD)v63 == 1032 )
            goto LABEL_148;
LABEL_113:
          if ( (_DWORD)v63 != 1030 )
            goto LABEL_85;
          v81 = (__int64)v185;
          if ( v185 )
          {
            v82 = *(_QWORD *)(v33 + 1168);
            if ( (unsigned __int64)(v82 + 1) <= 1 )
            {
              v184 = (__int64 *)v33;
              dl_allocate_static_tls(v33);
              v33 = (__int64)v184;
              v81 = (__int64)v185;
              v82 = v184[146];
            }
            *v64 = (__int64 (__fastcall *)(__int64))(v82 + v60[2] + *(_QWORD *)(v81 + 8));
          }
          goto LABEL_101;
        }
LABEL_152:
        v103 = (__int64)v185;
        if ( !v185 )
        {
LABEL_209:
          v64[1] = (__int64 (__fastcall *)(__int64))v60[2];
          *v64 = dl_tlsdesc_undefweak;
          goto LABEL_101;
        }
        v104 = *(_QWORD *)(v33 + 1168);
        if ( (unsigned __int64)(v104 + 1) <= 1 )
        {
          v184 = (__int64 *)v33;
          dl_allocate_static_tls(v33);
          v33 = (__int64)v184;
          v103 = (__int64)v185;
          v104 = v184[146];
        }
        v64[1] = (__int64 (__fastcall *)(__int64))(v104 + v60[2] + *(_QWORD *)(v103 + 8));
        *v64 = v177;
        goto LABEL_101;
      }
      v186 = 24LL;
      v170 = v33;
      v171 = &dl_hwcap;
      v188 = dl_hwcap2;
      v172 = &dl_hwcap2;
      v173 = &v186;
      v187 = dl_hwcap;
      v78 = (__int64 *)((__int64 (__fastcall *)(__int64))v78)(dl_hwcap | 0x4000000000000000LL);
      if ( (_DWORD)v63 == 1029 )
      {
LABEL_156:
        if ( v185 )
          *v64 = (__int64 (__fastcall *)(__int64))(*((_QWORD *)v185 + 1) + v60[2]);
        goto LABEL_101;
      }
      v33 = v170;
      v21 = v171;
      v24 = (__int64)v172;
      v101 = v173;
      if ( (unsigned int)v63 > 0x405 )
      {
        if ( (_DWORD)v63 != 1031 )
        {
          if ( (_DWORD)v63 == 1032 )
          {
            v100 = (__int64 (__fastcall *)(__int64))(v60[2] + *(_QWORD *)v59);
LABEL_150:
            v102 = *(const char **)v24;
            v186 = 24LL;
            v187 = *v21;
            v188 = (__int64)v102;
            v100 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *))v100)(
                                                      v187 | 0x4000000000000000LL,
                                                      v101);
LABEL_151:
            *v64 = v100;
            goto LABEL_101;
          }
          goto LABEL_113;
        }
        goto LABEL_152;
      }
      if ( (unsigned int)v63 > 0x402 )
      {
LABEL_109:
        if ( !v33 )
          goto LABEL_101;
LABEL_110:
        *v64 = *(__int64 (__fastcall **)(__int64))(v33 + 1176);
        goto LABEL_101;
      }
      if ( (unsigned int)v63 > 0x400 )
        goto LABEL_100;
      if ( (unsigned int)v63 <= 0x102 )
      {
LABEL_99:
        if ( (unsigned int)v63 <= 0x100 )
          goto LABEL_85;
        goto LABEL_100;
      }
      if ( (_DWORD)v63 != 1024 )
        goto LABEL_85;
      v105 = (__int64)v185;
      if ( v185 )
        goto LABEL_160;
LABEL_101:
      v60 += 3;
    }
    while ( v45 > (unsigned __int64)v60 );
    v41 = v59;
    v16 = (int)v174;
    v20 = v175;
    v39 = v176;
    if ( v180 )
      goto LABEL_50;
LABEL_103:
    v39 = (__int64 (__fastcall *)(__int64))((char *)v39 + 32);
    v40 = *(__int64 **)v41;
    v24 = *(_BYTE *)(v41 + 870) & 0x20;
    v42 = 1;
  }
  if ( (unsigned __int64)v46 < v45 )
  {
    LODWORD(v175) = v42;
    v118 = v41;
    v119 = v40;
    v180 = v16;
    v120 = v46;
    v184 = &dl_hwcap;
    v176 = v20;
    v177 = v39;
    v179 = &dl_hwcap2;
    v178 = dl_tlsdesc_return;
    while ( 1 )
    {
      v121 = *v120;
      v122 = v120[1];
      v123 = (__int64 (__fastcall **)(__int64))((char *)v119 + *v120);
      v124 = v122;
      v125 = (unsigned int *)(v44 + 24LL * HIDWORD(v122));
      v185 = v125;
      if ( (_DWORD)v122 == 1027 )
        goto LABEL_249;
      while ( !(_DWORD)v122 )
      {
        while ( 1 )
        {
LABEL_247:
          v120 += 3;
          if ( v45 <= (unsigned __int64)v120 )
          {
LABEL_231:
            v41 = v118;
            v16 = v180;
            v20 = v176;
            v39 = v177;
            v42 = (int)v175;
            goto LABEL_49;
          }
          v121 = *v120;
          v122 = v120[1];
          v123 = (__int64 (__fastcall **)(__int64))((char *)v119 + *v120);
          v124 = v122;
          v125 = (unsigned int *)(v44 + 24LL * HIDWORD(v122));
          v185 = v125;
          if ( (_DWORD)v122 != 1027 )
            break;
LABEL_249:
          *(__int64 *)((char *)v119 + v121) = *(_QWORD *)v118 + v120[2];
        }
      }
      v126 = *((unsigned __int8 *)v125 + 4);
      if ( !(v126 >> 4) || (*((_BYTE *)v125 + 5) & 3u) - 1 <= 1 )
      {
        v33 = v118;
        v135 = v126 & 0xF;
        v24 = *((unsigned __int16 *)v125 + 3);
        v134 = (__int64 (__fastcall *)(__int64))*((_QWORD *)v125 + 1);
        if ( (_DWORD)v24 == 65521 )
          goto LABEL_251;
LABEL_236:
        if ( (_DWORD)v24 )
          v136 = v135 == 10;
        else
          v136 = 0;
        v134 = (__int64 (__fastcall *)(__int64))((char *)v134 + *(_QWORD *)v33);
        if ( !v136 )
        {
          if ( (_DWORD)v122 != 1029 )
          {
            if ( (unsigned int)v122 <= 0x405 )
            {
              if ( (unsigned int)v122 <= 0x402 )
                goto LABEL_243;
LABEL_256:
              *v123 = *(__int64 (__fastcall **)(__int64))(v33 + 1176);
              goto LABEL_247;
            }
LABEL_257:
            if ( (_DWORD)v122 != 1031 )
            {
              if ( (_DWORD)v122 != 1032 )
              {
                if ( (_DWORD)v122 != 1030 )
                  goto LABEL_345;
LABEL_260:
                v137 = (__int64)v185;
                if ( v185 )
                {
                  v138 = *(_QWORD *)(v33 + 1168);
                  if ( (unsigned __int64)(v138 + 1) <= 1 )
                  {
                    v174 = (__int64 (__fastcall *)(_QWORD))v33;
                    dl_allocate_static_tls(v33);
                    v33 = (__int64)v174;
                    v137 = (__int64)v185;
                    v138 = *((_QWORD *)v174 + 146);
                  }
                  *v123 = (__int64 (__fastcall *)(__int64))(v138 + v120[2] + *(_QWORD *)(v137 + 8));
                }
                goto LABEL_247;
              }
LABEL_266:
              v139 = (__int64 (__fastcall *)(__int64))(*(_QWORD *)v118 + v120[2]);
              if ( !v181 )
              {
                v24 = (__int64)v179;
                v140 = &v186;
                v21 = v184;
                goto LABEL_268;
              }
LABEL_269:
              *v123 = v139;
              goto LABEL_247;
            }
LABEL_278:
            v143 = (__int64)v185;
            if ( v185 )
            {
              v144 = *(_QWORD *)(v33 + 1168);
              if ( (unsigned __int64)(v144 + 1) <= 1 )
              {
                v174 = (__int64 (__fastcall *)(_QWORD))v33;
                dl_allocate_static_tls(v33);
                v33 = (__int64)v174;
                v143 = (__int64)v185;
                v144 = *((_QWORD *)v174 + 146);
              }
              v123[1] = (__int64 (__fastcall *)(__int64))(v144 + v120[2] + *(_QWORD *)(v143 + 8));
              *v123 = v178;
              goto LABEL_247;
            }
LABEL_320:
            v123[1] = (__int64 (__fastcall *)(__int64))v120[2];
            *v123 = dl_tlsdesc_undefweak;
            goto LABEL_247;
          }
LABEL_276:
          if ( v185 )
            *v123 = (__int64 (__fastcall *)(__int64))(*((_QWORD *)v185 + 1) + v120[2]);
          goto LABEL_247;
        }
LABEL_270:
        if ( !v181 )
        {
          v186 = 24LL;
          v171 = &dl_hwcap;
          v172 = &dl_hwcap2;
          v188 = dl_hwcap2;
          v173 = &v186;
          v174 = (__int64 (__fastcall *)(_QWORD))v33;
          v187 = dl_hwcap;
          v142 = v134(dl_hwcap | 0x4000000000000000LL);
          v33 = (__int64)v174;
          v134 = (__int64 (__fastcall *)(__int64))v142;
          if ( (_DWORD)v122 != 1028 )
          {
            v140 = v173;
            v21 = v171;
            v24 = (__int64)v172;
            if ( (unsigned int)v122 > 0x404 )
            {
              if ( (_DWORD)v122 == 1031 )
                goto LABEL_278;
              if ( (unsigned int)v122 > 0x407 )
              {
                if ( (_DWORD)v122 != 1032 )
                  goto LABEL_345;
                v139 = (__int64 (__fastcall *)(__int64))(*(_QWORD *)v118 + v120[2]);
LABEL_268:
                v141 = *(const char **)v24;
                v186 = 24LL;
                v187 = *v21;
                v188 = (__int64)v141;
                v139 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *))v139)(
                                                          v187 | 0x4000000000000000LL,
                                                          v140);
                goto LABEL_269;
              }
              if ( (_DWORD)v122 != 1029 )
                goto LABEL_260;
              goto LABEL_276;
            }
            if ( (_DWORD)v122 != 1024 )
            {
              if ( (unsigned int)v122 > 0x400 || (unsigned int)(v122 - 257) <= 1 )
                goto LABEL_246;
              goto LABEL_345;
            }
            v145 = (__int64)v185;
            if ( !v185 )
              goto LABEL_247;
LABEL_284:
            v146 = *(_QWORD *)(v145 + 16);
            v147 = *((_QWORD *)v125 + 2);
            if ( v146 > v147 || ((_DWORD)dl_verbose ? (v152 = v146 >= v147) : (v152 = 1), !v152) )
            {
              v148 = *(_QWORD *)(*(_QWORD *)(v118 + 104) + 8LL);
              if ( (*(_BYTE *)(v118 + 870) & 0x20) != 0 )
                v148 += *(_QWORD *)v118;
              v174 = v134;
              v149 = (const char *)(v148 + *v125);
              v150 = (const char *)program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v150 = "<program name unknown>";
              dl_error_printf("%s: Symbol `%s' has different size in shared object, consider re-linking\n", v150, v149);
            }
            j_memcpy();
            goto LABEL_247;
          }
LABEL_255:
          if ( !v33 )
            goto LABEL_247;
          goto LABEL_256;
        }
LABEL_252:
        if ( (_DWORD)v122 == 1029 )
          goto LABEL_276;
        if ( (unsigned int)v122 > 0x405 )
          goto LABEL_257;
        if ( (unsigned int)v122 <= 0x402 )
        {
LABEL_243:
          if ( (unsigned int)v122 <= 0x400 )
          {
            if ( (unsigned int)v122 > 0x102 )
            {
              if ( (_DWORD)v122 != 1024 )
                goto LABEL_345;
              v145 = (__int64)v185;
              goto LABEL_284;
            }
            if ( (unsigned int)v122 <= 0x100 )
              goto LABEL_345;
          }
LABEL_246:
          *v123 = (__int64 (__fastcall *)(__int64))((char *)v134 + v120[2]);
          goto LABEL_247;
        }
        goto LABEL_255;
      }
      if ( v125 != *(unsigned int **)(v118 + 1096) )
      {
        v127 = 1;
        if ( (unsigned int)v122 != 1026LL )
        {
          if ( (unsigned int)v122 > 0x402uLL )
            v127 = (unsigned __int64)(unsigned int)v122 - 1028 <= 3;
          else
            v127 = 2 * ((unsigned int)v122 == 1024LL);
        }
        goto LABEL_221;
      }
      v151 = *(_DWORD *)(v118 + 1104);
      if ( (unsigned int)v122 == 1026LL )
      {
        v127 = 1;
        if ( v151 != 1 )
          goto LABEL_221;
      }
      else
      {
        if ( (unsigned int)v122 > 0x402uLL )
        {
          if ( (unsigned __int64)(unsigned int)v122 - 1028 > 3 )
          {
            v127 = 0;
            if ( !v151 )
            {
              v133 = *(_QWORD *)(v118 + 1120);
              v185 = (unsigned int *)v133;
              if ( !v133 )
              {
LABEL_264:
                if ( (_DWORD)v122 != 1031 )
                {
                  if ( (_DWORD)v122 != 1032 )
                  {
                    if ( (_DWORD)v122 == 1030 )
                      goto LABEL_247;
                    goto LABEL_345;
                  }
                  goto LABEL_266;
                }
                goto LABEL_320;
              }
              v33 = *(_QWORD *)(v118 + 1112);
LABEL_235:
              v24 = *(unsigned __int16 *)(v133 + 6);
              v134 = *(__int64 (__fastcall **)(__int64))(v133 + 8);
              v135 = *(_BYTE *)(v133 + 4) & 0xF;
              if ( (_DWORD)v24 != 65521 )
                goto LABEL_236;
LABEL_251:
              if ( v135 == 10 )
                goto LABEL_270;
              goto LABEL_252;
            }
          }
          else
          {
            v127 = 1;
            if ( v151 == 1 )
            {
              v133 = *(_QWORD *)(v118 + 1120);
              v185 = (unsigned int *)v133;
              v33 = *(_QWORD *)(v118 + 1112);
              if ( v133 )
                goto LABEL_235;
              goto LABEL_224;
            }
          }
LABEL_221:
          v128 = 0LL;
          v129 = *(_BYTE *)(v118 + 870);
          v130 = *v125;
          v131 = *(_QWORD *)(*(_QWORD *)(v118 + 104) + 8LL);
          *(_QWORD *)(v118 + 1096) = v125;
          *(_DWORD *)(v118 + 1104) = v127;
          if ( (v129 & 0x20) != 0 )
            v128 = *(_QWORD *)v118;
          v132 = dl_lookup_symbol_x(
                   (const char *)(v130 + v131 + v128),
                   v118,
                   v182,
                   v183,
                   0LL,
                   v127,
                   9,
                   0LL,
                   a5,
                   a6,
                   a7,
                   a8,
                   a9,
                   a10,
                   a11,
                   a12);
          *(_QWORD *)(v118 + 1112) = v132;
          v133 = (__int64)v185;
          *(_QWORD *)(v118 + 1120) = v185;
          v33 = v132;
          if ( v133 )
            goto LABEL_235;
LABEL_224:
          if ( (_DWORD)v122 != 1029 )
          {
            if ( (unsigned int)v122 > 0x405 )
              goto LABEL_264;
            goto LABEL_226;
          }
          goto LABEL_247;
        }
        if ( (unsigned int)v122 == 1024LL )
        {
          v127 = 2;
          if ( v151 != 2 )
            goto LABEL_221;
        }
        else
        {
          v127 = 0;
          if ( v151 )
            goto LABEL_221;
        }
      }
      v133 = *(_QWORD *)(v118 + 1120);
      v185 = (unsigned int *)v133;
      v33 = *(_QWORD *)(v118 + 1112);
      if ( v133 )
        goto LABEL_235;
LABEL_226:
      if ( (unsigned int)v122 > 0x402 )
        goto LABEL_255;
      if ( (unsigned int)v122 > 0x400 )
        goto LABEL_292;
      if ( (unsigned int)v122 <= 0x102 )
      {
        if ( (unsigned int)v122 > 0x100 )
        {
LABEL_292:
          v134 = 0LL;
          goto LABEL_246;
        }
LABEL_345:
        dl_reloc_bad_type(v118, v124, 0);
      }
      if ( (_DWORD)v122 != 1024 )
        goto LABEL_345;
      v120 += 3;
      if ( v45 <= (unsigned __int64)v120 )
        goto LABEL_231;
    }
  }
LABEL_49:
  if ( !v42 )
    goto LABEL_103;
LABEL_50:
  v19 = v41;
  if ( v16 )
  {
    v51 = *(_QWORD *)(v41 + 80);
    if ( v51 )
    {
      v52 = *(_QWORD *)(v51 + 8);
      v53 = 16LL;
      if ( *(_QWORD *)(*(_QWORD *)(v41 + 224) + 8LL) == 7LL )
        v53 = 24LL;
      v54 = calloc(
              0x20uLL,
              v52 / v53,
              24LL,
              (void *)v33,
              a5,
              a6,
              a7,
              a8,
              a9,
              a10,
              a11,
              a12,
              v24,
              v39,
              (__int64)v21,
              a16);
      *(_QWORD *)(v41 + 896) = v54;
      if ( !v54 )
      {
        v165 = (const char *)program_invocation_short_name[0];
        if ( !program_invocation_short_name[0] )
          v165 = "<program name unknown>";
        dl_fatal_printf("%s: out of memory to store relocation results for %s\n", v165, *(const char **)(v41 + 8));
      }
    }
  }
  result = *(unsigned __int16 *)(v41 + 868) | 8u;
  *(_WORD *)(v41 + 868) |= 8u;
  if ( v20 )
  {
    while ( 1 )
    {
      result = mprotect(*(void **)v20, *((_QWORD *)v20 + 1), *((_DWORD *)v20 + 4));
      if ( (result & 0x80000000) != 0 )
        break;
      v20 = (__int64 (__fastcall *)(__int64))*((_QWORD *)v20 + 3);
      if ( !v20 )
        return result;
    }
    v166 = "cannot restore segment prot after reloc";
LABEL_382:
    dl_signal_error(*(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40), *(_QWORD *)(v19 + 8), 0LL, v166);
  }
  return result;
}
// 43ED10: conditional instruction was optimized away because x1.8==407
// 43ED14: conditional instruction was optimized away because x1.8==407
// 43EE18: conditional instruction was optimized away because x1.8==402
// 43F974: conditional instruction was optimized away because x1.8==407
// 43F978: conditional instruction was optimized away because x1.8==407
// 43FB6C: conditional instruction was optimized away because x1.8==402
// 43E93C: variable 'v33' is possibly undefined
// 43E93C: variable 'a5' is possibly undefined
// 43E93C: variable 'a6' is possibly undefined
// 43E93C: variable 'a7' is possibly undefined
// 43E93C: variable 'a8' is possibly undefined
// 43E93C: variable 'a9' is possibly undefined
// 43E93C: variable 'a10' is possibly undefined
// 43E93C: variable 'a11' is possibly undefined
// 43E93C: variable 'a12' is possibly undefined
// 43E93C: variable 'v24' is possibly undefined
// 43E93C: variable 'v21' is possibly undefined
// 43E93C: variable 'a16' is possibly undefined
// 43FEFC: using guessed type __int64 __fastcall dl_runtime_resolve(int, int, int, int, int, int, int, int, __int64, __int64);
// 454610: using guessed type __int64 qword_454610;
// 490F10: using guessed type __int64 dl_pagesize;
// 491928: using guessed type __int64 *program_invocation_short_name[2];
// 496BE0: using guessed type __int64 dl_hwcap;
// 496BE8: using guessed type __int64 dl_hwcap2;
// 496C20: using guessed type __int64 dl_debug_mask;
// 496C30: using guessed type __int64 dl_verbose;

//----- (000000000043FC30) ----------------------------------------------------
unsigned __int64 __fastcall dl_relocate_object(
        unsigned __int64 result,
        void ***a2,
        int a3,
        int a4,
        __int64 a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  __int64 v16; // x5
  unsigned __int64 v17; // x19

  v16 = *(unsigned __int16 *)(result + 868);
  if ( (v16 & 8) == 0 )
  {
    v17 = result;
    dl_relocate_object_no_relro(result, a2, a3, a4, a6, a7, a8, a9, a10, a11, a12, a13, a5, v16, a15, a16);
    return dl_protect_relro(v17);
  }
  return result;
}

//----- (000000000043FC60) ----------------------------------------------------
__int64 __fastcall dl_scope_free(
        unsigned __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        void *a12,
        void *a13,
        void *a14,
        void *a15,
        __int64 a16)
{
  __int64 *v17; // x19
  __int64 v18; // x0
  __int64 v19; // x2
  __int64 v20; // x0
  double v22; // d0
  double v23; // d1
  double v24; // d2
  double v25; // d3
  double v26; // d4
  double v27; // d5
  double v28; // d6
  double v29; // d7
  __int64 i; // x0
  __int64 v31; // x0
  _QWORD *v32; // x0
  double v33; // d0
  double v34; // d1
  double v35; // d2
  double v36; // d3
  double v37; // d4
  double v38; // d5
  double v39; // d6
  double v40; // d7

  if ( _libc_single_threaded )
  {
    free(a1, a2, a3, a4, a5, a6, a7, a8, a9);
    return 0LL;
  }
  v17 = (__int64 *)dl_scope_free_list;
  if ( !dl_scope_free_list )
  {
    v32 = (_QWORD *)malloc(
                      408LL,
                      a1,
                      (__int64)&dl_scope_free_list,
                      a12,
                      a13,
                      a14,
                      a15,
                      a16,
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      a9);
    dl_scope_free_list = (__int64)v32;
    if ( v32 )
    {
      *v32 = 1LL;
      v32[1] = a1;
      return 0LL;
    }
    _thread_gscope_wait();
    free(a1, v33, v34, v35, v36, v37, v38, v39, v40);
    return 1LL;
  }
  v18 = *(_QWORD *)dl_scope_free_list;
  if ( *(_QWORD *)dl_scope_free_list > 0x31uLL )
  {
    _thread_gscope_wait();
    for ( i = *v17; *v17; i = *v17 )
    {
      v31 = i - 1;
      *v17 = v31;
      free(v17[v31 + 1], v22, v23, v24, v25, v26, v27, v28, v29);
    }
    return 1LL;
  }
  v19 = v18 + 1;
  v20 = dl_scope_free_list + 8 * v18;
  *(_QWORD *)dl_scope_free_list = v19;
  *(_QWORD *)(v20 + 8) = a1;
  return 0LL;
}
// 43FCE0: variable 'v22' is possibly undefined
// 43FCE0: variable 'v23' is possibly undefined
// 43FCE0: variable 'v24' is possibly undefined
// 43FCE0: variable 'v25' is possibly undefined
// 43FCE0: variable 'v26' is possibly undefined
// 43FCE0: variable 'v27' is possibly undefined
// 43FCE0: variable 'v28' is possibly undefined
// 43FCE0: variable 'v29' is possibly undefined
// 43FD28: variable 'v33' is possibly undefined
// 43FD28: variable 'v34' is possibly undefined
// 43FD28: variable 'v35' is possibly undefined
// 43FD28: variable 'v36' is possibly undefined
// 43FD28: variable 'v37' is possibly undefined
// 43FD28: variable 'v38' is possibly undefined
// 43FD28: variable 'v39' is possibly undefined
// 43FD28: variable 'v40' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;
// 496C60: using guessed type __int64 dl_scope_free_list;

//----- (000000000043FD40) ----------------------------------------------------
void _thread_gscope_wait()
{
  __int64 v0; // x1
  __int64 v1; // x2
  __int64 v2; // x3
  void *v3; // x4
  void *v4; // x5
  void *v5; // x6
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7
  int v14; // w0
  unsigned __int64 v15; // x21
  __int64 *v16; // x19
  void *v17; // x4
  void *v18; // x5
  void *v19; // x6
  double v20; // d0
  double v21; // d1
  double v22; // d2
  double v23; // d3
  double v24; // d4
  double v25; // d5
  double v26; // d6
  double v27; // d7
  int v28; // w0
  unsigned __int64 v29; // x0
  __int64 *v30; // x19
  void *v31; // x4
  void *v32; // x5
  void *v33; // x6
  int v34; // w0
  unsigned __int64 v35; // x0
  __int64 v36; // x1
  __int64 v37; // x2
  __int64 v38; // x3
  void *v39; // x4
  void *v40; // x5
  void *v41; // x6
  int v42; // w0

  _aarch64_cas4_acq();
  if ( v14 )
    _lll_lock_wait_private(dl_stack_cache_lock, v6, v7, v8, v9, v10, v11, v12, v13, v0, v1, v2, v3, v4, v5);
  v15 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
  v16 = (__int64 *)dl_stack_used;
  if ( (__int64 *)dl_stack_used != &dl_stack_used )
  {
    while ( 1 )
    {
      if ( (__int64 *)v15 != v16 - 24 )
      {
        if ( *((_DWORD *)v16 - 47) )
        {
          _aarch64_cas4_acq();
          if ( v28 == 1 )
            break;
        }
      }
LABEL_13:
      v16 = (__int64 *)*v16;
      if ( v16 == &dl_stack_used )
        goto LABEL_14;
    }
    while ( 1 )
    {
      v29 = linux_eabi_syscall(__NR_futex, (char *)v16 - 188, (void *)0x80, (void *)2, 0LL, v17, v18, v19);
      if ( v29 > 0xFFFFFFFFFFFFF000LL && (_DWORD)v29 != -11 && (_DWORD)v29 != -4 )
        break;
      if ( *((_DWORD *)v16 - 47) != 2 )
        goto LABEL_13;
    }
LABEL_12:
    _libc_fatal(
      (__int64)"The futex facility returned an unexpected error code.\n",
      v20,
      v21,
      v22,
      v23,
      v24,
      v25,
      v26,
      v27);
  }
LABEL_14:
  v30 = (__int64 *)dl_stack_user;
  if ( (__int64 *)dl_stack_user != &dl_stack_user )
  {
    while ( 1 )
    {
      if ( (__int64 *)v15 != v30 - 24 )
      {
        if ( *((_DWORD *)v30 - 47) )
        {
          _aarch64_cas4_acq();
          if ( v34 == 1 )
            break;
        }
      }
LABEL_24:
      v30 = (__int64 *)*v30;
      if ( v30 == &dl_stack_user )
        goto LABEL_25;
    }
    while ( 1 )
    {
      while ( 1 )
      {
        v35 = linux_eabi_syscall(__NR_futex, (char *)v30 - 188, (void *)0x80, (void *)2, 0LL, v31, v32, v33);
        if ( v35 > 0xFFFFFFFFFFFFF000LL && (_DWORD)v35 != -11 )
          break;
        if ( *((_DWORD *)v30 - 47) != 2 )
          goto LABEL_24;
      }
      if ( (_DWORD)v35 != -4 )
        goto LABEL_12;
      if ( *((_DWORD *)v30 - 47) != 2 )
        goto LABEL_24;
    }
  }
LABEL_25:
  _aarch64_swp4_rel();
  if ( v42 > 1 )
    _lll_lock_wake_private(dl_stack_cache_lock, v36, v37, v38, v39, v40, v41);
}
// 43FD64: variable 'v14' is possibly undefined
// 43FEDC: variable 'v6' is possibly undefined
// 43FEDC: variable 'v7' is possibly undefined
// 43FEDC: variable 'v8' is possibly undefined
// 43FEDC: variable 'v9' is possibly undefined
// 43FEDC: variable 'v10' is possibly undefined
// 43FEDC: variable 'v11' is possibly undefined
// 43FEDC: variable 'v12' is possibly undefined
// 43FEDC: variable 'v13' is possibly undefined
// 43FEDC: variable 'v0' is possibly undefined
// 43FEDC: variable 'v1' is possibly undefined
// 43FEDC: variable 'v2' is possibly undefined
// 43FEDC: variable 'v3' is possibly undefined
// 43FEDC: variable 'v4' is possibly undefined
// 43FEDC: variable 'v5' is possibly undefined
// 43FDB0: variable 'v28' is possibly undefined
// 43FDD8: variable 'v17' is possibly undefined
// 43FDD8: variable 'v18' is possibly undefined
// 43FDD8: variable 'v19' is possibly undefined
// 43FDFC: variable 'v20' is possibly undefined
// 43FDFC: variable 'v21' is possibly undefined
// 43FDFC: variable 'v22' is possibly undefined
// 43FDFC: variable 'v23' is possibly undefined
// 43FDFC: variable 'v24' is possibly undefined
// 43FDFC: variable 'v25' is possibly undefined
// 43FDFC: variable 'v26' is possibly undefined
// 43FDFC: variable 'v27' is possibly undefined
// 43FE4C: variable 'v34' is possibly undefined
// 43FE74: variable 'v31' is possibly undefined
// 43FE74: variable 'v32' is possibly undefined
// 43FE74: variable 'v33' is possibly undefined
// 43FEC0: variable 'v42' is possibly undefined
// 43FEF8: variable 'v36' is possibly undefined
// 43FEF8: variable 'v37' is possibly undefined
// 43FEF8: variable 'v38' is possibly undefined
// 43FEF8: variable 'v39' is possibly undefined
// 43FEF8: variable 'v40' is possibly undefined
// 43FEF8: variable 'v41' is possibly undefined
// 496C68: using guessed type _DWORD dl_stack_cache_lock[2];
// 496C90: using guessed type __int64 dl_stack_user;
// 496CA0: using guessed type __int64 dl_stack_used;

//----- (000000000043FEFC) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
__int64 __fastcall dl_runtime_resolve(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  __int64 v16; // x16
  char *v17; // x0

  v17 = dl_fixup(
          *(_QWORD *)(v16 - 8),
          (unsigned __int64)(24 * (*(_QWORD *)&a16 - v16) - 192) >> 3,
          a9,
          a10,
          a11,
          a12,
          a13,
          a14,
          a15,
          a16);
  return ((__int64 (__fastcall *)(__int64, __int64, __int64, __int64, __int64, __int64, __int64, __int64))v17)(
           a1,
           a2,
           a3,
           a4,
           a5,
           a6,
           a7,
           a8);
}
// 43FF70: positive sp value 10 has been found
// 43FF24: variable 'v16' is possibly undefined

//----- (000000000043FF74) ----------------------------------------------------
__int64 __fastcall dl_tlsdesc_return(__int64 a1)
{
  return *(_QWORD *)(a1 + 8);
}

//----- (000000000043FF80) ----------------------------------------------------
__int64 __fastcall dl_tlsdesc_undefweak(__int64 a1)
{
  __int64 v1; // x0

  v1 = *(_QWORD *)(a1 + 8);
  return v1 - _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
}

//----- (000000000043FFA0) ----------------------------------------------------
ssize_t __fastcall do_dlopen(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  ssize_t result; // x0

  result = dl_open(
             *(_QWORD *)a1,
             *(unsigned int *)(a1 + 8),
             *(_QWORD *)(a1 + 16),
             -2LL,
             (unsigned int)_libc_argc,
             (void *)_libc_argv,
             environ,
             a2,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9);
  *(_QWORD *)(a1 + 24) = result;
  return result;
}
// 496D08: using guessed type int _libc_argc;
// 496D10: using guessed type __int64 _libc_argv;

//----- (000000000043FFF0) ----------------------------------------------------
__int64 __fastcall dlerror_run(
        void (__fastcall *a1)(__int64),
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  unsigned int v8; // w1
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  unsigned int v18; // [xsp+1Ch] [xbp+1Ch]
  bool v19; // [xsp+2Fh] [xbp+2Fh] BYREF
  __int64 v20; // [xsp+30h] [xbp+30h] BYREF
  unsigned __int64 v21; // [xsp+38h] [xbp+38h] BYREF

  v21 = 0LL;
  v8 = dl_catch_error(&v20, &v21, &v19, a1, a2, a6, a7, a8);
  if ( !v8 )
  {
    if ( !v21 )
      return v8;
    v8 = 1;
  }
  if ( !v19 )
    return v8;
  v18 = v8;
  dl_error_free(v21, v9, v10, v11, v12, v13, v14, v15, v16);
  return v18;
}
// 440044: variable 'v9' is possibly undefined
// 440044: variable 'v10' is possibly undefined
// 440044: variable 'v11' is possibly undefined
// 440044: variable 'v12' is possibly undefined
// 440044: variable 'v13' is possibly undefined
// 440044: variable 'v14' is possibly undefined
// 440044: variable 'v15' is possibly undefined
// 440044: variable 'v16' is possibly undefined

//----- (0000000000440060) ----------------------------------------------------
__int64 __fastcall do_dlsym_private(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v10; // x1
  void ***v11; // x3
  __int64 result; // x0
  const char *v13[3]; // [xsp+28h] [xbp+28h] BYREF

  v13[0] = "GLIBC_PRIVATE";
  v10 = *(_QWORD *)a1;
  v11 = *(void ****)(*(_QWORD *)a1 + 976LL);
  *(_QWORD *)(a1 + 24) = 0LL;
  v13[1] = (const char *)0x10963CF85LL;
  v13[2] = 0LL;
  result = dl_lookup_symbol_x(
             *(const char **)(a1 + 8),
             v10,
             (__int64 *)(a1 + 24),
             v11,
             v13,
             0,
             0,
             0LL,
             a2,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

//----- (00000000004400C4) ----------------------------------------------------
__int64 __fastcall do_dlsym(
        __int64 *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  const char *v11; // x0
  __int64 v12; // t1
  __int64 result; // x0

  v11 = (const char *)a1[1];
  v12 = *a1;
  a1[3] = 0LL;
  result = dl_lookup_symbol_x(v11, v12, a1 + 3, (void ***)(v12 + 984), 0LL, 0, 2, 0LL, a2, a3, a4, a5, a6, a7, a8, a9);
  a1[2] = result;
  return result;
}

//----- (000000000044010C) ----------------------------------------------------
__int64 __fastcall do_dlvsym(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 *v10; // x2
  const char *v12; // x0
  __int64 v13; // t1
  __int64 result; // x0

  v10 = (__int64 *)(a1 + 24);
  v12 = *(const char **)(a1 + 8);
  v13 = *(_QWORD *)a1;
  *(_QWORD *)(a1 + 24) = 0LL;
  result = dl_lookup_symbol_x(
             v12,
             v13,
             v10,
             (void ***)(v13 + 984),
             (const char **)(a1 + 32),
             0,
             0,
             0LL,
             a2,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

//----- (0000000000440164) ----------------------------------------------------
__int64 __fastcall free_slotinfo(unsigned __int64 *a1)
{
  _QWORD *v2; // x0
  unsigned __int8 v3; // w0
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double v7; // d3
  double v8; // d4
  double v9; // d5
  double v10; // d6
  double v11; // d7
  unsigned int v12; // w1
  unsigned __int64 v13; // x0
  __int64 v14; // x3
  __int64 v15; // x1

  v2 = (_QWORD *)*a1;
  if ( v2 )
  {
    v3 = free_slotinfo(v2 + 1);
    v12 = v3;
    if ( (v3 & 1) == 0 )
      return v12;
    v13 = *a1;
    v14 = *(_QWORD *)*a1;
    if ( v14 )
    {
      v15 = 0LL;
      while ( !*(_QWORD *)(v13 + 24 + 16 * v15) )
      {
        if ( ++v15 == v14 )
          goto LABEL_9;
      }
      return 0;
    }
LABEL_9:
    free(v13, v4, v5, v6, v7, v8, v9, v10, v11);
    *a1 = 0LL;
  }
  return 1LL;
}
// 4401D0: variable 'v4' is possibly undefined
// 4401D0: variable 'v5' is possibly undefined
// 4401D0: variable 'v6' is possibly undefined
// 4401D0: variable 'v7' is possibly undefined
// 4401D0: variable 'v8' is possibly undefined
// 4401D0: variable 'v9' is possibly undefined
// 4401D0: variable 'v10' is possibly undefined
// 4401D0: variable 'v11' is possibly undefined

//----- (00000000004401EC) ----------------------------------------------------
__int64 __fastcall _libc_dlopen_mode(
        __int64 a1,
        int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  bool v17; // [xsp+1Fh] [xbp+1Fh] BYREF
  __int64 v18; // [xsp+20h] [xbp+20h] BYREF
  unsigned __int64 v19; // [xsp+28h] [xbp+28h] BYREF
  __int64 v20; // [xsp+30h] [xbp+30h] BYREF
  int v21; // [xsp+38h] [xbp+38h]
  __int64 v22; // [xsp+48h] [xbp+48h]

  v19 = 0LL;
  v20 = a1;
  v21 = a2;
  if ( !(unsigned int)dl_catch_error(
                        &v18,
                        &v19,
                        &v17,
                        (void (__fastcall *)(__int64))do_dlopen,
                        (__int64)&v20,
                        a6,
                        a7,
                        a8)
    && !v19 )
  {
    return v22;
  }
  if ( v17 )
    dl_error_free(v19, v8, v9, v10, v11, v12, v13, v14, v15);
  return 0LL;
}
// 440250: variable 'v8' is possibly undefined
// 440250: variable 'v9' is possibly undefined
// 440250: variable 'v10' is possibly undefined
// 440250: variable 'v11' is possibly undefined
// 440250: variable 'v12' is possibly undefined
// 440250: variable 'v13' is possibly undefined
// 440250: variable 'v14' is possibly undefined
// 440250: variable 'v15' is possibly undefined

//----- (0000000000440260) ----------------------------------------------------
__int64 __fastcall _libc_dlsym_private(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  __int64 result; // x0
  __int64 v9; // x1
  _QWORD v10[2]; // [xsp+10h] [xbp+10h] BYREF
  __int64 *v11; // [xsp+20h] [xbp+20h]
  __int64 v12; // [xsp+28h] [xbp+28h]

  v10[0] = a1;
  v10[1] = a2;
  if ( (unsigned int)dlerror_run((void (__fastcall *)(__int64))do_dlsym_private, (__int64)v10, a3, a4, a5, a6, a7, a8) )
    return 0LL;
  result = v12;
  if ( v12 )
  {
    if ( *(unsigned __int16 *)(v12 + 6) == 65521 )
    {
      v9 = 0LL;
    }
    else
    {
      v9 = 0LL;
      if ( v11 )
        v9 = *v11;
    }
    return v9 + *(_QWORD *)(v12 + 8);
  }
  return result;
}

//----- (00000000004402CC) ----------------------------------------------------
__int64 __fastcall _libc_dlsym(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  __int64 result; // x0
  __int64 v9; // x1
  _QWORD v10[2]; // [xsp+10h] [xbp+10h] BYREF
  __int64 *v11; // [xsp+20h] [xbp+20h]
  __int64 v12; // [xsp+28h] [xbp+28h]

  v10[0] = a1;
  v10[1] = a2;
  if ( (unsigned int)dlerror_run((void (__fastcall *)(__int64))do_dlsym, (__int64)v10, a3, a4, a5, a6, a7, a8) )
    return 0LL;
  result = v12;
  if ( v12 )
  {
    if ( *(unsigned __int16 *)(v12 + 6) == 65521 )
    {
      v9 = 0LL;
    }
    else
    {
      v9 = 0LL;
      if ( v11 )
        v9 = *v11;
    }
    return v9 + *(_QWORD *)(v12 + 8);
  }
  return result;
}

//----- (0000000000440340) ----------------------------------------------------
__int64 __fastcall _libc_dlvsym(
        unsigned __int64 a1,
        __int64 a2,
        unsigned __int8 *a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  unsigned int v8; // w1
  int v9; // w1
  __int64 result; // x0
  __int64 v11; // x1
  __int64 v12; // x1
  unsigned int v13; // t1
  _QWORD v14[2]; // [xsp+10h] [xbp+10h] BYREF
  __int64 *v15; // [xsp+20h] [xbp+20h]
  __int64 v16; // [xsp+28h] [xbp+28h]
  unsigned __int8 *v17; // [xsp+30h] [xbp+30h]
  int v18; // [xsp+38h] [xbp+38h]
  int v19; // [xsp+3Ch] [xbp+3Ch]
  __int64 v20; // [xsp+40h] [xbp+40h]

  v14[0] = a1;
  v14[1] = a2;
  v8 = *a3;
  v17 = a3;
  v19 = 1;
  LODWORD(a1) = 0;
  if ( v8 )
  {
    if ( a3[1] )
    {
      a1 = a3[1] + 16LL * v8;
      if ( a3[2] )
      {
        a1 = a3[2] + 16 * a1;
        if ( a3[3] )
        {
          a1 = a3[3] + 16 * a1;
          if ( a3[4] )
          {
            a1 = a3[4] + 16 * a1;
            v12 = a3[5];
            if ( a3[5] )
            {
              a3 += 5;
              do
              {
                a1 = (v12 + 16 * a1) ^ (((v12 + 16 * a1) & 0xF0000000) >> 24);
                v13 = *++a3;
                v12 = v13;
              }
              while ( v13 );
              LODWORD(a1) = a1 & 0xFFFFFFF;
            }
          }
        }
      }
    }
    else
    {
      LODWORD(a1) = v8;
    }
  }
  v18 = a1;
  v20 = 0LL;
  v9 = dlerror_run((void (__fastcall *)(__int64))do_dlvsym, (__int64)v14, (__int64)a3, a4, a5, a6, a7, a8);
  result = 0LL;
  if ( !v9 )
  {
    result = v16;
    if ( v16 )
    {
      if ( *(unsigned __int16 *)(v16 + 6) == 65521 )
      {
        v11 = 0LL;
      }
      else
      {
        v11 = 0LL;
        if ( v15 )
          v11 = *v15;
      }
      return v11 + *(_QWORD *)(v16 + 8);
    }
  }
  return result;
}

//----- (0000000000440430) ----------------------------------------------------
__int64 __fastcall _libc_dlclose(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  unsigned int v8; // w1
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  unsigned int v18; // [xsp+1Ch] [xbp+1Ch]
  bool v19; // [xsp+2Fh] [xbp+2Fh] BYREF
  __int64 v20; // [xsp+30h] [xbp+30h] BYREF
  unsigned __int64 v21; // [xsp+38h] [xbp+38h] BYREF

  v21 = 0LL;
  v8 = dl_catch_error(&v20, &v21, &v19, (void (__fastcall *)(__int64))do_dlclose, a1, a6, a7, a8);
  if ( !v8 )
  {
    if ( !v21 )
      return v8;
    v8 = 1;
  }
  if ( !v19 )
    return v8;
  v18 = v8;
  dl_error_free(v21, v9, v10, v11, v12, v13, v14, v15, v16);
  return v18;
}
// 440488: variable 'v9' is possibly undefined
// 440488: variable 'v10' is possibly undefined
// 440488: variable 'v11' is possibly undefined
// 440488: variable 'v12' is possibly undefined
// 440488: variable 'v13' is possibly undefined
// 440488: variable 'v14' is possibly undefined
// 440488: variable 'v15' is possibly undefined
// 440488: variable 'v16' is possibly undefined
// 440160: using guessed type __int64 __fastcall do_dlclose();

//----- (00000000004404A0) ----------------------------------------------------
void __fastcall _dl_libc_freemem(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  _QWORD *v8; // x19
  unsigned __int64 v9; // x0
  __int64 *i; // x20
  __int64 v11; // x0
  unsigned __int64 v12; // x19
  int v13; // w1
  unsigned __int64 v14; // x0
  unsigned __int64 v15; // x0
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  unsigned __int64 v24; // x0

  v8 = (_QWORD *)dl_all_dirs;
  if ( dl_all_dirs != dl_init_all_dirs )
  {
    do
    {
      v9 = (unsigned __int64)v8;
      v8 = (_QWORD *)*v8;
      free(v9, a1, a2, a3, a4, a5, a6, a7, a8);
    }
    while ( (_QWORD *)dl_init_all_dirs != v8 );
  }
  if ( dl_nns )
  {
    for ( i = dl_ns; i; i = (__int64 *)i[3] )
    {
      v11 = i[7];
      v12 = *(_QWORD *)(v11 + 8);
      *(_QWORD *)(v11 + 8) = 0LL;
      while ( v12 )
      {
        while ( 1 )
        {
          v13 = *(_DWORD *)(v12 + 16);
          v14 = v12;
          v12 = *(_QWORD *)(v12 + 8);
          if ( v13 )
            break;
          free(v14, a1, a2, a3, a4, a5, a6, a7, a8);
          if ( !v12 )
            goto LABEL_9;
        }
      }
LABEL_9:
      if ( (*((_BYTE *)i + 870) & 0x10) != 0 )
        free(i[129], a1, a2, a3, a4, a5, a6, a7, a8);
      i[129] = 0LL;
    }
    if ( dword_4914C0 && *((_DWORD *)off_4914B8 + 2) == dword_491498 )
    {
      v24 = (unsigned __int64)*off_4914B8;
      *off_4914B8 = dl_initial_searchlist;
      dword_4914C0 = 0;
      free(v24, a1, a2, a3, a4, a5, a6, a7, a8);
    }
  }
  free_slotinfo((unsigned __int64 *)(dl_tls_dtv_slotinfo_list + 8));
  v15 = dl_scope_free_list;
  dl_scope_free_list = 0LL;
  free(v15, v16, v17, v18, v19, v20, v21, v22, v23);
}
// 4404D4: variable 'a1' is possibly undefined
// 4404D4: variable 'a2' is possibly undefined
// 4404D4: variable 'a3' is possibly undefined
// 4404D4: variable 'a4' is possibly undefined
// 4404D4: variable 'a5' is possibly undefined
// 4404D4: variable 'a6' is possibly undefined
// 4404D4: variable 'a7' is possibly undefined
// 4404D4: variable 'a8' is possibly undefined
// 440588: variable 'v16' is possibly undefined
// 440588: variable 'v17' is possibly undefined
// 440588: variable 'v18' is possibly undefined
// 440588: variable 'v19' is possibly undefined
// 440588: variable 'v20' is possibly undefined
// 440588: variable 'v21' is possibly undefined
// 440588: variable 'v22' is possibly undefined
// 440588: variable 'v23' is possibly undefined
// 490F20: using guessed type __int64 dl_nns;
// 491490: using guessed type __int64 **dl_initial_searchlist;
// 491498: using guessed type int dword_491498;
// 4914A8: using guessed type __int64 *dl_ns;
// 4914B8: using guessed type __int64 ***off_4914B8;
// 4914C0: using guessed type int dword_4914C0;
// 4921E8: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 496C38: using guessed type __int64 dl_init_all_dirs;
// 496C40: using guessed type __int64 dl_all_dirs;
// 496C60: using guessed type __int64 dl_scope_free_list;

//----- (00000000004405E0) ----------------------------------------------------
__int64 __fastcall _gconv_open(__int64 a1, unsigned __int64 *a2, unsigned int a3)
{
  char v4; // w20
  __int64 *v5; // x21
  __int64 *v6; // x22
  int v7; // w19
  unsigned __int64 v8; // x23
  __int64 v9; // x1
  __int64 v10; // x2
  void *v11; // x3
  void *v12; // x4
  void *v13; // x5
  void *v14; // x6
  __int64 v15; // x7
  unsigned int transform; // w21
  double v17; // d0
  double v18; // d1
  double v19; // d2
  double v20; // d3
  double v21; // d4
  double v22; // d5
  double v23; // d6
  double v24; // d7
  unsigned __int64 (__fastcall *v26)(__int64); // x23
  unsigned __int64 (__fastcall *v27)(__int64); // x23
  __int64 v28; // x22
  _QWORD *v29; // x0
  __int64 v30; // x1
  __int64 v31; // x2
  void *v32; // x3
  void *v33; // x4
  void *v34; // x5
  void *v35; // x6
  __int64 v36; // x7
  double v37; // d0
  double v38; // d1
  double v39; // d2
  double v40; // d3
  double v41; // d4
  double v42; // d5
  double v43; // d6
  double v44; // d7
  int v45; // w19
  unsigned __int64 v46; // x25
  int v47; // w20
  __int64 v48; // x28
  unsigned __int64 v49; // x27
  unsigned __int64 v50; // x24
  unsigned __int64 v51; // x0
  int v52; // w26
  unsigned __int64 v53; // x0
  int v54; // w0
  unsigned __int64 StatusReg; // x22
  int v56; // w25
  unsigned __int64 v57; // x20
  unsigned __int64 *v58; // x27
  unsigned __int64 v59; // t1
  __int64 v60; // [xsp+0h] [xbp+0h] BYREF
  char *v61; // [xsp+68h] [xbp+68h]
  char ***v62; // [xsp+70h] [xbp+70h]
  unsigned __int64 *v63; // [xsp+78h] [xbp+78h]
  unsigned __int64 v64; // [xsp+80h] [xbp+80h] BYREF
  unsigned __int64 v65; // [xsp+88h] [xbp+88h] BYREF

  v63 = a2;
  v4 = *(_BYTE *)(a1 + 16);
  v6 = *(__int64 **)a1;
  v5 = *(__int64 **)(a1 + 8);
  v7 = *(unsigned __int8 *)(a1 + 17);
  if ( *(_BYTE *)v5 == 47 && *((_BYTE *)v5 + 1) == 47 && !*((_BYTE *)v5 + 2) )
  {
    _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v27 = strlen();
    v5 = &v60;
    strcpy((char *)v27 + (_QWORD)j_memcpy(), "//");
  }
  if ( *(_BYTE *)v6 == 47 && *((_BYTE *)v6 + 1) == 47 && !*((_BYTE *)v6 + 2) )
  {
    _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v26 = strlen();
    v6 = &v60;
    strcpy((char *)v26 + (_QWORD)j_memcpy(), "//");
  }
  v8 = 0LL;
  transform = _gconv_find_transform(v5, v6, &v64, &v65, a3);
  if ( !transform )
  {
    v28 = v65;
    v29 = (_QWORD *)malloc(48 * v65 + 16, v9, v10, v11, v12, v13, v14, v15, v17, v18, v19, v20, v21, v22, v23, v24);
    v8 = (unsigned __int64)v29;
    if ( v29 )
    {
      v29[1] = v64;
      *v29 = v28;
      memset();
      if ( !v28 )
        goto LABEL_6;
      v45 = 2 * v7;
      v46 = v8 + 56;
      v47 = v4 & 1;
      v48 = 0LL;
      v49 = 0LL;
      v62 = nl_C_locobj;
      v61 = "INTERNAL";
      while ( 1 )
      {
        *(_QWORD *)(v46 - 8) = v46;
        if ( v47 )
        {
          v54 = strcasecmp_l(*(_QWORD *)(v64 + v48 + 24), (__int64)v61, (__int64)v62);
          v50 = v65;
          v30 = v45 | 8u;
          if ( !v54 )
            v45 |= 8u;
          if ( v65 - 1 <= v49 )
          {
LABEL_21:
            *(_DWORD *)(v8 + 48 * v49 + 32) = v45 | 1;
            goto LABEL_6;
          }
        }
        else
        {
          v50 = v65;
          if ( v65 - 1 <= v49 )
            goto LABEL_21;
        }
        v51 = v64;
        *(_DWORD *)(v46 - 24) = v45;
        v52 = 8160 * *(_DWORD *)(v51 + v48 + 84);
        v53 = malloc(v52, v30, v31, v32, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44);
        *(_QWORD *)(v46 - 40) = v53;
        if ( !v53 )
          break;
        ++v49;
        *(_QWORD *)(v46 - 32) = v53 + v52;
        v48 += 104LL;
        v46 += 48LL;
        if ( v50 <= v49 )
          goto LABEL_6;
      }
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
      v56 = *(_DWORD *)(StatusReg + 40);
      if ( v49 )
      {
        v57 = v49 - 1;
        v58 = (unsigned __int64 *)(v8 - 32 + 48 * v49);
        do
        {
          v59 = *v58;
          v58 -= 6;
          --v57;
          free(v59, v37, v38, v39, v40, v41, v42, v43, v44);
        }
        while ( v57 != -1LL );
      }
      free(v8, v37, v38, v39, v40, v41, v42, v43, v44);
    }
    else
    {
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
      v56 = *(_DWORD *)(StatusReg + 40);
    }
    v8 = 0LL;
    _gconv_close_transform(v64, v65);
    *(_DWORD *)(StatusReg + 40) = v56;
    transform = 3;
  }
LABEL_6:
  *v63 = v8;
  return transform;
}
// 440778: variable 'v9' is possibly undefined
// 440778: variable 'v10' is possibly undefined
// 440778: variable 'v11' is possibly undefined
// 440778: variable 'v12' is possibly undefined
// 440778: variable 'v13' is possibly undefined
// 440778: variable 'v14' is possibly undefined
// 440778: variable 'v15' is possibly undefined
// 440778: variable 'v17' is possibly undefined
// 440778: variable 'v18' is possibly undefined
// 440778: variable 'v19' is possibly undefined
// 440778: variable 'v20' is possibly undefined
// 440778: variable 'v21' is possibly undefined
// 440778: variable 'v22' is possibly undefined
// 440778: variable 'v23' is possibly undefined
// 440778: variable 'v24' is possibly undefined
// 440800: variable 'v30' is possibly undefined
// 440800: variable 'v31' is possibly undefined
// 440800: variable 'v32' is possibly undefined
// 440800: variable 'v33' is possibly undefined
// 440800: variable 'v34' is possibly undefined
// 440800: variable 'v35' is possibly undefined
// 440800: variable 'v36' is possibly undefined
// 440800: variable 'v37' is possibly undefined
// 440800: variable 'v38' is possibly undefined
// 440800: variable 'v39' is possibly undefined
// 440800: variable 'v40' is possibly undefined
// 440800: variable 'v41' is possibly undefined
// 440800: variable 'v42' is possibly undefined
// 440800: variable 'v43' is possibly undefined
// 440800: variable 'v44' is possibly undefined
// 41FF6C: using guessed type __int64 __fastcall _gconv_find_transform(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD);
// 48FA30: using guessed type char **nl_C_locobj[6];

//----- (00000000004408E0) ----------------------------------------------------
__int64 __fastcall _gconv(_QWORD *a1, __int64 *a2, unsigned __int64 a3, __int64 *a4, __int64 a5, _QWORD *a6)
{
  __int64 v9; // x19
  __int64 v11; // x1
  unsigned __int64 v12; // x19
  _QWORD *v13; // x0
  __int64 v14; // x0
  unsigned __int64 v15; // x21
  __int64 v16; // x27
  unsigned int v17; // w4
  _DWORD *v19; // x1
  unsigned __int64 v20; // x0

  if ( a1 == (_QWORD *)-1LL )
    return 8LL;
  if ( !a6 )
    _libc_assert_fail((__int64)"irreversible != NULL", (__int64)"gconv.c", 0x2Au, (__int64)"__gconv");
  v9 = *a1;
  *a6 = 0LL;
  v11 = 0LL;
  v12 = v9 - 1;
  if ( a4 )
    v11 = *a4;
  v13 = &a1[6 * v12];
  v13[2] = v11;
  v13[3] = a5;
  v14 = a1[1];
  v15 = *(_QWORD *)(v14 + 40);
  if ( *(_QWORD *)v14 )
    v15 ^= _pointer_chk_guard_local;
  if ( a2 && (v16 = *a2) != 0 )
  {
    if ( !a4 || !*a4 )
      _libc_assert_fail((__int64)"outbuf != NULL && *outbuf != NULL", (__int64)"gconv.c", 0x46u, (__int64)"__gconv");
    while ( 1 )
    {
      v17 = ((__int64 (__fastcall *)(__int64, _QWORD *))v15)(v14, a1 + 2);
      if ( v17 != 4 )
        break;
      if ( *a2 == v16 )
        break;
      v14 = a1[1];
      if ( a3 < *a2 + *(int *)(v14 + 72) )
        break;
      v16 = *a2;
    }
  }
  else
  {
    v17 = ((__int64 (__fastcall *)(__int64, _QWORD *))v15)(v14, a1 + 2);
    if ( !v17 )
    {
      v19 = (_DWORD *)a1 + 9;
      v20 = 0LL;
      do
      {
        ++v20;
        *v19 = 0;
        v19 += 12;
      }
      while ( v12 >= v20 );
    }
    if ( !a4 )
      return v17;
  }
  if ( *a4 )
    *a4 = a1[6 * v12 + 2];
  return v17;
}
// 440AC0: using guessed type __int64 _gconv_close(void);
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000440AC0) ----------------------------------------------------
__int64 __fastcall _gconv_close(
        __int64 *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  unsigned __int64 v10; // x21
  __int64 *v11; // x19
  __int64 v12; // x22

  v10 = a1[1];
  v11 = a1 + 2;
  v12 = *a1;
  while ( (v11[2] & 1) == 0 )
  {
    if ( *v11 )
    {
      free(*v11, a2, a3, a4, a5, a6, a7, a8, a9);
      v11 += 6;
      if ( (*(_DWORD *)(v11 - 4) & 1) != 0 )
        break;
    }
    else
    {
      v11 += 6;
    }
  }
  free((unsigned __int64)a1, a2, a3, a4, a5, a6, a7, a8, a9);
  return _gconv_close_transform(v10, v12);
}
// 440AEC: variable 'a2' is possibly undefined
// 440AEC: variable 'a3' is possibly undefined
// 440AEC: variable 'a4' is possibly undefined
// 440AEC: variable 'a5' is possibly undefined
// 440AEC: variable 'a6' is possibly undefined
// 440AEC: variable 'a7' is possibly undefined
// 440AEC: variable 'a8' is possibly undefined
// 440AEC: variable 'a9' is possibly undefined

//----- (0000000000440B40) ----------------------------------------------------
unsigned __int64 __fastcall gconv_parse_code(unsigned __int8 **a1)
{
  unsigned __int64 StatusReg; // x22
  _BYTE *v3; // x24
  unsigned __int64 result; // x0
  char *v5; // x3
  int v6; // w2
  bool v7; // zf
  _BYTE *v9; // x1
  _BYTE *v10; // x24
  int v11; // w2
  bool v12; // zf
  unsigned int v13; // t1
  unsigned int v14; // t1

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  *((_WORD *)a1 + 4) = 0;
  while ( 1 )
  {
    v3 = *a1;
    result = (unsigned __int64)strlen();
    if ( !result )
      break;
    while ( 1 )
    {
      v5 = (char *)(result - 1);
      v6 = (unsigned __int8)v3[result - 1];
      v7 = v6 == 47 || v6 == 44;
      if ( !v7 && (*(_WORD *)(*(_QWORD *)(StatusReg + 72) + 2LL * (unsigned __int8)v3[result - 1]) & 0x2000) == 0 )
        break;
      --result;
      if ( !v5 )
        goto LABEL_11;
    }
    v3[result] = 0;
    v9 = *a1;
    result = **a1;
    if ( !**a1 )
      return result;
    v10 = 0LL;
    v11 = 0;
    do
    {
      while ( (_DWORD)result == 44 )
      {
        v10 = v9;
        v14 = (unsigned __int8)*++v9;
        result = v14;
        if ( !v14 )
          goto LABEL_22;
      }
      v12 = (_DWORD)result == 47;
      if ( (_DWORD)result == 47 )
        v10 = v9;
      v13 = (unsigned __int8)*++v9;
      result = v13;
      if ( v12 )
        ++v11;
    }
    while ( (_DWORD)result );
LABEL_22:
    if ( !v10 || v11 <= 1 )
      return result;
    if ( !(unsigned int)strcasecmp_l((__int64)v10, (__int64)"/TRANSLIT", (__int64)nl_C_locobj)
      || !(unsigned int)strcasecmp_l((__int64)v10, (__int64)",TRANSLIT", (__int64)nl_C_locobj) )
    {
      *((_BYTE *)a1 + 8) = 1;
    }
    if ( (unsigned int)strcasecmp_l((__int64)v10, (__int64)"/IGNORE", (__int64)nl_C_locobj)
      && (unsigned int)strcasecmp_l((__int64)v10, (__int64)",IGNORE", (__int64)nl_C_locobj) )
    {
      *v10 = 0;
    }
    else
    {
      *((_BYTE *)a1 + 9) = 1;
      *v10 = 0;
    }
  }
LABEL_11:
  *v3 = 0;
  return result;
}
// 48FA30: using guessed type char **nl_C_locobj[6];

//----- (0000000000440CC0) ----------------------------------------------------
_BYTE *__fastcall _gconv_create_spec(__int64 a1)
{
  unsigned __int8 *v2; // x19
  unsigned __int8 *v3; // x0
  double v4; // d0
  double v5; // d1
  double v6; // d2
  double v7; // d3
  double v8; // d4
  double v9; // d5
  double v10; // d6
  double v11; // d7
  bool v12; // zf
  unsigned __int64 (__fastcall *v13)(__int64); // x0
  __int64 v14; // x1
  __int64 v15; // x2
  void *v16; // x3
  void *v17; // x4
  void *v18; // x5
  void *v19; // x6
  __int64 v20; // x7
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  unsigned __int64 v29; // x0
  unsigned __int8 *v30; // x21
  _BYTE *v31; // x23
  unsigned __int64 (__fastcall *v32)(__int64); // x0
  __int64 v33; // x1
  __int64 v34; // x2
  void *v35; // x3
  void *v36; // x4
  void *v37; // x5
  void *v38; // x6
  __int64 v39; // x7
  double v40; // d0
  double v41; // d1
  double v42; // d2
  double v43; // d3
  double v44; // d4
  double v45; // d5
  double v46; // d6
  double v47; // d7
  unsigned __int64 v48; // x0
  _BYTE *v49; // x22
  int v50; // w2
  unsigned __int8 *v51; // x4
  int v52; // w9
  int v53; // t1
  unsigned int v54; // w1
  int v55; // t1
  int v56; // w9
  __int64 v57; // x24
  int v58; // w2
  int v59; // w8
  unsigned __int8 *v60; // x0
  int v61; // t1
  unsigned int v62; // w1
  int v63; // t1
  int v64; // w8
  __int64 v65; // x23
  double v66; // d0
  double v67; // d1
  double v68; // d2
  double v69; // d3
  double v70; // d4
  double v71; // d5
  double v72; // d6
  double v73; // d7
  unsigned __int64 v75; // x0
  unsigned __int8 *v76; // [xsp+40h] [xbp+40h] BYREF
  unsigned __int8 *v77; // [xsp+50h] [xbp+50h] BYREF
  __int16 v78; // [xsp+58h] [xbp+58h]

  v2 = (unsigned __int8 *)strdup();
  v3 = (unsigned __int8 *)strdup();
  v77 = v3;
  if ( v2 )
    v12 = v3 == 0LL;
  else
    v12 = 1;
  if ( v12 )
  {
    v30 = v3;
    v31 = 0LL;
  }
  else
  {
    v76 = v2;
    gconv_parse_code(&v76);
    v2 = v76;
    gconv_parse_code(&v77);
    *(_WORD *)(a1 + 16) = v78;
    v13 = strlen();
    v29 = malloc((__int64)v13 + 3, v14, v15, v16, v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28);
    *(_QWORD *)a1 = v29;
    v30 = v77;
    v31 = (_BYTE *)v29;
    if ( v29 )
    {
      v32 = strlen();
      v48 = malloc((__int64)v32 + 3, v33, v34, v35, v36, v37, v38, v39, v40, v41, v42, v43, v44, v45, v46, v47);
      *(_QWORD *)(a1 + 8) = v48;
      v49 = (_BYTE *)v48;
      if ( v48 )
      {
        v50 = *v2;
        if ( *v2 )
        {
          v51 = v2;
          v52 = 0;
          while ( 1 )
          {
            while ( 1 )
            {
              v54 = (unsigned __int8)(v50 - 44);
              if ( v54 <= 0x33 )
                break;
              if ( (word_45EA40[(unsigned __int8)v50] & 8) != 0 )
                goto LABEL_10;
LABEL_11:
              v53 = *++v51;
              v50 = v53;
              if ( !v53 )
                goto LABEL_17;
            }
            if ( !(((__int64)0xFFF7FFFFFFFFBFF8LL >> v54) & 1) || (word_45EA40[(unsigned __int8)v50] & 8) != 0 )
            {
LABEL_10:
              *v31++ = dword_45E140[v50];
              goto LABEL_11;
            }
            if ( v50 != 47 )
              goto LABEL_11;
            if ( v52 == 2 )
              goto LABEL_20;
            ++v52;
            *v31 = 47;
            v55 = *++v51;
            v50 = v55;
            ++v31;
            if ( !v55 )
            {
LABEL_17:
              if ( v52 <= 1 )
              {
                v56 = v52 + 1;
                goto LABEL_19;
              }
              goto LABEL_20;
            }
          }
        }
        v56 = 1;
LABEL_19:
        v57 = (unsigned int)(2 - v56);
        memset();
        v31 += v57 + 1;
LABEL_20:
        *v31 = 0;
        v58 = *v30;
        if ( *v30 )
        {
          v59 = 0;
          v60 = v30;
          while ( 1 )
          {
            while ( 1 )
            {
              v62 = (unsigned __int8)(v58 - 44);
              if ( v62 <= 0x33 )
                break;
              if ( (word_45EA40[(unsigned __int8)v58] & 8) != 0 )
                goto LABEL_23;
LABEL_24:
              v61 = *++v60;
              v58 = v61;
              if ( !v61 )
                goto LABEL_30;
            }
            if ( !(((__int64)0xFFF7FFFFFFFFBFF8LL >> v62) & 1) || (word_45EA40[(unsigned __int8)v58] & 8) != 0 )
            {
LABEL_23:
              *v49++ = dword_45E140[v58];
              goto LABEL_24;
            }
            if ( v58 != 47 )
              goto LABEL_24;
            if ( v59 == 2 )
              goto LABEL_33;
            ++v59;
            *v49 = 47;
            v63 = *++v60;
            v58 = v63;
            ++v49;
            if ( !v63 )
            {
LABEL_30:
              if ( v59 <= 1 )
              {
                v64 = v59 + 1;
                goto LABEL_32;
              }
              goto LABEL_33;
            }
          }
        }
        v64 = 1;
LABEL_32:
        v65 = (unsigned int)(2 - v64);
        memset();
        v49 += v65 + 1;
LABEL_33:
        v31 = (_BYTE *)a1;
        *v49 = 0;
      }
      else
      {
        v75 = (unsigned __int64)v31;
        v31 = 0LL;
        free(v75, v4, v5, v6, v7, v8, v9, v10, v11);
        *(_QWORD *)a1 = 0LL;
      }
    }
  }
  free((unsigned __int64)v2, v4, v5, v6, v7, v8, v9, v10, v11);
  free((unsigned __int64)v30, v66, v67, v68, v69, v70, v71, v72, v73);
  return v31;
}
// 440D30: variable 'v14' is possibly undefined
// 440D30: variable 'v15' is possibly undefined
// 440D30: variable 'v16' is possibly undefined
// 440D30: variable 'v17' is possibly undefined
// 440D30: variable 'v18' is possibly undefined
// 440D30: variable 'v19' is possibly undefined
// 440D30: variable 'v20' is possibly undefined
// 440D30: variable 'v21' is possibly undefined
// 440D30: variable 'v22' is possibly undefined
// 440D30: variable 'v23' is possibly undefined
// 440D30: variable 'v24' is possibly undefined
// 440D30: variable 'v25' is possibly undefined
// 440D30: variable 'v26' is possibly undefined
// 440D30: variable 'v27' is possibly undefined
// 440D30: variable 'v28' is possibly undefined
// 440D50: variable 'v33' is possibly undefined
// 440D50: variable 'v34' is possibly undefined
// 440D50: variable 'v35' is possibly undefined
// 440D50: variable 'v36' is possibly undefined
// 440D50: variable 'v37' is possibly undefined
// 440D50: variable 'v38' is possibly undefined
// 440D50: variable 'v39' is possibly undefined
// 440D50: variable 'v40' is possibly undefined
// 440D50: variable 'v41' is possibly undefined
// 440D50: variable 'v42' is possibly undefined
// 440D50: variable 'v43' is possibly undefined
// 440D50: variable 'v44' is possibly undefined
// 440D50: variable 'v45' is possibly undefined
// 440D50: variable 'v46' is possibly undefined
// 440D50: variable 'v47' is possibly undefined
// 440F18: variable 'v4' is possibly undefined
// 440F18: variable 'v5' is possibly undefined
// 440F18: variable 'v6' is possibly undefined
// 440F18: variable 'v7' is possibly undefined
// 440F18: variable 'v8' is possibly undefined
// 440F18: variable 'v9' is possibly undefined
// 440F18: variable 'v10' is possibly undefined
// 440F18: variable 'v11' is possibly undefined
// 440F20: variable 'v66' is possibly undefined
// 440F20: variable 'v67' is possibly undefined
// 440F20: variable 'v68' is possibly undefined
// 440F20: variable 'v69' is possibly undefined
// 440F20: variable 'v70' is possibly undefined
// 440F20: variable 'v71' is possibly undefined
// 440F20: variable 'v72' is possibly undefined
// 440F20: variable 'v73' is possibly undefined
// 45E140: using guessed type int dword_45E140[256];
// 45EA40: using guessed type _WORD word_45EA40[256];

//----- (0000000000440F6C) ----------------------------------------------------
void __fastcall _gconv_destroy_spec(
        unsigned __int64 *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7

  free(*a1, a2, a3, a4, a5, a6, a7, a8, a9);
  free(a1[1], v10, v11, v12, v13, v14, v15, v16, v17);
}
// 440F90: variable 'v10' is possibly undefined
// 440F90: variable 'v11' is possibly undefined
// 440F90: variable 'v12' is possibly undefined
// 440F90: variable 'v13' is possibly undefined
// 440F90: variable 'v14' is possibly undefined
// 440F90: variable 'v15' is possibly undefined
// 440F90: variable 'v16' is possibly undefined
// 440F90: variable 'v17' is possibly undefined

//----- (0000000000440FA0) ----------------------------------------------------
char **__fastcall nl_find_locale(const char *a1, __int64 a2, int a3, unsigned __int64 **a4)
{
  char *v8; // x19
  unsigned __int64 (__fastcall *v9)(__int64); // x0
  __int64 v10; // x4
  __int64 v11; // x5
  __int64 v12; // x6
  __int64 v13; // x7
  unsigned __int64 v14; // x23
  char *v15; // x0
  __int64 v16; // x2
  __int64 v17; // x3
  __int64 v18; // x4
  __int64 v19; // x5
  __int64 v20; // x6
  __int64 v21; // x7
  unsigned __int64 *v22; // x0
  char **result; // x0
  unsigned __int64 *v24; // x0
  unsigned __int64 *v25; // x0
  unsigned __int64 *v26; // x0
  unsigned __int64 *v27; // x19
  unsigned __int8 *v28; // x0
  double v29; // d0
  double v30; // d1
  double v31; // d2
  double v32; // d3
  double v33; // d4
  double v34; // d5
  double v35; // d6
  double v36; // d7
  int v37; // w23
  char *v38; // x20
  __int64 v39; // x2
  __int64 v40; // x3
  __int64 v41; // x4
  __int64 v42; // x5
  unsigned __int64 v43; // x6
  unsigned __int64 l10nflist; // x19
  double v45; // d0
  double v46; // d1
  double v47; // d2
  double v48; // d3
  double v49; // d4
  double v50; // d5
  double v51; // d6
  double v52; // d7
  __int64 (__fastcall **v53)(__int64, __int64 *, unsigned __int64); // x20
  unsigned __int64 *v54; // x22
  __int64 (__fastcall *v55)(__int64, __int64 *, unsigned __int64); // x21
  int v56; // w2
  unsigned __int64 *v57; // x6
  int v58; // w10
  int v59; // t1
  unsigned int v60; // w1
  int v61; // w9
  unsigned __int64 *v62; // x3
  unsigned __int64 *v63; // x1
  int v64; // t1
  int v65; // w0
  unsigned __int64 *v66; // x1
  int v67; // t1
  int v68; // w0
  int v69; // w1
  unsigned int v70; // w1
  __int64 v71; // x2
  __int64 v72; // x3
  __int64 v73; // x4
  __int64 v74; // x5
  __int64 v75; // x6
  __int64 v76; // x7
  int v77; // w10
  int v78; // w2
  int v79; // w9
  int v80; // t1
  unsigned int v81; // w1
  unsigned __int64 v82; // x2
  __int64 v83; // x0
  int v84; // w1
  unsigned __int64 v85; // x1
  __int64 v86; // x0
  unsigned __int64 *v87; // x20
  unsigned __int64 v88; // x1
  __int64 v89; // t1
  char v90; // [xsp+0h] [xbp-20h]
  unsigned __int64 v91; // [xsp+20h] [xbp+0h] BYREF
  char *v92; // [xsp+70h] [xbp+50h] BYREF
  unsigned __int64 v93; // [xsp+78h] [xbp+58h] BYREF
  unsigned __int64 v94; // [xsp+80h] [xbp+60h] BYREF
  unsigned __int64 v95; // [xsp+88h] [xbp+68h] BYREF
  unsigned __int64 *v96; // [xsp+90h] [xbp+70h] BYREF
  unsigned __int64 v97; // [xsp+98h] [xbp+78h] BYREF

  v92 = (char *)*a4;
  v8 = v92;
  if ( !*v92 )
  {
    v24 = (unsigned __int64 *)getenv("LC_ALL");
    v92 = (char *)v24;
    if ( v24 && *(_BYTE *)v24
      || (v26 = (unsigned __int64 *)getenv(&nl_category_names[(unsigned __int8)nl_category_name_idxs[a3]]),
          (v92 = (char *)v26) != 0LL)
      && *(_BYTE *)v26 )
    {
      v25 = (unsigned __int64 *)v92;
    }
    else
    {
      v25 = (unsigned __int64 *)getenv("LANG");
      v92 = (char *)v25;
      if ( !v25 )
      {
LABEL_28:
        v8 = "C";
        v92 = "C";
        goto LABEL_2;
      }
    }
    if ( *(_BYTE *)v25 )
    {
      v8 = v92;
      if ( !(unsigned int)strcmp((unsigned __int64 *)v92, (unsigned __int64)"C") )
        goto LABEL_24;
      goto LABEL_3;
    }
    goto LABEL_28;
  }
LABEL_2:
  if ( !(unsigned int)strcmp((unsigned __int64 *)v8, (unsigned __int64)"C") )
  {
LABEL_24:
    *a4 = (unsigned __int64 *)"C";
    return nl_C[a3];
  }
LABEL_3:
  if ( !(unsigned int)strcmp((unsigned __int64 *)v8, (unsigned __int64)"POSIX") )
    goto LABEL_24;
  v9 = strlen();
  v14 = (unsigned __int64)v9;
  if ( (unsigned __int64)v9 > 0xFF
    || memmem(
         (unsigned __int64 (__fastcall *)(__int64, unsigned int, unsigned __int64))v8,
         (unsigned __int64)v9,
         (int8x16_t *)"/../",
         4uLL,
         v10,
         v11,
         v12,
         v13,
         v90) )
  {
    goto LABEL_17;
  }
  if ( v14 == 2 )
  {
    if ( *v8 == 46 )
    {
      if ( v8[1] == 46 || memchr() )
        goto LABEL_17;
      goto LABEL_11;
    }
  }
  else if ( v14 > 2 )
  {
    if ( *v8 == 46 && v8[1] == 46 && v8[2] == 47 )
      goto LABEL_17;
    v15 = &v8[v14];
    if ( v8[v14 - 3] == 47 && *(v15 - 2) == 46 && *(v15 - 1) == 46 )
      goto LABEL_17;
  }
  if ( memchr() && *v8 != 47 )
  {
LABEL_17:
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return 0LL;
  }
LABEL_11:
  v22 = (unsigned __int64 *)v92;
  *a4 = (unsigned __int64 *)v92;
  if ( a1 )
  {
    v27 = (unsigned __int64 *)nl_expand_alias((__int64)v22);
    v92 = (char *)v27;
    goto LABEL_30;
  }
  result = (char **)nl_load_locale_from_archive(a3, a4, v16, v17, v18, v19, v20, v21);
  if ( result )
    return result;
  v92 = (char *)nl_expand_alias((__int64)*a4);
  if ( v92 )
  {
    result = (char **)nl_load_locale_from_archive(a3, (unsigned __int64 **)&v92, v71, v72, v73, v74, v75, v76);
    if ( result )
      return result;
    v27 = (unsigned __int64 *)v92;
    a2 = 12LL;
    a1 = "/lib/locale";
LABEL_30:
    if ( v27 )
      goto LABEL_31;
    goto LABEL_85;
  }
  a1 = "/lib/locale";
  a2 = 12LL;
LABEL_85:
  v92 = (char *)*a4;
LABEL_31:
  strlen();
  v28 = (unsigned __int8 *)j_memcpy();
  v37 = nl_explode_name(v28, &v93, &v94, (char *)&v95, &v96, &v97, v29, v30, v31, v32, v33, v34, v35, v36);
  if ( v37 == -1 )
    return 0LL;
  v38 = &nl_category_names[(unsigned __int8)nl_category_name_idxs[a3]];
  l10nflist = nl_make_l10nflist(
                &nl_locale_file_list[a3],
                (unsigned __int64)a1,
                a2,
                v37,
                v93,
                v95,
                (unsigned __int64)v96,
                v97,
                v94,
                (__int64)v38,
                0);
  if ( !l10nflist )
  {
    l10nflist = nl_make_l10nflist(
                  &nl_locale_file_list[a3],
                  (unsigned __int64)a1,
                  a2,
                  v37,
                  v93,
                  v95,
                  (unsigned __int64)v96,
                  v97,
                  v94,
                  (__int64)v38,
                  1);
    if ( !l10nflist )
      return 0LL;
  }
  if ( (v37 & 1) != 0 )
    free(v97, v45, v46, v47, v48, v49, v50, v51, v52);
  if ( !*(_DWORD *)(l10nflist + 8) )
    nl_load_locale(l10nflist, a3);
  v53 = *(__int64 (__fastcall ***)(__int64, __int64 *, unsigned __int64))(l10nflist + 16);
  if ( !v53 )
  {
    v86 = *(_QWORD *)(l10nflist + 32);
    if ( !v86 )
      goto LABEL_93;
    v87 = (unsigned __int64 *)(l10nflist + 32);
    while ( 1 )
    {
      if ( !*(_DWORD *)(v86 + 8) )
        nl_load_locale(v86, a3);
      v88 = *v87;
      if ( *(_QWORD *)(*v87 + 16) )
        break;
      v89 = v87[1];
      ++v87;
      v86 = v89;
      if ( !v89 )
      {
        *(_QWORD *)(l10nflist + 32) = 0LL;
        goto LABEL_93;
      }
    }
    v53 = *(__int64 (__fastcall ***)(__int64, __int64 *, unsigned __int64))(*v87 + 16);
    *(_QWORD *)(l10nflist + 32) = v88;
    l10nflist = v88;
  }
  v54 = v96;
  if ( v96 )
  {
    v55 = v53[codeset_idx_2[a3] + 7];
    if ( !v55 )
      _libc_assert_fail((__int64)"locale_codeset != NULL", (__int64)"findlocale.c", 0x121u, (__int64)"_nl_find_locale");
    strlen();
    v56 = *(unsigned __int8 *)v55;
    v57 = &v91;
    if ( *(_BYTE *)v55 )
    {
      v58 = 0;
      while ( 1 )
      {
        v60 = (unsigned __int8)(v56 - 44);
        if ( v60 <= 0x33 )
          break;
        if ( (word_45EA40[(unsigned __int8)v56] & 8) != 0 )
          goto LABEL_43;
LABEL_44:
        v59 = *((unsigned __int8 *)v55 + 1);
        v55 = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))((char *)v55 + 1);
        v56 = v59;
        if ( !v59 )
        {
          if ( v58 <= 1 )
          {
            v77 = v58 + 1;
            goto LABEL_72;
          }
          goto LABEL_73;
        }
      }
      if ( !(!(((__int64)0xFFF7FFFFFFFFBFF8LL >> v60) & 1) | ((word_45EA40[(unsigned __int8)v56] & 8u) >> 3) & 1) )
      {
        if ( v56 == 47 )
        {
          if ( v58 == 2 )
            goto LABEL_73;
          ++v58;
          *(_BYTE *)v57 = 47;
          v57 = (unsigned __int64 *)((char *)v57 + 1);
        }
        goto LABEL_44;
      }
LABEL_43:
      *(_BYTE *)v57 = dword_45E140[v56];
      v57 = (unsigned __int64 *)((char *)v57 + 1);
      goto LABEL_44;
    }
    v77 = 1;
LABEL_72:
    v57 = (unsigned __int64 *)((char *)memset() + (unsigned int)(2 - v77) + 1);
LABEL_73:
    *(_BYTE *)v57 = 0;
    strlen();
    v78 = *(unsigned __int8 *)v54;
    if ( *(_BYTE *)v54 )
    {
      v62 = &v91;
      v79 = 0;
      while ( 1 )
      {
        v81 = (unsigned __int8)(v78 - 44);
        if ( v81 <= 0x33 )
          break;
        if ( (word_45EA40[(unsigned __int8)v78] & 8) != 0 )
          goto LABEL_76;
LABEL_77:
        v80 = *((unsigned __int8 *)v54 + 1);
        v54 = (unsigned __int64 *)((char *)v54 + 1);
        v78 = v80;
        if ( !v80 )
        {
          if ( v79 <= 1 )
          {
            v61 = v79 + 1;
            goto LABEL_52;
          }
          goto LABEL_53;
        }
      }
      if ( ((__int64)0xFFF7FFFFFFFFBFF8LL >> v81) & 1 && (word_45EA40[(unsigned __int8)v78] & 8) == 0 )
      {
        if ( v78 == 47 )
        {
          if ( v79 == 2 )
            goto LABEL_53;
          ++v79;
          *(_BYTE *)v62 = 47;
          v62 = (unsigned __int64 *)((char *)v62 + 1);
        }
        goto LABEL_77;
      }
LABEL_76:
      *(_BYTE *)v62 = dword_45E140[v78];
      v62 = (unsigned __int64 *)((char *)v62 + 1);
      goto LABEL_77;
    }
    v61 = 1;
LABEL_52:
    v62 = (unsigned __int64 *)((char *)memset() + (unsigned int)(2 - v61) + 1);
LABEL_53:
    v63 = &v91;
    *(_BYTE *)v62 = 0;
    do
    {
      v64 = *(unsigned __int8 *)v63;
      v63 = (unsigned __int64 *)((char *)v63 + 1);
      v65 = (unsigned __int8)dword_45E140[v64];
      *((_BYTE *)v63 - 1) = v65;
    }
    while ( v65 );
    v66 = &v91;
    do
    {
      v67 = *(unsigned __int8 *)v66;
      v66 = (unsigned __int64 *)((char *)v66 + 1);
      v68 = (unsigned __int8)dword_45E140[v67];
      *((_BYTE *)v66 - 1) = v68;
    }
    while ( v68 );
    if ( !(unsigned int)_gconv_compare_alias(&v91, (unsigned __int8 *)&v91) )
    {
      v53 = *(__int64 (__fastcall ***)(__int64, __int64 *, unsigned __int64))(l10nflist + 16);
      goto LABEL_59;
    }
LABEL_93:
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 2;
    return 0LL;
  }
LABEL_59:
  if ( !*v53 )
  {
    v82 = strrchr(*(_QWORD *)l10nflist, 0x2Fu, v39, v40, v41, v42, v43);
    v83 = v82 - 1;
    if ( *(_BYTE *)(v82 - 2) == 47 )
    {
      v85 = 1LL;
    }
    else
    {
      do
      {
        v84 = *(unsigned __int8 *)(v83 - 2);
        --v83;
      }
      while ( v84 != 47 );
      v85 = v82 - v83;
    }
    *v53 = strndup(v83, v85);
  }
  if ( v94 )
  {
    v69 = strcasecmp_l(v94, (__int64)"TRANSLIT", (__int64)nl_C_locobj);
    result = *(char ***)(l10nflist + 16);
    if ( !v69 )
      *((_DWORD *)result + 11) = 1;
  }
  else
  {
    result = *(char ***)(l10nflist + 16);
  }
  v70 = *((_DWORD *)result + 10);
  if ( v70 <= 0xFFFFFFFD )
    *((_DWORD *)result + 10) = v70 + 1;
  return result;
}
// 44102C: variable 'v10' is possibly undefined
// 44102C: variable 'v11' is possibly undefined
// 44102C: variable 'v12' is possibly undefined
// 44102C: variable 'v13' is possibly undefined
// 44102C: variable 'v90' is possibly undefined
// 441084: variable 'v16' is possibly undefined
// 441084: variable 'v17' is possibly undefined
// 441084: variable 'v18' is possibly undefined
// 441084: variable 'v19' is possibly undefined
// 441084: variable 'v20' is possibly undefined
// 441084: variable 'v21' is possibly undefined
// 44121C: variable 'v29' is possibly undefined
// 44121C: variable 'v30' is possibly undefined
// 44121C: variable 'v31' is possibly undefined
// 44121C: variable 'v32' is possibly undefined
// 44121C: variable 'v33' is possibly undefined
// 44121C: variable 'v34' is possibly undefined
// 44121C: variable 'v35' is possibly undefined
// 44121C: variable 'v36' is possibly undefined
// 441660: variable 'v45' is possibly undefined
// 441660: variable 'v46' is possibly undefined
// 441660: variable 'v47' is possibly undefined
// 441660: variable 'v48' is possibly undefined
// 441660: variable 'v49' is possibly undefined
// 441660: variable 'v50' is possibly undefined
// 441660: variable 'v51' is possibly undefined
// 441660: variable 'v52' is possibly undefined
// 441464: variable 'v71' is possibly undefined
// 441464: variable 'v72' is possibly undefined
// 441464: variable 'v73' is possibly undefined
// 441464: variable 'v74' is possibly undefined
// 441464: variable 'v75' is possibly undefined
// 441464: variable 'v76' is possibly undefined
// 44158C: variable 'v39' is possibly undefined
// 44158C: variable 'v40' is possibly undefined
// 44158C: variable 'v41' is possibly undefined
// 44158C: variable 'v42' is possibly undefined
// 44158C: variable 'v43' is possibly undefined
// 441700: using guessed type __int64 nl_remove_locale(void);
// 45C780: using guessed type int codeset_idx_2[16];
// 45E140: using guessed type int dword_45E140[256];
// 45EA40: using guessed type _WORD word_45EA40[256];
// 48FA30: using guessed type char **nl_C_locobj[6];
// 48FB20: using guessed type char **nl_C[6];
// 496FE0: using guessed type _QWORD nl_locale_file_list[2];

//----- (0000000000441700) ----------------------------------------------------
void __fastcall nl_remove_locale(
        int a1,
        unsigned __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  int v10; // w2
  __int64 i; // x2

  v10 = *(_DWORD *)(a2 + 40) - 1;
  *(_DWORD *)(a2 + 40) = v10;
  if ( !v10 )
  {
    if ( *(_DWORD *)(a2 + 24) != 2 )
    {
      for ( i = nl_locale_file_list[a1]; *(_QWORD *)(i + 16) != a2; i = *(_QWORD *)(i + 24) )
        ;
      *(_DWORD *)(i + 8) = 0;
      *(_QWORD *)(i + 16) = 0LL;
    }
    nl_unload_locale(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10);
  }
}
// 496FE0: using guessed type _QWORD nl_locale_file_list[2];

//----- (0000000000441760) ----------------------------------------------------
__int64 __fastcall nl_load_locale_from_archive(
        int a1,
        unsigned __int64 **a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8)
{
  unsigned __int64 *v9; // x21
  _QWORD *v10; // x19
  unsigned __int64 *v11; // x20
  __int64 result; // x0
  __int64 v13; // x0
  __int64 v14; // x24
  unsigned __int64 (__fastcall *v15)(__int64); // x0
  unsigned int v16; // w25
  unsigned __int64 *v17; // x1
  int v18; // t1
  unsigned __int64 v19; // t2
  unsigned __int64 v20; // x1
  unsigned int v21; // w0
  unsigned __int64 v22; // x28
  unsigned __int64 v23; // x27
  unsigned __int64 v24; // x20
  _DWORD *v25; // x19
  unsigned int v26; // w1
  unsigned int v27; // w0
  void *v28; // x5
  double v29; // d0
  double v30; // d1
  double v31; // d2
  double v32; // d3
  double v33; // d4
  double v34; // d5
  double v35; // d6
  double v36; // d7
  unsigned __int64 v37; // x3
  unsigned int v38; // w0
  unsigned int v39; // w8
  _BYTE *v40; // x19
  unsigned int *v41; // x0
  _QWORD *v42; // x1
  __int64 v43; // x2
  unsigned int v44; // w6
  __int64 v45; // x7
  void *v46; // x4
  _QWORD *v47; // x26
  __int64 (__fastcall *v48)(__int64, __int64 *, unsigned __int64); // x0
  __int64 v49; // x4
  __int64 v50; // x5
  void *v51; // x6
  __int64 v52; // x7
  double v53; // d0
  double v54; // d1
  double v55; // d2
  double v56; // d3
  double v57; // d4
  double v58; // d5
  double v59; // d6
  double v60; // d7
  __int64 v61; // x3
  __int64 v62; // x0
  unsigned __int64 *v63; // x20
  bool v64; // zf
  _DWORD *v65; // x1
  unsigned __int64 v66; // x2
  unsigned __int64 v67; // x0
  int v68; // w3
  int v69; // w0
  int v70; // w25
  int8x16_t *v71; // x19
  unsigned __int64 v72; // x0
  unsigned __int64 v73; // x26
  _WORD *v74; // x2
  char *v75; // x3
  unsigned __int64 v76; // x4
  __int64 v77; // x5
  void *v78; // x6
  __int64 v79; // x7
  double v80; // d0
  double v81; // d1
  double v82; // d2
  double v83; // d3
  double v84; // d4
  double v85; // d5
  double v86; // d6
  double v87; // d7
  _DWORD *v88; // x0
  unsigned __int64 v89; // x20
  double v90; // d0
  double v91; // d1
  double v92; // d2
  double v93; // d3
  double v94; // d4
  double v95; // d5
  double v96; // d6
  double v97; // d7
  size_t v98; // x26
  unsigned int *v99; // x0
  __int64 v100; // x2
  unsigned int v101; // w1
  __int64 v102; // [xsp+0h] [xbp+0h] BYREF
  __int64 v103; // [xsp+60h] [xbp+60h]
  int v104; // [xsp+6Ch] [xbp+6Ch]
  _BYTE v105[208]; // [xsp+70h] [xbp+70h] BYREF

  v9 = *a2;
  v104 = a1;
  sysconf(30, (__int64)a2, a3, a4, a5, a6, a7, a8);
  v10 = (_QWORD *)archloaded;
  if ( archloaded )
  {
    while ( 1 )
    {
      v11 = (unsigned __int64 *)v10[1];
      if ( v11 == v9 || !(unsigned int)strcmp(v9, v10[1]) )
        break;
      v10 = (_QWORD *)*v10;
      if ( !v10 )
        goto LABEL_7;
    }
    result = v10[v104 + 2];
    *a2 = v11;
  }
  else
  {
LABEL_7:
    v13 = strchr((__int64)v9, 0x2Eu);
    if ( v13 && (*(_BYTE *)(v13 + 1) & 0xBF) != 0 )
    {
      v71 = (int8x16_t *)(v13 + 1);
      v72 = strchrnul(v13 + 1, 0x40u);
      v73 = v72 - (_QWORD)v71;
      v88 = nl_normalize_codeset(
              v71,
              v72 - (_QWORD)v71,
              v74,
              v75,
              v76,
              v77,
              v78,
              v79,
              v80,
              v81,
              v82,
              v83,
              v84,
              v85,
              v86,
              v87);
      v89 = (unsigned __int64)v88;
      if ( !v88 )
        return 0LL;
      if ( (unsigned int)strncmp((unsigned __int64)v88, (unsigned __int64)v71, v73) || *(_BYTE *)(v89 + v73) )
      {
        strlen();
        strlen();
        v9 = (unsigned __int64 *)&v102;
        j_memcpy();
        j_memcpy();
        j_memcpy();
      }
      free(v89, v90, v91, v92, v93, v94, v95, v96, v97);
    }
    if ( archmapped )
    {
      v14 = headmap;
      if ( headmap )
      {
LABEL_11:
        v15 = strlen();
        if ( !v15 )
          goto LABEL_43;
        v16 = (unsigned int)v15;
        v17 = v9;
        do
        {
          v18 = *(unsigned __int8 *)v17;
          v17 = (unsigned __int64 *)((char *)v17 + 1);
          HIDWORD(v19) = v16;
          LODWORD(v19) = v16;
          v16 = v18 + (v19 >> 23);
        }
        while ( v17 != (unsigned __int64 *)((char *)v9 + (_QWORD)v15) );
        v20 = v16;
        if ( !v16 )
        {
LABEL_43:
          v20 = 0xFFFFFFFFLL;
          v16 = -1;
        }
        v21 = *(_DWORD *)(v14 + 16);
        if ( v21 > 2 )
        {
          v22 = v21;
          v103 = v14 + *(unsigned int *)(v14 + 8);
          v23 = v20 % (v21 - 2) + 1;
          v24 = v20 % v21;
LABEL_17:
          v25 = (_DWORD *)(v103 + 12 * v24);
          while ( 1 )
          {
            v26 = v25[1];
            if ( !v26 )
              break;
            if ( *v25 == v16 )
            {
              v27 = strcmp(v9, v14 + v26);
              v37 = v27;
              if ( !v27 )
              {
                v38 = v25[2];
                if ( v38 )
                {
                  v39 = dword_497064;
                  if ( qword_4970A0 != dword_497064 )
                    _libc_assert_fail(
                      (__int64)"headmap.len == archive_stat.st_size",
                      (__int64)"loadarchive.c",
                      0x136u,
                      (__int64)"_nl_load_locale_from_archive");
                  v40 = v105;
                  v41 = (unsigned int *)(v14 + v38 + 4);
                  v42 = v105;
                  LODWORD(v43) = 0;
                  while ( 1 )
                  {
                    if ( (_DWORD)v43 == 6 )
                    {
                      v42 += 2;
                      v41 += 2;
                      LODWORD(v43) = 7;
                    }
                    v44 = v41[1];
                    v45 = *v41 + v44;
                    if ( v39 < (unsigned int)v45 )
                      break;
                    v46 = (void *)(v14 + *v41);
                    v43 = (unsigned int)(v43 + 1);
                    *v42 = v46;
                    v42[1] = v44;
                    v42 += 2;
                    v41 += 2;
                    if ( (_DWORD)v43 == 13 )
                    {
                      LODWORD(v103) = v37;
                      v47 = (_QWORD *)malloc(
                                        120LL,
                                        (__int64)v42,
                                        v43,
                                        (void *)v37,
                                        v46,
                                        v28,
                                        (void *)v44,
                                        v45,
                                        v29,
                                        v30,
                                        v31,
                                        v32,
                                        v33,
                                        v34,
                                        v35,
                                        v36);
                      if ( !v47 )
                        return 0LL;
                      v48 = strdup();
                      v47[1] = v48;
                      LODWORD(v61) = v103;
                      if ( v48 )
                      {
                        v62 = archloaded;
                        v63 = v47 + 2;
                        archloaded = (__int64)v47;
                        *v47 = v62;
                        do
                        {
                          v64 = (_DWORD)v61 == 6;
                          if ( (_DWORD)v61 == 6 )
                          {
                            v40 += 16;
                            v61 = 7LL;
                          }
                          else
                          {
                            v61 = (unsigned int)v61;
                          }
                          if ( v64 )
                            ++v63;
                          v65 = *(_DWORD **)v40;
                          v66 = *((_QWORD *)v40 + 1);
                          LODWORD(v103) = v61;
                          v67 = nl_intern_locale_data(
                                  v61,
                                  v65,
                                  v66,
                                  v53,
                                  v54,
                                  v55,
                                  v56,
                                  v57,
                                  v58,
                                  v59,
                                  v60,
                                  v61,
                                  v49,
                                  v50,
                                  v51,
                                  v52);
                          *v63 = v67;
                          v68 = v103;
                          if ( v67 )
                          {
                            *(_QWORD *)v67 = v47[1];
                            *(_DWORD *)(v67 + 24) = 2;
                            *(_DWORD *)(v67 + 40) = -1;
                          }
                          LODWORD(v61) = v68 + 1;
                          v40 += 16;
                          ++v63;
                        }
                        while ( (_DWORD)v61 != 13 );
                        *a2 = (unsigned __int64 *)v47[1];
                        return v47[v104 + 2];
                      }
                      else
                      {
                        free((unsigned __int64)v47, v53, v54, v55, v56, v57, v58, v59, v60);
                        return 0LL;
                      }
                    }
                  }
                }
                return 0LL;
              }
            }
            v24 += v23;
            v25 += 3 * (unsigned int)v23;
            if ( v22 <= v24 )
            {
              v24 -= v22;
              goto LABEL_17;
            }
          }
        }
      }
      return 0LL;
    }
    archmapped = (__int64)&headmap;
    v69 = _open_nocancel("/lib/locale/locale-archive", 0x80000);
    v70 = v69;
    if ( v69 < 0 )
      return 0LL;
    if ( (unsigned int)fstat64(v69, (struct stat *)&archive_stat) != -1 )
    {
      v98 = qword_4970A0;
      v99 = (unsigned int *)mmap64(0LL, qword_4970A0, 1, 2, v70, 0LL);
      v14 = (__int64)v99;
      if ( v99 != (unsigned int *)-1LL )
      {
        v100 = v99[2] + 12LL * v99[4];
        if ( v100 < v99[8] + 108LL * v99[9] )
          v100 = v99[8] + 108LL * v99[9];
        v101 = v99[6];
        if ( v100 < v99[5] + v101 )
          v100 = v99[5] + v101;
        if ( v98 >= v100 )
        {
          _close_nocancel(v70);
          dword_497064 = v98;
          headmap = v14;
          goto LABEL_11;
        }
        munmap(v99, v98);
      }
    }
    _close_nocancel(v70);
    return 0LL;
  }
  return result;
}
// 44196C: variable 'v28' is possibly undefined
// 44196C: variable 'v29' is possibly undefined
// 44196C: variable 'v30' is possibly undefined
// 44196C: variable 'v31' is possibly undefined
// 44196C: variable 'v32' is possibly undefined
// 44196C: variable 'v33' is possibly undefined
// 44196C: variable 'v34' is possibly undefined
// 44196C: variable 'v35' is possibly undefined
// 44196C: variable 'v36' is possibly undefined
// 4419CC: variable 'v53' is possibly undefined
// 4419CC: variable 'v54' is possibly undefined
// 4419CC: variable 'v55' is possibly undefined
// 4419CC: variable 'v56' is possibly undefined
// 4419CC: variable 'v57' is possibly undefined
// 4419CC: variable 'v58' is possibly undefined
// 4419CC: variable 'v59' is possibly undefined
// 4419CC: variable 'v60' is possibly undefined
// 4419CC: variable 'v49' is possibly undefined
// 4419CC: variable 'v50' is possibly undefined
// 4419CC: variable 'v51' is possibly undefined
// 4419CC: variable 'v52' is possibly undefined
// 441A90: variable 'v74' is possibly undefined
// 441A90: variable 'v75' is possibly undefined
// 441A90: variable 'v76' is possibly undefined
// 441A90: variable 'v77' is possibly undefined
// 441A90: variable 'v78' is possibly undefined
// 441A90: variable 'v79' is possibly undefined
// 441A90: variable 'v80' is possibly undefined
// 441A90: variable 'v81' is possibly undefined
// 441A90: variable 'v82' is possibly undefined
// 441A90: variable 'v83' is possibly undefined
// 441A90: variable 'v84' is possibly undefined
// 441A90: variable 'v85' is possibly undefined
// 441A90: variable 'v86' is possibly undefined
// 441A90: variable 'v87' is possibly undefined
// 441B1C: variable 'v90' is possibly undefined
// 441B1C: variable 'v91' is possibly undefined
// 441B1C: variable 'v92' is possibly undefined
// 441B1C: variable 'v93' is possibly undefined
// 441B1C: variable 'v94' is possibly undefined
// 441B1C: variable 'v95' is possibly undefined
// 441B1C: variable 'v96' is possibly undefined
// 441B1C: variable 'v97' is possibly undefined
// 497048: using guessed type __int64 archloaded;
// 497050: using guessed type __int64 archmapped;
// 497058: using guessed type __int64 headmap;
// 497064: using guessed type int dword_497064;
// 4970A0: using guessed type __int64 qword_4970A0;

//----- (0000000000441C00) ----------------------------------------------------
void __fastcall nl_archive_subfreeres(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  _QWORD *v8; // x21
  unsigned __int64 v9; // x22
  _QWORD *v10; // x20
  __int64 v11; // x19
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  unsigned __int64 v20; // x1
  __int64 v21; // x19
  size_t v22; // x1
  __int64 v23; // x19
  void **v24; // x20
  size_t v25; // x1
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7

  v8 = (_QWORD *)archloaded;
  if ( archloaded )
  {
    do
    {
      v9 = (unsigned __int64)v8;
      v10 = v8 + 2;
      v8 = (_QWORD *)*v8;
      v11 = 0LL;
      free(*(_QWORD *)(v9 + 8), a1, a2, a3, a4, a5, a6, a7, a8);
      do
      {
        if ( v11 == 6 )
          v11 = 7LL;
        v20 = v10[v11];
        if ( v20 )
          nl_unload_locale(v11, v20, v12, v13, v14, v15, v16, v17, v18, v19);
        ++v11;
      }
      while ( v11 != 13 );
      free(v9, v12, v13, v14, v15, v16, v17, v18, v19);
    }
    while ( v8 );
  }
  archloaded = 0LL;
  v21 = archmapped;
  if ( archmapped )
  {
    if ( (__int64 *)archmapped != &headmap )
      _libc_assert_fail(
        (__int64)"archmapped == &headmap",
        (__int64)"loadarchive.c",
        0x210u,
        (__int64)"_nl_archive_subfreeres");
    v22 = *(unsigned int *)(archmapped + 12);
    archmapped = 0LL;
    munmap(*(void **)v21, v22);
    v23 = *(_QWORD *)(v21 + 16);
    while ( v23 )
    {
      v24 = (void **)v23;
      v25 = *(unsigned int *)(v23 + 12);
      v23 = *(_QWORD *)(v23 + 16);
      munmap(*v24, v25);
      free((unsigned __int64)v24, v26, v27, v28, v29, v30, v31, v32, v33);
    }
  }
}
// 441C34: variable 'a1' is possibly undefined
// 441C34: variable 'a2' is possibly undefined
// 441C34: variable 'a3' is possibly undefined
// 441C34: variable 'a4' is possibly undefined
// 441C34: variable 'a5' is possibly undefined
// 441C34: variable 'a6' is possibly undefined
// 441C34: variable 'a7' is possibly undefined
// 441C34: variable 'a8' is possibly undefined
// 441C58: variable 'v12' is possibly undefined
// 441C58: variable 'v13' is possibly undefined
// 441C58: variable 'v14' is possibly undefined
// 441C58: variable 'v15' is possibly undefined
// 441C58: variable 'v16' is possibly undefined
// 441C58: variable 'v17' is possibly undefined
// 441C58: variable 'v18' is possibly undefined
// 441C58: variable 'v19' is possibly undefined
// 441CC0: variable 'v26' is possibly undefined
// 441CC0: variable 'v27' is possibly undefined
// 441CC0: variable 'v28' is possibly undefined
// 441CC0: variable 'v29' is possibly undefined
// 441CC0: variable 'v30' is possibly undefined
// 441CC0: variable 'v31' is possibly undefined
// 441CC0: variable 'v32' is possibly undefined
// 441CC0: variable 'v33' is possibly undefined
// 441D00: using guessed type __int64 nl_intern_locale_data(void);
// 497048: using guessed type __int64 archloaded;
// 497050: using guessed type __int64 archmapped;
// 497058: using guessed type __int64 headmap;

//----- (0000000000441D00) ----------------------------------------------------
unsigned __int64 __fastcall nl_intern_locale_data(
        int a1,
        _DWORD *a2,
        unsigned __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        void *a15,
        __int64 a16)
{
  int v16; // w3
  unsigned __int64 v17; // x3
  void *v18; // x4
  char *v19; // x3
  unsigned __int64 v20; // x0
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  _DWORD *v29; // x1
  unsigned __int64 v30; // x2
  unsigned __int64 v31; // x4
  int v32; // w10
  char *v33; // x11
  unsigned __int64 v34; // x8
  __int64 v35; // x14
  _DWORD *v36; // x7
  _DWORD *v37; // x1
  unsigned __int64 v38; // x3
  unsigned int v39; // w6
  unsigned __int64 v40; // x5
  unsigned __int64 v42; // x0
  char *v43; // x3
  bool v44; // zf
  unsigned __int64 v45; // x20
  __int64 v46; // x3
  __int64 v47; // x1
  __int64 v48; // x19
  unsigned __int8 *v49; // x0
  int v50; // w2
  char *v52; // [xsp+30h] [xbp-20h]
  __int64 v53; // [xsp+30h] [xbp-20h]
  __int64 v56; // [xsp+38h] [xbp-18h]
  unsigned __int64 v59; // [xsp+40h] [xbp-10h]

  if ( a3 > 7 )
  {
    if ( a1 == 3 )
    {
      v16 = 537202711;
    }
    else
    {
      v16 = a1 ^ 0x20031115;
      a14 = 537462560LL;
      if ( !a1 )
        v16 = 537462560;
    }
    if ( *a2 == v16 )
    {
      v17 = (unsigned int)a2[1];
      if ( v17 >= nl_category_num_items[a1] )
      {
        v18 = (void *)(v17 + 2);
        if ( a3 > 4 * (v17 + 2) )
        {
          v19 = (char *)(8 * (v17 + 7));
          if ( a1 )
          {
            v20 = malloc(
                    (__int64)v19,
                    (__int64)a2,
                    a3,
                    v19,
                    v18,
                    (void *)a14,
                    a15,
                    a16,
                    a4,
                    a5,
                    a6,
                    a7,
                    a8,
                    a9,
                    a10,
                    a11);
            v29 = a2;
            v30 = a3;
            v31 = v20;
            v32 = a1;
            v33 = "";
            if ( v20 )
            {
              *(_QWORD *)(v20 + 8) = a2;
              *(_QWORD *)(v20 + 16) = a3;
              *(_QWORD *)(v20 + 32) = 0LL;
              *(_QWORD *)(v20 + 40) = 0LL;
              LODWORD(v34) = a2[1];
              *(_DWORD *)(v20 + 48) = v34;
              if ( !(_DWORD)v34 )
                return v31;
              v34 = (unsigned int)v34;
              v35 = 0LL;
              goto LABEL_12;
            }
          }
          else
          {
            v52 = v19;
            v42 = malloc(
                    (__int64)(v19 + 24),
                    (__int64)a2,
                    a3,
                    v19,
                    v18,
                    (void *)a14,
                    a15,
                    a16,
                    a4,
                    a5,
                    a6,
                    a7,
                    a8,
                    a9,
                    a10,
                    a11);
            v31 = v42;
            v29 = a2;
            v33 = "US-ASCII//" + 10;
            v32 = 0;
            if ( v42 )
            {
              v43 = &v52[v42];
              *(_QWORD *)(v42 + 8) = a2;
              *(_QWORD *)(v42 + 16) = a3;
              *(_QWORD *)(v42 + 32) = &v52[v42];
              *(_QWORD *)v43 = 0LL;
              *((_QWORD *)v43 + 1) = 0LL;
              *((_QWORD *)v43 + 2) = 0LL;
              *(_QWORD *)(v42 + 40) = 0LL;
              LODWORD(v34) = a2[1];
              *(_DWORD *)(v42 + 48) = v34;
              if ( !(_DWORD)v34 )
              {
LABEL_37:
                v45 = v31 + 384;
                v46 = *(_QWORD *)(v31 + 32);
                v47 = 0LL;
                v48 = v46 + 9;
                *(_QWORD *)(v46 + 9) = 0x101010101010101LL;
                *(_WORD *)(v46 + 17) = 257;
                do
                {
                  while ( 1 )
                  {
                    v49 = *(unsigned __int8 **)(v45 + 8 * v47);
                    if ( *v49 != (_DWORD)v47 + 48 || (v50 = 1, v49[1]) )
                    {
                      v53 = v46;
                      v56 = v47;
                      *(_BYTE *)(v46 + 8) = 1;
                      v59 = v31;
                      v50 = (unsigned __int8)strlen();
                      v46 = v53;
                      v47 = v56;
                      v31 = v59;
                    }
                    *(_BYTE *)(v48 + v47) = v50;
                    if ( v47 )
                      break;
                    v47 = 1LL;
                    *(_BYTE *)(v46 + 19) = v50;
                  }
                  if ( *(unsigned __int8 *)(v46 + 19) != v50 )
                    *(_BYTE *)(v46 + 19) = 0;
                  ++v47;
                }
                while ( v47 != 10 );
                return v31;
              }
              v30 = *(_QWORD *)(v42 + 16);
              v34 = (unsigned int)v34;
              v35 = 24LL;
LABEL_12:
              v36 = (_DWORD *)(v31 + 56);
              v37 = v29 + 2;
              v38 = 0LL;
              while ( 2 )
              {
                v39 = v37[v38];
                v40 = v39;
                if ( v30 < v39 )
                  goto LABEL_19;
                switch ( v32 )
                {
                  case 1:
                    do
                    {
                      if ( v38 > 5 )
                        break;
                      if ( *(_DWORD *)&v33[4 * (unsigned int)v38 + 2960] != 5 )
                        goto LABEL_31;
                      if ( (v39 & 3) != 0 )
                        break;
                      ++v38;
                      *v36 = *(_DWORD *)(*(_QWORD *)(v31 + 8) + v40);
                      if ( v34 <= v38 )
                        goto LABEL_32;
                      v39 = v37[v38];
                      v36 += 2;
                      v40 = v39;
                    }
                    while ( v30 >= v39 );
                    goto LABEL_19;
                  case 2:
                    while ( 2 )
                    {
                      if ( v38 == 159 )
                        goto LABEL_19;
                      if ( *(_DWORD *)&v33[4 * (unsigned int)v38 + 2992] != 5 )
                        goto LABEL_31;
                      if ( (v39 & 3) != 0 )
                        goto LABEL_19;
                      ++v38;
                      *v36 = *(_DWORD *)(*(_QWORD *)(v31 + 8) + v40);
                      if ( v34 > v38 )
                      {
                        v39 = v37[v38];
                        v36 += 2;
                        v40 = v39;
                        if ( v30 < v39 )
                          goto LABEL_19;
                        continue;
                      }
                      goto LABEL_32;
                    }
                  case 3:
                    while ( 2 )
                    {
                      if ( v38 > 0x12 )
                        goto LABEL_19;
                      if ( *(_DWORD *)&v33[4 * (unsigned int)v38 + 2880] != 5 )
                        goto LABEL_31;
                      if ( (v39 & 3) != 0 )
                        goto LABEL_19;
                      ++v38;
                      *v36 = *(_DWORD *)(*(_QWORD *)(v31 + 8) + v40);
                      if ( v34 > v38 )
                      {
                        v39 = v37[v38];
                        v36 += 2;
                        v40 = v39;
                        if ( v30 < v39 )
                          goto LABEL_19;
                        continue;
                      }
                      goto LABEL_32;
                    }
                  case 4:
                    do
                    {
                      if ( v38 > 0x2D )
                        break;
                      if ( *(_DWORD *)&v33[4 * (unsigned int)v38 + 2480] != 5 )
                        goto LABEL_31;
                      if ( (v39 & 3) != 0 )
                        break;
                      ++v38;
                      *v36 = *(_DWORD *)(*(_QWORD *)(v31 + 8) + v40);
                      if ( v34 <= v38 )
                        goto LABEL_32;
                      v39 = v37[v38];
                      v36 += 2;
                      v40 = v39;
                    }
                    while ( v30 >= v39 );
                    goto LABEL_19;
                  case 5:
                    do
                    {
                      if ( v38 > 4 )
                        break;
                      if ( *(_DWORD *)&v33[4 * (unsigned int)v38 + 2672] != 5 )
                        goto LABEL_31;
                      if ( (v39 & 3) != 0 )
                        break;
                      ++v38;
                      *v36 = *(_DWORD *)(*(_QWORD *)(v31 + 8) + v40);
                      if ( v34 <= v38 )
                        goto LABEL_32;
                      v39 = v37[v38];
                      v36 += 2;
                      v40 = v39;
                    }
                    while ( v30 >= v39 );
                    goto LABEL_19;
                  case 7:
                    do
                    {
                      if ( v38 > 2 )
                        break;
                      if ( *(_DWORD *)&v33[4 * (unsigned int)v38 + 2696] != 5 )
                        goto LABEL_31;
                      if ( (v39 & 3) != 0 )
                        break;
                      ++v38;
                      *v36 = *(_DWORD *)(*(_QWORD *)(v31 + 8) + v40);
                      if ( v34 <= v38 )
                        goto LABEL_32;
                      v39 = v37[v38];
                      v36 += 2;
                      v40 = v39;
                    }
                    while ( v30 >= v39 );
                    goto LABEL_19;
                  case 8:
                    do
                    {
                      if ( v38 > 6 )
                        break;
                      if ( *(_DWORD *)&v33[4 * (unsigned int)v38 + 2720] != 5 )
                        goto LABEL_31;
                      if ( (v39 & 3) != 0 )
                        break;
                      ++v38;
                      *v36 = *(_DWORD *)(*(_QWORD *)(v31 + 8) + v40);
                      if ( v34 <= v38 )
                        goto LABEL_32;
                      v39 = v37[v38];
                      v36 += 2;
                      v40 = v39;
                    }
                    while ( v30 >= v39 );
                    goto LABEL_19;
                  case 9:
                    do
                    {
                      if ( v38 > 0xC )
                        break;
                      if ( *(_DWORD *)&v33[4 * (unsigned int)v38 + 2752] != 5 )
                        goto LABEL_31;
                      if ( (v39 & 3) != 0 )
                        break;
                      ++v38;
                      *v36 = *(_DWORD *)(*(_QWORD *)(v31 + 8) + v40);
                      if ( v34 <= v38 )
                        goto LABEL_32;
                      v39 = v37[v38];
                      v36 += 2;
                      v40 = v39;
                    }
                    while ( v30 >= v39 );
                    goto LABEL_19;
                  case 10:
                    do
                    {
                      if ( v38 > 4 )
                        break;
                      if ( nl_value_type_LC_TELEPHONE[(unsigned int)v38] != 5 )
                        goto LABEL_31;
                      if ( (v39 & 3) != 0 )
                        break;
                      ++v38;
                      *v36 = *(_DWORD *)(*(_QWORD *)(v31 + 8) + v40);
                      if ( v34 <= v38 )
                        goto LABEL_32;
                      v39 = v37[v38];
                      v36 += 2;
                      v40 = v39;
                    }
                    while ( v30 >= v39 );
                    goto LABEL_19;
                  case 11:
                    do
                    {
                      if ( v38 > 1 )
                        break;
                      if ( nl_value_type_LC_MEASUREMENT[(unsigned int)v38] != 5 )
                        goto LABEL_31;
                      if ( (v39 & 3) != 0 )
                        break;
                      ++v38;
                      *v36 = *(_DWORD *)(*(_QWORD *)(v31 + 8) + v40);
                      if ( v34 <= v38 )
                        goto LABEL_32;
                      v39 = v37[v38];
                      v36 += 2;
                      v40 = v39;
                    }
                    while ( v30 >= v39 );
                    goto LABEL_19;
                  case 12:
                    while ( 2 )
                    {
                      if ( v38 > 0xF )
                        goto LABEL_19;
                      if ( *(_DWORD *)&v33[4 * (unsigned int)v38 + 2816] == 5 )
                      {
                        if ( (v39 & 3) != 0 )
                          goto LABEL_19;
                        ++v38;
                        *v36 = *(_DWORD *)(*(_QWORD *)(v31 + 8) + v40);
                        if ( v34 > v38 )
                        {
                          v39 = v37[v38];
                          v36 += 2;
                          v40 = v39;
                          if ( v30 < v39 )
                            goto LABEL_19;
                          continue;
                        }
                        goto LABEL_32;
                      }
                      break;
                    }
LABEL_31:
                    ++v38;
                    *(_QWORD *)v36 = *(_QWORD *)(v31 + 8) + v40;
                    v36 += 2;
                    if ( v34 <= v38 )
                      goto LABEL_32;
                    continue;
                  default:
                    if ( v32 )
                      _libc_assert_fail(
                        (__int64)"category == LC_CTYPE",
                        (__int64)"loadlocale.c",
                        0xCEu,
                        (__int64)"_nl_intern_locale_data");
                    while ( 2 )
                    {
                      if ( v38 > 0x55 )
                      {
                        while ( 1 )
                        {
                          ++v38;
                          *(_QWORD *)v36 = *(_QWORD *)(v31 + 8) + v40;
                          if ( v34 <= v38 )
                            break;
                          v40 = (unsigned int)v37[v38];
                          v36 += 2;
                          if ( v40 > v30 )
                            goto LABEL_19;
                        }
LABEL_32:
                        if ( v35 )
                          v44 = v32 == 0;
                        else
                          v44 = 0;
                        if ( !v44 )
                          return v31;
                        goto LABEL_37;
                      }
                      if ( *(_DWORD *)&v33[4 * (unsigned int)v38 + 2128] != 5 )
                      {
                        ++v38;
                        *(_QWORD *)v36 = *(_QWORD *)(v31 + 8) + v40;
                        if ( v34 <= v38 )
                          goto LABEL_32;
                        goto LABEL_112;
                      }
                      if ( (v39 & 3) == 0 )
                      {
                        ++v38;
                        *v36 = *(_DWORD *)(*(_QWORD *)(v31 + 8) + v40);
                        if ( v34 <= v38 )
                          goto LABEL_32;
LABEL_112:
                        v39 = v37[v38];
                        v36 += 2;
                        v40 = v39;
                        if ( v30 < v39 )
                          break;
                        continue;
                      }
                      break;
                    }
LABEL_19:
                    free(v31, v21, v22, v23, v24, v25, v26, v27, v28);
                    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
                    break;
                }
                break;
              }
            }
          }
          return 0LL;
        }
      }
    }
  }
  *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
  return 0LL;
}
// 441E24: variable 'v21' is possibly undefined
// 441E24: variable 'v22' is possibly undefined
// 441E24: variable 'v23' is possibly undefined
// 441E24: variable 'v24' is possibly undefined
// 441E24: variable 'v25' is possibly undefined
// 441E24: variable 'v26' is possibly undefined
// 441E24: variable 'v27' is possibly undefined
// 441E24: variable 'v28' is possibly undefined
// 45ABE8: using guessed type _DWORD nl_value_type_LC_MEASUREMENT[2];
// 45C7E0: using guessed type _QWORD nl_category_num_items[14];
// 45CA70: using guessed type _DWORD nl_value_type_LC_TELEPHONE[6];

//----- (0000000000442400) ----------------------------------------------------
unsigned __int64 __fastcall nl_load_locale(__int64 a1, int a2)
{
  unsigned __int64 result; // x0
  int v5; // w19
  size_t v6; // x1
  unsigned __int64 StatusReg; // x23
  int v8; // w25
  __int64 v9; // x1
  __int64 v10; // x2
  void *v11; // x3
  void *v12; // x4
  void *v13; // x5
  void *v14; // x6
  __int64 v15; // x7
  _DWORD *v16; // x20
  double v17; // d0
  double v18; // d1
  double v19; // d2
  double v20; // d3
  double v21; // d4
  double v22; // d5
  double v23; // d6
  double v24; // d7
  __int64 v25; // x3
  __int64 v26; // x4
  __int64 v27; // x5
  void *v28; // x6
  __int64 v29; // x7
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  int v38; // w1
  signed __int64 v39; // x20
  unsigned __int64 v40; // x0
  _DWORD *v41; // x26
  char *v42; // x1
  signed __int64 nocancel; // x0
  double v44; // d0
  double v45; // d1
  double v46; // d2
  double v47; // d3
  double v48; // d4
  double v49; // d5
  double v50; // d6
  double v51; // d7
  unsigned __int64 (__fastcall *v52)(__int64); // x19
  __int64 v53; // x3
  __int64 v54; // x4
  __int64 v55; // x5
  void *v56; // x6
  __int64 v57; // x7
  double v58; // d0
  double v59; // d1
  double v60; // d2
  double v61; // d3
  double v62; // d4
  double v63; // d5
  double v64; // d6
  double v65; // d7
  __int64 v66; // [xsp+0h] [xbp+0h] BYREF
  char *v67; // [xsp+58h] [xbp+58h]
  _WORD v68[24]; // [xsp+60h] [xbp+60h] BYREF
  unsigned __int64 v69; // [xsp+90h] [xbp+90h]

  *(_QWORD *)(a1 + 16) = 0LL;
  result = _open_nocancel(*(const char **)a1, 0x80000);
  if ( (result & 0x80000000) != 0 )
    return result;
  v5 = result;
  if ( (fstat64(result, (struct stat *)v68) & 0x80000000) != 0 )
    return _close_nocancel(v5);
  if ( (v68[8] & 0xF000) == 0x4000 )
  {
    _close_nocancel(v5);
    v52 = strlen();
    qmemcpy((char *)v52 + (_QWORD)j_memcpy(), "/SYS_", 5);
    j_memcpy();
    result = _open_nocancel((const char *)&v66, 0x80000);
    v5 = result;
    if ( (result & 0x80000000) != 0 )
      return result;
    if ( (fstat64(result, (struct stat *)v68) & 0x80000000) != 0 )
      return _close_nocancel(v5);
  }
  v6 = v69;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v8 = *(_DWORD *)(StatusReg + 40);
  v16 = (_DWORD *)mmap64(0LL, v6, 1, 2, v5, 0LL);
  if ( v16 != (_DWORD *)-1LL )
  {
    result = _close_nocancel(v5);
    if ( !v16 )
      return result;
    result = nl_intern_locale_data(a2, v16, v69, v30, v31, v32, v33, v34, v35, v36, v37, v25, v26, v27, v28, v29);
    if ( !result )
      return munmap(v16, v69);
    v38 = 1;
    goto LABEL_8;
  }
  if ( *(_DWORD *)(StatusReg + 40) != 38 )
    return _close_nocancel(v5);
  v39 = v69;
  v40 = malloc(v69, v9, v10, v11, v12, v13, v14, v15, v17, v18, v19, v20, v21, v22, v23, v24);
  v41 = (_DWORD *)v40;
  if ( !v40 )
    return _close_nocancel(v5);
  v42 = (char *)v40;
  if ( v39 > 0 )
  {
    while ( 1 )
    {
      v67 = v42;
      nocancel = _read_nocancel(v5, v42, v39);
      if ( nocancel <= 0 )
        break;
      v39 -= nocancel;
      v42 = &v67[nocancel];
      if ( v39 <= 0 )
        goto LABEL_22;
    }
    v67 = (char *)nocancel;
    free((unsigned __int64)v41, v44, v45, v46, v47, v48, v49, v50, v51);
    if ( !v67 )
      *(_DWORD *)(StatusReg + 40) = 22;
    return _close_nocancel(v5);
  }
LABEL_22:
  *(_DWORD *)(StatusReg + 40) = v8;
  _close_nocancel(v5);
  result = nl_intern_locale_data(a2, v41, v69, v58, v59, v60, v61, v62, v63, v64, v65, v53, v54, v55, v56, v57);
  v38 = 0;
  if ( result )
  {
LABEL_8:
    *(_QWORD *)result = 0LL;
    *(_DWORD *)(result + 24) = v38;
    *(_QWORD *)(a1 + 16) = result;
    result = 1LL;
    *(_DWORD *)(a1 + 8) = 1;
  }
  return result;
}
// 4424A4: variable 'v30' is possibly undefined
// 4424A4: variable 'v31' is possibly undefined
// 4424A4: variable 'v32' is possibly undefined
// 4424A4: variable 'v33' is possibly undefined
// 4424A4: variable 'v34' is possibly undefined
// 4424A4: variable 'v35' is possibly undefined
// 4424A4: variable 'v36' is possibly undefined
// 4424A4: variable 'v37' is possibly undefined
// 4424A4: variable 'v25' is possibly undefined
// 4424A4: variable 'v26' is possibly undefined
// 4424A4: variable 'v27' is possibly undefined
// 4424A4: variable 'v28' is possibly undefined
// 4424A4: variable 'v29' is possibly undefined
// 4424F4: variable 'v9' is possibly undefined
// 4424F4: variable 'v10' is possibly undefined
// 4424F4: variable 'v11' is possibly undefined
// 4424F4: variable 'v12' is possibly undefined
// 4424F4: variable 'v13' is possibly undefined
// 4424F4: variable 'v14' is possibly undefined
// 4424F4: variable 'v15' is possibly undefined
// 4424F4: variable 'v17' is possibly undefined
// 4424F4: variable 'v18' is possibly undefined
// 4424F4: variable 'v19' is possibly undefined
// 4424F4: variable 'v20' is possibly undefined
// 4424F4: variable 'v21' is possibly undefined
// 4424F4: variable 'v22' is possibly undefined
// 4424F4: variable 'v23' is possibly undefined
// 4424F4: variable 'v24' is possibly undefined
// 442548: variable 'v44' is possibly undefined
// 442548: variable 'v45' is possibly undefined
// 442548: variable 'v46' is possibly undefined
// 442548: variable 'v47' is possibly undefined
// 442548: variable 'v48' is possibly undefined
// 442548: variable 'v49' is possibly undefined
// 442548: variable 'v50' is possibly undefined
// 442548: variable 'v51' is possibly undefined
// 442644: variable 'v58' is possibly undefined
// 442644: variable 'v59' is possibly undefined
// 442644: variable 'v60' is possibly undefined
// 442644: variable 'v61' is possibly undefined
// 442644: variable 'v62' is possibly undefined
// 442644: variable 'v63' is possibly undefined
// 442644: variable 'v64' is possibly undefined
// 442644: variable 'v65' is possibly undefined
// 442644: variable 'v53' is possibly undefined
// 442644: variable 'v54' is possibly undefined
// 442644: variable 'v55' is possibly undefined
// 442644: variable 'v56' is possibly undefined
// 442644: variable 'v57' is possibly undefined

//----- (0000000000442664) ----------------------------------------------------
void __fastcall nl_unload_locale(
        int a1,
        unsigned __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  int v11; // w0

  if ( a1 )
  {
    if ( a1 == 2 )
      nl_cleanup_time(a2, a3, a4, a5, a6, a7, a8, a9, a10);
  }
  else
  {
    nl_cleanup_ctype(a2);
  }
  v11 = *(_DWORD *)(a2 + 24);
  if ( v11 )
  {
    if ( v11 == 1 )
    {
      munmap(*(void **)(a2 + 8), *(_QWORD *)(a2 + 16));
      v11 = *(_DWORD *)(a2 + 24);
    }
  }
  else
  {
    free(*(_QWORD *)(a2 + 8), a3, a4, a5, a6, a7, a8, a9, a10);
    v11 = *(_DWORD *)(a2 + 24);
  }
  if ( v11 != 2 )
    free(*(_QWORD *)a2, a3, a4, a5, a6, a7, a8, a9, a10);
  free(a2, a3, a4, a5, a6, a7, a8, a9, a10);
}
// 4426A8: variable 'a3' is possibly undefined
// 4426A8: variable 'a4' is possibly undefined
// 4426A8: variable 'a5' is possibly undefined
// 4426A8: variable 'a6' is possibly undefined
// 4426A8: variable 'a7' is possibly undefined
// 4426A8: variable 'a8' is possibly undefined
// 4426A8: variable 'a9' is possibly undefined
// 4426A8: variable 'a10' is possibly undefined

//----- (0000000000442700) ----------------------------------------------------
__int64 __fastcall _current_locale_name(int a1)
{
  return *(_QWORD *)(*(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 32) + 8LL * a1 + 128);
}

//----- (0000000000442740) ----------------------------------------------------
void __noreturn _longjmp(struct __jmp_buf_tag env[1], int val)
{
  ((void (__fastcall *)(struct __jmp_buf_tag *__attribute__((__org_arrdim(0,1))), int))_libc_arm_za_disable)(env, val);
  __asm { HINT            #0x28 ; '(' }
}
// 48DC58: using guessed type __int64 _pointer_chk_guard_local;

//----- (0000000000442820) ----------------------------------------------------
__int64 __fastcall _mpn_cmp(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // x2
  unsigned __int64 v4; // x4
  unsigned __int64 v5; // x3

  v3 = a3 - 1;
  if ( v3 < 0 )
    return 0LL;
  while ( 1 )
  {
    v4 = *(_QWORD *)(a1 + 8 * v3);
    v5 = *(_QWORD *)(a2 + 8 * v3);
    if ( v4 != v5 )
      break;
    if ( --v3 == -1 )
      return 0LL;
  }
  if ( v4 <= v5 )
    return 0xFFFFFFFFLL;
  else
    return 1LL;
}

//----- (0000000000442860) ----------------------------------------------------
__int64 __fastcall _mpn_divrem(
        __int64 a1,
        __int64 a2,
        unsigned __int64 *a3,
        __int64 a4,
        unsigned __int64 *a5,
        __int64 a6)
{
  unsigned __int64 v7; // x7
  unsigned __int64 v8; // x8
  unsigned __int64 *v9; // x11
  unsigned __int64 v10; // x17
  unsigned __int64 v11; // x4
  __int64 v12; // x9
  unsigned __int64 v13; // x12
  unsigned __int64 v14; // x10
  unsigned __int64 v15; // x0
  unsigned __int64 v16; // x2
  unsigned __int64 v17; // x0
  unsigned __int64 v18; // x5
  unsigned __int64 v19; // x0
  unsigned __int64 v20; // x2
  __int128 v21; // t2
  unsigned __int64 v23; // x2
  unsigned __int64 v24; // x0
  unsigned __int64 v25; // x3
  unsigned __int64 v26; // x2
  unsigned __int64 v28; // x17
  unsigned __int64 v29; // x0
  unsigned __int64 v30; // x3
  __int64 v33; // x5
  unsigned __int128 v34; // kr00_16
  unsigned __int64 v35; // x4
  unsigned __int64 v36; // x0
  __int64 v37; // x3
  unsigned __int64 v38; // x9
  __int64 v39; // x12
  unsigned __int64 v40; // x5
  unsigned __int64 v41; // x0
  unsigned __int64 v42; // x8
  unsigned __int64 v43; // x10
  unsigned __int64 v44; // x0
  bool v45; // cf
  unsigned __int64 v46; // x7
  unsigned __int64 v47; // x8
  unsigned __int64 v48; // x0
  __int128 v49; // t2
  __int64 v51; // x1
  unsigned __int64 v52; // x7
  unsigned __int64 v53; // x3
  unsigned __int64 v54; // x0
  unsigned __int64 v55; // x5
  unsigned __int64 v56; // x8
  unsigned __int64 v57; // x0
  unsigned __int64 v59; // x5
  unsigned __int64 v60; // x0
  __int64 v63; // x0
  unsigned __int64 *v64; // x19
  __int64 v65; // x26
  unsigned __int64 v67; // x28
  unsigned __int64 v68; // x11
  unsigned __int64 *v69; // x22
  unsigned __int64 v70; // x27
  __int64 v71; // x25
  unsigned __int64 v72; // x24
  __int64 v73; // x23
  unsigned __int64 v74; // x4
  unsigned __int64 v75; // x0
  unsigned __int64 v76; // x11
  __int128 v77; // t2
  unsigned __int64 v79; // x11
  unsigned __int64 v80; // x0
  unsigned __int64 v81; // x3
  unsigned __int64 v82; // x2
  unsigned __int64 v84; // x2
  unsigned __int64 v85; // x11
  unsigned __int64 v86; // x1
  unsigned __int64 v87; // x0
  unsigned __int128 i; // kr20_16
  int v89; // w0
  unsigned __int64 v91; // [xsp+60h] [xbp+60h]
  unsigned __int64 v92; // [xsp+60h] [xbp+60h]
  __int64 v95; // [xsp+88h] [xbp+88h]
  _BOOL8 v96; // [xsp+88h] [xbp+88h]
  __int64 v97; // [xsp+88h] [xbp+88h]
  __int64 v98; // [xsp+90h] [xbp+90h]
  unsigned __int64 v99; // [xsp+A0h] [xbp+A0h]
  __int64 v100; // [xsp+A8h] [xbp+A8h]

  if ( a6 == 1 )
  {
    v35 = *a5;
    v36 = a3[a4 - 1];
    v96 = v35 <= v36;
    if ( v35 <= v36 )
      v36 -= v35;
    v37 = a4 - 2;
    if ( v37 >= 0 )
    {
      v38 = HIDWORD(v35);
      v39 = a1 + 8 * a2;
      while ( 1 )
      {
        v40 = v36 / v38;
        v46 = a3[v37];
        v47 = v36 / v38 * (unsigned int)v35;
        *((_QWORD *)&v49 + 1) = v36 % v38;
        *(_QWORD *)&v49 = v46;
        v48 = v49 >> 32;
        if ( v48 < v47 )
        {
          v45 = __CFADD__(v35, v48);
          v48 += v35;
          if ( v45 || v48 >= v47 )
          {
            --v40;
          }
          else
          {
            v40 -= 2LL;
            v48 += v35;
          }
        }
        v41 = v48 - v47;
        v42 = v41 / v38;
        v43 = v41 / v38 * (unsigned int)v35;
        v44 = (unsigned int)v46 | ((v41 % v38) << 32);
        if ( v44 >= v43 )
          goto LABEL_54;
        v45 = __CFADD__(v35, v44);
        v44 += v35;
        v45 = v45 || v44 >= v43;
        if ( v45 )
        {
          --v42;
LABEL_54:
          *(_QWORD *)(v39 + 8 * v37--) = v42 | (v40 << 32);
          v36 = v44 - v43;
          if ( v37 == -1 )
            break;
        }
        else
        {
          *(_QWORD *)(v39 + 8 * v37--) = (v42 - 2) | (v40 << 32);
          v36 = v44 + v35 - v43;
          if ( v37 == -1 )
            break;
        }
      }
    }
    v51 = a2 - 1;
    if ( v51 < 0 )
    {
LABEL_109:
      *a3 = v36;
      return v96;
    }
    v52 = HIDWORD(v35);
    while ( 1 )
    {
      v53 = v36 / v52;
      v59 = v36 / v52 * (unsigned int)v35;
      v60 = (v36 % v52) << 32;
      if ( v60 < v59 )
      {
        v45 = __CFADD__(v35, v60);
        v60 += v35;
        if ( v45 || v60 >= v59 )
        {
          --v53;
        }
        else
        {
          v53 -= 2LL;
          v60 += v35;
        }
      }
      v54 = v60 - v59;
      v55 = v54 / v52;
      v56 = v54 / v52 * (unsigned int)v35;
      v57 = (v54 % v52) << 32;
      if ( v57 >= v56 )
        goto LABEL_72;
      v45 = __CFADD__(v35, v57);
      v57 += v35;
      if ( v45 || v57 >= v56 )
      {
        --v55;
LABEL_72:
        *(_QWORD *)(a1 + 8 * v51--) = v55 | (v53 << 32);
        v36 = v57 - v56;
        if ( v51 == -1 )
          goto LABEL_109;
      }
      else
      {
        *(_QWORD *)(a1 + 8 * v51--) = (v55 - 2) | (v53 << 32);
        v36 = v57 + v35 - v56;
        if ( v51 == -1 )
          goto LABEL_109;
      }
    }
  }
  if ( a6 != 2 )
  {
    if ( a6 )
    {
      v100 = a6 - 1;
      v63 = a6 - 1;
      v64 = &a3[a4 - a6];
      v65 = v63 * 8 - 8;
      v67 = a5[v63];
      v98 = v63 * 8;
      v68 = v64[v63];
      v69 = &v64[v63];
      v70 = a5[v63 - 1];
      if ( v67 > v68
        || v67 >= v68 && (v92 = v64[v63], v89 = _mpn_cmp((__int64)&a3[a4 - a6], (__int64)a5, v100), v68 = v92, v89 < 0) )
      {
        v97 = 0LL;
      }
      else
      {
        _mpn_sub_n((__int64)v64, (__int64)v64, (__int64)a5, a6);
        v68 = *v69;
        v97 = 1LL;
      }
      v71 = a4 + a2 - a6 - 1;
      if ( v71 >= 0 )
      {
        v72 = HIDWORD(v67);
        do
        {
          if ( a2 > v71 )
          {
            v91 = *v69;
            if ( (v100 & 0x8000000000000000LL) == 0 )
            {
              v99 = v68;
              j_memmove();
              v68 = v99;
            }
            *v64 = 0LL;
          }
          else
          {
            --v64;
            v91 = v64[a6];
            v69 = (unsigned __int64 *)((char *)v64 + v98);
          }
          v73 = -1LL;
          if ( v67 != v68 )
          {
            v74 = v68 / v72;
            v75 = (unsigned int)v67 * (v68 / v72);
            *((_QWORD *)&v77 + 1) = v68 % v72;
            *(_QWORD *)&v77 = *v69;
            v76 = v77 >> 32;
            if ( v75 > v76 )
            {
              v45 = __CFADD__(v67, v76);
              v76 += v67;
              if ( !v45 && v75 > v76 )
              {
                v74 -= 2LL;
                v76 += v67;
              }
              else
              {
                --v74;
              }
            }
            v79 = v76 - v75;
            v80 = v79 / v72;
            v81 = (unsigned int)v67 * (v79 / v72);
            v82 = (unsigned int)*v69 | ((v79 % v72) << 32);
            if ( v81 > v82 )
            {
              v45 = __CFADD__(v67, v82);
              v82 += v67;
              if ( !v45 && v81 > v82 )
              {
                v80 -= 2LL;
                v82 += v67;
              }
              else
              {
                --v80;
              }
            }
            v73 = v80 | (v74 << 32);
            v84 = v82 - v81;
            v85 = HIDWORD(v70) * (unsigned __int64)(unsigned int)v80;
            v86 = HIDWORD(v70) * (unsigned __int64)HIDWORD(v73);
            v87 = v85
                + HIDWORD(v73) * (unsigned __int64)(unsigned int)v70
                + (((unsigned int)v80 * (unsigned __int64)(unsigned int)v70) >> 32);
            if ( v85 > v87 )
              v86 += 0x100000000LL;
            for ( i = __PAIR128__(v86 + HIDWORD(v87), (unsigned int)(v73 * v70) + (v87 << 32));
                  __PAIR128__(v84, *(unsigned __int64 *)((char *)v64 + v65)) < i;
                  i -= v70 )
            {
              --v73;
              v45 = __CFADD__(v84, v67);
              v84 += v67;
              if ( v45 )
                break;
            }
          }
          if ( v91 != _mpn_submul_1((__int64)v64, (__int64)a5, a6, v73) )
          {
            --v73;
            _mpn_add_n((__int64)v64, (__int64)v64, (__int64)a5, a6);
          }
          *(_QWORD *)(a1 + 8 * v71--) = v73;
          v68 = *v69;
        }
        while ( v71 != -1 );
      }
      return v97;
    }
    __break(0x3E8u);
  }
  v8 = *a5;
  v7 = a5[1];
  v9 = &a3[a4 - 2];
  v95 = 0LL;
  v10 = *v9;
  v11 = v9[1];
  if ( v7 <= v11 && (v7 < v11 || v8 <= v10) )
  {
    v11 = (__PAIR128__(v11, v10) - __PAIR128__(v7, v8)) >> 64;
    v10 -= v8;
    v95 = 1LL;
  }
  v12 = a4 + a2 - 3;
  if ( v12 >= 0 )
  {
    v13 = HIDWORD(v7);
    while ( 1 )
    {
      if ( a2 <= v12 )
      {
        v14 = *--v9;
        if ( v7 != v11 )
          goto LABEL_17;
      }
      else
      {
        *v9 = 0LL;
        v14 = 0LL;
        if ( v7 != v11 )
        {
LABEL_17:
          v18 = v11 / v13;
          v19 = (unsigned int)v7 * (v11 / v13);
          *((_QWORD *)&v21 + 1) = v11 % v13;
          *(_QWORD *)&v21 = v10;
          v20 = v21 >> 32;
          if ( v19 > v20 )
          {
            v45 = __CFADD__(v7, v20);
            v20 += v7;
            if ( !v45 && v19 > v20 )
            {
              v18 -= 2LL;
              v20 += v7;
            }
            else
            {
              --v18;
            }
          }
          v23 = v20 - v19;
          v24 = v23 / v13;
          v25 = (unsigned int)v7 * (v23 / v13);
          v26 = (unsigned int)v10 | ((v23 % v13) << 32);
          if ( v25 > v26 )
          {
            v45 = __CFADD__(v7, v26);
            v26 += v7;
            if ( !v45 && v25 > v26 )
            {
              v24 -= 2LL;
              v26 += v7;
            }
            else
            {
              --v24;
            }
          }
          v33 = v24 | (v18 << 32);
          v16 = v26 - v25;
          v28 = HIDWORD(v8) * (unsigned __int64)(unsigned int)v33;
          v29 = HIDWORD(v8) * (unsigned __int64)HIDWORD(v33);
          v30 = v28
              + HIDWORD(v33) * (unsigned __int64)(unsigned int)v8
              + (((unsigned int)v33 * (unsigned __int64)(unsigned int)v8) >> 32);
          if ( v28 > v30 )
            v29 += 0x100000000LL;
          v34 = __PAIR128__(v29 + HIDWORD(v30), (unsigned int)(v33 * v8) + (v30 << 32));
          goto LABEL_32;
        }
      }
      v15 = v7 + v10;
      v16 = v7 + v10;
      if ( __CFADD__(v7, v10) )
      {
        v10 = v8 + v14;
        v17 = v15 - v8;
        *(_QWORD *)(a1 + 8 * v12--) = -1LL;
        if ( __CFADD__(v8, v14) )
          v11 = v17 + 1;
        else
          v11 = v17;
        if ( v12 == -1 )
          break;
      }
      else
      {
        v33 = -1LL;
        v34 = __PAIR128__(v8 - (v8 != 0), -(__int64)v8);
        do
        {
LABEL_32:
          if ( *((_QWORD *)&v34 + 1) <= v16 && (*((_QWORD *)&v34 + 1) != v16 || (unsigned __int64)v34 <= v14) )
            break;
          --v33;
          v34 -= v8;
          v45 = __CFADD__(v16, v7);
          v16 += v7;
        }
        while ( !v45 );
        *(_QWORD *)(a1 + 8 * v12--) = v33;
        v11 = (__PAIR128__(v16, v14) - v34) >> 64;
        v10 = v14 - v34;
        if ( v12 == -1 )
          break;
      }
    }
  }
  *v9 = v10;
  v9[1] = v11;
  return v95;
}

//----- (0000000000442E80) ----------------------------------------------------
unsigned __int64 __fastcall _mpn_lshift(__int64 a1, __int64 a2, __int64 a3, char a4)
{
  __int64 v4; // x7
  __int64 v5; // x0
  __int64 v6; // x2
  unsigned __int64 v7; // x5
  unsigned __int64 result; // x0
  __int64 v9; // x4

  v4 = a1 + 8;
  v5 = a3 - 1;
  v6 = a3 - 2;
  v7 = *(_QWORD *)(a2 + 8 * v5);
  result = v7 >> (64 - a4);
  if ( v6 >= 0 )
  {
    do
    {
      v9 = v7 << a4;
      v7 = *(_QWORD *)(a2 + 8 * v6);
      *(_QWORD *)(v4 + 8 * v6--) = v9 | (v7 >> (64 - a4));
    }
    while ( v6 != -1 );
  }
  *(_QWORD *)(v4 + 8 * v6) = v7 << a4;
  return result;
}

//----- (0000000000442EE0) ----------------------------------------------------
unsigned __int64 __fastcall _mpn_mul(__int64 a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5)
{
  unsigned __int64 v10; // x3
  __int64 v12; // x28
  __int64 v13; // x26
  _QWORD *v14; // x21
  __int64 v15; // x20
  __int64 *v16; // x27
  __int64 v17; // x0
  __int64 v18; // x2
  bool v19; // cf
  _QWORD *v20; // x0
  __int64 *v21; // x1
  __int64 v22; // t1
  __int64 v23; // x21
  __int64 *v24; // x19
  __int64 v25; // x25
  __int64 v26; // x0
  __int64 v27; // x2
  __int64 *v28; // x1
  __int64 v29; // x2
  _QWORD *v30; // x0
  _QWORD *v31; // x0
  __int64 v32; // t1
  __int64 i; // x0
  __int64 vars0; // [xsp+0h] [xbp+0h] BYREF

  if ( a5 <= 31 )
  {
    v10 = 0LL;
    if ( !a5 )
      return v10;
    if ( (unsigned __int64)*a4 > 1 )
    {
      v10 = _mpn_mul_1(a1, a2, a3, *a4);
    }
    else
    {
      if ( *a4 != 1 )
      {
        if ( a3 > 0 )
          memset();
        goto LABEL_8;
      }
      if ( a3 <= 0 )
      {
LABEL_8:
        v10 = 0LL;
        goto LABEL_22;
      }
      for ( i = 0LL; i != a3; ++i )
        *(_QWORD *)(a1 + 8 * i) = *(_QWORD *)(a2 + 8 * i);
      v10 = 0LL;
    }
LABEL_22:
    *(_QWORD *)(a1 + 8 * a3) = v10;
    if ( a5 > 1 )
    {
      v23 = a1 + 8;
      v24 = a4 + 1;
      v25 = a1 + 8LL * (unsigned int)a5;
      do
      {
        if ( (unsigned __int64)*v24 <= 1 )
        {
          v10 = 0LL;
          if ( *v24 == 1 )
            v10 = _mpn_add_n(v23, v23, a2, a3);
        }
        else
        {
          v10 = _mpn_addmul_1(v23, a2, a3, *v24);
        }
        *(_QWORD *)(v23 + 8 * a3) = v10;
        v23 += 8LL;
        ++v24;
      }
      while ( v23 != v25 );
    }
    return v10;
  }
  v12 = a5 - 1 + a3;
  v13 = a3 - a5;
  _mpn_impn_mul_n(a1, a2, a4, a5, (__int64)&vars0);
  v14 = (_QWORD *)(a1 + 8 * a5);
  v15 = a2 + 8 * a5;
  if ( a5 <= v13 )
  {
    v16 = &vars0 + a5;
    do
    {
LABEL_13:
      _mpn_impn_mul_n((__int64)&vars0, v15, a4, a5, (__int64)&vars0);
      v17 = _mpn_add_n((__int64)v14, (__int64)v14, (__int64)&vars0, a5);
      v14 += a5;
      v18 = a5;
      v19 = __CFADD__(v17, *v16);
      *v14 = v17 + *v16;
      v20 = v14 + 1;
      v21 = v16 + 1;
      if ( v19 )
      {
        while ( --v18 )
        {
          v22 = *v21++;
          *v20++ = v22 + 1;
          if ( v22 != -1 )
          {
            if ( v18 > 1 )
              goto LABEL_11;
            v13 -= a5;
            v15 += 8 * a5;
            if ( a5 <= v13 )
              goto LABEL_13;
            goto LABEL_19;
          }
        }
      }
      else
      {
LABEL_11:
        j_memcpy();
      }
      v13 -= a5;
      v15 += 8 * a5;
    }
    while ( a5 <= v13 );
  }
LABEL_19:
  if ( !v13 )
    return *(_QWORD *)(a1 + 8 * v12);
  _mpn_mul(&vars0, a4, a5, v15, v13);
  v26 = _mpn_add_n((__int64)v14, (__int64)v14, (__int64)&vars0, a5);
  v27 = *(&vars0 + a5);
  v28 = &vars0 + a5 + 1;
  v19 = __CFADD__(v26, v27);
  v29 = v26 + v27;
  v30 = &v14[a5];
  *v30 = v29;
  v31 = v30 + 1;
  if ( !v19 )
  {
LABEL_30:
    if ( v13 > 1 )
    {
      j_memcpy();
      return *(_QWORD *)(a1 + 8 * v12);
    }
    return *(_QWORD *)(a1 + 8 * v12);
  }
  while ( --v13 )
  {
    v32 = *v28++;
    *v31++ = v32 + 1;
    if ( v32 != -1 )
      goto LABEL_30;
  }
  return *(_QWORD *)(a1 + 8 * v12);
}

//----- (00000000004431A0) ----------------------------------------------------
unsigned __int64 __fastcall _mpn_mul_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x7
  __int64 v5; // x1
  __int64 v6; // x2
  unsigned __int64 result; // x0
  __int64 v8; // x4
  unsigned __int64 v9; // x5
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x6
  unsigned __int64 v12; // x4
  unsigned __int64 v13; // x5
  unsigned __int64 v14; // x4

  v4 = -a3;
  v5 = a2 + 8 * a3;
  v6 = a1 + 8 * a3;
  result = 0LL;
  do
  {
    v8 = *(_QWORD *)(v5 + 8 * v4);
    v9 = (unsigned int)v8 * (unsigned __int64)(unsigned int)a4;
    v10 = HIDWORD(v8) * (unsigned __int64)(unsigned int)a4;
    v11 = HIDWORD(a4) * (unsigned __int64)HIDWORD(v8);
    v12 = v10 + HIDWORD(a4) * (unsigned __int64)(unsigned int)v8 + HIDWORD(v9);
    v13 = result + (unsigned int)v9 + (v12 << 32);
    if ( v12 < v10 )
      v11 += 0x100000000LL;
    v14 = HIDWORD(v12);
    *(_QWORD *)(v6 + 8 * v4) = v13;
    if ( v13 < result )
      ++v14;
    result = v14 + v11;
    ++v4;
  }
  while ( v4 );
  return result;
}

//----- (0000000000443220) ----------------------------------------------------
__int64 __fastcall _mpn_impn_mul_n_basecase(__int64 result, __int64 a2, __int64 *a3, __int64 a4)
{
  __int64 v4; // x20
  __int64 v5; // x19
  __int64 v9; // x19
  __int64 v10; // x20
  unsigned __int64 v11; // x3

  v4 = 8 * a4;
  v5 = result;
  if ( (unsigned __int64)*a3 <= 1 )
  {
    if ( *a3 == 1 )
    {
      result = 0LL;
      if ( a4 > 0 )
      {
        do
        {
          *(_QWORD *)(v5 + 8 * result) = *(_QWORD *)(a2 + 8 * result);
          ++result;
        }
        while ( a4 != result );
        goto LABEL_5;
      }
    }
    else if ( a4 > 0 )
    {
      memset();
LABEL_5:
      result = 0LL;
      goto LABEL_6;
    }
    *(_QWORD *)(v5 + 8 * a4) = 0LL;
    return result;
  }
  result = _mpn_mul_1(result, a2, a4, *a3);
LABEL_6:
  *(_QWORD *)(v5 + v4) = result;
  v9 = v5 + 8;
  v10 = 1LL;
  if ( a4 > 1 )
  {
    do
    {
      while ( 1 )
      {
        v11 = a3[v10];
        if ( v11 <= 1 )
          break;
        ++v10;
        result = _mpn_addmul_1(v9, a2, a4, v11);
        *(_QWORD *)(v9 + 8 * a4) = result;
        v9 += 8LL;
        if ( a4 == v10 )
          return result;
      }
      result = 0LL;
      if ( v11 == 1 )
        result = _mpn_add_n(v9, v9, a2, a4);
      ++v10;
      *(_QWORD *)(v9 + 8 * a4) = result;
      v9 += 8LL;
    }
    while ( a4 != v10 );
  }
  return result;
}

//----- (0000000000443340) ----------------------------------------------------
__int64 __fastcall _mpn_impn_mul_n(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, __int64 a5)
{
  __int64 v9; // x20
  __int64 result; // x0
  __int64 v11; // x28
  __int64 v12; // x20
  __int64 v13; // x21
  __int64 *v14; // x24
  __int64 v15; // x27
  int v17; // w0
  __int64 v18; // x3
  int v19; // w0
  __int64 *v20; // x21
  __int64 v21; // x3
  __int64 v22; // x4
  _QWORD *v23; // x1
  __int64 v24; // x24
  __int64 v25; // x24
  __int64 v26; // x24
  __int64 v27; // x0
  bool v28; // cf
  __int64 v29; // x20
  __int64 v30; // x19
  __int64 v31; // x1
  int v32; // w0
  int v33; // w0
  __int64 v34; // x0
  __int64 v35; // x1
  __int64 v36; // x2
  __int64 v37; // x0
  __int64 v38; // x1
  __int64 v39; // x0
  int v40; // [xsp+6Ch] [xbp+6Ch]
  __int64 v41; // [xsp+70h] [xbp+70h]
  __int64 v42; // [xsp+78h] [xbp+78h]
  __int64 v43; // [xsp+80h] [xbp+80h]
  __int64 v44; // [xsp+88h] [xbp+88h]

  if ( (a4 & 1) != 0 )
  {
    v9 = a4 - 1;
    if ( a4 - 1 <= 31 )
      _mpn_impn_mul_n_basecase(a1, a2, a3, v9);
    else
      _mpn_impn_mul_n(a1, a2, a3, v9);
    *(_QWORD *)(a1 + 16 * v9) = _mpn_addmul_1(a1 + 8 * v9, a2, v9, a3[v9]);
    result = _mpn_addmul_1(a1 + 8 * v9, (__int64)a3, a4, *(_QWORD *)(a2 + 8 * v9));
    *(_QWORD *)(a1 + 8 * (a4 + v9)) = result;
    return result;
  }
  v11 = a4 >> 1;
  v12 = a1 + 8 * a4;
  v13 = a2 + 8 * (a4 >> 1);
  v14 = &a3[a4 >> 1];
  v41 = 8 * a4;
  v42 = 8 * (a4 >> 1);
  v15 = a4 & 1;
  if ( a4 >> 1 <= 31 )
  {
    _mpn_impn_mul_n_basecase(v12, v13, v14, v11);
    v32 = _mpn_cmp(v13, a2, v11);
    v18 = v11;
    if ( (v32 & 0x80000000) == 0 )
    {
LABEL_7:
      _mpn_sub_n(a1, v13, a2, v18);
      v40 = 0;
      v19 = _mpn_cmp((__int64)v14, (__int64)a3, v11);
      v20 = (__int64 *)(a1 + 8 * v11);
      v21 = v11;
      if ( (v19 & 0x80000000) == 0 )
        goto LABEL_8;
      goto LABEL_27;
    }
  }
  else
  {
    _mpn_impn_mul_n(v12, v13, v14, v11);
    v17 = _mpn_cmp(v13, a2, v11);
    v18 = v11;
    if ( (v17 & 0x80000000) == 0 )
      goto LABEL_7;
  }
  _mpn_sub_n(a1, a2, v13, v18);
  v40 = 1;
  v33 = _mpn_cmp((__int64)v14, (__int64)a3, v11);
  v20 = (__int64 *)(a1 + 8 * v11);
  v21 = v11;
  if ( (v33 & 0x80000000) == 0 )
  {
LABEL_8:
    _mpn_sub_n((__int64)v20, (__int64)v14, (__int64)a3, v21);
    v40 ^= 1u;
    if ( v11 <= 31 )
      goto LABEL_9;
LABEL_28:
    _mpn_impn_mul_n(a5, a1, v20, v11);
LABEL_10:
    v22 = a4 + v11;
    v23 = (_QWORD *)v12;
    do
    {
      v23[v11 - a4] = *v23;
      ++v23;
    }
    while ( v23 != (_QWORD *)(a1 + 8 * (a4 + v11)) );
    goto LABEL_12;
  }
LABEL_27:
  _mpn_sub_n((__int64)v20, (__int64)a3, (__int64)v14, v21);
  if ( v11 > 31 )
    goto LABEL_28;
LABEL_9:
  _mpn_impn_mul_n_basecase(a5, a1, v20, v11);
  if ( v11 > 0 )
    goto LABEL_10;
  v22 = a4 + v11;
LABEL_12:
  v43 = 8 * v22;
  v44 = a1 + 8 * v22;
  v24 = _mpn_add_n(v12, v12, v44, v11);
  if ( v40 )
    v25 = v24 - _mpn_sub_n((__int64)v20, (__int64)v20, a5, a4);
  else
    v25 = v24 + _mpn_add_n((__int64)v20, (__int64)v20, a5, a4);
  if ( v11 <= 31 )
  {
    _mpn_impn_mul_n_basecase(a5, a2, a3, v11);
    v26 = v25 + _mpn_add_n((__int64)v20, (__int64)v20, a5, a4);
    if ( !v26 )
      goto LABEL_16;
    v39 = *(_QWORD *)(a1 + v43);
    *(_QWORD *)(a1 + v43) = v26 + v39;
    if ( !__CFADD__(v26, v39) )
      goto LABEL_16;
    goto LABEL_33;
  }
  _mpn_impn_mul_n(a5, a2, a3, v11);
  v34 = _mpn_add_n((__int64)v20, (__int64)v20, a5, a4) + v25;
  if ( v34 )
  {
    v35 = *(_QWORD *)(a1 + v43);
    *(_QWORD *)(a1 + v43) = v34 + v35;
    if ( __CFADD__(v34, v35) )
    {
LABEL_33:
      v36 = v44 + 8;
      v37 = 0LL;
      do
      {
        if ( v11 - 1 == v37 )
          break;
        v38 = *(_QWORD *)(v36 + 8 * v37) + 1LL;
        *(_QWORD *)(v36 + 8 * v37++) = v38;
      }
      while ( !v38 );
LABEL_16:
      if ( v11 <= 0 )
        goto LABEL_18;
      goto LABEL_17;
    }
  }
  do
  {
LABEL_17:
    *(_QWORD *)(a1 + 8 * v15) = *(_QWORD *)(a5 + 8 * v15);
    ++v15;
  }
  while ( v11 != v15 );
LABEL_18:
  result = _mpn_add_n((__int64)v20, (__int64)v20, a5 + v42, v11);
  if ( result )
  {
    v27 = *(_QWORD *)(a1 + v41);
    v28 = __CFADD__(v27, 1LL);
    result = v27 + 1;
    *(_QWORD *)(a1 + v41) = result;
    if ( v28 )
    {
      v29 = v12 + 8;
      v30 = a4 - 1;
      v31 = 0LL;
      do
      {
        result = *(_QWORD *)(v29 + 8 * v31) + 1LL;
        *(_QWORD *)(v29 + 8 * v31) = result;
        if ( result )
          break;
        ++v31;
      }
      while ( v31 != v30 );
    }
  }
  return result;
}

//----- (0000000000443720) ----------------------------------------------------
__int64 __fastcall _mpn_impn_sqr_n_basecase(__int64 result, __int64 *a2, __int64 a3)
{
  __int64 v3; // x19
  __int64 v4; // x20
  __int64 v7; // x19
  __int64 v8; // x20
  unsigned __int64 v9; // x3

  v3 = result;
  v4 = 8 * a3;
  if ( (unsigned __int64)*a2 <= 1 )
  {
    if ( *a2 == 1 )
    {
      result = 0LL;
      if ( a3 > 0 )
      {
        do
        {
          *(_QWORD *)(v3 + 8 * result) = a2[result];
          ++result;
        }
        while ( a3 != result );
        goto LABEL_5;
      }
    }
    else if ( a3 > 0 )
    {
      memset();
LABEL_5:
      result = 0LL;
      goto LABEL_6;
    }
    *(_QWORD *)(v3 + 8 * a3) = 0LL;
    return result;
  }
  result = _mpn_mul_1(result, (__int64)a2, a3, *a2);
LABEL_6:
  *(_QWORD *)(v3 + v4) = result;
  v7 = v3 + 8;
  v8 = 1LL;
  if ( a3 > 1 )
  {
    do
    {
      while ( 1 )
      {
        v9 = a2[v8];
        if ( v9 <= 1 )
          break;
        ++v8;
        result = _mpn_addmul_1(v7, (__int64)a2, a3, v9);
        *(_QWORD *)(v7 + 8 * a3) = result;
        v7 += 8LL;
        if ( a3 == v8 )
          return result;
      }
      result = 0LL;
      if ( v9 == 1 )
        result = _mpn_add_n(v7, v7, (__int64)a2, a3);
      ++v8;
      *(_QWORD *)(v7 + 8 * a3) = result;
      v7 += 8LL;
    }
    while ( a3 != v8 );
  }
  return result;
}

//----- (0000000000443828) ----------------------------------------------------
__int64 __fastcall _mpn_impn_sqr_n(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4)
{
  __int64 v7; // x19
  __int64 result; // x0
  __int64 v9; // x20
  __int64 v10; // x19
  __int64 *v11; // x24
  __int64 v12; // x27
  __int64 v13; // x25
  int v15; // w0
  __int64 v16; // x3
  __int64 v17; // x28
  __int64 v18; // x24
  __int64 i; // x1
  __int64 v20; // x0
  __int64 v21; // x1
  __int64 v22; // x0
  bool v23; // cf
  __int64 v24; // x27
  __int64 v25; // x22
  __int64 v26; // x1
  int v27; // w0
  __int64 v28; // x0
  __int64 v29; // x1
  __int64 v30; // x24
  __int64 v31; // x0
  __int64 v32; // x1
  __int64 v33; // [xsp+68h] [xbp+68h]
  __int64 v34; // [xsp+70h] [xbp+70h]
  __int64 v35; // [xsp+70h] [xbp+70h]
  __int64 v36; // [xsp+70h] [xbp+70h]
  __int64 v37; // [xsp+78h] [xbp+78h]

  if ( (a3 & 1) != 0 )
  {
    v7 = a3 - 1;
    if ( a3 - 1 <= 31 )
      _mpn_impn_sqr_n_basecase((__int64)a1, a2, v7);
    else
      _mpn_impn_sqr_n(a1, a2, v7);
    a1[2 * v7] = _mpn_addmul_1((__int64)&a1[v7], (__int64)a2, v7, a2[v7]);
    result = _mpn_addmul_1((__int64)&a1[v7], (__int64)a2, a3, a2[v7]);
    a1[a3 + v7] = result;
    return result;
  }
  v9 = a3 >> 1;
  v10 = a3 & 1;
  v11 = &a2[a3 >> 1];
  v12 = (__int64)&a1[a3];
  v33 = 8 * (a3 >> 1);
  v13 = a3;
  if ( a3 >> 1 <= 31 )
  {
    _mpn_impn_sqr_n_basecase(v12, v11, v9);
    v27 = _mpn_cmp((__int64)v11, (__int64)a2, v9);
    v16 = v9;
    if ( (v27 & 0x80000000) == 0 )
    {
LABEL_7:
      _mpn_sub_n((__int64)a1, (__int64)v11, (__int64)a2, v16);
      v17 = (__int64)&a1[v9];
      v37 = a3 + v9;
      v18 = (__int64)&a1[v37];
      if ( v9 <= 31 )
        goto LABEL_8;
LABEL_24:
      _mpn_impn_sqr_n(a4, a1, v9);
      goto LABEL_9;
    }
  }
  else
  {
    _mpn_impn_sqr_n(v12, v11, v9);
    v15 = _mpn_cmp((__int64)v11, (__int64)a2, v9);
    v16 = v9;
    if ( (v15 & 0x80000000) == 0 )
      goto LABEL_7;
  }
  _mpn_sub_n((__int64)a1, (__int64)a2, (__int64)v11, v16);
  v17 = (__int64)&a1[v9];
  v37 = a3 + v9;
  v18 = (__int64)&a1[v37];
  if ( v9 > 31 )
    goto LABEL_24;
LABEL_8:
  _mpn_impn_sqr_n_basecase(a4, a1, v9);
  if ( v9 <= 0 )
  {
    v36 = _mpn_add_n(v12, v12, v18, v9);
    v35 = v36 - _mpn_sub_n(v17, v17, a4, a3);
    goto LABEL_27;
  }
LABEL_9:
  for ( i = 0LL; i < v9; ++i )
    *(_QWORD *)(v17 + 8 * i) = *(_QWORD *)(v12 + 8 * i);
  v34 = _mpn_add_n(v12, v12, v18, v9);
  v35 = v34 - _mpn_sub_n(v17, v17, a4, a3);
  if ( v9 <= 31 )
  {
LABEL_27:
    _mpn_impn_sqr_n_basecase(a4, a2, v9);
    v28 = _mpn_add_n(v17, v17, a4, a3) + v35;
    if ( !v28 )
      goto LABEL_33;
    v29 = a1[v37];
    a1[v37] = v28 + v29;
    if ( !__CFADD__(v28, v29) )
      goto LABEL_33;
    goto LABEL_30;
  }
  _mpn_impn_sqr_n(a4, a2, v9);
  v20 = _mpn_add_n(v17, v17, a4, a3) + v35;
  if ( !v20 )
    goto LABEL_14;
  v21 = a1[v37];
  a1[v37] = v21 + v20;
  if ( !__CFADD__(v21, v20) )
    goto LABEL_14;
LABEL_30:
  v30 = v18 + 8;
  v31 = 0LL;
  do
  {
    if ( v9 - 1 == v31 )
      break;
    v32 = *(_QWORD *)(v30 + 8 * v31) + 1LL;
    *(_QWORD *)(v30 + 8 * v31++) = v32;
  }
  while ( !v32 );
LABEL_33:
  if ( v9 > 0 )
  {
    a1[v10] = *(_QWORD *)(a4 + 8 * v10);
    if ( v9 != ++v10 )
    {
      do
      {
LABEL_14:
        a1[v10] = *(_QWORD *)(a4 + 8 * v10);
        ++v10;
      }
      while ( v9 != v10 );
    }
  }
  result = _mpn_add_n(v17, v17, a4 + v33, v9);
  if ( result )
  {
    v22 = a1[v13];
    v23 = __CFADD__(v22, 1LL);
    result = v22 + 1;
    a1[v13] = result;
    if ( v23 )
    {
      v24 = v12 + 8;
      v25 = a3 - 1;
      v26 = 0LL;
      do
      {
        result = *(_QWORD *)(v24 + 8 * v26) + 1LL;
        *(_QWORD *)(v24 + 8 * v26) = result;
        if ( result )
          break;
        ++v26;
      }
      while ( v26 != v25 );
    }
  }
  return result;
}

//----- (0000000000443BA8) ----------------------------------------------------
__int64 __fastcall _mpn_mul_n(__int64 *a1, __int64 *a2, __int64 *a3, __int64 a4)
{
  __int64 vars0; // [xsp+0h] [xbp+0h] BYREF

  if ( a2 == a3 )
  {
    if ( a4 > 31 )
      return _mpn_impn_sqr_n(a1, a2, a4, (__int64)&vars0);
    else
      return _mpn_impn_sqr_n_basecase((__int64)a1, a2, a4);
  }
  else if ( a4 <= 31 )
  {
    return _mpn_impn_mul_n_basecase((__int64)a1, (__int64)a2, a3, a4);
  }
  else
  {
    return _mpn_impn_mul_n((__int64)a1, (__int64)a2, a3, a4, (__int64)(&vars0 - 2 * a4));
  }
}

//----- (0000000000443C40) ----------------------------------------------------
unsigned __int64 __fastcall _mpn_rshift(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, int a4)
{
  bool v4; // zf
  unsigned __int64 v5; // x6
  unsigned __int64 result; // x0
  unsigned __int64 *v8; // x8
  __int64 i; // x5
  unsigned __int64 v10; // x4

  if ( a3 )
    v4 = a4 == 0;
  else
    v4 = 1;
  if ( v4 )
    _libc_assert_fail((__int64)"usize != 0 && cnt != 0", (__int64)"rshift.c", 0x2Du, (__int64)"__mpn_rshift");
  v5 = *a2;
  result = *a2 << (64 - (unsigned __int8)a4);
  if ( a3 > 1 )
  {
    v8 = a1 - 1;
    for ( i = 1LL; i != a3; ++i )
    {
      v10 = v5 >> a4;
      v5 = a2[i];
      v8[i] = v10 | (v5 << (64 - (unsigned __int8)a4));
    }
    a1 = &v8[a3];
  }
  *a1 = v5 >> a4;
  return result;
}

//----- (0000000000443CE0) ----------------------------------------------------
__int64 __fastcall _mpn_sub_n(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x4
  __int64 v5; // x2
  __int64 v6; // x1
  __int64 v7; // x3
  __int64 result; // x0
  __int64 v9; // x6
  unsigned __int64 v10; // x5
  bool v11; // cf
  unsigned __int64 v12; // x0
  __int64 v13; // x6

  v4 = -a4;
  v5 = a3 + 8 * a4;
  v6 = a2 + 8 * a4;
  v7 = a1 + 8 * a4;
  result = 0LL;
  do
  {
    v9 = *(_QWORD *)(v5 + 8 * v4);
    v10 = *(_QWORD *)(v6 + 8 * v4);
    v11 = __CFADD__(result, v9);
    v12 = result + v9;
    v13 = v11;
    *(_QWORD *)(v7 + 8 * v4) = v10 - v12;
    if ( v10 >= v12 )
      result = v13;
    else
      result = v13 + 1;
    ++v4;
  }
  while ( v4 );
  return result;
}

//----- (0000000000443D40) ----------------------------------------------------
unsigned __int64 __fastcall _mpn_submul_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x7
  __int64 v5; // x1
  __int64 v6; // x2
  unsigned __int64 result; // x0
  __int64 v8; // x4
  unsigned __int64 v9; // x6
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x5
  unsigned __int64 v12; // x4
  bool v13; // cf
  unsigned __int64 v14; // x8
  unsigned __int64 v15; // x6
  unsigned __int64 v16; // x4

  v4 = -a3;
  v5 = a2 + 8 * a3;
  v6 = a1 + 8 * a3;
  result = 0LL;
  do
  {
    v8 = *(_QWORD *)(v5 + 8 * v4);
    v9 = (unsigned int)v8 * (unsigned __int64)(unsigned int)a4;
    v10 = HIDWORD(v8) * (unsigned __int64)(unsigned int)a4;
    v11 = HIDWORD(a4) * (unsigned __int64)HIDWORD(v8);
    v12 = v10 + HIDWORD(a4) * (unsigned __int64)(unsigned int)v8 + HIDWORD(v9);
    v13 = v12 >= v10;
    v14 = *(_QWORD *)(v6 + 8 * v4);
    v15 = result + (unsigned int)v9 + (v12 << 32);
    if ( !v13 )
      v11 += 0x100000000LL;
    v16 = HIDWORD(v12);
    if ( v15 < result )
      ++v16;
    *(_QWORD *)(v6 + 8 * v4) = v14 - v15;
    if ( v14 < v15 )
      ++v11;
    result = v11 + v16;
    ++v4;
  }
  while ( v4 );
  return result;
}

//----- (0000000000443DC0) ----------------------------------------------------
__int64 __fastcall _mpn_extract_double(_QWORD *a1, double a2, __int64 a3, _DWORD *a4, _DWORD *a5)
{
  unsigned __int64 v5; // x1
  __int64 result; // x0
  int v7; // w3

  *a5 = *(_QWORD *)&a2 >> 63;
  v5 = *(_QWORD *)&a2 & 0xFFFFFFFFFFFFFLL;
  *a4 = ((*(_QWORD *)&a2 >> 52) & 0x7FF) - 1023;
  *a1 = *(_QWORD *)&a2 & 0xFFFFFFFFFFFFFLL;
  if ( (*(_QWORD *)&a2 & 0x7FF0000000000000LL) != 0 )
  {
    *a1 = v5 | 0x10000000000000LL;
    return 1LL;
  }
  else if ( v5 )
  {
    v7 = __clz(v5) - 11;
    *a1 = v5 << v7;
    *a4 = -1022 - v7;
    return 1LL;
  }
  else
  {
    result = 1LL;
    *a4 = 0;
  }
  return result;
}

//----- (0000000000443E40) ----------------------------------------------------
__int64 __fastcall _mpn_extract_long_double(unsigned __int64 *a1, long double a2, __int64 a3, _DWORD *a4, _DWORD *a5)
{
  unsigned __int64 v5; // x3
  int v7; // w5
  unsigned __int64 v8; // x4
  int v9; // w4

  *a5 = *((_QWORD *)&a2 + 1) >> 63;
  *a4 = (HIWORD(a2) & 0x7FFF) - 0x3FFF;
  v5 = *((_QWORD *)&a2 + 1) & 0xFFFFFFFFFFFFLL;
  *a1 = *(_QWORD *)&a2;
  a1[1] = *((_QWORD *)&a2 + 1) & 0xFFFFFFFFFFFFLL;
  if ( (*((_QWORD *)&a2 + 1) & 0x7FFF000000000000LL) != 0 )
  {
    a1[1] = v5 | 0x1000000000000LL;
    return 2LL;
  }
  if ( !*(_QWORD *)&a2 )
  {
    if ( !v5 )
    {
      *a4 = 0;
      return 2LL;
    }
    goto LABEL_10;
  }
  if ( v5 )
  {
LABEL_10:
    v9 = __clz(v5) - 15;
    *a1 = *(_QWORD *)&a2 << v9;
    a1[1] = (*(_QWORD *)&a2 >> -(char)v9) | (v5 << v9);
    *a4 = -16382 - v9;
    return 2LL;
  }
  v7 = __clz(*(unsigned __int64 *)&a2);
  if ( v7 <= 14 )
  {
    v5 = *(_QWORD *)&a2 << ((unsigned __int8)v7 + 49);
    v8 = *(_QWORD *)&a2 >> (15 - (unsigned __int8)v7);
  }
  else
  {
    v8 = *(_QWORD *)&a2 << ((unsigned __int8)v7 - 15);
  }
  *a1 = v5;
  a1[1] = v8;
  *a4 = -16431 - v7;
  return 2LL;
}

//----- (0000000000443F40) ----------------------------------------------------
__int64 __fastcall _printf_buffer_as_file_commit(_QWORD *a1)
{
  _QWORD *v1; // x1
  unsigned __int64 v2; // x2
  unsigned __int64 v3; // x3
  __int64 result; // x0

  v1 = (_QWORD *)a1[28];
  v2 = a1[5];
  if ( v2 < v1[1] )
    _libc_assert_fail(
      (__int64)"file->stream._IO_write_ptr >= file->next->write_ptr",
      (__int64)"printf_buffer_as_file.c",
      0x1Eu,
      (__int64)"__printf_buffer_as_file_commit");
  v3 = v1[2];
  if ( v2 > v3 )
    _libc_assert_fail(
      (__int64)"file->stream._IO_write_ptr <= file->next->write_end",
      (__int64)"printf_buffer_as_file.c",
      0x1Fu,
      (__int64)"__printf_buffer_as_file_commit");
  if ( a1[4] != *v1 )
    _libc_assert_fail(
      (__int64)"file->stream._IO_write_base == file->next->write_base",
      (__int64)"printf_buffer_as_file.c",
      0x20u,
      (__int64)"__printf_buffer_as_file_commit");
  result = a1[6];
  if ( v3 != result )
    _libc_assert_fail(
      (__int64)"file->stream._IO_write_end == file->next->write_end",
      (__int64)"printf_buffer_as_file.c",
      0x21u,
      (__int64)"__printf_buffer_as_file_commit");
  v1[1] = v2;
  return result;
}
// 444010: using guessed type __int64 _printf_buffer_as_file_overflow(void);

//----- (0000000000444010) ----------------------------------------------------
__int64 __fastcall _printf_buffer_as_file_overflow(_QWORD *a1, int a2)
{
  void *v4; // x3
  __int64 v5; // x4
  _DWORD *v6; // x5
  void *v7; // x6
  __int64 v8; // x7
  double v9; // d0
  double v10; // d1
  double v11; // d2
  double v12; // d3
  double v13; // d4
  double v14; // d5
  double v15; // d6
  double v16; // d7
  __int64 v17; // x0
  __int64 v19; // x1
  __int64 v20; // x2
  unsigned __int64 v21; // x0
  _BYTE *v22; // x2
  __int64 v23; // x0
  int v24; // w1

  _printf_buffer_as_file_commit(a1);
  if ( a2 != -1 )
  {
    v21 = a1[28];
    v22 = *(_BYTE **)(v21 + 8);
    if ( v22 == *(_BYTE **)(v21 + 16) )
    {
      _printf_buffer_putc_1(v21, a2);
    }
    else
    {
      v4 = v22 + 1;
      *(_QWORD *)(v21 + 8) = v22 + 1;
      *v22 = a2;
    }
  }
  v17 = a1[28];
  if ( !*(_DWORD *)(v17 + 32) )
  {
    a1[4] = *(_QWORD *)v17;
    a1[5] = *(_QWORD *)(v17 + 8);
    a1[6] = *(_QWORD *)(v17 + 16);
    return 0xFFFFFFFFLL;
  }
  v20 = *(_QWORD *)(v17 + 8);
  v19 = *(_QWORD *)(v17 + 16);
  if ( v20 == v19 )
  {
    _printf_buffer_flush(v17, v9, v10, v11, v12, v13, v14, v15, v16, v19, v20, v4, v5, v6, v7, v8);
    v23 = a1[28];
    v24 = *(_DWORD *)(v23 + 32);
    a1[4] = *(_QWORD *)v23;
    a1[5] = *(_QWORD *)(v23 + 8);
    a1[6] = *(_QWORD *)(v23 + 16);
    if ( !v24 )
      return 0xFFFFFFFFLL;
    return (unsigned __int8)a2;
  }
  else
  {
    a1[4] = *(_QWORD *)v17;
    a1[5] = *(_QWORD *)(v17 + 8);
    a1[6] = *(_QWORD *)(v17 + 16);
    return (unsigned __int8)a2;
  }
}
// 4440BC: variable 'v9' is possibly undefined
// 4440BC: variable 'v10' is possibly undefined
// 4440BC: variable 'v11' is possibly undefined
// 4440BC: variable 'v12' is possibly undefined
// 4440BC: variable 'v13' is possibly undefined
// 4440BC: variable 'v14' is possibly undefined
// 4440BC: variable 'v15' is possibly undefined
// 4440BC: variable 'v16' is possibly undefined
// 4440BC: variable 'v4' is possibly undefined
// 4440BC: variable 'v5' is possibly undefined
// 4440BC: variable 'v6' is possibly undefined
// 4440BC: variable 'v7' is possibly undefined
// 4440BC: variable 'v8' is possibly undefined

//----- (0000000000444100) ----------------------------------------------------
unsigned __int64 __fastcall _printf_buffer_as_file_xsputn(_QWORD *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v5; // x0
  __int64 v6; // x1

  _printf_buffer_as_file_commit(a1);
  _printf_buffer_write(a1[28], a2, a3);
  v5 = a1[28];
  a1[4] = *(_QWORD *)v5;
  a1[5] = *(_QWORD *)(v5 + 8);
  v6 = *(_QWORD *)(v5 + 16);
  LODWORD(v5) = *(_DWORD *)(v5 + 32);
  a1[6] = v6;
  if ( (_DWORD)v5 )
    return a3;
  else
    return 0LL;
}

//----- (0000000000444160) ----------------------------------------------------
__int64 __fastcall _printf_buffer_as_file_init(_QWORD *a1, __int64 *a2)
{
  __int64 result; // x0
  __int64 v5; // x1

  a1[17] = 0LL;
  IO_no_init((__int64)a1, 0x8000, -1, 0LL, 0LL);
  a1[27] = &unk_48E440;
  a1[28] = a2;
  result = *a2;
  a1[4] = *a2;
  a1[5] = a2[1];
  v5 = a2[2];
  a1[1] = result;
  a1[2] = result;
  a1[3] = result;
  a1[6] = v5;
  return result;
}

//----- (00000000004441C4) ----------------------------------------------------
__int64 __fastcall _printf_buffer_as_file_terminate(_QWORD *a1)
{
  if ( (*(_DWORD *)a1 & 0x20) != 0 )
    return 0LL;
  _printf_buffer_as_file_commit(a1);
  return 1LL;
}

//----- (0000000000444200) ----------------------------------------------------
__int64 __fastcall _printf_buffer_flush(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        void *a12,
        __int64 a13,
        _DWORD *a14,
        void *a15,
        __int64 a16)
{
  _QWORD *v16; // x29
  __int64 v17; // x30
  int v18; // w1
  __int64 v19; // x1
  __int64 v20; // x1
  __int64 v21; // x2
  __int64 result; // x0
  unsigned __int64 StatusReg; // x2
  _QWORD v24[3]; // [xsp+0h] [xbp-20h] BYREF
  __int64 v25; // [xsp+18h] [xbp-8h]

  v18 = *(_DWORD *)(a1 + 32);
  if ( v18 )
  {
    v19 = (unsigned int)(v18 - 1);
    while ( 2 )
    {
      v24[0] = v16;
      v24[1] = v17;
      v16 = v24;
      switch ( (int)v19 )
      {
        case 0:
          goto LABEL_6;
        case 1:
          v25 = a1;
          _printf_buffer_flush_snprintf((_QWORD *)a1);
          a1 = v25;
          if ( !*(_DWORD *)(v25 + 32) )
            return 0LL;
          goto LABEL_6;
        case 2:
          _chk_fail(a2, a3, a4, a5, a6, a7, a8, a9);
        case 3:
          v25 = a1;
          _printf_buffer_flush_to_file((unsigned __int64 *)a1, a2, a3, a4, a5, a6, a7, a8, a9);
          a1 = v25;
          if ( !*(_DWORD *)(v25 + 32) )
            return 0LL;
          goto LABEL_6;
        case 4:
          v25 = a1;
          _printf_buffer_flush_asprintf(a1, a2, a3, a4, a5, a6, a7, a8, a9, v19, a11, a12, a13, a14, a15, a16);
          a1 = v25;
          if ( !*(_DWORD *)(v25 + 32) )
            return 0LL;
          goto LABEL_6;
        case 5:
          v25 = a1;
          if ( !*(_DWORD *)(a1 + 32) )
            return 0LL;
          goto LABEL_6;
        case 6:
          StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
          *(_DWORD *)(a1 + 32) = 0;
          *(_DWORD *)(StatusReg + 40) = 7;
          return 0LL;
        case 7:
          v25 = a1;
          _printf_buffer_flush_fp(a1);
          a1 = v25;
          if ( !*(_DWORD *)(v25 + 32) )
            return 0LL;
          goto LABEL_6;
        case 8:
          v25 = a1;
          _printf_buffer_flush_fp_to_wide(a1, a2, a3, a4, a5, a6, a7, a8, a9, v19, a11, (__int64)a12, a13, a14, a15);
          a1 = v25;
          if ( *(_DWORD *)(v25 + 32) )
            goto LABEL_6;
          return 0LL;
        case 9:
          v25 = a1;
          _printf_buffer_flush_fphex_to_wide(a1, a2, a3, a4, a5, a6, a7, a8, a9, v19, a11, (__int64)a12, a13, a14, a15);
          a1 = v25;
          if ( !*(_DWORD *)(v25 + 32) )
            return 0LL;
          goto LABEL_6;
        case 10:
          v25 = a1;
          if ( !*(_DWORD *)(a1 + 32) )
            return 0LL;
LABEL_6:
          v21 = *(_QWORD *)(a1 + 8);
          v20 = *(_QWORD *)(a1 + 16);
          result = 1LL;
          if ( v21 == v20 )
            _libc_assert_fail(
              (__int64)"buf->write_ptr != buf->write_end",
              (__int64)"Xprintf_buffer_flush.c",
              0x46u,
              (__int64)"__printf_buffer_flush");
          return result;
        default:
          __break(0x3E8u);
          continue;
      }
    }
  }
  return 0LL;
}
// 444218: variable 'v16' is possibly undefined
// 444218: variable 'v17' is possibly undefined

//----- (0000000000444360) ----------------------------------------------------
__int64 __fastcall _wprintf_buffer_done(__int64 a1)
{
  int v1; // w2
  unsigned __int64 v2; // x1
  __int64 result; // x0

  if ( !*(_DWORD *)(a1 + 32) )
    return 0xFFFFFFFFLL;
  v1 = 0;
  v2 = (__int64)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  result = v2 + *(_QWORD *)(a1 + 24);
  if ( result < 0 || result < v2 )
    v1 = 1;
  if ( result != (int)result || v1 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 75;
    return 0xFFFFFFFFLL;
  }
  return result;
}

//----- (00000000004443C0) ----------------------------------------------------
__int64 __fastcall _wprintf_buffer_flush(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        unsigned __int64 a12,
        __int64 a13,
        _DWORD *a14,
        void *a15)
{
  unsigned __int64 v15; // x2
  __int64 result; // x0
  __int64 v18; // x0
  unsigned __int64 StatusReg; // x2

  v15 = *(unsigned int *)(a1 + 32);
  switch ( (_DWORD)v15 )
  {
    case 0:
      return 0LL;
    case 1:
      v18 = *(_QWORD *)(a1 + 16);
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
      *(_DWORD *)(v18 - 4) = 0;
      *(_DWORD *)(a1 + 32) = 0;
      *(_DWORD *)(StatusReg + 40) = 7;
      return 0LL;
    case 2:
      _wprintf_buffer_flush_to_file(a1, a2, a3, a4, a5, a6, a7, a8, a9);
      if ( *(_DWORD *)(a1 + 32) )
      {
        result = 1LL;
        if ( *(_QWORD *)(a1 + 8) == *(_QWORD *)(a1 + 16) )
          _libc_assert_fail(
            (__int64)"buf->write_ptr != buf->write_end",
            (__int64)"Xprintf_buffer_flush.c",
            0x46u,
            (__int64)"__wprintf_buffer_flush");
      }
      else
      {
        return 0LL;
      }
      break;
    default:
      __break(0x3E8u);
      return (__int64)IO_getline_info(a1, a1, v15, a12, a13, a14, a15, a2, a3, a4, a5, a6, a7, a8, a9);
  }
  return result;
}

//----- (0000000000444480) ----------------------------------------------------
_BYTE *__fastcall IO_getline_info(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        _DWORD *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  int v17; // w23
  __int64 v19; // x2
  int v20; // w26
  _BYTE *v22; // x22
  __int64 v23; // x27
  __int64 v24; // x19
  unsigned __int64 (__fastcall *v25)(__int64, unsigned int, unsigned __int64); // x0
  unsigned __int64 (__fastcall *v26)(__int64, unsigned int, unsigned __int64); // x3
  _BYTE *v27; // x24
  _BYTE *result; // x0
  int v29; // w0
  _BYTE *v30; // x19
  char *v31; // x24
  unsigned __int64 (__fastcall *v32)(__int64, unsigned int, unsigned __int64); // [xsp+68h] [xbp+68h]

  v17 = a4;
  if ( a6 )
    *a6 = 0;
  v19 = *(unsigned int *)(a1 + 192);
  if ( !(_DWORD)v19 )
    *(_DWORD *)(a1 + 192) = -1;
  if ( !a3 )
    return 0LL;
  v20 = a5;
  v22 = (_BYTE *)a2;
  while ( 1 )
  {
    while ( 1 )
    {
      v23 = *(_QWORD *)(a1 + 8);
      v24 = *(_QWORD *)(a1 + 16) - v23;
      if ( v24 <= 0 )
        break;
      if ( v24 > a3 )
        v24 = a3;
      v25 = memchr();
      v26 = v25;
      if ( v25 )
      {
        v30 = &v22[-a2];
        v31 = (char *)v25 - v23;
        if ( v20 >= 0 )
        {
          v26 = (unsigned __int64 (__fastcall *)(__int64, unsigned int, unsigned __int64))((char *)v25 + 1);
          if ( v20 )
            ++v31;
        }
        v32 = v26;
        j_memcpy();
        result = &v30[(_QWORD)v31];
        *(_QWORD *)(a1 + 8) = v32;
        return result;
      }
      j_memcpy();
      v22 += v24;
      a3 -= v24;
      *(_QWORD *)(a1 + 8) += v24;
      if ( !a3 )
        return &v22[-a2];
    }
    v29 = _uflow(a1, a8, a9, a10, a11, a12, a13, a14, a15, a2, v19, a4, a5, (__int64)a6, a7);
    if ( v29 == -1 )
      break;
    if ( v17 == v29 )
    {
      if ( v20 <= 0 )
      {
        if ( v20 )
          IO_sputbackc((unsigned int *)a1, v17, a8, a9, a10, a11, a12, a13, a14, a15);
      }
      else
      {
        *v22++ = v17;
      }
      return &v22[-a2];
    }
    *v22++ = v29;
    if ( !--a3 )
      return &v22[-a2];
  }
  v27 = &v22[-a2];
  if ( a6 )
    *a6 = -1;
  return v27;
}
// 44454C: variable 'a8' is possibly undefined
// 44454C: variable 'a9' is possibly undefined
// 44454C: variable 'a10' is possibly undefined
// 44454C: variable 'a11' is possibly undefined
// 44454C: variable 'a12' is possibly undefined
// 44454C: variable 'a13' is possibly undefined
// 44454C: variable 'a14' is possibly undefined
// 44454C: variable 'a15' is possibly undefined
// 44454C: variable 'a2' is possibly undefined
// 44454C: variable 'v19' is possibly undefined
// 44454C: variable 'a4' is possibly undefined
// 44454C: variable 'a5' is possibly undefined
// 44454C: variable 'a6' is possibly undefined
// 44454C: variable 'a7' is possibly undefined

//----- (0000000000444620) ----------------------------------------------------
_BYTE *__fastcall IO_getline(
        __int64 a1,
        __int64 a2,
        unsigned __int64 a3,
        unsigned __int64 a4,
        __int64 a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        __int64 a14,
        void *a15)
{
  return IO_getline_info(a1, a2, a3, a4, a5, 0LL, a15, a6, a7, a8, a9, a10, a11, a12, a13);
}

//----- (0000000000444640) ----------------------------------------------------
_QWORD *__fastcall pthread_cleanup_push(_QWORD *result, __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // x1

  *result = a2;
  result[1] = a3;
  v3 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
  result[3] = *(_QWORD *)(v3 + 0xF8);
  *(_QWORD *)(v3 + 0xF8) = result;
  return result;
}

//----- (0000000000444660) ----------------------------------------------------
__int64 __fastcall pthread_cleanup_pop(__int64 result, int a2)
{
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824 + 0xF8) = *(_QWORD *)(result + 24);
  if ( a2 )
    return (*(__int64 (__fastcall **)(_QWORD))result)(*(_QWORD *)(result + 8));
  return result;
}

//----- (00000000004446A0) ----------------------------------------------------
_QWORD *__fastcall _nptl_stack_list_del(__int64 *a1)
{
  _QWORD *result; // x0
  __int64 v2; // x2

  dl_in_flight_stack = (__int64)a1;
  __dmb(0xBu);
  v2 = *a1;
  result = (_QWORD *)a1[1];
  *(_QWORD *)(v2 + 8) = result;
  *result = v2;
  __dmb(0xBu);
  dl_in_flight_stack = 0LL;
  return result;
}
// 496C70: using guessed type __int64 dl_in_flight_stack;

//----- (00000000004446C8) ----------------------------------------------------
unsigned __int64 __fastcall _nptl_stack_list_add(unsigned __int64 result, unsigned __int64 *a2)
{
  unsigned __int64 v2; // x3

  dl_in_flight_stack = result | 1;
  __dmb(0xBu);
  v2 = *a2;
  *(_QWORD *)result = *a2;
  *(_QWORD *)(result + 8) = a2;
  *(_QWORD *)(v2 + 8) = result;
  __dmb(0xBu);
  *a2 = result;
  __dmb(0xBu);
  dl_in_flight_stack = 0LL;
  return result;
}
// 496C70: using guessed type __int64 dl_in_flight_stack;

//----- (0000000000444700) ----------------------------------------------------
__int64 __fastcall _nptl_free_stacks(
        __int64 result,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 v9; // x2
  unsigned __int64 v10; // x23
  __int64 *i; // x19
  __int64 v12; // x20
  _QWORD *v13; // x0
  __int64 v14; // x1

  v9 = qword_496C88;
  if ( (__int64 *)qword_496C88 != &dl_stack_cache )
  {
    v10 = result;
    for ( i = *(__int64 **)(qword_496C88 + 8); ; i = (__int64 *)i[1] )
    {
      v12 = v9 - 192;
      if ( *(int *)(v9 + 16) <= 0 )
      {
        dl_in_flight_stack = v9;
        __dmb(0xBu);
        v14 = *(_QWORD *)v9;
        v13 = *(_QWORD **)(v9 + 8);
        *(_QWORD *)(v14 + 8) = v13;
        *v13 = v14;
        __dmb(0xBu);
        dl_in_flight_stack = 0LL;
        dl_stack_cache_actsize -= *(_QWORD *)(v9 + 984);
        dl_deallocate_tls((void **)(v9 + 1632), 0, a2, a3, a4, a5, a6, a7, a8, a9);
        if ( (unsigned int)munmap(*(void **)(v12 + 1168), *(_QWORD *)(v12 + 1176)) )
          abort();
        result = dl_stack_cache_actsize;
        if ( dl_stack_cache_actsize <= v10 )
          break;
      }
      v9 = (__int64)i;
      if ( i == &dl_stack_cache )
        break;
    }
  }
  return result;
}
// 44479C: variable 'a2' is possibly undefined
// 44479C: variable 'a3' is possibly undefined
// 44479C: variable 'a4' is possibly undefined
// 44479C: variable 'a5' is possibly undefined
// 44479C: variable 'a6' is possibly undefined
// 44479C: variable 'a7' is possibly undefined
// 44479C: variable 'a8' is possibly undefined
// 44479C: variable 'a9' is possibly undefined
// 496C70: using guessed type __int64 dl_in_flight_stack;
// 496C78: using guessed type __int64 dl_stack_cache_actsize;
// 496C80: using guessed type __int64 dl_stack_cache;
// 496C88: using guessed type __int64 qword_496C88;

//----- (00000000004447E0) ----------------------------------------------------
void __fastcall _nptl_deallocate_stack(__int64 a1)
{
  __int64 v2; // x1
  __int64 v3; // x2
  __int64 v4; // x3
  void *v5; // x4
  void *v6; // x5
  void *v7; // x6
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  int v16; // w0
  __int64 v17; // x1
  _QWORD *v18; // x2
  __int64 v19; // x3
  __int64 v20; // x3
  __int64 v21; // x1
  __int64 v22; // x2
  __int64 v23; // x3
  void *v24; // x4
  void *v25; // x5
  void *v26; // x6
  int v27; // w0
  int v28; // w0

  _aarch64_cas4_acq();
  if ( v16 )
    _lll_lock_wait_private(dl_stack_cache_lock, v8, v9, v10, v11, v12, v13, v14, v15, v2, v3, v4, v5, v6, v7);
  v17 = a1 + 192;
  dl_in_flight_stack = a1 + 192;
  __dmb(0xBu);
  v19 = *(_QWORD *)(a1 + 192);
  v18 = *(_QWORD **)(a1 + 200);
  *(_QWORD *)(v19 + 8) = v18;
  *v18 = v19;
  __dmb(0xBu);
  LOBYTE(v18) = *(_BYTE *)(a1 + 1042);
  dl_in_flight_stack = 0LL;
  if ( ((unsigned __int8)v18 & 1) != 0 )
  {
    dl_deallocate_tls((void **)(a1 + 1824), 0, v8, v9, v10, v11, v12, v13, v14, v15);
    _aarch64_swp4_rel();
    if ( v28 <= 1 )
      return;
LABEL_9:
    _lll_lock_wake_private(dl_stack_cache_lock, v21, v22, v23, v24, v25, v26);
    return;
  }
  dl_in_flight_stack = v17 | 1;
  __dmb(0xBu);
  v20 = dl_stack_cache;
  *(_QWORD *)(a1 + 192) = dl_stack_cache;
  *(_QWORD *)(a1 + 200) = &dl_stack_cache;
  *(_QWORD *)(v20 + 8) = v17;
  __dmb(0xBu);
  dl_stack_cache = a1 + 192;
  __dmb(0xBu);
  dl_in_flight_stack = 0LL;
  dl_stack_cache_actsize += *(_QWORD *)(a1 + 1176);
  if ( dl_stack_cache_actsize > (unsigned __int64)_nptl_stack_cache_maxsize )
    _nptl_free_stacks(_nptl_stack_cache_maxsize, v8, v9, v10, v11, v12, v13, v14, v15);
  _aarch64_swp4_rel();
  if ( v27 > 1 )
    goto LABEL_9;
}
// 444804: variable 'v16' is possibly undefined
// 4448BC: variable 'v8' is possibly undefined
// 4448BC: variable 'v9' is possibly undefined
// 4448BC: variable 'v10' is possibly undefined
// 4448BC: variable 'v11' is possibly undefined
// 4448BC: variable 'v12' is possibly undefined
// 4448BC: variable 'v13' is possibly undefined
// 4448BC: variable 'v14' is possibly undefined
// 4448BC: variable 'v15' is possibly undefined
// 4448BC: variable 'v2' is possibly undefined
// 4448BC: variable 'v3' is possibly undefined
// 4448BC: variable 'v4' is possibly undefined
// 4448BC: variable 'v5' is possibly undefined
// 4448BC: variable 'v6' is possibly undefined
// 4448BC: variable 'v7' is possibly undefined
// 4448A4: variable 'v27' is possibly undefined
// 4448E4: variable 'v28' is possibly undefined
// 4448F8: variable 'v21' is possibly undefined
// 4448F8: variable 'v22' is possibly undefined
// 4448F8: variable 'v23' is possibly undefined
// 4448F8: variable 'v24' is possibly undefined
// 4448F8: variable 'v25' is possibly undefined
// 4448F8: variable 'v26' is possibly undefined
// 491938: using guessed type __int64 _nptl_stack_cache_maxsize;
// 496C68: using guessed type _DWORD dl_stack_cache_lock[2];
// 496C70: using guessed type __int64 dl_in_flight_stack;
// 496C78: using guessed type __int64 dl_stack_cache_actsize;
// 496C80: using guessed type __int64 dl_stack_cache;

//----- (0000000000444904) ----------------------------------------------------
unsigned __int64 _pthread_get_minstack()
{
  return dl_pagesize
       + 0x20000
       + (dl_tls_static_align + dl_tls_static_size - 1) / (unsigned __int64)dl_tls_static_align * dl_tls_static_align;
}
// 490F10: using guessed type __int64 dl_pagesize;
// 4921F8: using guessed type __int64 dl_tls_static_align;
// 492200: using guessed type __int64 dl_tls_static_size;

//----- (0000000000444940) ----------------------------------------------------
__int64 __fastcall two_way_long_needle_0(
        __int64 a1,
        __int64 a2,
        int8x16_t *a3,
        unsigned __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9)
{
  unsigned __int64 v11; // x21
  __int64 v14; // x6
  __int64 v15; // x2
  __int64 v16; // x1
  __int64 v17; // x0
  __int64 v18; // x3
  unsigned int v19; // w5
  unsigned int v20; // w4
  unsigned __int64 v21; // x26
  __int64 v22; // x2
  __int64 v23; // x1
  __int64 v24; // x0
  __int64 v25; // x22
  unsigned int v26; // w5
  unsigned int v27; // w4
  unsigned __int64 v28; // x22
  unsigned __int64 v29; // x3
  char *v30; // x0
  int8x16_t *v31; // x0
  __int64 v32; // x2
  unsigned __int64 v33; // x1
  unsigned __int64 v34; // x23
  unsigned __int64 v35; // x19
  unsigned __int64 v36; // x7
  unsigned __int64 v37; // x5
  unsigned __int64 v38; // x2
  bool v39; // zf
  unsigned __int64 v41; // x0
  __int64 v42; // x1
  unsigned __int64 v43; // x0
  unsigned __int64 v44; // x3
  unsigned __int64 i; // x0
  unsigned __int64 v47; // x19
  unsigned __int64 v48; // x4
  unsigned __int64 v49; // x19
  __int64 v50; // x0
  unsigned __int64 v51; // x0
  unsigned __int64 v52; // x0
  _QWORD v53[256]; // [xsp+50h] [xbp+50h] BYREF

  v11 = a4 - 1;
  if ( a4 <= 1 )
  {
    v21 = 1LL;
    v28 = 0LL;
    goto LABEL_16;
  }
  v14 = 1LL;
  v15 = 0LL;
  v16 = 1LL;
  v17 = 1LL;
  v18 = -1LL;
  do
  {
    while ( 1 )
    {
      v19 = a3->n128_u8[v17];
      v20 = a3->n128_u8[v18 + v16];
      if ( v19 >= v20 )
        break;
      v14 = v17 - v18;
      v15 = v17;
      v16 = 1LL;
LABEL_4:
      v17 = v15 + v16;
      if ( a4 <= v15 + v16 )
        goto LABEL_8;
    }
    if ( v19 == v20 )
    {
      if ( v14 == v16 )
      {
        v15 += v14;
        v16 = 1LL;
      }
      else
      {
        ++v16;
      }
      goto LABEL_4;
    }
    v18 = v15;
    v14 = 1LL;
    ++v15;
    v16 = 1LL;
    v17 = v15 + 1;
  }
  while ( a4 > v15 + 1 );
LABEL_8:
  v21 = 1LL;
  v22 = 0LL;
  v23 = 1LL;
  v24 = 1LL;
  v25 = -1LL;
  do
  {
    while ( 1 )
    {
      v26 = a3->n128_u8[v24];
      v27 = a3->n128_u8[v23 + v25];
      if ( v26 <= v27 )
        break;
      v21 = v24 - v25;
      v22 = v24;
      v23 = 1LL;
LABEL_10:
      v24 = v22 + v23;
      if ( a4 <= v22 + v23 )
        goto LABEL_14;
    }
    if ( v26 == v27 )
    {
      if ( v23 == v21 )
      {
        v22 += v23;
        v23 = 1LL;
      }
      else
      {
        ++v23;
      }
      goto LABEL_10;
    }
    v25 = v22;
    v21 = 1LL;
    ++v22;
    v23 = 1LL;
    v24 = v22 + 1;
  }
  while ( a4 > v22 + 1 );
LABEL_14:
  v28 = v25 + 1;
  v29 = v18 + 1;
  if ( v28 < v29 )
  {
    v21 = v14;
    v28 = v29;
  }
LABEL_16:
  v30 = (char *)v53;
  do
  {
    *(_QWORD *)v30 = a4;
    v30 += 8;
  }
  while ( &a9 != v30 );
  v31 = a3;
  if ( a4 )
  {
    do
    {
      v32 = v31->n128_u8[0];
      v33 = (char *)a3 - (char *)v31 + v11;
      v31 = (int8x16_t *)((char *)v31 + 1);
      v53[v32] = v33;
    }
    while ( (int8x16_t *)((char *)a3 + a4) != v31 );
  }
  v34 = a2 - a4;
  if ( !(unsigned int)memcmp(a3, (int8x16_t *)((char *)a3 + v21), v28) )
  {
    v35 = a4 - v21;
    v36 = 1 - v28;
    v37 = 0LL;
    v38 = 0LL;
    while ( 1 )
    {
      v42 = a1 + v38;
      v41 = v53[*(unsigned __int8 *)(a1 + v38 + v11)];
      if ( v41 )
        break;
      if ( v28 < v37 )
        v43 = v37;
      else
        v43 = v28;
      if ( v11 <= v43 )
        goto LABEL_44;
      while ( a3->n128_u8[v43] == *(unsigned __int8 *)(v42 + v43) )
      {
        if ( v11 == ++v43 )
          goto LABEL_44;
      }
      v44 = v43 + v38;
      if ( v11 <= v43 )
      {
LABEL_44:
        if ( v28 <= v37 )
        {
          i = v28;
        }
        else
        {
          for ( i = v28 - 1; a3->n128_u8[i] == *(unsigned __int8 *)(a1 + v38 + i); --i )
          {
            if ( i == v37 )
              goto LABEL_50;
          }
          ++i;
        }
LABEL_50:
        if ( v37 + 1 > i )
          return v42;
        v38 += v21;
        v37 = v35;
LABEL_28:
        if ( v38 > v34 )
          return 0LL;
      }
      else
      {
        v38 = v36 + v44;
        v37 = 0LL;
        if ( v36 + v44 > v34 )
          return 0LL;
      }
    }
    v39 = v37 == 0;
    v37 = 0LL;
    if ( !v39 && v41 < v21 )
      v41 = v35;
    v38 += v41;
    goto LABEL_28;
  }
  v47 = a4 - v28;
  if ( v47 < v28 )
    v47 = v28;
  v48 = 0LL;
  v49 = v47 + 1;
  while ( 2 )
  {
    v42 = a1 + v48;
    v50 = v53[*(unsigned __int8 *)(a1 + v48 + v11)];
    if ( v50 )
    {
      v48 += v50;
      goto LABEL_56;
    }
    v51 = v28;
    if ( v11 > v28 )
    {
      while ( a3->n128_u8[v51] == *(unsigned __int8 *)(v42 + v51) )
      {
        if ( v11 <= ++v51 )
          goto LABEL_64;
      }
      if ( v11 > v51 )
      {
        v48 += 1 - v28 + v51;
        goto LABEL_56;
      }
    }
LABEL_64:
    v52 = v28 - 1;
    if ( v28 )
    {
      while ( a3->n128_u8[v52] == *(unsigned __int8 *)(a1 + v48 + v52) )
      {
        if ( --v52 == -1LL )
          return v42;
      }
      v48 += v49;
LABEL_56:
      if ( v48 > v34 )
        return 0LL;
      continue;
    }
    return v42;
  }
}

//----- (0000000000444CE0) ----------------------------------------------------
unsigned __int64 (__fastcall *__fastcall memmem(
        unsigned __int64 (__fastcall *result)(__int64 a1, unsigned int a2, unsigned __int64 a3),
        unsigned __int64 a2,
        int8x16_t *a3,
        unsigned __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        char a9))(__int64 a1, unsigned int a2, unsigned __int64 a3)
{
  int8x16_t *v9; // x19
  char *v11; // x21
  unsigned __int64 v12; // x20
  unsigned __int8 v13; // w1
  unsigned __int64 v14; // x2
  unsigned __int8 v15; // w0
  unsigned __int64 v16; // x22
  unsigned __int64 v17; // x26
  __int64 v18; // x0
  __int64 v19; // x23
  __int64 v20; // x23
  __int64 v21; // x3
  unsigned __int64 v22; // x0
  bool v23; // cf
  int v24; // w2
  char *v25; // x19
  int v26; // w0
  int v28; // t1
  _BYTE v30[256]; // [xsp+50h] [xbp+50h] BYREF

  v9 = (int8x16_t *)result;
  if ( a4 )
  {
    if ( a4 == 1 )
      return memchr();
    if ( a4 <= a2 )
    {
      v11 = (char *)result + a2 - a4;
      if ( a4 == 2 )
      {
        v24 = a3->n128_u8[1] | (a3->n128_u8[0] << 16);
        v25 = (char *)result + 1;
        v26 = *((unsigned __int8 *)result + 1) | (*(unsigned __int8 *)result << 16);
        if ( v24 != v26 && v11 >= v25 )
        {
          do
          {
            v28 = (unsigned __int8)*++v25;
            v26 = v28 | (v26 << 16);
          }
          while ( v11 >= v25 && v24 != v26 );
        }
        if ( v24 == v26 )
          return (unsigned __int64 (__fastcall *)(__int64, unsigned int, unsigned __int64))(v25 - 1);
      }
      else
      {
        if ( a4 > 0x100 )
          return (unsigned __int64 (__fastcall *)(__int64, unsigned int, unsigned __int64))two_way_long_needle_0(
                                                                                             (__int64)result,
                                                                                             a2,
                                                                                             a3,
                                                                                             a4,
                                                                                             a5,
                                                                                             a2 - a4,
                                                                                             a7,
                                                                                             a8,
                                                                                             a9);
        v12 = a4 - 1;
        memset(v30, 0, sizeof(v30));
        v13 = a3->n128_u8[0];
        v14 = 1LL;
        do
        {
          v15 = v13;
          v13 = a3->n128_u8[v14];
          v30[(unsigned __int8)(v13 - 8 * v15)] = v14++;
        }
        while ( v12 > v14 );
        v16 = a4 - 9;
        v17 = 0LL;
        v18 = (unsigned __int8)(a3->n128_u8[v12] - 8 * a3->n128_u8[a4 - 2]);
        v19 = (unsigned __int8)v30[v18];
        v30[v18] = v12;
        v20 = v12 - v19;
        while ( v11 >= (char *)v9 )
        {
          while ( 1 )
          {
            do
            {
              v9 = (int8x16_t *)((char *)v9 + v12);
              v21 = (unsigned __int8)(v9->n128_u8[0] - 8 * v9[-1].n128_u8[15]);
              v22 = (unsigned __int8)v30[v21];
              if ( v30[v21] )
                v23 = 0;
              else
                v23 = v11 >= (char *)v9;
            }
            while ( v23 );
            v9 = (int8x16_t *)((char *)v9 - v22);
            if ( v12 > v22 )
              break;
            if ( v12 <= 0xE
              || *(unsigned __int64 *)((char *)a3->n128_u64 + v17) == *(unsigned __int64 *)((char *)v9->n128_u64 + v17) )
            {
              if ( !(unsigned int)memcmp(v9, a3, v12) )
                return (unsigned __int64 (__fastcall *)(__int64, unsigned int, unsigned __int64))v9;
              if ( v17 >= 8 )
                v17 -= 8LL;
              else
                v17 = v16;
            }
            v9 = (int8x16_t *)((char *)v9 + v20);
            if ( v11 < (char *)v9 )
              return 0LL;
          }
        }
      }
    }
    return 0LL;
  }
  return result;
}

//----- (0000000000444EE0) ----------------------------------------------------
__int64 (__fastcall *__fastcall strndup(
        __int64 a1,
        unsigned __int64 a2))(__int64 result, __int64 *a2, unsigned __int64 a3)
{
  __int64 v2; // x1
  void *v3; // x3
  void *v4; // x4
  void *v5; // x5
  void *v6; // x6
  __int64 v7; // x7
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  __int64 (__fastcall *result)(__int64, __int64 *, unsigned __int64); // x0
  unsigned __int64 v17; // [xsp+28h] [xbp+28h]

  v17 = strnlen(a1, a2);
  result = (__int64 (__fastcall *)(__int64, __int64 *, unsigned __int64))malloc(
                                                                           v17 + 1,
                                                                           v2,
                                                                           v17,
                                                                           v3,
                                                                           v4,
                                                                           v5,
                                                                           v6,
                                                                           v7,
                                                                           v8,
                                                                           v9,
                                                                           v10,
                                                                           v11,
                                                                           v12,
                                                                           v13,
                                                                           v14,
                                                                           v15);
  if ( result )
  {
    *((_BYTE *)result + v17) = 0;
    return j_memcpy();
  }
  return result;
}
// 444F00: variable 'v2' is possibly undefined
// 444F00: variable 'v3' is possibly undefined
// 444F00: variable 'v4' is possibly undefined
// 444F00: variable 'v5' is possibly undefined
// 444F00: variable 'v6' is possibly undefined
// 444F00: variable 'v7' is possibly undefined
// 444F00: variable 'v8' is possibly undefined
// 444F00: variable 'v9' is possibly undefined
// 444F00: variable 'v10' is possibly undefined
// 444F00: variable 'v11' is possibly undefined
// 444F00: variable 'v12' is possibly undefined
// 444F00: variable 'v13' is possibly undefined
// 444F00: variable 'v14' is possibly undefined
// 444F00: variable 'v15' is possibly undefined

//----- (0000000000444F40) ----------------------------------------------------
__int64 __fastcall strspn(unsigned __int64 a1, unsigned __int8 *a2)
{
  unsigned int v2; // w2
  unsigned int v4; // t1
  __int64 result; // x0
  unsigned __int8 *v6; // x1
  unsigned int v7; // t1
  int v8; // w6
  int v9; // w2
  int v10; // w4
  unsigned __int8 *v11; // x1
  unsigned __int8 *v12; // x6
  unsigned __int64 v13; // x1
  int v14; // t1
  _OWORD v15[16]; // [xsp+0h] [xbp-100h] BYREF

  v2 = *a2;
  if ( !*a2 )
    return 0LL;
  if ( !a2[1] )
  {
    if ( *(unsigned __int8 *)a1 == v2 )
    {
      v13 = a1;
      do
        v14 = *(unsigned __int8 *)++v13;
      while ( v14 == v2 );
      return v13 - a1;
    }
    return 0LL;
  }
  memset(v15, 0, sizeof(v15));
  do
  {
    *((_BYTE *)v15 + v2) = 1;
    v4 = *++a2;
    v2 = v4;
  }
  while ( v4 );
  if ( !*((_BYTE *)v15 + *(unsigned __int8 *)a1) )
    return 0LL;
  result = 1LL;
  if ( *((_BYTE *)v15 + *(unsigned __int8 *)(a1 + 1)) )
  {
    result = 2LL;
    if ( *((_BYTE *)v15 + *(unsigned __int8 *)(a1 + 2)) )
    {
      result = 3LL;
      if ( *((_BYTE *)v15 + *(unsigned __int8 *)(a1 + 3)) )
      {
        v6 = (unsigned __int8 *)(a1 & 0xFFFFFFFFFFFFFFFCLL);
        do
        {
          v7 = v6[4];
          v6 += 4;
          v8 = *((unsigned __int8 *)v15 + v7);
          v9 = *((unsigned __int8 *)v15 + v6[2]);
          v10 = (unsigned __int8)(v8 & *((_BYTE *)v15 + v6[1]));
        }
        while ( ((unsigned __int8)v10 & (unsigned __int8)(v9 & *((_BYTE *)v15 + v6[3]))) != 0 );
        v11 = &v6[-a1];
        v12 = &v11[v8];
        result = (__int64)&v11[v9 + 2];
        if ( !v10 )
          return (__int64)v12;
      }
    }
  }
  return result;
}

//----- (0000000000445060) ----------------------------------------------------
void __fastcall nl_cleanup_time(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  unsigned __int64 *v9; // x19
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7
  double v18; // d0
  double v19; // d1
  double v20; // d2
  double v21; // d3
  double v22; // d4
  double v23; // d5
  double v24; // d6
  double v25; // d7
  double v26; // d0
  double v27; // d1
  double v28; // d2
  double v29; // d3
  double v30; // d4
  double v31; // d5
  double v32; // d6
  double v33; // d7

  v9 = *(unsigned __int64 **)(a1 + 32);
  if ( v9 )
  {
    *(_QWORD *)(a1 + 32) = 0LL;
    free(*v9, a2, a3, a4, a5, a6, a7, a8, a9);
    free(v9[3], v10, v11, v12, v13, v14, v15, v16, v17);
    free(v9[4], v18, v19, v20, v21, v22, v23, v24, v25);
    free((unsigned __int64)v9, v26, v27, v28, v29, v30, v31, v32, v33);
  }
}
// 445084: variable 'v10' is possibly undefined
// 445084: variable 'v11' is possibly undefined
// 445084: variable 'v12' is possibly undefined
// 445084: variable 'v13' is possibly undefined
// 445084: variable 'v14' is possibly undefined
// 445084: variable 'v15' is possibly undefined
// 445084: variable 'v16' is possibly undefined
// 445084: variable 'v17' is possibly undefined
// 44508C: variable 'v18' is possibly undefined
// 44508C: variable 'v19' is possibly undefined
// 44508C: variable 'v20' is possibly undefined
// 44508C: variable 'v21' is possibly undefined
// 44508C: variable 'v22' is possibly undefined
// 44508C: variable 'v23' is possibly undefined
// 44508C: variable 'v24' is possibly undefined
// 44508C: variable 'v25' is possibly undefined
// 44509C: variable 'v26' is possibly undefined
// 44509C: variable 'v27' is possibly undefined
// 44509C: variable 'v28' is possibly undefined
// 44509C: variable 'v29' is possibly undefined
// 44509C: variable 'v30' is possibly undefined
// 44509C: variable 'v31' is possibly undefined
// 44509C: variable 'v32' is possibly undefined
// 44509C: variable 'v33' is possibly undefined

//----- (00000000004450C0) ----------------------------------------------------
unsigned __int64 __fastcall fdopendir(int a1)
{
  void *v2; // x2
  __int64 v3; // x3
  __int64 v4; // x4
  __int64 v5; // x5
  __int64 v6; // x6
  __int64 v7; // x7
  unsigned int v8; // w0
  void *v9; // x4
  void *v10; // x5
  void *v11; // x6
  __int64 v12; // x7
  double v13; // d0
  double v14; // d1
  double v15; // d2
  double v16; // d3
  double v17; // d4
  double v18; // d5
  double v19; // d6
  double v20; // d7
  char v22; // [xsp+0h] [xbp+0h]
  unsigned int v23[4]; // [xsp+20h] [xbp+20h] BYREF
  int v24; // [xsp+30h] [xbp+30h]

  if ( (fstat64(a1, (struct stat *)v23) & 0x80000000) != 0 )
    return 0LL;
  if ( (v24 & 0xF000) != 0x4000 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 20;
    return 0LL;
  }
  v8 = _fcntl64_nocancel(a1, 3, v2, v3, v4, v5, v6, v7, v22);
  if ( v8 == -1 )
    return 0LL;
  if ( (v8 & 0x200000) != 0 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 9;
    return 0LL;
  }
  else if ( (v8 & 3) == 1 )
  {
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 22;
    return 0LL;
  }
  else
  {
    return _alloc_dir(a1, 0, v8, v23, v9, v10, v11, v12, v13, v14, v15, v16, v17, v18, v19, v20);
  }
}
// 4450F4: variable 'v2' is possibly undefined
// 4450F4: variable 'v3' is possibly undefined
// 4450F4: variable 'v4' is possibly undefined
// 4450F4: variable 'v5' is possibly undefined
// 4450F4: variable 'v6' is possibly undefined
// 4450F4: variable 'v7' is possibly undefined
// 4450F4: variable 'v22' is possibly undefined
// 445120: variable 'v9' is possibly undefined
// 445120: variable 'v10' is possibly undefined
// 445120: variable 'v11' is possibly undefined
// 445120: variable 'v12' is possibly undefined
// 445120: variable 'v13' is possibly undefined
// 445120: variable 'v14' is possibly undefined
// 445120: variable 'v15' is possibly undefined
// 445120: variable 'v16' is possibly undefined
// 445120: variable 'v17' is possibly undefined
// 445120: variable 'v18' is possibly undefined
// 445120: variable 'v19' is possibly undefined
// 445120: variable 'v20' is possibly undefined

//----- (00000000004451A0) ----------------------------------------------------
void __fastcall rewinddir(__int64 a1)
{
  __int64 v2; // x1
  __int64 v3; // x2
  __int64 v4; // x3
  void *v5; // x4
  void *v6; // x5
  void *v7; // x6
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  int v16; // w0
  __int64 v17; // x1
  __int64 v18; // x2
  __int64 v19; // x3
  void *v20; // x4
  void *v21; // x5
  void *v22; // x6
  int v23; // w0

  _aarch64_cas4_acq();
  if ( v16 )
    _lll_lock_wait_private((_DWORD *)(a1 + 4), v8, v9, v10, v11, v12, v13, v14, v15, v2, v3, v4, v5, v6, v7);
  lseek64(*(_DWORD *)a1, 0LL, 0);
  *(_QWORD *)(a1 + 16) = 0LL;
  *(_QWORD *)(a1 + 24) = 0LL;
  *(_QWORD *)(a1 + 32) = 0LL;
  *(_DWORD *)(a1 + 40) = 0;
  _aarch64_swp4_rel();
  if ( v23 > 1 )
    _lll_lock_wake_private((void *)(a1 + 4), v17, v18, v19, v20, v21, v22);
}
// 4451C0: variable 'v16' is possibly undefined
// 445204: variable 'v8' is possibly undefined
// 445204: variable 'v9' is possibly undefined
// 445204: variable 'v10' is possibly undefined
// 445204: variable 'v11' is possibly undefined
// 445204: variable 'v12' is possibly undefined
// 445204: variable 'v13' is possibly undefined
// 445204: variable 'v14' is possibly undefined
// 445204: variable 'v15' is possibly undefined
// 445204: variable 'v2' is possibly undefined
// 445204: variable 'v3' is possibly undefined
// 445204: variable 'v4' is possibly undefined
// 445204: variable 'v5' is possibly undefined
// 445204: variable 'v6' is possibly undefined
// 445204: variable 'v7' is possibly undefined
// 4451F0: variable 'v23' is possibly undefined
// 445218: variable 'v17' is possibly undefined
// 445218: variable 'v18' is possibly undefined
// 445218: variable 'v19' is possibly undefined
// 445218: variable 'v20' is possibly undefined
// 445218: variable 'v21' is possibly undefined
// 445218: variable 'v22' is possibly undefined

//----- (0000000000445220) ----------------------------------------------------
rlim64_t _get_child_max()
{
  struct rlimit64 v1; // [xsp+10h] [xbp+10h] BYREF

  if ( (unsigned int)getrlimit64(__RLIMIT_NPROC, &v1) )
    return -1LL;
  else
    return v1.rlim_cur;
}

//----- (0000000000445260) ----------------------------------------------------
__int64 __fastcall fstatat64(int a1, const char *a2, struct stat *a3, int a4)
{
  unsigned int v4; // w0

  v4 = linux_eabi_syscall(__NR_fstatat, a1, a2, a3, a4);
  if ( v4 <= 0xFFFFF000 )
    return 0LL;
  *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = -v4;
  return 0xFFFFFFFFLL;
}

//----- (0000000000445380) ----------------------------------------------------
__int64 __fastcall remove_slotinfo(__int64 a1, _QWORD *a2, __int64 a3, char a4)
{
  __int64 v4; // x7
  unsigned __int64 v5; // x4
  _QWORD *v6; // x5
  __int64 v7; // x1
  unsigned __int64 v8; // x0
  unsigned __int64 v9; // x6
  _QWORD *v11; // x1
  unsigned __int64 v12; // x0
  unsigned __int64 v13; // x6
  _QWORD *v15; // [xsp+18h] [xbp-8h]

  v4 = a3;
  v5 = a1 - a3;
  v6 = a2;
  if ( (unsigned __int64)(a1 - a3) >= *a2 )
  {
    v7 = a2[1];
    if ( v7 )
    {
      v15 = v6;
      if ( (remove_slotinfo(a1, v7) & 1) != 0 )
        return 1LL;
      v4 = a3;
      v6 = v15;
      v5 = *v15;
    }
    else if ( (a4 & 1) != 0 )
    {
      _libc_assert_fail((__int64)"! should_be_there", (__int64)"dl-close.c", 0x37u, (__int64)"remove_slotinfo");
    }
    v8 = v5;
    if ( v4 )
      v9 = 0LL;
    else
      v9 = dl_tls_static_nelem + 1;
    while ( 1 )
    {
      if ( v9 >= v8 )
        return 0LL;
      if ( v6[2 * v8 + 1] )
        break;
      --v8;
    }
    dl_tls_max_dtv_idx = v4 - 1 + v8;
    return 1LL;
  }
  v11 = &a2[2 * v5 + 2];
  if ( v11[1] )
  {
    *v11 = dl_tls_generation + 1;
    v11[1] = 0LL;
  }
  if ( dl_tls_max_dtv_idx == a1 )
  {
    v12 = a1 - a3;
    if ( a3 )
      v13 = 0LL;
    else
      v13 = dl_tls_static_nelem + 1;
    while ( 1 )
    {
      if ( v13 >= v12 )
        return 0LL;
      if ( v6[2 * v12 + 1] )
        break;
      --v12;
    }
    dl_tls_max_dtv_idx = a3 - 1 + v12;
    return 1LL;
  }
  else
  {
    dl_tls_dtv_gaps = 1;
    return 1LL;
  }
}
// 44550C: using guessed type __int64 dl_close_worker(void);
// 4921E0: using guessed type __int64 dl_tls_max_dtv_idx;
// 4921F0: using guessed type __int64 dl_tls_static_nelem;
// 492608: using guessed type __int64 dl_tls_generation;
// 492628: using guessed type char dl_tls_dtv_gaps;

//----- (000000000044550C) ----------------------------------------------------
ssize_t __fastcall dl_close_worker(ssize_t result, unsigned __int8 a2)
{
  int v2; // w2
  __int64 v3; // x28
  __int64 v4; // x25
  unsigned int v5; // w24
  __int64 v6; // x22
  unsigned __int64 v7; // x1
  __int64 v8; // x2
  char v9; // w3
  int v10; // w3
  int v11; // w2
  unsigned __int64 v12; // x1
  signed int v13; // w3
  unsigned int *v14; // x1
  unsigned __int64 v15; // x5
  __int16 v16; // w1
  __int64 v17; // x4
  __int64 v18; // x1
  _QWORD *v19; // x4
  signed int v20; // w1
  __int64 v21; // t1
  int v22; // w2
  unsigned int *v24; // x6
  __int64 v25; // x4
  int v26; // w2
  unsigned __int64 v28; // x1
  _QWORD *v29; // x3
  __int64 v30; // x4
  __int64 *v31; // x5
  unsigned __int64 v32; // x6
  double v33; // d0
  double v34; // d1
  double v35; // d2
  double v36; // d3
  double v37; // d4
  double v38; // d5
  double v39; // d6
  double v40; // d7
  __int64 v41; // x20
  unsigned int v42; // w28
  __int64 v43; // x7
  int v44; // w24
  __int64 v45; // x27
  unsigned __int64 v46; // x19
  unsigned int v47; // w22
  int v48; // w1
  _QWORD *v49; // x2
  unsigned __int64 v50; // x8
  __int64 v51; // x21
  __int64 v52; // x0
  unsigned __int64 v53; // x26
  __int64 v54; // x1
  int v55; // w9
  __int64 v56; // x0
  __int64 v57; // x0
  int v58; // w21
  int v59; // w26
  unsigned int v60; // w24
  unsigned __int64 v61; // x0
  _QWORD *v62; // x10
  __int64 v64; // x11
  __int64 v65; // x1
  __int64 v66; // t1
  __int64 v67; // t1
  bool v68; // zf
  int v69; // w0
  unsigned __int64 v70; // x0
  __int64 v71; // x11
  int *v72; // x23
  __int64 v73; // x1
  __int64 v74; // x2
  __int64 v75; // x3
  __int64 v76; // x4
  unsigned __int64 v77; // x5
  __int64 *v78; // x6
  double v79; // d0
  double v80; // d1
  double v81; // d2
  double v82; // d3
  double v83; // d4
  double v84; // d5
  double v85; // d6
  double v86; // d7
  int v87; // w7
  __int64 *v88; // x19
  __int64 v89; // x1
  __int64 v90; // x2
  __int64 v91; // x3
  __int64 v92; // x4
  void *v93; // x5
  void *v94; // x6
  double v95; // d0
  double v96; // d1
  double v97; // d2
  double v98; // d3
  double v99; // d4
  double v100; // d5
  double v101; // d6
  double v102; // d7
  __int64 *v103; // x2
  void (__fastcall *v104)(__int64); // x4
  void *v105; // x6
  double v106; // d0
  double v107; // d1
  double v108; // d2
  double v109; // d3
  double v110; // d4
  double v111; // d5
  double v112; // d6
  double v113; // d7
  unsigned __int64 *v114; // x20
  __int64 v115; // x3
  __int64 *v116; // x22
  unsigned __int64 *v117; // x19
  __int64 **v118; // x21
  int v119; // w24
  __int64 v120; // x28
  char v121; // w27
  unsigned __int64 v122; // x26
  __int16 v123; // w0
  __int64 v124; // x2
  __int64 v125; // x1
  double v126; // d0
  double v127; // d1
  double v128; // d2
  double v129; // d3
  double v130; // d4
  double v131; // d5
  double v132; // d6
  double v133; // d7
  double v134; // d0
  double v135; // d1
  double v136; // d2
  double v137; // d3
  double v138; // d4
  double v139; // d5
  double v140; // d6
  double v141; // d7
  unsigned __int64 v142; // x0
  double v143; // d0
  double v144; // d1
  double v145; // d2
  double v146; // d3
  double v147; // d4
  double v148; // d5
  double v149; // d6
  double v150; // d7
  double v151; // d0
  double v152; // d1
  double v153; // d2
  double v154; // d3
  double v155; // d4
  double v156; // d5
  double v157; // d6
  double v158; // d7
  unsigned __int64 v159; // x23
  unsigned __int64 v160; // x0
  int v161; // w2
  double v162; // d0
  double v163; // d1
  double v164; // d2
  double v165; // d3
  double v166; // d4
  double v167; // d5
  double v168; // d6
  double v169; // d7
  unsigned __int64 v170; // x0
  unsigned __int64 v171; // x0
  unsigned __int64 v172; // x0
  double v173; // d0
  double v174; // d1
  double v175; // d2
  double v176; // d3
  double v177; // d4
  double v178; // d5
  double v179; // d6
  double v180; // d7
  __int64 v181; // x0
  __int64 v182; // x0
  char *v183; // x5
  int *v184; // x23
  double v185; // d0
  double v186; // d1
  double v187; // d2
  double v188; // d3
  double v189; // d4
  double v190; // d5
  double v191; // d6
  double v192; // d7
  __int64 **v193; // x1
  __int64 *v194; // x0
  __int64 v195; // x9
  unsigned int i; // w0
  __int64 *v197; // x19
  __int64 v198; // x0
  __int64 v199; // x0
  __int64 v200; // x1
  __int64 v201; // x2
  __int64 v202; // x3
  __int64 v203; // x4
  void *v204; // x5
  void *v205; // x6
  __int64 v206; // x1
  __int64 v207; // x2
  __int64 v208; // x3
  __int64 v209; // x4
  void *v210; // x5
  void *v211; // x6
  double v212; // d0
  double v213; // d1
  double v214; // d2
  double v215; // d3
  double v216; // d4
  double v217; // d5
  double v218; // d6
  double v219; // d7
  unsigned int v220; // w0
  unsigned int v221; // w2
  __int64 v222; // x1
  int v223; // w3
  unsigned __int64 v224; // x1
  __int64 *v225; // x3
  __int64 *v226; // x3
  __int64 *v227; // x2
  void (__fastcall *v228)(__int64); // x1
  void (__fastcall *v229)(__int64); // x0
  unsigned __int64 v230[2]; // [xsp+0h] [xbp+0h] BYREF
  __int64 *v231; // [xsp+60h] [xbp+60h]
  int v232; // [xsp+6Ch] [xbp+6Ch]
  __int64 *v233; // [xsp+70h] [xbp+70h]
  char *v234; // [xsp+78h] [xbp+78h]
  unsigned __int64 *v235; // [xsp+80h] [xbp+80h]
  int *v236; // [xsp+88h] [xbp+88h]
  int *v237; // [xsp+90h] [xbp+90h]
  __int64 *v238; // [xsp+98h] [xbp+98h]
  _QWORD *v239; // [xsp+A0h] [xbp+A0h]
  unsigned int v240; // [xsp+A8h] [xbp+A8h]
  int v241; // [xsp+ACh] [xbp+ACh]
  unsigned __int64 v242; // [xsp+B0h] [xbp+B0h]
  unsigned __int64 v243; // [xsp+B8h] [xbp+B8h]
  __int64 v244; // [xsp+C0h] [xbp+C0h]
  __int64 **v245; // [xsp+C8h] [xbp+C8h]
  __int64 v246; // [xsp+D0h] [xbp+D0h]
  unsigned __int64 *v247; // [xsp+D8h] [xbp+D8h]
  int *v248; // [xsp+E0h] [xbp+E0h]
  void (__fastcall *v249)(__int64); // [xsp+E8h] [xbp+E8h]

  v2 = *(_DWORD *)(result + 864) - 1;
  *(_DWORD *)(result + 864) = v2;
  if ( v2 || (*(_WORD *)(result + 868) & 3) != 2 )
  {
LABEL_31:
    if ( (dl_debug_mask & 0x40) != 0 )
      return dl_debug_printf("\nclosing file=%s; direct_opencount=%u\n", *(const char **)(result + 8), v2);
    return result;
  }
  if ( dl_close_state_2 )
  {
    dl_close_state_2 = 2;
    goto LABEL_31;
  }
  v245 = &dl_ns;
  v234 = &_libc_single_threaded;
  v231 = &dl_scope_free_list;
  v237 = (int *)&dl_load_tls_lock;
  v3 = *(_QWORD *)(result + 48);
  v232 = a2;
  v236 = dl_load_write_lock;
  v238 = &dl_debug_mask;
  v4 = v3;
  v233 = &dl_initfirst;
  v235 = (unsigned __int64 *)&dl_tls_generation;
  while ( 1 )
  {
    dl_close_state_2 = 1;
    v5 = (unsigned int)v245[21 * v4 + 1];
    v247 = v230;
    v6 = v5;
    v7 = (unsigned __int64)v245[21 * v4];
    if ( v7 )
      break;
    if ( v5 )
      goto LABEL_215;
    if ( !result )
    {
      dl_sort_maps(v230, 0, 0, 1);
      goto LABEL_82;
    }
    v223 = *(_DWORD *)(result + 1068);
    v224 = v230[0];
    v230[v223] = v230[0];
    *(_DWORD *)(v224 + 1068) = v223;
    v230[0] = result;
    *(_DWORD *)(result + 1068) = 0;
    dl_sort_maps(v230, 0, 1u, 1);
    if ( dl_close_state_2 != 2 )
      goto LABEL_183;
LABEL_83:
    result = 0LL;
  }
  v8 = 0LL;
  do
  {
    v9 = *(_BYTE *)(v7 + 869);
    *(_DWORD *)(v7 + 1068) = v8;
    *(_BYTE *)(v7 + 869) = v9 & 0xF3;
    v230[v8] = v7;
    v10 = v8++;
    v7 = *(_QWORD *)(v7 + 24);
  }
  while ( v7 );
  if ( v10 + 1 != v5 )
LABEL_215:
    _libc_assert_fail((__int64)"idx == nloaded", (__int64)"dl-close.c", 0x9Au, (__int64)"_dl_close_worker");
  if ( result )
  {
    v11 = *(_DWORD *)(result + 1068);
    v12 = v230[0];
    v230[v11] = v230[0];
    *(_DWORD *)(v12 + 1068) = v11;
    v230[0] = result;
    *(_DWORD *)(result + 1068) = 0;
  }
  v13 = 0;
  do
  {
    while ( 1 )
    {
      v15 = v230[v13];
      v16 = *(_WORD *)(v15 + 868);
      if ( (v16 & 0x800) == 0 )
        break;
LABEL_13:
      if ( ++v13 >= v5 )
        goto LABEL_52;
    }
    if ( (v16 & 3) != 2
      || *(_DWORD *)(v15 + 864)
      || (*(_BYTE *)(v15 + 871) & 1) != 0
      || (v28 = atomic_load((unsigned __int64 *)(v15 + 1184))) != 0
      || (*(_WORD *)(v15 + 868) & 0x400) != 0 )
    {
      v17 = *(_QWORD *)(v15 + 1032);
      *(_DWORD *)(v15 + 1068) = -1;
      *(_BYTE *)(v15 + 869) |= 0xCu;
      if ( v17 )
      {
        v18 = *(_QWORD *)(v17 + 8);
        if ( v18 )
        {
          v19 = (_QWORD *)(v17 + 8);
          do
          {
            v22 = *(_DWORD *)(v18 + 1068);
            if ( v22 != -1 )
            {
              if ( v22 < 0 || v22 >= v5 )
                _libc_assert_fail(
                  (__int64)"(*lp)->l_idx >= 0 && (*lp)->l_idx < nloaded",
                  (__int64)"dl-close.c",
                  0xCAu,
                  (__int64)"_dl_close_worker");
              if ( (*(_WORD *)(v18 + 868) & 0x400) == 0 )
              {
                *(_WORD *)(v18 + 868) |= 0x400u;
                v20 = *(_DWORD *)(*v19 + 1068LL);
                if ( v20 <= v13 )
                  v13 = v20 - 1;
              }
            }
            v21 = v19[1];
            ++v19;
            v18 = v21;
          }
          while ( v21 );
        }
      }
      v14 = *(unsigned int **)(v15 + 1040);
      if ( v14 && *v14 )
      {
        v24 = &v14[2 * *v14];
        do
        {
          v25 = *((_QWORD *)v14 + 1);
          v26 = *(_DWORD *)(v25 + 1068);
          if ( v26 != -1 )
          {
            if ( v26 < 0 || v26 >= v5 )
              _libc_assert_fail(
                (__int64)"jmap->l_idx >= 0 && jmap->l_idx < nloaded",
                (__int64)"dl-close.c",
                0xE3u,
                (__int64)"_dl_close_worker");
            if ( (*(_WORD *)(v25 + 868) & 0x400) == 0 )
            {
              *(_WORD *)(v25 + 868) |= 0x400u;
              if ( v26 <= v13 )
                v13 = v26 - 1;
            }
          }
          v14 += 2;
        }
        while ( v24 != v14 );
      }
      goto LABEL_13;
    }
    ++v13;
  }
  while ( v13 < v5 );
LABEL_52:
  dl_sort_maps(v230, v5, result != 0, 1);
  v41 = 0LL;
  v42 = -1;
  v43 = 0LL;
  LODWORD(v246) = v5;
  v44 = 0;
  LODWORD(v248) = 0;
  v249 = (void (__fastcall *)(__int64))dl_call_fini;
  v45 = v6;
  do
  {
    while ( 1 )
    {
      v46 = v230[v41];
      v47 = v41;
      if ( *(_QWORD *)(v46 + 48) != v4 )
        _libc_assert_fail((__int64)"imap->l_ns == nsid", (__int64)"dl-close.c", 0xFEu, (__int64)"_dl_close_worker");
      v61 = *(unsigned __int16 *)(v46 + 868);
      v48 = v61 & 3;
      if ( (v61 & 0x400) == 0 )
      {
        if ( v48 != 2 || (*(_BYTE *)(v46 + 871) & 1) != 0 )
          _libc_assert_fail(
            (__int64)"imap->l_type == lt_loaded && !imap->l_nodelete_active",
            (__int64)"dl-close.c",
            0x102u,
            (__int64)"_dl_close_worker");
        if ( (v61 & 0x10) != 0 )
        {
          dl_catch_exception(0LL, v249, v230[v41], (__int64)v29, v30, (__int64)v31, v32, v43);
          v61 = *(unsigned __int16 *)(v46 + 868);
        }
        v44 += (v61 >> 5) & 1;
        if ( v42 > (unsigned int)v41 )
          v42 = v41;
        v43 = 1LL;
        *(_BYTE *)(v46 + 870) |= 4u;
        goto LABEL_60;
      }
      if ( v48 == 2 )
        break;
LABEL_60:
      if ( v45 == ++v41 )
        goto LABEL_81;
    }
    if ( *(_QWORD *)(v46 + 776) )
    {
      v49 = *(_QWORD **)(v46 + 976);
      v50 = 0LL;
      v32 = 1LL;
      v51 = *v49;
      if ( !*v49 )
        goto LABEL_75;
    }
    else
    {
      v50 = *(_QWORD *)(v46 + 1032);
      if ( v50 )
      {
        if ( *(_QWORD *)(v50 + 8) )
        {
          v220 = 1;
          do
            v221 = v220++;
          while ( *(_QWORD *)(v50 + 8LL * v220) );
          v222 = 8LL * (v221 + 2);
        }
        else
        {
          v222 = 16LL;
          v220 = 1;
        }
        v49 = *(_QWORD **)(v46 + 976);
        v51 = *v49;
        *(_QWORD *)(v46 + 776) = v50 + v222;
        *(_DWORD *)(v46 + 784) = v220;
        if ( !v51 )
        {
LABEL_74:
          *(_QWORD *)(v46 + 776) = 0LL;
          *(_DWORD *)(v46 + 784) = 0;
          goto LABEL_75;
        }
        v50 = v46 + 776;
        v32 = 2LL;
      }
      else
      {
        v49 = *(_QWORD **)(v46 + 976);
        v32 = 1LL;
        v51 = *v49;
        if ( !*v49 )
          goto LABEL_75;
      }
    }
    v52 = v51;
    v53 = v46 + 792;
    v54 = 1LL;
    v55 = 0;
    do
    {
      while ( v53 != v52 )
      {
        v56 = v52 - 776;
        v29 = *(_QWORD **)(v56 + 48);
        if ( v29 != (_QWORD *)v4 )
          _libc_assert_fail((__int64)"tmap->l_ns == nsid", (__int64)"dl-close.c", 0x149u, (__int64)"_dl_close_worker");
        if ( *(_DWORD *)(v56 + 1068) == -1 )
          break;
        v52 = v49[v54];
        v55 = 1;
        ++v54;
        if ( !v52 )
          goto LABEL_72;
      }
      v52 = v49[v54];
      ++v32;
      ++v54;
    }
    while ( v52 );
LABEL_72:
    if ( v55 )
    {
      v62 = (_QWORD *)(v46 + 936);
      if ( v49 == (_QWORD *)(v46 + 936) || v32 > 3 )
      {
        v64 = *(_QWORD *)(v46 + 968);
        v239 = v49;
        v240 = v43;
        v241 = v55;
        v242 = v50;
        v243 = v46 + 936;
        v244 = v64;
        v70 = malloc(
                8 * v64,
                v54 * 8,
                (__int64)v49,
                v29,
                (void *)v30,
                v31,
                (void *)v32,
                v43,
                v33,
                v34,
                v35,
                v36,
                v37,
                v38,
                v39,
                v40);
        v49 = v239;
        v71 = v244;
        v50 = v242;
        v62 = (_QWORD *)v243;
        v43 = v240;
        v55 = v241;
        if ( !v70 )
          dl_signal_error(0xCu, (__int64)"dlclose", 0LL, "cannot create scope list");
      }
      else
      {
        v70 = v46 + 936;
        v71 = 4LL;
      }
      v31 = v49 + 1;
      v65 = 0LL;
      do
      {
        while ( 1 )
        {
          v32 = 8 * v65;
          v29 = (_QWORD *)(v70 + 8 * v65);
          if ( v53 != v51 )
          {
            v30 = *(unsigned int *)(v51 + 292);
            if ( (_DWORD)v30 != -1 )
              break;
          }
          *v29 = v51;
          ++v65;
          v67 = *v31++;
          v51 = v67;
          if ( !v67 )
            goto LABEL_97;
        }
        if ( v50 )
        {
          ++v65;
          *(_QWORD *)(v70 + v32) = v50;
          v50 = 0LL;
        }
        v66 = *v31++;
        v51 = v66;
      }
      while ( v66 );
LABEL_97:
      *(_QWORD *)(v70 + 8 * v65) = 0LL;
      *(_QWORD *)(v46 + 976) = v70;
      if ( v49 == v62 )
      {
        LODWORD(v248) = v55;
        *(_QWORD *)(v46 + 968) = v71;
      }
      else
      {
        LODWORD(v243) = v43;
        v244 = v71;
        if ( (unsigned int)dl_scope_free(
                             (unsigned __int64)v49,
                             v33,
                             v34,
                             v35,
                             v36,
                             v37,
                             v38,
                             v39,
                             v40,
                             v65,
                             (__int64)v49,
                             v29,
                             (void *)v30,
                             v31,
                             (void *)v32,
                             v43) )
          v68 = 1;
        else
          v68 = (_DWORD)v248 == 0;
        v69 = !v68;
        v43 = (unsigned int)v243;
        LODWORD(v248) = v69;
        *(_QWORD *)(v46 + 968) = v244;
      }
    }
    else if ( v50 )
    {
      goto LABEL_74;
    }
LABEL_75:
    v57 = *(_QWORD *)(v46 + 808);
    if ( v57 && *(_DWORD *)(v57 + 1068) != -1 )
      *(_QWORD *)(v46 + 808) = 0LL;
    ++v41;
    if ( v42 > v47 )
      v42 = v47;
  }
  while ( v45 != v41 );
LABEL_81:
  v58 = v44;
  v59 = v43;
  v60 = v246;
  if ( !(_DWORD)v43 )
    goto LABEL_82;
  v72 = dl_debug_update(v4);
  v72[6] = 2;
  ((void (*)(void))dl_debug_state)();
  v87 = (unsigned __int8)*v234;
  if ( v58 )
  {
    v73 = (__int64)v245;
    v78 = v245[21 * v4 + 2];
    for ( i = *((_DWORD *)v78 + 2); i; --i )
    {
      v73 = *v78;
      v74 = *(unsigned __int8 *)(*(_QWORD *)(*v78 + 8LL * (i - 1)) + 870LL);
      if ( (v74 & 4) == 0 )
      {
        v77 = v58 + i;
        if ( *((_DWORD *)v78 + 2) != (_DWORD)v77 )
        {
          v195 = i;
          v74 = 0LL;
          i = 0;
          do
          {
            v75 = *(_QWORD *)(v73 + 8 * v74);
            v76 = *(unsigned __int8 *)(v75 + 870);
            if ( (v76 & 4) == 0 )
            {
              if ( i != (_DWORD)v74 )
                *(_QWORD *)(v73 + 8LL * i) = v75;
              ++i;
            }
            ++v74;
          }
          while ( v74 != v195 );
        }
        break;
      }
    }
    *((_DWORD *)v78 + 2) = i;
    if ( v87 )
    {
LABEL_114:
      pthread_mutex_lock(v237, v79, v80, v81, v82, v83, v84, v85, v86, v73, v74, v75, v76, (void *)v77, v78);
      pthread_mutex_lock(v236, v95, v96, v97, v98, v99, v100, v101, v102, v89, v90, v91, v92, v93, v94);
      if ( v42 >= v60 )
        goto LABEL_173;
      goto LABEL_115;
    }
LABEL_168:
    v88 = &dl_scope_free_list;
    goto LABEL_169;
  }
  if ( *v234 )
    goto LABEL_114;
  if ( ((unsigned __int8)v248 & 1) != 0 )
    goto LABEL_168;
  v88 = v231;
  if ( !*v231 || !*(_QWORD *)*v231 )
    goto LABEL_114;
LABEL_169:
  _thread_gscope_wait();
  v197 = (__int64 *)*v88;
  if ( !v197 )
    goto LABEL_114;
  v198 = *v197;
  if ( !*v197 )
    goto LABEL_114;
  do
  {
    v199 = v198 - 1;
    *v197 = v199;
    free(v197[v199 + 1], v79, v80, v81, v82, v83, v84, v85, v86);
    v198 = *v197;
  }
  while ( *v197 );
  pthread_mutex_lock(v237, v79, v80, v81, v82, v83, v84, v85, v86, v200, v201, v202, v203, v204, v205);
  pthread_mutex_lock(v236, v212, v213, v214, v215, v216, v217, v218, v219, v206, v207, v208, v209, v210, v211);
  if ( v42 >= v60 )
  {
LABEL_173:
    pthread_mutex_unlock(dl_load_write_lock, v106, v107, v108, v109, v110, v111, v112, v113);
    goto LABEL_147;
  }
LABEL_115:
  v114 = &v230[v42];
  v115 = v60 - 1 - v42 + (unsigned __int64)v42;
  v116 = v233;
  v117 = &v230[v115 + 1];
  v118 = v245;
  v119 = v232 & 1;
  v120 = 0LL;
  v121 = 0;
  LODWORD(v244) = v59;
  v248 = v72;
  v249 = 0LL;
  while ( 2 )
  {
    while ( 1 )
    {
      v122 = *v114;
      v123 = *(_WORD *)(*v114 + 868);
      if ( (v123 & 0x400) == 0 )
        break;
      if ( v117 == ++v114 )
        goto LABEL_143;
    }
    if ( (v123 & 3) != 2 )
      _libc_assert_fail(
        (__int64)"imap->l_type == lt_loaded",
        (__int64)"dl-close.c",
        0x1F1u,
        (__int64)"_dl_close_worker");
    if ( *(_QWORD *)(v122 + 1144) )
    {
      if ( dl_tls_dtv_slotinfo_list
        && (remove_slotinfo(
              *(_QWORD *)(v122 + 1176),
              (_QWORD *)dl_tls_dtv_slotinfo_list,
              0LL,
              (*(_QWORD *)(v122 + 864) & 0x1000000000LL) != 0) & 1) == 0 )
      {
        dl_tls_max_dtv_idx = dl_tls_static_nelem;
      }
      v182 = *(_QWORD *)(v122 + 1168);
      v121 = v244;
      if ( (unsigned __int64)(v182 + 1) > 1 )
      {
        if ( !v120 )
        {
          v120 = *(_QWORD *)(v122 + 1160);
          v249 = (void (__fastcall *)(__int64))(v182 + *(_QWORD *)(v122 + 1144));
          if ( v119 )
            goto LABEL_158;
          goto LABEL_121;
        }
        v228 = *(void (__fastcall **)(__int64))(v122 + 1160);
        v229 = (void (__fastcall *)(__int64))(v182 + *(_QWORD *)(v122 + 1144));
        v103 = (__int64 *)v249;
        if ( v249 == v228 )
        {
          v249 = v229;
        }
        else if ( (void (__fastcall *)(__int64))v120 == v229 )
        {
          v120 = *(_QWORD *)(v122 + 1160);
        }
        else
        {
          v103 = &dl_tls_static_used;
          v115 = dl_tls_static_used;
          if ( (void (__fastcall *)(__int64))dl_tls_static_used == v229 )
          {
            dl_tls_static_used = *(_QWORD *)(v122 + 1160);
          }
          else
          {
            v104 = v249;
            if ( (void (__fastcall *)(__int64))dl_tls_static_used == v249 )
            {
              dl_tls_static_used = v120;
              v120 = (__int64)v228;
              v249 = v229;
            }
            else
            {
              v103 = (__int64 *)v249;
              if ( (unsigned __int64)v249 < (unsigned __int64)v228 )
                v120 = *(_QWORD *)(v122 + 1160);
              else
                v229 = v249;
              v249 = v229;
            }
          }
        }
      }
    }
    if ( v119 )
    {
LABEL_158:
      v246 = 168 * v4;
      v183 = (char *)(168 * v4 + 40);
      v184 = (int *)&v183[(_QWORD)v118];
      pthread_mutex_lock(
        &v183[(_QWORD)v118],
        v106,
        v107,
        v108,
        v109,
        v110,
        v111,
        v112,
        v113,
        168 * v4,
        (__int64)v103,
        v115,
        (__int64)v104,
        v183,
        v105);
      v193 = &v118[(unsigned __int64)v246 / 8];
      v194 = v118[(unsigned __int64)v246 / 8 + 11];
      if ( v194 )
      {
        v225 = v193[12];
        if ( v225 )
        {
          v226 = &v194[4 * (_QWORD)v225];
          do
          {
            if ( v194[1] && v194[3] == v122 )
            {
              v227 = v193[13];
              *(_DWORD *)v194 = 0;
              v194[1] = 0LL;
              v193[13] = (__int64 *)((char *)v227 - 1);
            }
            v194 += 4;
          }
          while ( v194 != v226 );
        }
      }
      pthread_mutex_unlock(v184, v185, v186, v187, v188, v189, v190, v191, v192);
    }
LABEL_121:
    dl_unmap(v122);
    if ( v4 )
      _libc_assert_fail((__int64)"nsid == LM_ID_BASE", (__int64)"dl-close.c", 0x27Fu, (__int64)"_dl_close_worker");
    v124 = *(_QWORD *)(v122 + 32);
    if ( !v124 )
      _libc_assert_fail((__int64)"imap->l_prev != NULL", (__int64)"dl-close.c", 0x280u, (__int64)"_dl_close_worker");
    v125 = *(_QWORD *)(v122 + 24);
    *(_QWORD *)(v124 + 24) = v125;
    --*((_DWORD *)v118 + 2);
    if ( v125 )
      *(_QWORD *)(v125 + 32) = v124;
    dl_find_object_dlclose(v122);
    free(*(_QWORD *)(v122 + 816), v126, v127, v128, v129, v130, v131, v132, v133);
    v142 = *(_QWORD *)(v122 + 912);
    if ( v142 != -1LL )
      free(v142, v134, v135, v136, v137, v138, v139, v140, v141);
    free(*(_QWORD *)(v122 + 1040), v134, v135, v136, v137, v138, v139, v140, v141);
    if ( (*(_DWORD *)v238 & 0x40) != 0 )
      dl_debug_printf("\nfile=%s [%lu];  destroying link map\n", *(const char **)(v122 + 8), *(_QWORD *)(v122 + 48));
    free(*(_QWORD *)(v122 + 8), v143, v144, v145, v146, v147, v148, v149, v150);
    v159 = *(_QWORD *)(v122 + 56);
    do
    {
      while ( 1 )
      {
        v160 = v159;
        v161 = *(_DWORD *)(v159 + 16);
        v159 = *(_QWORD *)(v159 + 8);
        if ( !v161 )
          break;
        if ( !v159 )
          goto LABEL_132;
      }
      free(v160, v151, v152, v153, v154, v155, v156, v157, v158);
    }
    while ( v159 );
LABEL_132:
    free(*(_QWORD *)(v122 + 1032), v151, v152, v153, v154, v155, v156, v157, v158);
    v170 = *(_QWORD *)(v122 + 976);
    if ( v170 != v122 + 936 )
      free(v170, v162, v163, v164, v165, v166, v167, v168, v169);
    if ( (*(_WORD *)(v122 + 868) & 0x1000) != 0 )
      free(*(_QWORD *)(v122 + 752), v162, v163, v164, v165, v166, v167, v168, v169);
    v171 = *(_QWORD *)(v122 + 880);
    if ( v171 != -1LL )
      free(v171, v162, v163, v164, v165, v166, v167, v168, v169);
    v172 = *(_QWORD *)(v122 + 1016);
    if ( v172 != -1LL )
      free(v172, v162, v163, v164, v165, v166, v167, v168, v169);
    if ( *v116 == v122 )
      *v116 = 0LL;
    ++v114;
    free(v122, v162, v163, v164, v165, v166, v167, v168, v169);
    if ( v117 != v114 )
      continue;
    break;
  }
LABEL_143:
  v72 = v248;
  pthread_mutex_unlock(v236, v106, v107, v108, v109, v110, v111, v112, v113);
  if ( (v121 & 1) != 0 )
  {
    if ( *v235 == -1LL )
      dl_fatal_printf("TLS generation counter wrapped!  Please report as described in <https://gitlab.archlinux.org/archl"
                      "inux/packaging/packages/aarch64-linux-gnu-glibc/-/issues>.\n");
    atomic_store(*v235 + 1, v235);
    if ( (void (__fastcall *)(__int64))dl_tls_static_used == v249 )
      dl_tls_static_used = v120;
  }
LABEL_147:
  v181 = pthread_mutex_unlock(v237, v173, v174, v175, v176, v177, v178, v179, v180);
  v72[6] = 0;
  dl_debug_state(v181);
  if ( !v245[21 * v4] && dl_nns - 1 == v4 )
    dl_nns = v4;
LABEL_82:
  if ( dl_close_state_2 == 2 )
    goto LABEL_83;
LABEL_183:
  dl_close_state_2 = 0;
  return (ssize_t)v247;
}
// 4459A0: variable 'v29' is possibly undefined
// 4459A0: variable 'v30' is possibly undefined
// 4459A0: variable 'v31' is possibly undefined
// 4459A0: variable 'v32' is possibly undefined
// 4459D4: variable 'v33' is possibly undefined
// 4459D4: variable 'v34' is possibly undefined
// 4459D4: variable 'v35' is possibly undefined
// 4459D4: variable 'v36' is possibly undefined
// 4459D4: variable 'v37' is possibly undefined
// 4459D4: variable 'v38' is possibly undefined
// 4459D4: variable 'v39' is possibly undefined
// 4459D4: variable 'v40' is possibly undefined
// 445B04: variable 'v79' is possibly undefined
// 445B04: variable 'v80' is possibly undefined
// 445B04: variable 'v81' is possibly undefined
// 445B04: variable 'v82' is possibly undefined
// 445B04: variable 'v83' is possibly undefined
// 445B04: variable 'v84' is possibly undefined
// 445B04: variable 'v85' is possibly undefined
// 445B04: variable 'v86' is possibly undefined
// 445B04: variable 'v73' is possibly undefined
// 445B04: variable 'v74' is possibly undefined
// 445B04: variable 'v75' is possibly undefined
// 445B04: variable 'v76' is possibly undefined
// 445B04: variable 'v77' is possibly undefined
// 445B04: variable 'v78' is possibly undefined
// 445B0C: variable 'v95' is possibly undefined
// 445B0C: variable 'v96' is possibly undefined
// 445B0C: variable 'v97' is possibly undefined
// 445B0C: variable 'v98' is possibly undefined
// 445B0C: variable 'v99' is possibly undefined
// 445B0C: variable 'v100' is possibly undefined
// 445B0C: variable 'v101' is possibly undefined
// 445B0C: variable 'v102' is possibly undefined
// 445B0C: variable 'v89' is possibly undefined
// 445B0C: variable 'v90' is possibly undefined
// 445B0C: variable 'v91' is possibly undefined
// 445B0C: variable 'v92' is possibly undefined
// 445B0C: variable 'v93' is possibly undefined
// 445B0C: variable 'v94' is possibly undefined
// 445BC0: variable 'v126' is possibly undefined
// 445BC0: variable 'v127' is possibly undefined
// 445BC0: variable 'v128' is possibly undefined
// 445BC0: variable 'v129' is possibly undefined
// 445BC0: variable 'v130' is possibly undefined
// 445BC0: variable 'v131' is possibly undefined
// 445BC0: variable 'v132' is possibly undefined
// 445BC0: variable 'v133' is possibly undefined
// 445BD0: variable 'v134' is possibly undefined
// 445BD0: variable 'v135' is possibly undefined
// 445BD0: variable 'v136' is possibly undefined
// 445BD0: variable 'v137' is possibly undefined
// 445BD0: variable 'v138' is possibly undefined
// 445BD0: variable 'v139' is possibly undefined
// 445BD0: variable 'v140' is possibly undefined
// 445BD0: variable 'v141' is possibly undefined
// 445BEC: variable 'v143' is possibly undefined
// 445BEC: variable 'v144' is possibly undefined
// 445BEC: variable 'v145' is possibly undefined
// 445BEC: variable 'v146' is possibly undefined
// 445BEC: variable 'v147' is possibly undefined
// 445BEC: variable 'v148' is possibly undefined
// 445BEC: variable 'v149' is possibly undefined
// 445BEC: variable 'v150' is possibly undefined
// 445C18: variable 'v151' is possibly undefined
// 445C18: variable 'v152' is possibly undefined
// 445C18: variable 'v153' is possibly undefined
// 445C18: variable 'v154' is possibly undefined
// 445C18: variable 'v155' is possibly undefined
// 445C18: variable 'v156' is possibly undefined
// 445C18: variable 'v157' is possibly undefined
// 445C18: variable 'v158' is possibly undefined
// 445C2C: variable 'v162' is possibly undefined
// 445C2C: variable 'v163' is possibly undefined
// 445C2C: variable 'v164' is possibly undefined
// 445C2C: variable 'v165' is possibly undefined
// 445C2C: variable 'v166' is possibly undefined
// 445C2C: variable 'v167' is possibly undefined
// 445C2C: variable 'v168' is possibly undefined
// 445C2C: variable 'v169' is possibly undefined
// 445C80: variable 'v106' is possibly undefined
// 445C80: variable 'v107' is possibly undefined
// 445C80: variable 'v108' is possibly undefined
// 445C80: variable 'v109' is possibly undefined
// 445C80: variable 'v110' is possibly undefined
// 445C80: variable 'v111' is possibly undefined
// 445C80: variable 'v112' is possibly undefined
// 445C80: variable 'v113' is possibly undefined
// 445CC0: variable 'v173' is possibly undefined
// 445CC0: variable 'v174' is possibly undefined
// 445CC0: variable 'v175' is possibly undefined
// 445CC0: variable 'v176' is possibly undefined
// 445CC0: variable 'v177' is possibly undefined
// 445CC0: variable 'v178' is possibly undefined
// 445CC0: variable 'v179' is possibly undefined
// 445CC0: variable 'v180' is possibly undefined
// 445D7C: variable 'v103' is possibly undefined
// 445D7C: variable 'v115' is possibly undefined
// 445D7C: variable 'v104' is possibly undefined
// 445D7C: variable 'v105' is possibly undefined
// 445D94: variable 'v185' is possibly undefined
// 445D94: variable 'v186' is possibly undefined
// 445D94: variable 'v187' is possibly undefined
// 445D94: variable 'v188' is possibly undefined
// 445D94: variable 'v189' is possibly undefined
// 445D94: variable 'v190' is possibly undefined
// 445D94: variable 'v191' is possibly undefined
// 445D94: variable 'v192' is possibly undefined
// 445E2C: variable 'v200' is possibly undefined
// 445E2C: variable 'v201' is possibly undefined
// 445E2C: variable 'v202' is possibly undefined
// 445E2C: variable 'v203' is possibly undefined
// 445E2C: variable 'v204' is possibly undefined
// 445E2C: variable 'v205' is possibly undefined
// 445E34: variable 'v212' is possibly undefined
// 445E34: variable 'v213' is possibly undefined
// 445E34: variable 'v214' is possibly undefined
// 445E34: variable 'v215' is possibly undefined
// 445E34: variable 'v216' is possibly undefined
// 445E34: variable 'v217' is possibly undefined
// 445E34: variable 'v218' is possibly undefined
// 445E34: variable 'v219' is possibly undefined
// 445E34: variable 'v206' is possibly undefined
// 445E34: variable 'v207' is possibly undefined
// 445E34: variable 'v208' is possibly undefined
// 445E34: variable 'v209' is possibly undefined
// 445E34: variable 'v210' is possibly undefined
// 445E34: variable 'v211' is possibly undefined
// 417FA0: using guessed type __int64 __fastcall dl_debug_state(_QWORD);
// 4461A0: using guessed type __int64 dl_close(void);
// 490F08: using guessed type char _libc_single_threaded;
// 490F20: using guessed type __int64 dl_nns;
// 490F60: using guessed type int dl_load_write_lock[12];
// 4914A8: using guessed type __int64 *dl_ns;
// 4921E0: using guessed type __int64 dl_tls_max_dtv_idx;
// 4921E8: using guessed type __int64 dl_tls_dtv_slotinfo_list;
// 4921F0: using guessed type __int64 dl_tls_static_nelem;
// 492608: using guessed type __int64 dl_tls_generation;
// 492620: using guessed type __int64 dl_tls_static_used;
// 496C20: using guessed type __int64 dl_debug_mask;
// 496C60: using guessed type __int64 dl_scope_free_list;
// 496CB8: using guessed type __int64 dl_initfirst;
// 4970F0: using guessed type int dl_close_state_2;

//----- (00000000004461A0) ----------------------------------------------------
__int64 __fastcall dl_close(
        ssize_t a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        void *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7

  pthread_mutex_lock(dl_load_lock, a8, a9, a10, a11, a12, a13, a14, a15, a2, a3, a4, a5, a6, a7);
  if ( (*(_BYTE *)(a1 + 871) & 1) == 0 )
  {
    if ( !*(_DWORD *)(a1 + 864) )
    {
      pthread_mutex_unlock(dl_load_lock, v16, v17, v18, v19, v20, v21, v22, v23);
      dl_signal_error(0, *(_QWORD *)(a1 + 8), 0LL, "shared object not open");
    }
    dl_close_worker(a1, 0);
  }
  return pthread_mutex_unlock(dl_load_lock, v16, v17, v18, v19, v20, v21, v22, v23);
}
// 4461E8: variable 'v16' is possibly undefined
// 4461E8: variable 'v17' is possibly undefined
// 4461E8: variable 'v18' is possibly undefined
// 4461E8: variable 'v19' is possibly undefined
// 4461E8: variable 'v20' is possibly undefined
// 4461E8: variable 'v21' is possibly undefined
// 4461E8: variable 'v22' is possibly undefined
// 4461E8: variable 'v23' is possibly undefined
// 490F90: using guessed type int dl_load_lock[12];

//----- (0000000000446220) ----------------------------------------------------
void (__fastcall **__fastcall call_dl_init(__int64 a1))(_QWORD, __int64, __int64)
{
  return dl_init(*(_QWORD *)(a1 + 24), *(_DWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
}

//----- (0000000000446230) ----------------------------------------------------
__int64 *__fastcall add_to_global_update(__int64 a1)
{
  unsigned int v1; // w6
  __int64 v2; // x7
  __int64 **v3; // x9
  __int64 v4; // x8
  __int64 **v5; // x1
  unsigned int v6; // w2
  __int64 *v7; // x10
  __int64 v8; // x5
  __int64 v9; // x3
  __int64 v10; // x4
  __int16 v11; // w1
  __int64 **v12; // x0
  unsigned int v13; // w6
  __int64 **v14; // x0
  unsigned int v15; // w3
  int v16; // w1
  __int64 **v17; // x0
  __int64 *result; // x0
  __int64 v19; // [xsp+18h] [xbp+18h]
  unsigned int v20; // [xsp+24h] [xbp+24h]
  __int64 v21; // [xsp+28h] [xbp+28h]
  __int64 v22; // [xsp+30h] [xbp+30h]
  __int64 **v23; // [xsp+38h] [xbp+38h]
  __int64 *v24; // [xsp+40h] [xbp+40h]
  __int64 v25; // [xsp+48h] [xbp+48h]

  v1 = *(_DWORD *)(a1 + 784);
  v2 = *(_QWORD *)(a1 + 48);
  v3 = &dl_ns;
  v4 = 21 * v2;
  v5 = &(&dl_ns)[21 * v2];
  v6 = *((_DWORD *)v5[2] + 2);
  if ( v1 )
  {
    v7 = &dl_debug_mask;
    v8 = a1;
    v9 = 0LL;
    do
    {
      v10 = *(_QWORD *)(*(_QWORD *)(v8 + 776) + 8 * v9);
      v11 = *(_WORD *)(v10 + 868);
      if ( (v11 & 0x20) == 0 )
      {
        v12 = &v3[v4];
        *(_WORD *)(v10 + 868) = v11 | 0x20;
        if ( *((_DWORD *)v12 + 6) <= v6 )
          _libc_assert_fail(
            (__int64)"new_nlist < ns->_ns_global_scope_alloc",
            (__int64)"dl-open.c",
            0xBCu,
            (__int64)"add_to_global_update");
        v13 = v6 + 1;
        *(_QWORD *)(*v12[2] + 8LL * v6) = v10;
        if ( (*(_DWORD *)v7 & 0x200) != 0 )
        {
          v19 = v2;
          v20 = v6 + 1;
          v21 = v9;
          v22 = v4;
          v23 = v3;
          v24 = v7;
          v25 = v8;
          dl_debug_printf("\nadd %s [%lu] to global scope\n", *(const char **)(v10 + 8), *(_QWORD *)(v10 + 48));
          v2 = v19;
          v8 = v25;
          v9 = v21;
          v4 = v22;
          v3 = v23;
          v7 = v24;
          v13 = v20;
        }
        v6 = v13;
        v1 = *(_DWORD *)(v8 + 784);
      }
      ++v9;
    }
    while ( v1 > (unsigned int)v9 );
    v14 = &v3[21 * v2];
    v15 = *((_DWORD *)v14 + 7);
    v16 = *((_DWORD *)v14[2] + 2);
    if ( v15 < v6 - v16 )
      _libc_assert_fail(
        (__int64)"added <= ns->_ns_global_scope_pending_adds",
        (__int64)"dl-open.c",
        0xCAu,
        (__int64)"add_to_global_update");
  }
  else
  {
    v15 = *((_DWORD *)v5 + 7);
    v16 = *((_DWORD *)v5[2] + 2);
  }
  v17 = &v3[21 * v2];
  *((_DWORD *)v17 + 7) = v16 + v15 - v6;
  __dmb(0xBu);
  result = v17[2];
  *((_DWORD *)result + 2) = v6;
  return result;
}
// 4463A0: using guessed type __int64 dl_open_worker(void);
// 4914A8: using guessed type __int64 *dl_ns;
// 496C20: using guessed type __int64 dl_debug_mask;

//----- (00000000004463A0) ----------------------------------------------------
ssize_t __fastcall dl_open_worker(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        void *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  __int64 v16; // x3
  __int64 v17; // x4
  __int64 v18; // x5
  __int64 v19; // x6
  __int64 v20; // x7
  unsigned int v21; // w21
  double v22; // d0
  double v23; // d1
  double v24; // d2
  double v25; // d3
  double v26; // d4
  double v27; // d5
  double v28; // d6
  double v29; // d7
  __int64 v30; // x3
  __int64 v31; // x4
  __int64 v32; // x5
  __int64 v33; // x6
  __int64 v34; // x7
  __int64 v35; // x0
  __int64 v36; // x1
  int *v37; // x0
  ssize_t result; // x0
  int v39; // w20
  __int64 v40; // x21
  const char *v41; // [xsp+38h] [xbp+38h] BYREF
  __int64 v42; // [xsp+40h] [xbp+40h]

  *(_BYTE *)(a1 + 45) = 0;
  pthread_mutex_lock(dl_load_tls_lock, a8, a9, a10, a11, a12, a13, a14, a15, a2, a3, a4, a5, a6, a7);
  v21 = dl_catch_exception(&v41, (void (__fastcall *)(__int64))dl_open_worker_begin, a1, v16, v17, v18, v19, v20);
  pthread_mutex_unlock(dl_load_tls_lock, v22, v23, v24, v25, v26, v27, v28, v29);
  v36 = *(_QWORD *)(a1 + 24);
  v35 = *(_QWORD *)(a1 + 32);
  if ( (v35 & 0x8000000000000000LL) == 0 )
  {
    if ( !v36 )
      goto LABEL_4;
    goto LABEL_3;
  }
  if ( v36 )
  {
LABEL_3:
    v35 = *(_QWORD *)(v36 + 48);
LABEL_4:
    v37 = dl_debug_update(v35);
    v37[6] = 0;
    dl_debug_state(v37);
    if ( !v42 )
      goto LABEL_5;
LABEL_13:
    dl_signal_exception(v21, &v41, 0LL);
  }
  if ( v42 )
    goto LABEL_13;
LABEL_5:
  result = *(unsigned __int8 *)(a1 + 45);
  if ( (result & 1) != 0 )
  {
    v39 = *(_DWORD *)(a1 + 8);
    v40 = *(_QWORD *)(a1 + 24);
    dl_catch_exception(0LL, (void (__fastcall *)(__int64))call_dl_init, a1, v30, v31, v32, v33, v34);
    if ( (v39 & 0x100) != 0 )
      add_to_global_update(v40);
    result = (unsigned int)dl_debug_mask;
    if ( (dl_debug_mask & 0x40) != 0 )
      return dl_debug_printf(
               "opening file=%s [%lu]; direct_opencount=%u\n\n",
               *(const char **)(v40 + 8),
               *(_QWORD *)(v40 + 48),
               *(_DWORD *)(v40 + 864));
  }
  return result;
}
// 4463D4: variable 'v16' is possibly undefined
// 4463D4: variable 'v17' is possibly undefined
// 4463D4: variable 'v18' is possibly undefined
// 4463D4: variable 'v19' is possibly undefined
// 4463D4: variable 'v20' is possibly undefined
// 4463E4: variable 'v22' is possibly undefined
// 4463E4: variable 'v23' is possibly undefined
// 4463E4: variable 'v24' is possibly undefined
// 4463E4: variable 'v25' is possibly undefined
// 4463E4: variable 'v26' is possibly undefined
// 4463E4: variable 'v27' is possibly undefined
// 4463E4: variable 'v28' is possibly undefined
// 4463E4: variable 'v29' is possibly undefined
// 446440: variable 'v30' is possibly undefined
// 446440: variable 'v31' is possibly undefined
// 446440: variable 'v32' is possibly undefined
// 446440: variable 'v33' is possibly undefined
// 446440: variable 'v34' is possibly undefined
// 417FA0: using guessed type __int64 __fastcall dl_debug_state(_QWORD);
// 490F30: using guessed type int dl_load_tls_lock[12];
// 496C20: using guessed type __int64 dl_debug_mask;

//----- (00000000004464A4) ----------------------------------------------------
void __fastcall __noreturn add_to_global_resize_failure_isra_0(__int64 *a1)
{
  dl_signal_error(0xCu, *a1, 0LL, "cannot extend global scope");
}

//----- (00000000004464C4) ----------------------------------------------------
void __fastcall add_to_global_resize(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 **v9; // x5
  int v10; // w1
  void *v11; // x4
  __int64 *v12; // x0
  __int64 *v13; // x3
  __int64 v14; // t1
  __int64 **v15; // x3
  int v16; // w0
  bool v17; // cf
  unsigned int v18; // w0
  unsigned __int64 *v19; // x6
  __int64 v20; // x1
  __int64 v21; // x2
  unsigned __int64 v22; // x0
  void *v23; // x3
  unsigned __int64 v24; // x19
  unsigned __int64 v25; // x0
  int v26; // w3
  double v27; // d0
  double v28; // d1
  double v29; // d2
  double v30; // d3
  double v31; // d4
  double v32; // d5
  double v33; // d6
  double v34; // d7
  int v35; // w0
  int v36; // [xsp+20h] [xbp+20h]
  unsigned __int64 *v37; // [xsp+20h] [xbp+20h]
  void *v38; // [xsp+28h] [xbp+28h]
  unsigned __int64 *v39; // [xsp+30h] [xbp+30h]
  int v40; // [xsp+30h] [xbp+30h]
  unsigned __int64 v41; // [xsp+38h] [xbp+38h]
  __int64 **v42; // [xsp+48h] [xbp+48h]

  v9 = (__int64 **)a1;
  v10 = *(_DWORD *)(a1 + 784);
  v11 = *(void **)(a1 + 48);
  if ( v10 )
  {
    v12 = *(__int64 **)(a1 + 776);
    v13 = &v12[v10];
    v10 = 0;
    do
    {
      v14 = *v12++;
      if ( (*(_WORD *)(v14 + 868) & 0x20LL) == 0 )
        ++v10;
    }
    while ( v13 != v12 );
  }
  v15 = &(&dl_ns)[21 * (_QWORD)v11];
  v16 = *((_DWORD *)v15 + 7);
  v17 = __CFADD__(v16, v10);
  v18 = v16 + v10;
  *((_DWORD *)v15 + 7) = v18;
  if ( v17 )
    goto LABEL_18;
  v19 = (unsigned __int64 *)v15[2];
  v20 = *((unsigned int *)v15 + 6);
  v21 = *((unsigned int *)v19 + 2);
  v22 = v21 + v18;
  if ( (_DWORD)v20 )
  {
    if ( v22 <= (unsigned int)v20 )
      return;
    v23 = (void *)(2 * v22);
    if ( 2 * v22 == 2 * (_DWORD)v22 )
    {
      v24 = *v19;
      if ( !(_DWORD)v23 )
        return;
      goto LABEL_11;
    }
LABEL_18:
    add_to_global_resize_failure_isra_0(v9[7]);
  }
  v23 = (void *)(v22 + 8);
  if ( v22 + 8 != (_DWORD)v22 + 8 )
    goto LABEL_18;
  v24 = 0LL;
  if ( (_DWORD)v22 == -8 )
    return;
LABEL_11:
  v36 = (int)v23;
  v38 = v11;
  v39 = v19;
  v42 = v9;
  v25 = malloc(8LL * (unsigned int)v23, v20, v21, v23, v11, v9, v19, (__int64)&dl_ns, a2, a3, a4, a5, a6, a7, a8, a9);
  v9 = v42;
  v26 = v36;
  if ( !v25 )
    goto LABEL_18;
  v37 = v39;
  v40 = v26;
  v41 = v25;
  j_memcpy();
  v35 = (unsigned __int8)_libc_single_threaded;
  LODWORD((&dl_ns)[21 * (_QWORD)v38 + 3]) = v40;
  *v37 = v41;
  if ( !v35 )
    _thread_gscope_wait();
  free(v24, v27, v28, v29, v30, v31, v32, v33, v34);
}
// 446618: variable 'v27' is possibly undefined
// 446618: variable 'v28' is possibly undefined
// 446618: variable 'v29' is possibly undefined
// 446618: variable 'v30' is possibly undefined
// 446618: variable 'v31' is possibly undefined
// 446618: variable 'v32' is possibly undefined
// 446618: variable 'v33' is possibly undefined
// 446618: variable 'v34' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;
// 4914A8: using guessed type __int64 *dl_ns;

//----- (0000000000446624) ----------------------------------------------------
__int64 *__fastcall dl_find_dso_for_object(unsigned __int64 a1)
{
  __int64 *v2; // x19

  if ( !dl_nns )
    return 0LL;
  v2 = dl_ns;
  if ( !dl_ns )
    return 0LL;
  while ( v2[115] > a1
       || v2[116] <= a1
       || (*((_BYTE *)v2 + 870) & 8) == 0 && !(unsigned int)dl_addr_inside_object(v2, a1) )
  {
    v2 = (__int64 *)v2[3];
    if ( !v2 )
      return 0LL;
  }
  if ( v2[6] )
    _libc_assert_fail((__int64)"ns == l->l_ns", (__int64)"dl-open.c", 0xE0u, (__int64)"_dl_find_dso_for_object");
  return v2;
}
// 4466E4: using guessed type __int64 dl_open(void);
// 490F20: using guessed type __int64 dl_nns;
// 4914A8: using guessed type __int64 *dl_ns;

//----- (00000000004466E4) ----------------------------------------------------
ssize_t __fastcall dl_open(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        void *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  int v15; // w20
  int v19; // w25
  __int64 v22; // x3
  __int64 v23; // x4
  __int64 v24; // x5
  __int64 v25; // x6
  __int64 v26; // x7
  double v27; // d0
  double v28; // d1
  double v29; // d2
  double v30; // d3
  double v31; // d4
  double v32; // d5
  double v33; // d6
  double v34; // d7
  unsigned int v35; // w20
  double v36; // d0
  double v37; // d1
  double v38; // d2
  double v39; // d3
  double v40; // d4
  double v41; // d5
  double v42; // d6
  double v43; // d7
  __int64 v44; // x0
  double v45; // d0
  double v46; // d1
  double v47; // d2
  double v48; // d3
  double v49; // d4
  double v50; // d5
  double v51; // d6
  double v52; // d7
  const char *v54[3]; // [xsp+58h] [xbp+58h] BYREF
  __int64 v55; // [xsp+70h] [xbp+70h] BYREF
  int v56; // [xsp+78h] [xbp+78h]
  __int64 v57; // [xsp+80h] [xbp+80h]
  ssize_t v58; // [xsp+88h] [xbp+88h]
  __int64 v59; // [xsp+90h] [xbp+90h]
  int v60; // [xsp+98h] [xbp+98h]
  char v61; // [xsp+9Ch] [xbp+9Ch]
  int v62; // [xsp+A0h] [xbp+A0h]
  void *v63; // [xsp+A8h] [xbp+A8h]
  void *v64; // [xsp+B0h] [xbp+B0h]

  v15 = a2;
  if ( (a2 & 3) == 0 )
    dl_signal_error(0x16u, a1, 0LL, "invalid mode for dlopen()");
  v19 = a5;
  pthread_mutex_lock(dl_load_lock, a8, a9, a10, a11, a12, a13, a14, a15, a2, a3, a4, a5, a6, a7);
  if ( a4 == -1 )
  {
    pthread_mutex_unlock(dl_load_lock, v27, v28, v29, v30, v31, v32, v33, v34);
    dl_signal_error(0x16u, a1, 0LL, "no more namespaces available for dlmopen()");
  }
  if ( ((a4 + 2) & 0xFFFFFFFFFFFFFFFDLL) != 0 )
    dl_signal_error(0x16u, a1, 0LL, "invalid target namespace in dlmopen()");
  v55 = a1;
  v56 = v15;
  v57 = a3;
  v58 = 0LL;
  v59 = a4;
  v62 = v19;
  v63 = a6;
  v64 = a7;
  v35 = dl_catch_exception(v54, (void (__fastcall *)(__int64))dl_open_worker, (__int64)&v55, v22, v23, v24, v25, v26);
  dl_unload_cache();
  v44 = v59;
  if ( (v59 & 0x8000000000000000LL) == 0 )
    HIDWORD((&dl_ns)[21 * v59 + 3]) = v60;
  if ( v54[1] )
  {
    if ( (v61 & 1) == 0 )
      (&dl_ns)[21 * v44 + 4] = 0LL;
    if ( v58 )
      dl_close_worker(v58, 1u);
    pthread_mutex_unlock(dl_load_lock, v36, v37, v38, v39, v40, v41, v42, v43);
    dl_signal_exception(v35, v54, 0LL);
  }
  if ( dl_debug_update(v44)[6] )
    _libc_assert_fail((__int64)"r_state == RT_CONSISTENT", (__int64)"dl-open.c", 0x39Au, (__int64)"_dl_open");
  pthread_mutex_unlock(dl_load_lock, v45, v46, v47, v48, v49, v50, v51, v52);
  return v58;
}
// 446768: variable 'v22' is possibly undefined
// 446768: variable 'v23' is possibly undefined
// 446768: variable 'v24' is possibly undefined
// 446768: variable 'v25' is possibly undefined
// 446768: variable 'v26' is possibly undefined
// 4467B4: variable 'v45' is possibly undefined
// 4467B4: variable 'v46' is possibly undefined
// 4467B4: variable 'v47' is possibly undefined
// 4467B4: variable 'v48' is possibly undefined
// 4467B4: variable 'v49' is possibly undefined
// 4467B4: variable 'v50' is possibly undefined
// 4467B4: variable 'v51' is possibly undefined
// 4467B4: variable 'v52' is possibly undefined
// 4467DC: variable 'v27' is possibly undefined
// 4467DC: variable 'v28' is possibly undefined
// 4467DC: variable 'v29' is possibly undefined
// 4467DC: variable 'v30' is possibly undefined
// 4467DC: variable 'v31' is possibly undefined
// 4467DC: variable 'v32' is possibly undefined
// 4467DC: variable 'v33' is possibly undefined
// 4467DC: variable 'v34' is possibly undefined
// 446848: variable 'v36' is possibly undefined
// 446848: variable 'v37' is possibly undefined
// 446848: variable 'v38' is possibly undefined
// 446848: variable 'v39' is possibly undefined
// 446848: variable 'v40' is possibly undefined
// 446848: variable 'v41' is possibly undefined
// 446848: variable 'v42' is possibly undefined
// 446848: variable 'v43' is possibly undefined
// 490F90: using guessed type int dl_load_lock[12];
// 4914A8: using guessed type __int64 *dl_ns;

//----- (00000000004468A0) ----------------------------------------------------
ssize_t __fastcall dl_show_scope(_QWORD *a1, int a2)
{
  const char *v3; // x1
  __int64 v5; // x0
  __int64 v6; // x20
  __int64 v7; // x2
  __int64 v8; // x19
  const char *v9; // x1

  v3 = (const char *)a1[1];
  if ( !*v3 )
  {
    v3 = (const char *)program_invocation_short_name[0];
    if ( !program_invocation_short_name[0] )
      v3 = "<main program>";
  }
  dl_debug_printf("object=%s [%lu]\n", v3, a1[6]);
  v5 = a1[122];
  if ( v5 )
  {
    v6 = 8LL * a2;
    if ( *(_QWORD *)(v5 + v6) )
    {
      do
      {
        dl_debug_printf(" scope %u:", a2);
        v7 = *(_QWORD *)(a1[122] + v6);
        if ( *(_DWORD *)(v7 + 8) )
        {
          v8 = 0LL;
          do
          {
            v9 = *(const char **)(*(_QWORD *)(*(_QWORD *)v7 + 8 * v8) + 8LL);
            if ( !*v9 )
            {
              v9 = (const char *)program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v9 = "<program name unknown>";
            }
            dl_debug_printf_c(" %s", v9);
            ++v8;
            v7 = *(_QWORD *)(a1[122] + v6);
          }
          while ( *(_DWORD *)(v7 + 8) > (unsigned int)v8 );
        }
        dl_debug_printf_c((unsigned __int8 *)"\n");
        v6 += 8LL;
        ++a2;
      }
      while ( *(_QWORD *)(a1[122] + v6) );
    }
    return dl_debug_printf((unsigned __int8 *)"\n");
  }
  else
  {
    dl_debug_printf(" no scope\n");
    return dl_debug_printf((unsigned __int8 *)"\n");
  }
}
// 491928: using guessed type __int64 *program_invocation_short_name[2];

//----- (0000000000446A10) ----------------------------------------------------
ssize_t __fastcall dl_open_worker_begin(__int64 a1)
{
  unsigned __int8 *v2; // x24
  int v3; // w23
  __int64 *v4; // x19
  __int64 *dso_for_object; // x0
  __int64 v6; // x21
  __int64 **v7; // x0
  __int64 *v8; // x1
  ssize_t result; // x0
  __int64 v10; // x5
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7
  __int64 v19; // x19
  int v20; // w3
  __int64 v21; // x0
  int v22; // w3
  void *v23; // x3
  void *v24; // x5
  __int64 v25; // x6
  __int64 v26; // x7
  double v27; // d0
  double v28; // d1
  double v29; // d2
  double v30; // d3
  double v31; // d4
  double v32; // d5
  double v33; // d6
  double v34; // d7
  __int64 v35; // x4
  __int64 i; // x21
  __int64 v37; // x24
  __int64 v38; // x0
  __int64 v39; // x2
  __int64 v40; // x0
  __int64 *v41; // x4
  int v42; // w25
  unsigned int v43; // w24
  unsigned int v44; // w26
  unsigned int v45; // w1
  __int64 v46; // x0
  unsigned int v47; // w3
  __int64 v48; // x2
  __int64 v49; // x4
  __int64 *v50; // x5
  __int64 v51; // x6
  unsigned __int64 v52; // x7
  double v53; // d0
  double v54; // d1
  double v55; // d2
  double v56; // d3
  double v57; // d4
  double v58; // d5
  double v59; // d6
  double v60; // d7
  __int64 v61; // x0
  unsigned int v62; // w1
  __int64 v63; // x24
  __int64 v64; // x26
  unsigned __int64 v65; // x0
  void *v66; // x4
  void *v67; // x6
  void *v68; // x3
  void **v69; // x1
  void *v70; // x0
  void *v71; // t1
  void *v72; // x7
  unsigned __int64 v73; // x26
  __int64 *v74; // x8
  __int64 v76; // x1
  __int64 (__fastcall *v77)(__int64, __int64 *, unsigned __int64); // x4
  unsigned __int64 v78; // x0
  __int64 v79; // x24
  int v80; // w25
  unsigned __int64 v81; // x0
  bool v82; // zf
  __int64 v83; // x1
  __int64 *j; // x24
  void *v85; // x4
  __int64 k; // x23
  _QWORD *v87; // x0
  __int64 m; // x21
  unsigned __int64 v89; // x0
  unsigned int v90; // w4
  __int64 v91; // x21
  __int64 v92; // x23
  __int64 v93; // t1
  __int64 v94; // x3
  __int64 v95; // x2
  unsigned __int64 v96; // x3
  __int64 v97; // x26
  __int64 *v98; // [xsp+50h] [xbp+50h]
  __int64 *v99; // [xsp+50h] [xbp+50h]
  __int64 *v100; // [xsp+58h] [xbp+58h]
  __int64 *v101; // [xsp+58h] [xbp+58h]
  void *v102; // [xsp+60h] [xbp+60h]
  void *v103; // [xsp+68h] [xbp+68h]
  void *v104; // [xsp+68h] [xbp+68h]
  void *v105; // [xsp+78h] [xbp+78h]

  v2 = *(unsigned __int8 **)a1;
  v3 = *(_DWORD *)(a1 + 8);
  if ( strchr(*(_QWORD *)a1, 0x24u) || (v6 = *(_QWORD *)(a1 + 32), v6 == -2) || (v4 = 0LL, !strchr((__int64)v2, 0x2Fu)) )
  {
    v4 = dl_ns;
    dso_for_object = dl_find_dso_for_object(*(_QWORD *)(a1 + 16));
    v6 = *(_QWORD *)(a1 + 32);
    if ( dso_for_object )
      v4 = dso_for_object;
    if ( v6 == -2 )
    {
      v6 = v4[6];
      *(_QWORD *)(a1 + 32) = v6;
    }
  }
  v7 = &(&dl_ns)[21 * v6];
  v8 = v7[4];
  *(_DWORD *)(a1 + 40) = *((_DWORD *)v7 + 7);
  *(_BYTE *)(a1 + 44) = v8 != 0LL;
  dl_debug_initialize(0LL, v6);
  result = (ssize_t)dl_map_object((__int64)v4, v2, 2, 0, v3 | 0x10000000u, *(_QWORD *)(a1 + 32));
  *(_QWORD *)(a1 + 24) = result;
  v19 = result;
  if ( !result )
  {
    if ( (v3 & 4) == 0 )
      _libc_assert_fail((__int64)"mode & RTLD_NOLOAD", (__int64)"dl-open.c", 0x225u, (__int64)"dl_open_worker_begin");
    return result;
  }
  if ( (v3 & 0x40000000) != 0 )
    return result;
  v20 = *(_DWORD *)(result + 864);
  v21 = *(_QWORD *)(result + 776);
  v22 = v20 + 1;
  *(_DWORD *)(v19 + 864) = v22;
  if ( v21 )
  {
    result = (unsigned int)dl_debug_mask;
    if ( (dl_debug_mask & 0x40) != 0 )
      result = dl_debug_printf(
                 "opening file=%s [%lu]; direct_opencount=%u\n\n",
                 *(const char **)(v19 + 8),
                 *(_QWORD *)(v19 + 48),
                 v22);
    if ( (v3 & 0x100) == 0 )
    {
      if ( (v3 & 0x1000) == 0 )
        return result;
      if ( (dl_debug_mask & 0x40) == 0 || (*(_BYTE *)(v19 + 871) & 1) != 0 )
      {
        result = 1LL;
        *(_BYTE *)(v19 + 871) = 1;
        return result;
      }
LABEL_129:
      dl_debug_printf("marking %s [%lu] as NODELETE\n", *(const char **)(v19 + 8), *(_QWORD *)(v19 + 48));
      result = 1LL;
      *(_BYTE *)(v19 + 871) = 1;
      if ( (v3 & 0x100) == 0 )
        return result;
      goto LABEL_116;
    }
    result = *(unsigned __int16 *)(v19 + 868);
    if ( (result & 0x20) != 0 )
    {
      if ( (v3 & 0x1000) == 0 )
        return result;
    }
    else
    {
      add_to_global_resize(v19, v11, v12, v13, v14, v15, v16, v17, v18);
      if ( (v3 & 0x1000) == 0 )
        goto LABEL_116;
    }
    if ( (dl_debug_mask & 0x40) != 0 && (*(_BYTE *)(v19 + 871) & 1) == 0 )
      goto LABEL_129;
    *(_BYTE *)(v19 + 871) = 1;
LABEL_116:
    result = *(unsigned __int16 *)(v19 + 868);
    if ( (result & 0x20) == 0 )
      return (ssize_t)add_to_global_update(v19);
    return result;
  }
  if ( (v3 & 0x1000) != 0 )
    *(_BYTE *)(v19 + 872) = 1;
  dl_map_object_deps(v19, 0LL, 0, 0, v3 & 0x88000008, v10, v11, v12, v13, v14, v15, v16, v17, v18);
  v35 = *(unsigned int *)(v19 + 784);
  for ( i = 0LL; (unsigned int)v35 > (unsigned int)i; ++i )
  {
    while ( 1 )
    {
      v37 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v19 + 776) + 8 * i) + 40LL);
      if ( !*(_QWORD *)(v37 + 816) )
        break;
      if ( (unsigned int)v35 <= (unsigned int)++i )
        goto LABEL_21;
    }
    dl_check_map_versions(
      *(__int64 **)(*(_QWORD *)(*(_QWORD *)(v19 + 776) + 8 * i) + 40LL),
      0,
      0LL,
      v23,
      v35,
      v24,
      v25,
      v26,
      v27,
      v28,
      v29,
      v30,
      v31,
      v32,
      v33,
      v34);
    v38 = *(_QWORD *)(v37 + 176);
    if ( !v38 )
      goto LABEL_19;
    v39 = 0LL;
    v40 = *(_QWORD *)(v38 + 8);
    if ( (*(_BYTE *)(v37 + 870) & 0x20) != 0 )
      v39 = *(_QWORD *)v37;
    if ( !(unsigned int)strcmp(
                          (unsigned __int64 *)(v40 + *(_QWORD *)(*(_QWORD *)(v37 + 104) + 8LL) + v39),
                          (unsigned __int64)"ld-linux-aarch64.so.1") )
    {
      _rtld_static_init((__int64 *)v37);
      v35 = *(unsigned int *)(v19 + 784);
    }
    else
    {
LABEL_19:
      v35 = *(unsigned int *)(v19 + 784);
    }
  }
LABEL_21:
  dl_bti_check(v19, 0LL);
  dl_gcs_check((__int64 *)v19, 0LL);
  if ( (dl_debug_mask & 0x200) != 0 )
    dl_show_scope((_QWORD *)v19, 0);
  v41 = *(__int64 **)(v19 + 1032);
  v42 = v3 & 0x8000001;
  v43 = 0;
  v44 = -1;
  v45 = 0;
  if ( !dl_lazy )
    v42 = v3 & 0x8000000;
  v46 = *v41;
  do
  {
    v47 = v45++;
    if ( (*(_WORD *)(*(_QWORD *)(v46 + 40) + 868LL) & 8) == 0 )
    {
      v43 = v45;
      if ( v44 == -1 )
        v44 = v47;
    }
    v46 = v41[v45];
  }
  while ( v46 );
  dl_debug_update(*(_QWORD *)(a1 + 32));
  if ( v43 > v44 )
  {
    v61 = v43 - 1;
    v62 = v43 - 1;
    v48 = v61 - 1;
    v63 = 8 * v61;
    v64 = 8 * (v61 - 1 - (v62 - v44));
    do
    {
      v65 = *(_QWORD *)(*(_QWORD *)(v19 + 1032) + v63);
      if ( (*(_WORD *)(*(_QWORD *)(v65 + 40) + 868LL) & 8) == 0 )
        dl_relocate_object(
          v65,
          *(void ****)(v65 + 976),
          v42,
          0,
          v49,
          v53,
          v54,
          v55,
          v56,
          v57,
          v58,
          v59,
          v60,
          (__int64)v50,
          v51,
          v52);
      v63 -= 8LL;
    }
    while ( v64 != v63 );
  }
  v66 = (void *)*(unsigned int *)(v19 + 784);
  v67 = (void *)(v19 + 776);
  v68 = 0LL;
  if ( !(_DWORD)v66 )
    goto LABEL_118;
  do
  {
    v50 = *(__int64 **)(*(_QWORD *)(v19 + 776) + 8LL * (_QWORD)v68);
    if ( (v50[108] & 0x1300000000LL) == 0x1200000000LL )
    {
      v69 = (void **)v50[122];
      v70 = *v69;
      if ( *v69 )
      {
        v48 = (__int64)(v69 + 1);
        while ( v70 != v67 )
        {
          v71 = *(void **)v48;
          v48 += 8LL;
          v70 = v71;
          if ( !v71 )
          {
            do
            {
              v72 = v70;
              v70 = (char *)v70 + 1;
              v48 = (__int64)v69[(_QWORD)v70];
            }
            while ( v48 );
            v52 = (unsigned __int64)v72 + 2;
            goto LABEL_45;
          }
        }
      }
      else
      {
        v52 = 1LL;
LABEL_45:
        v73 = v50[121];
        if ( v73 <= v52 )
        {
          v74 = v50 + 117;
          if ( v50 + 117 == (__int64 *)v69 || v73 > 3 )
          {
            v98 = *(__int64 **)(*(_QWORD *)(v19 + 776) + 8LL * (_QWORD)v68);
            v100 = v50 + 117;
            v103 = v68;
            v105 = v67;
            if ( !malloc(16 * v73, (__int64)v69, v48, v68, v66, v50, v67, v52, v53, v54, v55, v56, v57, v58, v59, v60) )
              dl_signal_error(0xCu, (__int64)"dlopen", 0LL, "cannot create scope list");
            v50 = v98;
            v74 = v100;
            v97 = 2 * v73;
            v68 = v103;
            v67 = v105;
          }
          else
          {
            v97 = 4LL;
          }
          v99 = v50;
          v101 = v74;
          v102 = v68;
          v104 = v67;
          v77 = j_memcpy();
          v50 = v99;
          v68 = v102;
          v67 = v104;
          v78 = v99[122];
          v99[122] = (__int64)v77;
          if ( v101 != (__int64 *)v78 )
          {
            dl_scope_free(v78, v53, v54, v55, v56, v57, v58, v59, v60, v76, v48, v102, v77, v99, v104, v52);
            v50 = v99;
            v68 = v102;
            v67 = v104;
          }
          v66 = (void *)*(unsigned int *)(v19 + 784);
          v50[121] = v97;
        }
      }
    }
    v68 = (char *)v68 + 1;
  }
  while ( (unsigned int)v66 > (unsigned int)v68 );
  if ( (_DWORD)v66 )
  {
    v79 = 0LL;
    v80 = 0;
    do
    {
      v81 = *(_QWORD *)(*(_QWORD *)(v19 + 776) + 8 * v79++);
      if ( (unsigned __int8)dl_add_to_slotinfo(v81, 0) )
        v82 = 0;
      else
        v82 = v80 == 0;
      v80 = !v82;
    }
    while ( *(_DWORD *)(v19 + 784) > (unsigned int)v79 );
    if ( (v3 & 0x100) == 0 )
      goto LABEL_66;
  }
  else
  {
LABEL_118:
    v80 = 0;
    if ( (v3 & 0x100) == 0 )
      goto LABEL_66;
  }
  add_to_global_resize(v19, v53, v54, v55, v56, v57, v58, v59, v60);
LABEL_66:
  v83 = *(_QWORD *)(v19 + 48);
  for ( j = (&dl_ns)[21 * v83]; j; j = (__int64 *)j[3] )
  {
    if ( (j[109] & 1) != 0 )
    {
      if ( (dl_debug_mask & 0x40) != 0 )
        dl_debug_printf("activating NODELETE for %s [%lu]\n", (const char *)j[1], j[6]);
      *(_WORD *)((char *)j + 871) = 1;
    }
  }
  v85 = (void *)*(unsigned int *)(v19 + 784);
  for ( k = 0LL; (unsigned int)v85 > (unsigned int)k; ++k )
  {
    v83 = 0LL;
    v87 = *(_QWORD **)(*(_QWORD *)(v19 + 776) + 8 * k);
    if ( (v87[108] & 0x1300000000LL) == 0x1200000000LL )
    {
      v50 = (__int64 *)v87[122];
      v83 = *v50;
      if ( *v50 )
      {
        v48 = (__int64)(v50 + 1);
        v68 = (void *)(v19 + 776);
        while ( (void *)v83 != v68 )
        {
          v93 = *(_QWORD *)v48;
          v48 += 8LL;
          v83 = v93;
          if ( !v93 )
          {
            do
              v94 = v83++;
            while ( v50[v83] );
            v95 = 8 * v83;
            v96 = v94 + 2;
            goto LABEL_105;
          }
        }
        continue;
      }
      v96 = 1LL;
      v95 = 0LL;
LABEL_105:
      if ( v87[121] <= v96 )
        _libc_assert_fail(
          (__int64)"cnt + 1 < imap->l_scope_max",
          (__int64)"dl-open.c",
          0x153u,
          (__int64)"update_scopes");
      v50[v96] = 0LL;
      __dmb(0xBu);
      v68 = (void *)(v19 + 776);
      *(_QWORD *)(v87[122] + v95) = v19 + 776;
    }
    v48 = (unsigned int)dl_debug_mask;
    if ( (dl_debug_mask & 0x200) != 0 )
      dl_show_scope(v87, v83);
    v85 = (void *)*(unsigned int *)(v19 + 784);
  }
  if ( (dl_find_object_update(v19, v53, v54, v55, v56, v57, v58, v59, v60, v83, v48, v68, v85, v50, v67, v52) & 1) == 0 )
    dl_signal_error(0xCu, **(_QWORD **)(v19 + 56), 0LL, "cannot allocate address lookup data");
  if ( v80 )
  {
    for ( m = 0LL; *(_DWORD *)(v19 + 784) > (unsigned int)m; ++m )
    {
      v89 = *(_QWORD *)(*(_QWORD *)(v19 + 776) + 8 * m);
      dl_add_to_slotinfo(v89, 1);
    }
    if ( dl_tls_generation == -1 )
      dl_fatal_printf("TLS generation counter wrapped!  Please report this.");
    atomic_store(dl_tls_generation + 1, (unsigned __int64 *)&dl_tls_generation);
    v90 = *(_DWORD *)(v19 + 784);
    if ( v90 )
    {
      v91 = 0LL;
      do
      {
        v92 = *(_QWORD *)(*(_QWORD *)(v19 + 776) + 8 * v91);
        if ( *(__int16 *)(v92 + 868) < 0 && *(_QWORD *)(v92 + 1144) )
        {
          *(_WORD *)(v92 + 868) &= ~0x8000u;
          dl_init_static_tls();
          if ( *(__int16 *)(v92 + 868) < 0 )
            _libc_assert_fail(
              (__int64)"imap->l_need_tls_init == 0",
              (__int64)"dl-open.c",
              0x19Du,
              (__int64)"update_tls_slotinfo");
          v90 = *(_DWORD *)(v19 + 784);
        }
        ++v91;
      }
      while ( v90 > (unsigned int)v91 );
    }
  }
  if ( (*(_BYTE *)(a1 + 44) & 1) == 0 )
    dl_call_libc_early_init((__int64)(&dl_ns)[21 * *(_QWORD *)(a1 + 32) + 4], 0);
  result = 1LL;
  *(_BYTE *)(a1 + 45) = 1;
  return result;
}
// 446B08: variable 'v10' is possibly undefined
// 446B08: variable 'v11' is possibly undefined
// 446B08: variable 'v12' is possibly undefined
// 446B08: variable 'v13' is possibly undefined
// 446B08: variable 'v14' is possibly undefined
// 446B08: variable 'v15' is possibly undefined
// 446B08: variable 'v16' is possibly undefined
// 446B08: variable 'v17' is possibly undefined
// 446B08: variable 'v18' is possibly undefined
// 446B50: variable 'v23' is possibly undefined
// 446B50: variable 'v24' is possibly undefined
// 446B50: variable 'v25' is possibly undefined
// 446B50: variable 'v26' is possibly undefined
// 446B50: variable 'v27' is possibly undefined
// 446B50: variable 'v28' is possibly undefined
// 446B50: variable 'v29' is possibly undefined
// 446B50: variable 'v30' is possibly undefined
// 446B50: variable 'v31' is possibly undefined
// 446B50: variable 'v32' is possibly undefined
// 446B50: variable 'v33' is possibly undefined
// 446B50: variable 'v34' is possibly undefined
// 446C80: variable 'v49' is possibly undefined
// 446C80: variable 'v53' is possibly undefined
// 446C80: variable 'v54' is possibly undefined
// 446C80: variable 'v55' is possibly undefined
// 446C80: variable 'v56' is possibly undefined
// 446C80: variable 'v57' is possibly undefined
// 446C80: variable 'v58' is possibly undefined
// 446C80: variable 'v59' is possibly undefined
// 446C80: variable 'v60' is possibly undefined
// 446C80: variable 'v50' is possibly undefined
// 446C80: variable 'v51' is possibly undefined
// 446C80: variable 'v52' is possibly undefined
// 446D30: variable 'v48' is possibly undefined
// 446D80: variable 'v76' is possibly undefined
// 446E58: variable 'v83' is possibly undefined
// 446E58: variable 'v68' is possibly undefined
// 446E58: variable 'v67' is possibly undefined
// 447200: using guessed type __int64 dl_fixup(void);
// 4914A8: using guessed type __int64 *dl_ns;
// 492608: using guessed type __int64 dl_tls_generation;
// 496C20: using guessed type __int64 dl_debug_mask;
// 496C48: using guessed type int dl_lazy;

//----- (0000000000447200) ----------------------------------------------------
char *__fastcall dl_fixup(
        __int64 a1,
        unsigned int a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10)
{
  __int64 v10; // x20
  __int64 v11; // x2
  __int64 v12; // x3
  __int64 v13; // x4
  __int64 v14; // x1
  __int64 v15; // x19
  unsigned __int64 v16; // x6
  unsigned int *v17; // x2
  __int64 v18; // x1
  __int64 v19; // x8
  __int64 v20; // x4
  char v21; // w6
  char **v22; // x4
  char *v23; // x3
  bool v24; // zf
  unsigned __int64 StatusReg; // x21
  void *v27; // x5
  void *v28; // x6
  int v29; // w0
  signed __int64 v30; // x0
  __int64 v31; // x3
  char **v32; // [xsp+38h] [xbp+38h]
  unsigned int *v33; // [xsp+40h] [xbp+40h] BYREF
  _QWORD v34[3]; // [xsp+48h] [xbp+48h] BYREF

  v10 = *(_QWORD *)a1;
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 112) + 8LL);
  if ( (*(_BYTE *)(a1 + 870) & 0x20) != 0 )
    v12 = *(_QWORD *)a1;
  else
    v12 = 0LL;
  if ( (*(_BYTE *)(a1 + 870) & 0x20) != 0 )
    v11 += v10;
  v13 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8LL);
  v14 = *(_QWORD *)(*(_QWORD *)(a1 + 248) + 8LL) + a2;
  v15 = *(_QWORD *)(v14 + v12);
  v16 = *(_QWORD *)(v14 + v12 + 8);
  v17 = (unsigned int *)(v11 + 24LL * HIDWORD(v16));
  v33 = v17;
  if ( (_DWORD)v16 != 1026 )
    _libc_assert_fail(
      (__int64)"ELFW(R_TYPE)(reloc->r_info) == ELF_MACHINE_JMP_SLOT",
      (__int64)"dl-runtime.c",
      0x3Fu,
      (__int64)"_dl_fixup");
  if ( (*((_BYTE *)v17 + 5) & 3) != 0 )
  {
    if ( *((unsigned __int16 *)v17 + 3) == 65521 )
      v31 = 0LL;
    else
      v31 = v10;
    v23 = (char *)(v31 + *((_QWORD *)v17 + 1));
  }
  else
  {
    v18 = *(_QWORD *)(a1 + 536);
    v19 = v13 + v12;
    v20 = 0LL;
    if ( v18 )
    {
      v20 = *(_QWORD *)(a1 + 816) + 24LL * (*(_WORD *)(v12 + 2 * HIDWORD(v16) + *(_QWORD *)(v18 + 8)) & 0x7FFF);
      if ( !*(_DWORD *)(v20 + 8) )
        v20 = 0LL;
    }
    v21 = 1;
    if ( !_libc_single_threaded )
    {
      *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1820) = 1;
      __dmb(0xBu);
      v17 = v33;
      v21 = 5;
    }
    v22 = (char **)dl_lookup_symbol_x(
                     (const char *)(v19 + *v17),
                     a1,
                     (__int64 *)&v33,
                     *(void ****)(a1 + 976),
                     (const char **)v20,
                     1,
                     v21,
                     0LL,
                     a3,
                     a4,
                     a5,
                     a6,
                     a7,
                     a8,
                     a9,
                     a10);
    if ( _libc_single_threaded
      || (StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)), v32 = v22, _aarch64_swp4_rel(), v22 = v32, v29 != 2) )
    {
      v17 = v33;
      v23 = 0LL;
      if ( !v33 )
        goto LABEL_23;
    }
    else
    {
      v30 = linux_eabi_syscall(__NR_futex, (void *)(StatusReg - 1820), (void *)0x81, (void *)1, 0LL, v32, v27, v28);
      v17 = v33;
      v23 = 0LL;
      if ( !v33 )
        goto LABEL_23;
    }
    if ( v22 )
      v24 = *((unsigned __int16 *)v17 + 3) == 65521;
    else
      v24 = 1;
    if ( !v24 )
      v23 = *v22;
    v23 += *((_QWORD *)v17 + 1);
  }
  if ( (v17[1] & 0xF) == 0xA )
  {
    v34[0] = 24LL;
    v34[2] = dl_hwcap2;
    v34[1] = dl_hwcap;
    v23 = (char *)((__int64 (__fastcall *)(__int64, _QWORD *))v23)(dl_hwcap | 0x4000000000000000LL, v34);
  }
LABEL_23:
  if ( !dl_bind_not )
    *(_QWORD *)(v15 + v10) = v23;
  return v23;
}
// 447360: variable 'v29' is possibly undefined
// 447378: variable 'v27' is possibly undefined
// 447378: variable 'v28' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;
// 496BE0: using guessed type __int64 dl_hwcap;
// 496BE8: using guessed type __int64 dl_hwcap2;
// 496C4C: using guessed type int dl_bind_not;

//----- (0000000000447440) ----------------------------------------------------
_QWORD *__fastcall dfs_traversal_part_0(_QWORD *result, __int64 a2, _BYTE *a3)
{
  __int64 v3; // x4
  __int64 *v4; // x5
  __int64 v5; // x1
  __int64 v6; // x3
  _QWORD *v7; // x2
  _DWORD *v8; // x1
  int v9; // w3
  _QWORD *v10; // [xsp+10h] [xbp+10h]
  _QWORD *v11; // [xsp+10h] [xbp+10h]
  _BYTE *v12; // [xsp+18h] [xbp+18h]
  _BYTE *v13; // [xsp+18h] [xbp+18h]
  __int64 v14; // [xsp+20h] [xbp+20h]
  int v15; // [xsp+20h] [xbp+20h]
  __int64 v16; // [xsp+28h] [xbp+28h]
  __int64 v17; // [xsp+28h] [xbp+28h]

  v3 = a2;
  v4 = *(__int64 **)(a2 + 1032);
  *(_WORD *)(a2 + 868) |= 0x200u;
  if ( v4 )
  {
    v5 = *v4;
    if ( *v4 )
    {
      v6 = 8LL;
      do
      {
        if ( (*(_WORD *)(v5 + 868) & 0x4300) == 0 )
        {
          v10 = result;
          v12 = a3;
          v14 = v6;
          v16 = v3;
          dfs_traversal_part_0();
          v6 = v14;
          v3 = v16;
          result = v10;
          a3 = v12;
          v4 = *(__int64 **)(v16 + 1032);
        }
        v5 = *(__int64 *)((char *)v4 + v6);
        v6 += 8LL;
      }
      while ( v5 );
    }
  }
  if ( a3 )
  {
    v8 = *(_DWORD **)(v3 + 1040);
    if ( v8 )
    {
      *a3 = 1;
      v9 = *v8 - 1;
      if ( v9 >= 0 )
      {
        if ( (*(_WORD *)(*(_QWORD *)&v8[2 * v9 + 2] + 868LL) & 0x4300) == 0 )
          goto LABEL_14;
        while ( --v9 != -1 )
        {
          if ( (*(_WORD *)(*(_QWORD *)(*(_QWORD *)(v3 + 1040) + 8LL * v9 + 8) + 868LL) & 0x4300) == 0 )
          {
LABEL_14:
            v11 = result;
            v13 = a3;
            v15 = v9;
            v17 = v3;
            dfs_traversal_part_0();
            v3 = v17;
            result = v11;
            a3 = v13;
            v9 = v15;
          }
        }
      }
    }
  }
  v7 = (_QWORD *)(*result - 8LL);
  *result = v7;
  *v7 = v3;
  return result;
}

//----- (0000000000447540) ----------------------------------------------------
int *dl_sort_maps_init()
{
  int *result; // x0
  int v1; // [xsp+1Ch] [xbp+1Ch] BYREF

  _tunable_get_val(29LL, (char **)&v1, 0LL);
  result = &dl_dso_sort_algo;
  dl_dso_sort_algo = v1 != 1;
  return result;
}
// 496CB0: using guessed type int dl_dso_sort_algo;

//----- (0000000000447580) ----------------------------------------------------
unsigned __int64 __fastcall dl_sort_maps(unsigned __int64 *a1, unsigned int a2, unsigned __int8 a3, char a4)
{
  unsigned int v7; // w27
  unsigned int v8; // w22
  unsigned __int64 *v9; // x24
  int v10; // w26
  __int64 v11; // x25
  unsigned int v12; // w21
  unsigned __int64 v13; // x6
  __int16 v14; // w23
  unsigned int v15; // w20
  __int64 *v16; // x19
  __int64 v17; // x2
  __int64 *v18; // x1
  __int64 v19; // x5
  __int64 v20; // x5
  int *v21; // x1
  _DWORD *v22; // x1
  int v23; // w5
  int v24; // t1
  __int64 *v25; // x1
  __int64 v26; // x5
  unsigned __int64 result; // x0
  _QWORD *v28; // x20
  __int64 v29; // x12
  unsigned __int64 v30; // x10
  __int64 v31; // x0
  unsigned __int64 v32; // x2
  char *v33; // x14
  char *v34; // x8
  __int64 v35; // x11
  __int16 v36; // w13
  __int64 v37; // x1
  char *v38; // x9
  __int64 v39; // x2
  __int16 v40; // w8
  __int64 v41; // x1
  __int64 v42; // x0
  unsigned int v43; // w2
  __int64 v44; // [xsp+0h] [xbp+0h] BYREF
  __int64 *v45; // [xsp+68h] [xbp+68h]
  __int64 *v46; // [xsp+70h] [xbp+70h]
  unsigned int v47; // [xsp+7Ch] [xbp+7Ch]
  _WORD *v48; // [xsp+80h] [xbp+80h]
  unsigned __int64 v49; // [xsp+88h] [xbp+88h]
  __int64 v50; // [xsp+90h] [xbp+90h]
  __int64 v51; // [xsp+98h] [xbp+98h]
  char v52; // [xsp+AFh] [xbp+AFh] BYREF
  char *v53; // [xsp+B0h] [xbp+B0h] BYREF
  unsigned __int64 *v54; // [xsp+B8h] [xbp+B8h] BYREF

  v7 = dl_dso_sort_algo;
  if ( dl_dso_sort_algo )
  {
    v28 = (_QWORD *)*a1;
    v29 = 8LL * a2;
    LODWORD(v30) = a2 - 1;
    if ( (int)(a2 - 1) < 0 )
    {
      v52 = 0;
      v53 = (char *)&v44 + v29;
      if ( (__int64 *)((char *)&v44 + v29) != &v44 )
LABEL_56:
        _libc_assert_fail((__int64)"rpo_head == rpo", (__int64)"dl-sort-maps.c", 0xE5u, (__int64)"_dl_sort_maps_dfs");
    }
    else
    {
      v30 = (unsigned int)v30;
      v31 = (unsigned int)v30;
      do
      {
        v32 = a1[v31--];
        *(_WORD *)(v32 + 868) &= ~0x200u;
      }
      while ( (v31 & 0x80000000) == 0 );
      v33 = &v52;
      if ( (a4 & 1) == 0 )
        v33 = 0LL;
      v34 = (char *)&v44;
      v35 = (unsigned int)v30;
      v36 = 16896;
      v52 = 0;
      v53 = (char *)&v44 + v29;
      while ( 1 )
      {
        v37 = a1[v35];
        if ( ((unsigned __int16)v36 & *(_WORD *)(v37 + 868)) == 0 )
          dfs_traversal_part_0(&v53, v37, v33);
        v38 = v53;
        if ( v34 == v53 )
          break;
        if ( (--v35 & 0x80000000) != 0 )
          goto LABEL_56;
      }
      if ( (v52 & 1) != 0 )
      {
        result = v30;
        do
        {
          v39 = *(_QWORD *)&v38[8 * result--];
          *(_WORD *)(v39 + 868) &= ~0x200u;
        }
        while ( (result & 0x80000000) == 0 );
        v40 = 16896;
        v54 = &a1[(unsigned __int64)v29 / 8];
        while ( 1 )
        {
          v41 = *(_QWORD *)&v38[8 * v30];
          if ( ((unsigned __int16)v40 & *(_WORD *)(v41 + 868)) == 0 )
            result = (unsigned __int64)dfs_traversal_part_0(&v54, v41, 0LL);
          if ( a1 == v54 )
            break;
          if ( (--v30 & 0x80000000) != 0 )
            _libc_assert_fail(
              (__int64)"maps_head == maps",
              (__int64)"dl-sort-maps.c",
              0x104u,
              (__int64)"_dl_sort_maps_dfs");
        }
        if ( (a3 & 1) == 0 )
          return result;
LABEL_49:
        result = *a1;
        if ( v28 != (_QWORD *)*a1 )
        {
          v42 = 1LL;
          do
            v43 = v42++;
          while ( v28 != (_QWORD *)a1[v42 - 1] );
          if ( a2 <= v43 )
            _libc_assert_fail((__int64)"i < nmaps", (__int64)"dl-sort-maps.c", 0x119u, (__int64)"_dl_sort_maps_dfs");
          result = (unsigned __int64)j_memmove();
          *a1 = (unsigned __int64)v28;
        }
        return result;
      }
    }
    result = (unsigned __int64)j_memcpy();
    if ( (a3 & 1) == 0 )
      return result;
    goto LABEL_49;
  }
  v8 = a2 - a3;
  v45 = &v44;
  if ( v8 > 1 )
  {
    v9 = &a1[a3];
    v10 = a4 & 1;
    v11 = 0LL;
    memset();
    v12 = 1;
    v47 = v8 - 1;
    v46 = (__int64 *)&v9[v8 - 1];
LABEL_4:
    while ( 1 )
    {
      v48 = (_WORD *)&v44 + v11;
      v13 = v9[v11];
      v14 = *v48 + 1;
      *v48 = v14;
      if ( !v10 )
        break;
      if ( v13 != *(_QWORD *)(v13 + 40) )
        goto LABEL_10;
      if ( *(_DWORD *)(v13 + 1068) != -1 )
        break;
      if ( v8 == v12 )
        return (unsigned __int64)v45;
LABEL_15:
      v7 = v12;
      v11 = v12++;
      memset();
    }
    v15 = v47;
    if ( v7 < v47 )
    {
      v16 = v46;
      do
      {
        v17 = *v16;
        v18 = *(__int64 **)(*v16 + 1032);
        if ( v18 )
        {
          while ( 1 )
          {
            v19 = *v18;
            if ( !*v18 )
              break;
            ++v18;
            if ( v13 == v19 )
            {
LABEL_14:
              v49 = v13;
              v50 = v12;
              v51 = v15 - v7;
              j_memmove();
              v20 = v50;
              *v16 = v49;
              if ( *((unsigned __int16 *)&v44 + v20) > v8 - v7 )
                goto LABEL_15;
              j_memmove();
              *((_WORD *)&v44 + v15) = v14;
              goto LABEL_4;
            }
          }
        }
        if ( v10 )
        {
          v21 = *(int **)(v17 + 1040);
          if ( v21 )
          {
            v24 = *v21;
            v22 = v21 + 2;
            v23 = v24;
            while ( v23 )
            {
              if ( v13 == *(_QWORD *)&v22[2 * --v23] )
              {
                v25 = *(__int64 **)(v13 + 1032);
                if ( v25 )
                {
                  while ( 1 )
                  {
                    v26 = *v25;
                    if ( !*v25 )
                      break;
                    ++v25;
                    if ( v17 == v26 )
                      goto LABEL_9;
                  }
                }
                goto LABEL_14;
              }
            }
          }
        }
LABEL_9:
        --v15;
        --v16;
      }
      while ( v7 != v15 );
    }
LABEL_10:
    if ( v8 == v12 )
      return (unsigned __int64)v45;
    goto LABEL_15;
  }
  return (unsigned __int64)v45;
}
// 4477F0: variable 'v35' is possibly undefined
// 447800: variable 'v36' is possibly undefined
// 447810: variable 'v33' is possibly undefined
// 44781C: variable 'v34' is possibly undefined
// 447828: variable 'v30' is possibly undefined
// 44784C: variable 'v29' is possibly undefined
// 44785C: variable 'v38' is possibly undefined
// 447864: variable 'v40' is possibly undefined
// 447980: using guessed type __int64 dl_check_map_versions(void);
// 496CB0: using guessed type int dl_dso_sort_algo;

//----- (0000000000447980) ----------------------------------------------------
__int64 __fastcall dl_check_map_versions(
        __int64 *a1,
        int a2,
        __int64 a3,
        void *a4,
        __int64 a5,
        void *a6,
        __int64 a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  __int64 v17; // x0
  __int64 v18; // x19
  __int64 v19; // x0
  __int64 v20; // x4
  __int64 v21; // x0
  __int64 v22; // x21
  unsigned int v23; // w20
  unsigned __int64 *v24; // x22
  __int64 *v25; // x27
  int *i; // x23
  const char *v27; // x22
  __int64 v28; // x10
  unsigned __int64 *v29; // x25
  __int64 v30; // x26
  int v31; // w11
  __int64 v32; // x12
  __int64 v33; // x0
  __int64 v34; // x0
  unsigned __int16 *v35; // x24
  unsigned int v36; // w1
  const char *v37; // x19
  __int64 v38; // x0
  double v39; // d0
  double v40; // d1
  double v41; // d2
  double v42; // d3
  double v43; // d4
  double v44; // d5
  double v45; // d6
  double v46; // d7
  int v47; // w0
  unsigned int v48; // w0
  unsigned int v49; // w0
  __int64 j; // x1
  unsigned int v51; // w0
  __int64 v53; // x25
  const char *v54; // x1
  const char *v55; // x2
  const char *v56; // x1
  int8x16_t *(__fastcall *v57)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  unsigned int v58; // w21
  char v59; // w2
  __int64 v60; // x1
  __int64 v61; // x9
  unsigned int *k; // x6
  char *m; // x1
  __int16 v64; // w3
  char *v65; // x4
  unsigned int v66; // w2
  unsigned int v67; // w1
  const char *v68; // x19
  __int64 v69; // x0
  double v70; // d0
  double v71; // d1
  double v72; // d2
  double v73; // d3
  double v74; // d4
  double v75; // d5
  double v76; // d6
  double v77; // d7
  unsigned int v78; // w0
  __int64 n; // x1
  char *v80; // x4
  __int64 v81; // x3
  unsigned int v82; // w2
  __int64 v83; // x21
  __int64 *v84; // x19
  __int64 v85; // x0
  __int64 v86; // t1
  const char *v87; // x1
  const char *v88; // x1
  const char *v89; // x1
  __int64 v90; // [xsp+60h] [xbp+60h]
  int v91; // [xsp+60h] [xbp+60h]
  int v92; // [xsp+68h] [xbp+68h]
  __int64 v93; // [xsp+68h] [xbp+68h]
  __int16 v94; // [xsp+78h] [xbp+78h]
  __int64 v95; // [xsp+90h] [xbp+90h]
  int v96; // [xsp+A0h] [xbp+A0h]
  int v97; // [xsp+A4h] [xbp+A4h]
  __int64 v98; // [xsp+A8h] [xbp+A8h]
  _BYTE v99[5]; // [xsp+C3h] [xbp+C3h] BYREF
  __int64 (__fastcall *v100[3])(__int64, __int64 *, unsigned __int64); // [xsp+C8h] [xbp+C8h] BYREF

  v17 = a1[13];
  if ( !v17 )
    return 0LL;
  v18 = *(_QWORD *)(v17 + 8);
  if ( (*((_BYTE *)a1 + 870) & 0x20) == 0 )
  {
    v19 = a1[53];
    v96 = a3;
    v97 = a2;
    v98 = v19;
    v95 = a1[55];
    if ( v19 )
      goto LABEL_4;
LABEL_42:
    v23 = 0;
    if ( !v95 )
      return 0LL;
    goto LABEL_43;
  }
  v18 += *a1;
  v19 = a1[53];
  v96 = a3;
  v97 = a2;
  v98 = v19;
  v95 = a1[55];
  if ( !v19 )
    goto LABEL_42;
LABEL_4:
  v20 = *a1;
  v21 = *(_QWORD *)(v19 + 8);
  v22 = *a1 + v21;
  if ( *(_WORD *)v22 != 1 )
  {
    v68 = (const char *)a1[1];
    v99[0] = 0;
    if ( !*v68 )
    {
      v68 = (const char *)program_invocation_short_name[0];
      if ( !program_invocation_short_name[0] )
        v68 = "<main program>";
    }
    v69 = itoa_word(*(unsigned __int16 *)(v20 + v21), (__int64)v99, 0xAu, 0);
    dl_exception_create_format(
      v100,
      (__int64)v68,
      (__int64)"unsupported version %s of Verneed record",
      v70,
      v71,
      v72,
      v73,
      v74,
      v75,
      v76,
      v77,
      v69);
LABEL_92:
    v78 = 0;
    goto LABEL_93;
  }
  v23 = 0;
  while ( 1 )
  {
    v24 = (unsigned __int64 *)(v18 + *(unsigned int *)(v22 + 4));
    v25 = (&dl_ns)[21 * a1[6]];
    if ( v25 )
    {
      while ( !(unsigned int)dl_name_match_p(v24, (__int64)v25) )
      {
        v25 = (__int64 *)v25[3];
        if ( !v25 )
          goto LABEL_54;
      }
    }
    else
    {
LABEL_54:
      if ( !*((_DWORD *)a1 + 196) )
        goto LABEL_59;
      v53 = 0LL;
      while ( !(unsigned int)dl_name_match_p(v24, *(_QWORD *)(a1[97] + 8 * v53)) )
      {
        if ( *((_DWORD *)a1 + 196) <= (unsigned int)++v53 )
          goto LABEL_59;
      }
      v25 = *(__int64 **)(a1[97] + 8 * v53);
      if ( !v25 )
LABEL_59:
        _libc_assert_fail((__int64)"needed != NULL", (__int64)"dl-version.c", 0xCCu, (__int64)"_dl_check_map_versions");
    }
    if ( !v96 || (v25[108] & 0x400000000000LL) == 0 )
    {
      for ( i = (int *)(v22 + *(unsigned int *)(v22 + 8)); ; i = (int *)((char *)i + v48) )
      {
        v27 = (const char *)a1[1];
        v28 = (unsigned int)i[2];
        v29 = (unsigned __int64 *)(v18 + v28);
        if ( !*v27 )
        {
          v27 = (const char *)program_invocation_short_name[0];
          if ( !program_invocation_short_name[0] )
            v27 = "<main program>";
        }
        v30 = v25[5];
        v94 = *((_WORD *)i + 2);
        v31 = *i;
        v32 = *(_QWORD *)(*(_QWORD *)(v30 + 104) + 8LL);
        if ( (*(_BYTE *)(v30 + 870) & 0x20) != 0 )
          v32 += *(_QWORD *)v30;
        if ( (dl_debug_mask & 0x10) != 0 )
        {
          v55 = *(const char **)(v30 + 8);
          if ( !*v55 )
          {
            v55 = (const char *)program_invocation_short_name[0];
            if ( !program_invocation_short_name[0] )
              v55 = "<main program>";
          }
          v91 = *i;
          v93 = v32;
          dl_debug_printf(
            "checking for version `%s' in file %s [%lu] required by file %s [%lu]\n",
            (const char *)(v18 + v28),
            v55,
            *(_QWORD *)(v30 + 48),
            v27,
            a1[6]);
          v32 = v93;
          v31 = v91;
        }
        v33 = *(_QWORD *)(v30 + 440);
        if ( v33 )
        {
          v34 = *(_QWORD *)(v33 + 8);
          if ( !v34 )
            _libc_assert_fail((__int64)"def_offset != 0", (__int64)"dl-version.c", 0x57u, (__int64)"match_symbol");
          v35 = (unsigned __int16 *)(v34 + *(_QWORD *)v30);
          if ( *v35 != 1 )
          {
LABEL_24:
            v99[0] = 0;
            v37 = *(const char **)(v30 + 8);
            if ( !*v37 )
            {
              v37 = (const char *)program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v37 = "<main program>";
            }
            v38 = itoa_word(*v35, (__int64)v99, 0xAu, 0);
            dl_exception_create_format(
              v100,
              (__int64)v37,
              (__int64)"unsupported version %s of Verdef record",
              v39,
              v40,
              v41,
              v42,
              v43,
              v44,
              v45,
              v46,
              v38);
            goto LABEL_28;
          }
          while ( 1 )
          {
            if ( v31 == *((_DWORD *)v35 + 2) )
            {
              v90 = v32;
              v92 = v31;
              v47 = strcmp(v29, v32 + *(unsigned int *)((char *)v35 + *((unsigned int *)v35 + 3)));
              v32 = v90;
              v31 = v92;
              if ( !v47 )
                goto LABEL_30;
            }
            v36 = *((_DWORD *)v35 + 4);
            if ( !v36 )
              break;
            v35 = (unsigned __int16 *)((char *)v35 + v36);
            if ( *v35 != 1 )
              goto LABEL_24;
          }
          if ( (v94 & 2) == 0 )
          {
            v88 = *(const char **)(v30 + 8);
            if ( !*v88 )
            {
              v88 = (const char *)program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v88 = "<main program>";
            }
            dl_exception_create_format(
              v100,
              (__int64)v88,
              (__int64)"version `%s' not found (required by %s)",
              a9,
              a10,
              a11,
              a12,
              a13,
              a14,
              a15,
              a16,
              v29,
              v27);
            goto LABEL_28;
          }
          if ( v97 )
          {
            v56 = *(const char **)(v30 + 8);
            if ( !*v56 )
            {
              v56 = (const char *)program_invocation_short_name[0];
              if ( !program_invocation_short_name[0] )
                v56 = "<main program>";
            }
            dl_exception_create_format(
              v100,
              (__int64)v56,
              (__int64)"weak version `%s' not found (required by %s)",
              a9,
              a10,
              a11,
              a12,
              a13,
              a14,
              a15,
              a16,
              v29,
              v27);
            goto LABEL_28;
          }
        }
        else if ( v97 )
        {
          v54 = *(const char **)(v30 + 8);
          if ( !*v54 )
          {
            v54 = (const char *)program_invocation_short_name[0];
            if ( !program_invocation_short_name[0] )
              v54 = "<main program>";
          }
          dl_exception_create_format(
            v100,
            (__int64)v54,
            (__int64)"no version information available (required by %s)",
            a9,
            a10,
            a11,
            a12,
            a13,
            a14,
            a15,
            a16,
            v27);
LABEL_28:
          dl_signal_exception(0, (const char **)v100, "version lookup error");
        }
LABEL_30:
        if ( *i == 16584258 && !(unsigned int)strcmp(v29, (unsigned __int64)"GLIBC_ABI_DT_RELR") )
        {
          *((_WORD *)a1 + 434) |= 4u;
          if ( v23 < (*((_WORD *)i + 3) & 0x7FFFu) )
            v23 = *((_WORD *)i + 3) & 0x7FFF;
          v48 = i[3];
          if ( !v48 )
            break;
        }
        else
        {
          if ( v23 < (*((_WORD *)i + 3) & 0x7FFFu) )
            v23 = *((_WORD *)i + 3) & 0x7FFF;
          v48 = i[3];
          if ( !v48 )
            break;
        }
      }
    }
    v49 = *(_DWORD *)(v22 + 12);
    if ( !v49 )
      break;
    v22 += v49;
  }
  if ( !v95 )
  {
    if ( !v23 )
      goto LABEL_50;
    goto LABEL_76;
  }
LABEL_43:
  for ( j = *a1 + *(_QWORD *)(v95 + 8); ; j += v51 )
  {
    if ( v23 < (*(_WORD *)(j + 4) & 0x7FFFu) )
      v23 = *(_WORD *)(j + 4) & 0x7FFF;
    v51 = *(_DWORD *)(j + 16);
    if ( !v51 )
      break;
  }
  if ( !v23 )
  {
LABEL_49:
    if ( !v98 )
      return 0LL;
    goto LABEL_50;
  }
LABEL_76:
  v57 = calloc(v23 + 1, 0x18uLL, a3, a4, a9, a10, a11, a12, a13, a14, a15, a16, a5, a6, a7, a8);
  a1[102] = (__int64)v57;
  v58 = v23 + 1;
  if ( !v57 )
  {
    v89 = (const char *)a1[1];
    if ( !*v89 )
    {
      v89 = (const char *)program_invocation_short_name[0];
      if ( !program_invocation_short_name[0] )
        v89 = "<main program>";
    }
    dl_exception_create(v100, (__int64)v89);
    v78 = 12;
LABEL_93:
    dl_signal_exception(v78, (const char **)v100, 0LL);
  }
  v59 = *((_BYTE *)a1 + 870);
  v60 = *(_QWORD *)(a1[67] + 8);
  *((_DWORD *)a1 + 206) = v58;
  if ( (v59 & 0x20) != 0 )
    v60 += *a1;
  a1[113] = v60;
  if ( !v98 )
  {
    if ( !v95 )
      return 0LL;
    v61 = *a1;
    goto LABEL_95;
  }
  v61 = *a1;
  for ( k = (unsigned int *)(*a1 + *(_QWORD *)(v98 + 8)); ; k = (unsigned int *)((char *)k + v67) )
  {
    for ( m = (char *)k + k[2]; ; m += v66 )
    {
      v64 = *((_WORD *)m + 3);
      if ( v58 > (v64 & 0x7FFFu) )
      {
        v65 = (char *)v57 + 24 * (*((_WORD *)m + 3) & 0x7FFF);
        *((_DWORD *)v65 + 2) = *(_DWORD *)m;
        *((_DWORD *)v65 + 3) = v64 & 0x8000;
        *(_QWORD *)v65 = v18 + *((unsigned int *)m + 2);
        *((_QWORD *)v65 + 2) = v18 + k[1];
      }
      v66 = *((_DWORD *)m + 3);
      if ( !v66 )
        break;
    }
    v67 = k[3];
    if ( !v67 )
      break;
  }
  if ( v95 )
  {
LABEL_95:
    for ( n = v61 + *(_QWORD *)(v95 + 8); ; n += v82 )
    {
      if ( (*(_WORD *)(n + 2) & 1) == 0 )
      {
        v80 = (char *)v57 + 24 * (*(_WORD *)(n + 4) & 0x7FFF);
        v81 = v18 + *(unsigned int *)(n + *(unsigned int *)(n + 12));
        *((_DWORD *)v80 + 2) = *(_DWORD *)(n + 8);
        *(_QWORD *)v80 = v81;
        *((_QWORD *)v80 + 2) = 0LL;
      }
      v82 = *(_DWORD *)(n + 16);
      if ( !v82 )
        break;
    }
    goto LABEL_49;
  }
LABEL_50:
  if ( a1[9] && a1[44] && (*((_WORD *)a1 + 434) & 4) == 0 )
  {
    v83 = *(_QWORD *)(a1[13] + 8);
    if ( (*((_BYTE *)a1 + 870) & 0x20) != 0 )
      v83 += *a1;
    v84 = (__int64 *)a1[2];
    v85 = *v84;
    if ( *v84 )
    {
      while ( v85 != 1 || (unsigned int)strncmp(v83 + v84[1], (unsigned __int64)"libc.so.", 8uLL) )
      {
        v86 = v84[2];
        v84 += 2;
        v85 = v86;
        if ( !v86 )
          return 0LL;
      }
      v87 = (const char *)a1[1];
      if ( !*v87 )
      {
        v87 = (const char *)program_invocation_short_name[0];
        if ( !program_invocation_short_name[0] )
          v87 = "<main program>";
      }
      dl_exception_create(v100, (__int64)v87);
      goto LABEL_92;
    }
  }
  return 0LL;
}
// 447B68: variable 'v39' is possibly undefined
// 447B68: variable 'v40' is possibly undefined
// 447B68: variable 'v41' is possibly undefined
// 447B68: variable 'v42' is possibly undefined
// 447B68: variable 'v43' is possibly undefined
// 447B68: variable 'v44' is possibly undefined
// 447B68: variable 'v45' is possibly undefined
// 447B68: variable 'v46' is possibly undefined
// 447D5C: variable 'a9' is possibly undefined
// 447D5C: variable 'a10' is possibly undefined
// 447D5C: variable 'a11' is possibly undefined
// 447D5C: variable 'a12' is possibly undefined
// 447D5C: variable 'a13' is possibly undefined
// 447D5C: variable 'a14' is possibly undefined
// 447D5C: variable 'a15' is possibly undefined
// 447D5C: variable 'a16' is possibly undefined
// 447E20: variable 'a3' is possibly undefined
// 447E20: variable 'a4' is possibly undefined
// 447E20: variable 'a5' is possibly undefined
// 447E20: variable 'a6' is possibly undefined
// 447E20: variable 'a7' is possibly undefined
// 447E20: variable 'a8' is possibly undefined
// 447F0C: variable 'v70' is possibly undefined
// 447F0C: variable 'v71' is possibly undefined
// 447F0C: variable 'v72' is possibly undefined
// 447F0C: variable 'v73' is possibly undefined
// 447F0C: variable 'v74' is possibly undefined
// 447F0C: variable 'v75' is possibly undefined
// 447F0C: variable 'v76' is possibly undefined
// 447F0C: variable 'v77' is possibly undefined
// 4914A8: using guessed type __int64 *dl_ns;
// 491928: using guessed type __int64 *program_invocation_short_name[2];
// 496C20: using guessed type __int64 dl_debug_mask;

//----- (0000000000448188) ----------------------------------------------------
__int64 __fastcall dl_check_all_versions(
        __int64 a1,
        int a2,
        unsigned int a3,
        void *a4,
        __int64 a5,
        void *a6,
        __int64 a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  __int64 v16; // x19

  if ( !a1 )
    return 0LL;
  v16 = a1;
  do
  {
    while ( (*(_WORD *)(v16 + 868) & 0x4000) != 0 )
    {
      v16 = *(_QWORD *)(v16 + 24);
      if ( !v16 )
        return 0LL;
    }
    dl_check_map_versions((__int64 *)v16, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16);
    v16 = *(_QWORD *)(v16 + 24);
  }
  while ( v16 );
  return 0LL;
}
// 4481C8: variable 'a4' is possibly undefined
// 4481C8: variable 'a5' is possibly undefined
// 4481C8: variable 'a6' is possibly undefined
// 4481C8: variable 'a7' is possibly undefined
// 4481C8: variable 'a8' is possibly undefined
// 4481C8: variable 'a9' is possibly undefined
// 4481C8: variable 'a10' is possibly undefined
// 4481C8: variable 'a11' is possibly undefined
// 4481C8: variable 'a12' is possibly undefined
// 4481C8: variable 'a13' is possibly undefined
// 4481C8: variable 'a14' is possibly undefined
// 4481C8: variable 'a15' is possibly undefined
// 4481C8: variable 'a16' is possibly undefined

//----- (0000000000448200) ----------------------------------------------------
unsigned __int64 __fastcall dl_unmap(__int64 a1)
{
  return munmap(*(void **)(a1 + 920), *(_QWORD *)(a1 + 928) - *(_QWORD *)(a1 + 920));
}

//----- (0000000000448220) ----------------------------------------------------
__int64 __fastcall dl_addr_inside_object(__int64 *a1, __int64 a2)
{
  int v2; // w3
  __int64 v3; // x2
  __int64 v4; // x5
  __int64 v5; // x0
  __int64 v6; // x1
  unsigned int *v7; // x2
  __int64 v8; // x3
  __int64 result; // x0

  v2 = *((unsigned __int16 *)a1 + 384);
  if ( !*((_WORD *)a1 + 384) )
    return 0LL;
  v3 = *a1;
  v4 = 56LL * *((unsigned __int16 *)a1 + 384);
  v5 = a1[94];
  v6 = a2 - v3;
  v7 = (unsigned int *)(v5 - 56 + v4);
  v8 = v4 - 56LL * (unsigned int)(v2 - 1) + v5 - 112;
  while ( 1 )
  {
    result = *v7;
    if ( (_DWORD)result == 1 && (unsigned __int64)(v6 - *((_QWORD *)v7 + 2)) < *((_QWORD *)v7 + 5) )
      break;
    v7 -= 14;
    if ( v7 == (unsigned int *)v8 )
      return 0LL;
  }
  return result;
}

//----- (00000000004482A0) ----------------------------------------------------
__int64 __fastcall dl_find_object_from_map(__int64 result, _QWORD *a2)
{
  unsigned __int64 v2; // x2
  unsigned __int64 v3; // x4

  *a2 = *(_QWORD *)(result + 920);
  a2[1] = *(_QWORD *)(result + 928);
  a2[2] = result;
  v2 = *(_QWORD *)(result + 752);
  v3 = v2 + 56LL * *(unsigned __int16 *)(result + 768);
  if ( v2 >= v3 )
  {
LABEL_6:
    a2[3] = 0LL;
  }
  else
  {
    while ( *(_DWORD *)v2 != 1685382480 )
    {
      v2 += 56LL;
      if ( v3 <= v2 )
        goto LABEL_6;
    }
    result = *(_QWORD *)(v2 + 16) + *(_QWORD *)result;
    a2[3] = result;
  }
  return result;
}

//----- (0000000000448320) ----------------------------------------------------
__int64 dlfo_process_initial()
{
  __int64 *v0; // x7
  __int64 v1; // x8
  __int64 v2; // x10
  _QWORD *v3; // x9
  __int64 result; // x0
  __int64 *v5; // x6
  int v6; // w0
  __int64 v7; // x1
  __int64 **v8; // x6
  _DWORD *v9; // x0
  _DWORD *v10; // x2
  __int64 v11; // x11
  __int128 v12; // q31
  char *v13; // x1
  __int64 v14; // x3
  _OWORD v15[2]; // [xsp+10h] [xbp+10h] BYREF

  v0 = dl_ns;
  if ( (*((_BYTE *)dl_ns + 870) & 8) != 0 )
  {
    v1 = dl_nns;
    if ( !dl_nns )
    {
      v2 = 0LL;
      v3 = &unk_48F000;
      goto LABEL_4;
    }
    v5 = dl_ns;
    v1 = 0LL;
    v3 = &unk_48F000;
    goto LABEL_6;
  }
  dl_find_object_from_map((__int64)dl_ns, v15);
  v9 = (_DWORD *)v0[94];
  v10 = &v9[14 * *((unsigned __int16 *)v0 + 384)];
  if ( v9 >= v10 )
  {
    v1 = 0LL;
    v3 = (_QWORD *)&unk_48F000;
    goto LABEL_27;
  }
  v3 = &unk_48F000;
  v1 = 0LL;
LABEL_21:
  while ( *v9 != 1 )
  {
LABEL_20:
    v9 += 14;
    if ( v10 <= v9 )
      goto LABEL_27;
  }
  if ( !dlfo_nodelete_mappings )
  {
    ++v1;
    goto LABEL_20;
  }
  v11 = *v0;
  while ( 1 )
  {
    v12 = v15[1];
    v13 = (char *)dlfo_nodelete_mappings + 32 * v1;
    v9 += 14;
    ++v1;
    *(_OWORD *)v13 = v15[0];
    *((_OWORD *)v13 + 1) = v12;
    v14 = *((_QWORD *)v9 - 5) + v11;
    *(_QWORD *)v13 = v14;
    *((_QWORD *)v13 + 1) = *((_QWORD *)v9 - 2) + v14;
    if ( v10 <= v9 )
      break;
    if ( *v9 != 1 )
    {
      v9 += 14;
      if ( v10 > v9 )
        goto LABEL_21;
      break;
    }
  }
LABEL_27:
  v2 = dl_nns;
  if ( dl_nns )
  {
    v5 = *v8;
    v2 = 0LL;
    if ( v5 )
    {
LABEL_6:
      v2 = 0LL;
      do
      {
        if ( v0 != v5 && (__int64 *)v5[5] == v5 )
        {
          v6 = *((_WORD *)v5 + 434) & 3;
          if ( v6 == 1 || (*((_BYTE *)v5 + 871) & 1) != 0 )
          {
            v7 = v3[369];
            if ( v7 )
              dl_find_object_from_map((__int64)v5, (_QWORD *)(v7 + 32 * v1));
            ++v1;
          }
          else if ( v6 == 2 )
          {
            ++v2;
            if ( dlfo_loaded_mappings[0] )
              dl_find_object_from_map((__int64)v5, (_QWORD *)(dlfo_loaded_mappings[0] + 32 * v2));
          }
        }
        v5 = (__int64 *)v5[3];
      }
      while ( v5 );
    }
  }
LABEL_4:
  result = v2;
  v3[370] = v1;
  return result;
}
// 448358: variable 'v2' is possibly undefined
// 44835C: variable 'v1' is possibly undefined
// 44835C: variable 'v3' is possibly undefined
// 44837C: variable 'v5' is possibly undefined
// 448388: variable 'v0' is possibly undefined
// 4484B0: variable 'v8' is possibly undefined
// 48FB88: using guessed type _UNKNOWN *dlfo_nodelete_mappings;
// 490F20: using guessed type __int64 dl_nns;
// 4914A8: using guessed type __int64 *dl_ns;
// 497100: using guessed type __int64 dlfo_loaded_mappings[];

//----- (00000000004484E0) ----------------------------------------------------
__int128 *__fastcall dlfo_sort_mappings_part_0(__int128 *result, unsigned __int64 a2)
{
  __int128 *v2; // x6
  unsigned __int64 v3; // x7
  unsigned __int64 v4; // x5
  unsigned __int64 v5; // x3
  unsigned __int64 v6; // x2
  unsigned __int64 v7; // x4
  __int128 *v8; // x5
  __int128 v9; // q31
  __int128 v10; // q28
  __int128 v11; // [xsp+10h] [xbp-10h]

  v2 = result;
  v3 = 0LL;
  do
  {
    v4 = v3++;
    if ( v3 >= a2 )
    {
      v8 = v2;
    }
    else
    {
      v5 = *(_QWORD *)v2;
      v6 = v3;
      do
      {
        v7 = *(_QWORD *)&result[2 * v6];
        if ( v5 > v7 )
          v4 = v6;
        ++v6;
        if ( v5 > v7 )
          v5 = v7;
      }
      while ( a2 != v6 );
      v8 = &result[2 * v4];
    }
    v9 = *v8;
    v11 = v8[1];
    v10 = v2[1];
    *v8 = *v2;
    v8[1] = v10;
    *v2 = v9;
    v2[1] = v11;
    v2 += 2;
  }
  while ( v3 < a2 - 1 );
  return result;
}

//----- (0000000000448560) ----------------------------------------------------
__int64 __fastcall dl_find_object(unsigned __int64 a1, __int64 a2)
{
  __int64 v2; // x11
  char *v4; // x1
  unsigned __int64 v5; // x7
  unsigned __int64 *v6; // x2
  unsigned __int64 *v7; // x4
  unsigned __int64 v8; // x3
  unsigned __int64 v9; // x2
  __int64 result; // x0
  unsigned __int64 *v11; // x10
  unsigned __int64 v12; // x2
  unsigned __int64 *v13; // x5
  _QWORD *v14; // x2
  unsigned __int64 v15; // x2
  __int128 v16; // q31
  bool v17; // cf
  unsigned __int64 v18; // x1
  unsigned __int64 i; // x2
  unsigned __int64 *v20; // x4
  __int128 v21; // q31
  unsigned __int64 v22; // x1
  __int64 *v23; // x2
  int v24; // w0
  bool v25; // cf
  __int64 *v26; // [xsp+18h] [xbp+18h]
  unsigned __int64 v27; // [xsp+20h] [xbp+20h]
  __int64 v28; // [xsp+28h] [xbp+28h]
  __int128 v29; // [xsp+30h] [xbp+30h] BYREF
  __int128 v30; // [xsp+40h] [xbp+40h]

  v2 = a2;
  if ( *((_QWORD *)&dlfo_main + 1) )
  {
    if ( (unsigned __int64)dlfo_main > a1 || *((_QWORD *)&dlfo_main + 1) <= a1 )
    {
      v4 = (char *)dlfo_nodelete_mappings;
      if ( *(_QWORD *)dlfo_nodelete_mappings > a1 || dlfo_nodelete_mappings_end <= a1 )
        goto LABEL_7;
      for ( i = dlfo_nodelete_mappings_size; i; i >>= 1 )
      {
        while ( 1 )
        {
          v20 = (unsigned __int64 *)&v4[32 * (i >> 1)];
          if ( a1 <= *v20 )
            break;
          v4 = (char *)(v20 + 4);
          i = i - 1 - (i >> 1);
          if ( !i )
            goto LABEL_37;
        }
      }
LABEL_37:
      if ( v4 == (char *)dlfo_nodelete_mappings + 32 * dlfo_nodelete_mappings_size || a1 != *(_QWORD *)v4 )
      {
        if ( a1 >= *((_QWORD *)v4 - 3) )
          goto LABEL_7;
        v4 -= 32;
        goto LABEL_41;
      }
      if ( v4 )
        v25 = a1 >= *((_QWORD *)v4 + 1);
      else
        v25 = 1;
      if ( !v25 )
      {
LABEL_41:
        v21 = *(_OWORD *)v4;
        *(_QWORD *)v2 = 0LL;
        result = 0LL;
        *(_OWORD *)(v2 + 8) = v21;
        *(_OWORD *)(v2 + 24) = *((_OWORD *)v4 + 1);
        return result;
      }
LABEL_7:
      while ( 2 )
      {
        while ( 2 )
        {
          while ( 1 )
          {
            v5 = atomic_load((unsigned __int64 *)&dlfo_loaded_mappings_version);
            v6 = (unsigned __int64 *)dlfo_loaded_mappings[v5 & 1];
            if ( v6 )
              break;
LABEL_12:
            __dmb(9u);
            v9 = atomic_load((unsigned __int64 *)&dlfo_loaded_mappings_version);
            if ( v5 == v9 )
              return 0xFFFFFFFFLL;
          }
          while ( 1 )
          {
            v8 = v6[2];
            if ( !v8 )
              goto LABEL_12;
            v7 = v6 + 4;
            if ( a1 >= v6[4] )
              break;
            v6 = (unsigned __int64 *)atomic_load(v6);
            if ( !v6 )
              goto LABEL_12;
          }
          v11 = &v7[4 * v8];
          do
          {
            while ( 1 )
            {
              v12 = v8 >> 1;
              v13 = &v7[4 * (v8 >> 1)];
              if ( a1 <= *v13 )
                break;
              v7 = v13 + 4;
              v8 = v8 - 1 - v12;
              if ( !v8 )
                goto LABEL_17;
            }
            v8 >>= 1;
          }
          while ( v12 );
LABEL_17:
          if ( v7 != v11 && a1 == *v7 )
          {
            v14 = v7 + 1;
            if ( v7 )
              v17 = a1 >= v7[1];
            else
              v17 = 1;
            if ( !v17 )
            {
LABEL_21:
              *(_QWORD *)&v29 = *v7;
              *((_QWORD *)&v29 + 1) = *v14;
              v30 = *((_OWORD *)v7 + 1);
              __dmb(9u);
              v15 = atomic_load((unsigned __int64 *)&dlfo_loaded_mappings_version);
              if ( v5 != v15 )
                continue;
              goto LABEL_22;
            }
          }
          else if ( a1 < *(v7 - 3) )
          {
            v7 -= 4;
            v14 = v7 + 1;
            goto LABEL_21;
          }
          break;
        }
        __dmb(9u);
        v18 = atomic_load((unsigned __int64 *)&dlfo_loaded_mappings_version);
        if ( v5 != v18 )
          continue;
        return 0xFFFFFFFFLL;
      }
    }
    *(_QWORD *)a2 = 0LL;
    *(_OWORD *)(a2 + 8) = dlfo_main;
    result = 0LL;
    *(_OWORD *)(a2 + 24) = xmmword_48FBA8;
  }
  else
  {
    if ( !dl_nns )
      return 0xFFFFFFFFLL;
    v22 = a1;
    v23 = dl_ns;
    if ( !dl_ns )
      return 0xFFFFFFFFLL;
    while ( 1 )
    {
      if ( v22 >= v23[115] && v22 < v23[116] )
      {
        if ( (*((_BYTE *)v23 + 870) & 8) != 0 )
          break;
        v26 = v23;
        v27 = v22;
        v28 = v2;
        v24 = dl_addr_inside_object(v23, v22);
        v2 = v28;
        v23 = v26;
        v22 = v27;
        if ( v24 )
          break;
      }
      v23 = (__int64 *)v23[3];
      if ( !v23 )
        return 0xFFFFFFFFLL;
    }
    if ( v23[6] )
      _libc_assert_fail((__int64)"ns == l->l_ns", (__int64)"dl-find_object.c", 0x2Du, (__int64)"_dl_find_object_slow");
    dl_find_object_from_map((__int64)v23, &v29);
LABEL_22:
    v16 = v29;
    result = 0LL;
    *(_QWORD *)v2 = 0LL;
    *(_OWORD *)(v2 + 8) = v16;
    *(_OWORD *)(v2 + 24) = v30;
  }
  return result;
}
// 4486B0: variable 'v2' is possibly undefined
// 448860: using guessed type __int64 dlfo_sort_mappings(void);
// 48FB88: using guessed type _UNKNOWN *dlfo_nodelete_mappings;
// 48FB90: using guessed type __int64 dlfo_nodelete_mappings_size;
// 48FB98: using guessed type __int128 dlfo_main;
// 48FBA8: using guessed type __int128 xmmword_48FBA8;
// 48FBB8: using guessed type __int64 dlfo_nodelete_mappings_end;
// 490F20: using guessed type __int64 dl_nns;
// 4914A8: using guessed type __int64 *dl_ns;
// 497100: using guessed type __int64 dlfo_loaded_mappings[];
// 497110: using guessed type __int64 dlfo_loaded_mappings_version;

//----- (0000000000448860) ----------------------------------------------------
__int128 *__fastcall dlfo_sort_mappings(__int128 *result, unsigned __int64 a2)
{
  if ( a2 > 1 )
    return dlfo_sort_mappings_part_0(result, a2);
  return result;
}

//----- (0000000000448870) ----------------------------------------------------
// write access to const memory has been detected, the output may be wrong!
__int128 *dl_find_object_init()
{
  unsigned __int64 v0; // x22
  __int64 v1; // x1
  __int64 v2; // x2
  void *v3; // x3
  void *v4; // x4
  void *v5; // x5
  void *v6; // x6
  __int64 v7; // x7
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  void *v16; // x0
  __int64 v17; // x1
  __int64 v18; // x2
  void *v19; // x3
  void *v20; // x4
  void *v21; // x5
  void *v22; // x6
  __int64 v23; // x7
  double v24; // d0
  double v25; // d1
  double v26; // d2
  double v27; // d3
  double v28; // d4
  double v29; // d5
  double v30; // d6
  double v31; // d7
  void *v32; // x19
  __int128 *result; // x0
  __int64 v34; // x1
  _QWORD *v35; // x0
  __int64 v36; // x12
  __int64 v37; // x1
  unsigned __int64 v38; // x1

  if ( (*((_BYTE *)dl_ns + 870) & 8) != 0 )
    dl_find_object_from_map((__int64)dl_ns, &dlfo_main);
  else
    dlfo_main = 0u;
  v0 = dlfo_process_initial();
  v16 = (void *)malloc(
                  32 * dlfo_nodelete_mappings_size,
                  v1,
                  v2,
                  v3,
                  v4,
                  v5,
                  v6,
                  v7,
                  v8,
                  v9,
                  v10,
                  v11,
                  v12,
                  v13,
                  v14,
                  v15);
  dlfo_nodelete_mappings = v16;
  v32 = v16;
  if ( !v0 )
  {
    if ( v16 )
    {
      dlfo_nodelete_mappings_size = 0LL;
      result = (__int128 *)dlfo_process_initial();
      if ( dlfo_nodelete_mappings_size )
      {
        if ( dlfo_nodelete_mappings_size == 1 )
        {
          result = (__int128 *)*((_QWORD *)v32 + 1);
        }
        else
        {
          dlfo_sort_mappings_part_0((__int128 *)v32, dlfo_nodelete_mappings_size);
          result = (__int128 *)*((_QWORD *)v32 + 4 * v34 - 3);
        }
        dlfo_nodelete_mappings_end = (__int64)result;
      }
      return result;
    }
LABEL_23:
    dl_fatal_printf("Fatal glibc error: cannot allocate memory for find-object data\n");
  }
  if ( v0 < 0x3F )
    v0 = 63LL;
  v35 = (_QWORD *)malloc(32 * (v0 + 1), v17, v18, v19, v20, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31);
  if ( !v35 )
  {
    dlfo_loaded_mappings[0] = 0LL;
    goto LABEL_23;
  }
  v35[2] = 0LL;
  v35[3] = v0;
  dlfo_loaded_mappings[0] = (__int64)v35;
  *v35 = 0LL;
  v35[1] = 0LL;
  if ( !v32 )
    goto LABEL_23;
  dlfo_nodelete_mappings_size = 0LL;
  dlfo_process_initial();
  if ( dlfo_nodelete_mappings_size )
  {
    if ( dlfo_nodelete_mappings_size == 1 )
    {
      dlfo_nodelete_mappings_end = *((_QWORD *)v32 + 1);
    }
    else
    {
      dlfo_sort_mappings_part_0((__int128 *)v32, dlfo_nodelete_mappings_size);
      dlfo_nodelete_mappings_end = *((_QWORD *)v32 + 4 * v37 - 3);
    }
  }
  result = *(__int128 **)(v36 + 256);
  v38 = *((_QWORD *)result + 2);
  if ( v38 > 1 )
    return dlfo_sort_mappings_part_0(result + 2, v38);
  return result;
}
// 4488BC: write access to const memory at 48FB88 has been detected
// 4488A0: write access to const memory at 48FB98 has been detected
// 4488F4: write access to const memory at 48FBB8 has been detected
// 4488CC: write access to const memory at 48FB90 has been detected
// 448960: write access to const memory at 48FBB8 has been detected
// 44899C: write access to const memory at 48FBB8 has been detected
// 448938: write access to const memory at 48FB90 has been detected
// 4488B8: variable 'v1' is possibly undefined
// 4488B8: variable 'v2' is possibly undefined
// 4488B8: variable 'v3' is possibly undefined
// 4488B8: variable 'v4' is possibly undefined
// 4488B8: variable 'v5' is possibly undefined
// 4488B8: variable 'v6' is possibly undefined
// 4488B8: variable 'v7' is possibly undefined
// 4488B8: variable 'v8' is possibly undefined
// 4488B8: variable 'v9' is possibly undefined
// 4488B8: variable 'v10' is possibly undefined
// 4488B8: variable 'v11' is possibly undefined
// 4488B8: variable 'v12' is possibly undefined
// 4488B8: variable 'v13' is possibly undefined
// 4488B8: variable 'v14' is possibly undefined
// 4488B8: variable 'v15' is possibly undefined
// 4488EC: variable 'v34' is possibly undefined
// 44891C: variable 'v17' is possibly undefined
// 44891C: variable 'v18' is possibly undefined
// 44891C: variable 'v19' is possibly undefined
// 44891C: variable 'v20' is possibly undefined
// 44891C: variable 'v21' is possibly undefined
// 44891C: variable 'v22' is possibly undefined
// 44891C: variable 'v23' is possibly undefined
// 44891C: variable 'v24' is possibly undefined
// 44891C: variable 'v25' is possibly undefined
// 44891C: variable 'v26' is possibly undefined
// 44891C: variable 'v27' is possibly undefined
// 44891C: variable 'v28' is possibly undefined
// 44891C: variable 'v29' is possibly undefined
// 44891C: variable 'v30' is possibly undefined
// 44891C: variable 'v31' is possibly undefined
// 448958: variable 'v37' is possibly undefined
// 448964: variable 'v36' is possibly undefined
// 48FB88: using guessed type _UNKNOWN *dlfo_nodelete_mappings;
// 48FB90: using guessed type __int64 dlfo_nodelete_mappings_size;
// 48FB98: using guessed type __int128 dlfo_main;
// 48FBB8: using guessed type __int64 dlfo_nodelete_mappings_end;
// 4914A8: using guessed type __int64 *dl_ns;
// 497100: using guessed type __int64 dlfo_loaded_mappings[];

//----- (00000000004489C4) ----------------------------------------------------
__int64 __fastcall dl_find_object_update(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        void *a12,
        void *a13,
        void *a14,
        void *a15,
        __int64 a16)
{
  __int64 v16; // x19
  __int64 v17; // x1
  unsigned __int64 v18; // x20
  __int16 v19; // w0
  char *v20; // x4
  _QWORD *v21; // x5
  unsigned __int64 v22; // x21
  double v23; // d0
  double v24; // d1
  double v25; // d2
  double v26; // d3
  double v27; // d4
  double v28; // d5
  double v29; // d6
  double v30; // d7
  __int64 v31; // x1
  char *v32; // x0
  __int64 v33; // x6
  unsigned __int64 v34; // x2
  char *v35; // x1
  unsigned __int64 v36; // x3
  __int64 v37; // x1
  _QWORD *v38; // x2
  __int64 v39; // x2
  _QWORD *v40; // x6
  _QWORD *v41; // x0
  char *i; // x1
  __int64 v43; // x3
  unsigned __int64 v44; // x19
  _QWORD *v45; // x3
  _QWORD *v46; // x0
  unsigned __int64 v47; // x1
  __int64 v48; // x2
  unsigned __int64 v49; // x1
  unsigned __int64 v50; // x0
  unsigned __int64 v51; // x0
  _QWORD *v52; // x8
  unsigned __int64 v53; // x0
  unsigned __int64 v54; // x7
  __int64 v55; // x2
  __int64 v56; // x9
  _QWORD *v57; // x1
  __int64 v58; // x10
  unsigned __int64 v59; // x11
  __int64 v60; // x9
  _QWORD *v63; // x8
  unsigned __int64 v64; // x1
  __int64 v65; // x6
  __int64 v66; // x6
  unsigned int v67; // w19
  unsigned __int64 v68; // x1
  _QWORD *v69; // x0
  _QWORD *v70; // x1
  __int64 v71; // [xsp+38h] [xbp+38h]
  unsigned __int64 v72; // [xsp+40h] [xbp+40h]
  _QWORD *v73; // [xsp+48h] [xbp+48h]
  __int64 v74; // [xsp+50h] [xbp+50h]
  bool v75; // [xsp+5Ch] [xbp+5Ch]

  if ( !a1 )
    return 1;
  v16 = a1;
  v17 = a1;
  v18 = 0LL;
  do
  {
    while ( *(_QWORD *)(v17 + 40) != v17 )
    {
      v17 = *(_QWORD *)(v17 + 24);
      if ( !v17 )
        goto LABEL_6;
    }
    v19 = *(_WORD *)(v17 + 870);
    v17 = *(_QWORD *)(v17 + 24);
    v18 += (v19 & 0x40) == 0LL;
  }
  while ( v17 );
LABEL_6:
  if ( !v18 )
    return 1;
  v22 = malloc(8 * v18, v17, a11, a12, a13, a14, a15, a16, a2, a3, a4, a5, a6, a7, a8, a9);
  if ( !v22 )
    return 0;
  v31 = 0LL;
  do
  {
    while ( *(_QWORD *)(v16 + 40) != v16 || (*(_BYTE *)(v16 + 870) & 0x40) != 0 )
    {
      v16 = *(_QWORD *)(v16 + 24);
      if ( !v16 )
        goto LABEL_13;
    }
    *(_QWORD *)(v22 + 8 * v31++) = v16;
    v16 = *(_QWORD *)(v16 + 24);
  }
  while ( v16 );
LABEL_13:
  if ( v18 != 1 )
  {
    v21 = (_QWORD *)v22;
    v32 = 0LL;
    do
    {
      v20 = v32++;
      v33 = *v21;
      if ( (unsigned __int64)v32 >= v18 )
      {
        v37 = *v21;
        v38 = v21;
      }
      else
      {
        v34 = *(_QWORD *)(v33 + 920);
        v35 = v32;
        do
        {
          v36 = *(_QWORD *)(*(_QWORD *)(v22 + 8LL * (_QWORD)v35) + 920LL);
          if ( v36 < v34 )
            v20 = v35;
          ++v35;
          if ( v36 < v34 )
            v34 = v36;
        }
        while ( v35 != (char *)v18 );
        v37 = *(_QWORD *)(v22 + 8LL * (_QWORD)v20);
        v38 = (_QWORD *)(v22 + 8LL * (_QWORD)v20);
      }
      *v38 = v33;
      *v21++ = v37;
    }
    while ( (char *)(v18 - 1) != v32 );
  }
  v39 = 0LL;
  v40 = (_QWORD *)dlfo_loaded_mappings[dlfo_loaded_mappings_version & 1];
  v41 = v40;
  if ( v40 )
  {
    do
    {
      v20 = (char *)v41[2];
      if ( !v20 )
        break;
      v21 = v41 + 6;
      for ( i = 0LL; i != v20; ++i )
      {
        v43 = 4LL * (_QWORD)i;
        if ( v21[v43] )
          ++v39;
      }
      v41 = (_QWORD *)*v41;
    }
    while ( v41 );
    v44 = v39 + v18;
    v45 = (_QWORD *)dlfo_loaded_mappings[!(dlfo_loaded_mappings_version & 1)];
  }
  else
  {
    v45 = (_QWORD *)dlfo_loaded_mappings[!(dlfo_loaded_mappings_version & 1)];
    v44 = v18;
  }
  if ( v45 )
  {
    v46 = v45;
    v47 = 0LL;
    do
    {
      v48 = v46[3];
      v46 = (_QWORD *)*v46;
      v47 += v48;
    }
    while ( v46 );
    if ( v47 >= v44 )
    {
      __dmb(0xBu);
      v52 = v45;
LABEL_42:
      v54 = v52[3];
      if ( v54 > v44 )
        v54 = v44;
      v52[2] = v54;
      if ( v40 )
      {
        v55 = v40[2];
LABEL_46:
        while ( 1 )
        {
          if ( !v55 )
          {
            v40 = (_QWORD *)*v40;
            if ( !v40 )
              break;
            v55 = v40[2];
            if ( !v55 )
              break;
          }
          while ( 1 )
          {
            v56 = v55--;
            if ( !v40[4 * v55 + 6] )
              break;
            if ( !v44 )
              goto LABEL_80;
            if ( v54 )
            {
              v57 = &v52[4 * v54--];
              if ( !v18 )
                goto LABEL_73;
            }
            else
            {
              v52 = (_QWORD *)*v52;
              v68 = v52[3];
              if ( v68 > v44 )
                v68 = v44;
              v52[2] = v68;
              v54 = v68 - 1;
              v57 = &v52[4 * v68];
              if ( !v18 )
              {
LABEL_73:
                *v57 = v40[4 * v56];
                v69 = &v40[4 * v55];
                v70 = &v52[4 * v54];
                v70[5] = v69[5];
                v70[6] = v69[6];
                v70[7] = v69[7];
                --v44;
                goto LABEL_46;
              }
            }
            if ( *(_QWORD *)(*(_QWORD *)(v22 + 8 * (v18 - 1)) + 920LL) < v40[4 * v55 + 4] )
              goto LABEL_73;
            dl_find_object_from_map(*(_QWORD *)(v22 + 8 * (v18 - 1)), v57);
            --v44;
            v18 = v59;
            v55 = v60;
            *(_BYTE *)(v58 + 870) |= 0x40u;
          }
        }
      }
      while ( v18 )
      {
        while ( 1 )
        {
          if ( !v44 )
LABEL_80:
            _libc_assert_fail(
              (__int64)"remaining_to_add > 0",
              (__int64)"dl-find_object.c",
              0x2E3u,
              (__int64)"_dl_find_object_update_1");
          --v18;
          if ( !v54 )
            break;
          --v44;
          dl_find_object_from_map(*(_QWORD *)(v22 + 8 * v18), &v52[4 * v54]);
          *(_BYTE *)(v66 + 870) |= 0x40u;
          if ( !v18 )
            goto LABEL_64;
        }
        v63 = (_QWORD *)*v52;
        v64 = v63[3];
        if ( v64 > v44 )
          v64 = v44;
        v63[2] = v64;
        --v44;
        dl_find_object_from_map(*(_QWORD *)(v22 + 8 * v18), &v63[4 * v64]);
        *(_BYTE *)(v65 + 870) |= 0x40u;
      }
LABEL_64:
      if ( v44 )
        _libc_assert_fail(
          (__int64)"remaining_to_add == 0",
          (__int64)"dl-find_object.c",
          0x30Bu,
          (__int64)"_dl_find_object_update_1");
      if ( v54 )
        _libc_assert_fail(
          (__int64)"target_seg_index1 == 0",
          (__int64)"dl-find_object.c",
          0x30Eu,
          (__int64)"_dl_find_object_update_1");
      if ( *v52 )
        *(_QWORD *)(*v52 + 16LL) = 0LL;
      __dmb(0xBu);
      ++dlfo_loaded_mappings_version;
      v67 = 1;
      goto LABEL_69;
    }
    v49 = v44 - v47;
    v50 = 2LL * v45[3];
  }
  else
  {
    v49 = v44;
    v50 = 63LL;
  }
  v73 = v45;
  v74 = dlfo_loaded_mappings[dlfo_loaded_mappings_version & 1];
  if ( v50 >= v49 )
    v49 = v50;
  v75 = !(dlfo_loaded_mappings_version & 1);
  v71 = 32 * (v49 + 9);
  v72 = v49;
  v51 = malloc(v71, v49, v71, v45, v20, v21, v40, v75, v23, v24, v25, v26, v27, v28, v29, v30);
  if ( v51 )
  {
    v52 = (_QWORD *)((v51 + 127) & 0xFFFFFFFFFFFFFF80LL);
    *v52 = v73;
    v52[1] = v51;
    v53 = (((v51 + v71) & 0xFFFFFFFFFFFFFF80LL) - (unsigned __int64)v52 - 32) >> 5;
    v52[2] = 0LL;
    v52[3] = v53;
    v40 = (_QWORD *)v74;
    if ( v72 > v53 )
      _libc_assert_fail(
        (__int64)"result->allocated >= size",
        (__int64)"dl-find_object.c",
        0xECu,
        (__int64)"_dlfo_mappings_segment_allocate");
    __dmb(0xBu);
    atomic_store((unsigned __int64)v52, (unsigned __int64 *)&dlfo_loaded_mappings[v75]);
    goto LABEL_42;
  }
  v67 = 0;
LABEL_69:
  free(v22, v23, v24, v25, v26, v27, v28, v29, v30);
  return v67;
}
// 448B90: variable 'v20' is possibly undefined
// 448B90: variable 'v21' is possibly undefined
// 448B90: variable 'v23' is possibly undefined
// 448B90: variable 'v24' is possibly undefined
// 448B90: variable 'v25' is possibly undefined
// 448B90: variable 'v26' is possibly undefined
// 448B90: variable 'v27' is possibly undefined
// 448B90: variable 'v28' is possibly undefined
// 448B90: variable 'v29' is possibly undefined
// 448B90: variable 'v30' is possibly undefined
// 448C0C: variable 'v40' is possibly undefined
// 448C38: variable 'v54' is possibly undefined
// 448C3C: variable 'v52' is possibly undefined
// 448C74: variable 'v59' is possibly undefined
// 448C78: variable 'v60' is possibly undefined
// 448C6C: variable 'v58' is possibly undefined
// 448CCC: variable 'v65' is possibly undefined
// 448D08: variable 'v66' is possibly undefined
// 497100: using guessed type __int64 dlfo_loaded_mappings[];
// 497110: using guessed type __int64 dlfo_loaded_mappings_version;

//----- (0000000000448EA0) ----------------------------------------------------
unsigned __int64 __fastcall dl_find_object_dlclose(unsigned __int64 result)
{
  _QWORD *v1; // x1
  unsigned __int64 v2; // x3
  _QWORD *v3; // x1
  _QWORD *v4; // x6
  unsigned __int64 v5; // x2
  unsigned __int64 *v6; // x4
  bool v7; // cf

  v1 = (_QWORD *)dlfo_loaded_mappings[dlfo_loaded_mappings_version & 1];
  if ( v1 )
  {
    v2 = *(_QWORD *)(result + 920);
    while ( 1 )
    {
      result = v1[2];
      if ( !result )
        return result;
      if ( v1[4] <= v2 )
        break;
      v1 = (_QWORD *)*v1;
      if ( !v1 )
        return result;
    }
    v3 = v1 + 4;
    v4 = &v3[4 * result];
    do
    {
      while ( 1 )
      {
        v5 = result >> 1;
        v6 = &v3[4 * (result >> 1)];
        if ( v2 <= *v6 )
          break;
        v3 = v6 + 4;
        result = result - 1 - v5;
        if ( !result )
          goto LABEL_10;
      }
      result >>= 1;
    }
    while ( v5 );
LABEL_10:
    if ( v4 == v3 || v2 != *v3 )
    {
      result = *(v3 - 3);
      if ( v2 >= result )
        return result;
      v3 -= 4;
      result = (unsigned __int64)(v3 + 1);
      goto LABEL_14;
    }
    result = (unsigned __int64)(v3 + 1);
    if ( v3 )
      v7 = v2 >= v3[1];
    else
      v7 = 1;
    if ( !v7 )
    {
LABEL_14:
      *(_QWORD *)result = *v3;
      v3[2] = 0LL;
    }
  }
  return result;
}
// 497100: using guessed type __int64 dlfo_loaded_mappings[];
// 497110: using guessed type __int64 dlfo_loaded_mappings_version;

//----- (0000000000448F70) ----------------------------------------------------
void __fastcall dl_find_object_freeres(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  _QWORD *v8; // x19
  unsigned __int64 v9; // x0
  _QWORD *v10; // x19
  unsigned __int64 v11; // x0

  v8 = (_QWORD *)dlfo_loaded_mappings[0];
  if ( dlfo_loaded_mappings[0] )
  {
    do
    {
      v9 = v8[1];
      v8 = (_QWORD *)*v8;
      free(v9, a1, a2, a3, a4, a5, a6, a7, a8);
    }
    while ( v8 );
  }
  dlfo_loaded_mappings[0] = 0LL;
  v10 = (_QWORD *)qword_497108;
  if ( qword_497108 )
  {
    do
    {
      v11 = v10[1];
      v10 = (_QWORD *)*v10;
      free(v11, a1, a2, a3, a4, a5, a6, a7, a8);
    }
    while ( v10 );
  }
  qword_497108 = 0LL;
}
// 448F90: variable 'a1' is possibly undefined
// 448F90: variable 'a2' is possibly undefined
// 448F90: variable 'a3' is possibly undefined
// 448F90: variable 'a4' is possibly undefined
// 448F90: variable 'a5' is possibly undefined
// 448F90: variable 'a6' is possibly undefined
// 448F90: variable 'a7' is possibly undefined
// 448F90: variable 'a8' is possibly undefined
// 497100: using guessed type __int64 dlfo_loaded_mappings[];
// 497108: using guessed type __int64 qword_497108;

//----- (0000000000448FE0) ----------------------------------------------------
__int64 __fastcall _rtld_static_init(__int64 *a1)
{
  unsigned int *v2; // x0
  __int64 v3; // x1
  bool v4; // zf
  __int64 result; // x0
  __int64 v6; // x2
  __int64 v7; // x2
  __int64 v8; // x2

  v2 = dl_lookup_direct(
         (__int64)a1,
         (unsigned __int64)"_rtld_global_ro",
         0x9F28436A,
         (unsigned __int64)"GLIBC_PRIVATE",
         157536133);
  if ( !v2 )
    _libc_assert_fail((__int64)"sym != NULL", (__int64)"rtld_static_init.c", 0x35u, (__int64)"__rtld_static_init");
  v3 = 0LL;
  if ( a1 )
    v4 = *((unsigned __int16 *)v2 + 3) == 65521;
  else
    v4 = 1;
  if ( !v4 )
    v3 = *a1;
  result = v3 + *((_QWORD *)v2 + 1);
  v6 = dl_auxv;
  *(_DWORD *)(result + 64) = dl_clktck;
  *(_QWORD *)(result + 680) = dlfcn_hook;
  *(_QWORD *)(result + 96) = dl_hwcap;
  *(_QWORD *)(result + 104) = v6;
  *(_QWORD *)(result + 568) = dl_hwcap2;
  v7 = dl_minsigstacksize;
  *(_QWORD *)(result + 24) = dl_pagesize;
  *(_QWORD *)(result + 32) = v7;
  v8 = dl_tls_static_align;
  *(_QWORD *)(result + 472) = dl_tls_static_size;
  *(_QWORD *)(result + 480) = v8;
  *(_QWORD *)(result + 672) = dl_find_object;
  return result;
}
// 448560: using guessed type __int64 __fastcall dl_find_object();
// 48FBC0: using guessed type __int64 (__fastcall *dlfcn_hook[13])();
// 490F10: using guessed type __int64 dl_pagesize;
// 490F18: using guessed type __int64 dl_minsigstacksize;
// 4921F8: using guessed type __int64 dl_tls_static_align;
// 492200: using guessed type __int64 dl_tls_static_size;
// 496BD0: using guessed type __int64 dl_auxv;
// 496BE0: using guessed type __int64 dl_hwcap;
// 496BE8: using guessed type __int64 dl_hwcap2;
// 496C00: using guessed type int dl_clktck;

//----- (00000000004490E0) ----------------------------------------------------
__int64 __fastcall _mpn_add_n(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x4
  __int64 v5; // x2
  __int64 v6; // x1
  __int64 v7; // x3
  __int64 result; // x0
  __int64 v9; // x6
  __int64 v10; // x5
  bool v11; // cf
  __int64 v12; // x0
  __int64 v13; // x6

  v4 = -a4;
  v5 = a3 + 8 * a4;
  v6 = a2 + 8 * a4;
  v7 = a1 + 8 * a4;
  result = 0LL;
  do
  {
    v9 = *(_QWORD *)(v5 + 8 * v4);
    v10 = *(_QWORD *)(v6 + 8 * v4);
    v11 = __CFADD__(result, v9);
    v12 = result + v9;
    v13 = v11;
    *(_QWORD *)(v7 + 8 * v4) = v10 + v12;
    if ( __CFADD__(v10, v12) )
      result = v13 + 1;
    else
      result = v13;
    ++v4;
  }
  while ( v4 );
  return result;
}

//----- (0000000000449140) ----------------------------------------------------
unsigned __int64 __fastcall _mpn_addmul_1(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // x7
  __int64 v5; // x1
  __int64 v6; // x2
  unsigned __int64 result; // x0
  __int64 v8; // x4
  unsigned __int64 v9; // x5
  unsigned __int64 v10; // x8
  unsigned __int64 v11; // x6
  unsigned __int64 v12; // x4
  bool v13; // cf
  unsigned __int64 v14; // x8
  unsigned __int64 v15; // x5
  unsigned __int64 v16; // x4

  v4 = -a3;
  v5 = a2 + 8 * a3;
  v6 = a1 + 8 * a3;
  result = 0LL;
  do
  {
    v8 = *(_QWORD *)(v5 + 8 * v4);
    v9 = (unsigned int)v8 * (unsigned __int64)(unsigned int)a4;
    v10 = HIDWORD(v8) * (unsigned __int64)(unsigned int)a4;
    v11 = HIDWORD(a4) * (unsigned __int64)HIDWORD(v8);
    v12 = v10 + HIDWORD(a4) * (unsigned __int64)(unsigned int)v8 + HIDWORD(v9);
    v13 = v12 >= v10;
    v14 = *(_QWORD *)(v6 + 8 * v4);
    v15 = result + (unsigned int)v9 + (v12 << 32);
    if ( !v13 )
      v11 += 0x100000000LL;
    v16 = HIDWORD(v12);
    if ( v15 < result )
      ++v16;
    *(_QWORD *)(v6 + 8 * v4) = v14 + v15;
    result = (__PAIR128__(v11, v14) + __PAIR128__(v16, v15)) >> 64;
    ++v4;
  }
  while ( v4 );
  return result;
}

//----- (00000000004491C0) ----------------------------------------------------
__int64 __fastcall dladdr(
        unsigned __int64 a1,
        _QWORD *a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        void *a14,
        void *a15)
{
  return dl_addr(a1, a2, 0LL, 0LL, a13, a14, a15, a3, a4, a5, a6, a7, a8, a9, a10);
}

//----- (00000000004491E0) ----------------------------------------------------
__int64 __fastcall dladdr1(
        unsigned __int64 a1,
        _QWORD *a2,
        __int64 **a3,
        int a4,
        __int64 a5,
        void *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  bool v15; // zf
  __int64 **v16; // x3

  if ( a4 == 1 )
  {
    v16 = a3;
    a3 = 0LL;
  }
  else
  {
    v15 = a4 == 2;
    v16 = 0LL;
    if ( !v15 )
      a3 = 0LL;
  }
  return dl_addr(a1, a2, a3, v16, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15);
}

//----- (0000000000449220) ----------------------------------------------------
__int64 __fastcall dlclose(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  if ( (unsigned int)dlerror_run(
                       (void (__fastcall *)(__int64))dl_close,
                       a1,
                       a2,
                       a3,
                       a4,
                       a5,
                       a6,
                       a7,
                       a8,
                       a9,
                       a11,
                       a12,
                       a13,
                       a14,
                       a15,
                       a16) )
    return 0xFFFFFFFFLL;
  else
    return 0LL;
}

//----- (0000000000449260) ----------------------------------------------------
const char *__fastcall dlerror(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  unsigned __int64 StatusReg; // x5
  unsigned __int64 v9; // x19
  unsigned __int64 *v10; // x1
  const char *v11; // x20
  __int64 *v12; // x3
  unsigned __int64 *v13; // x0
  int v14; // w0
  double v15; // d0
  double v16; // d1
  double v17; // d2
  double v18; // d3
  double v19; // d4
  double v20; // d5
  double v21; // d6
  double v22; // d7
  const char *result; // x0
  __int64 *v24; // x3
  unsigned __int64 *v25; // x0
  int v26; // w0
  int v27; // w0
  int v28; // w0
  const char *v29; // [xsp+28h] [xbp+28h]
  const char *v30; // [xsp+28h] [xbp+28h]
  unsigned __int64 v31; // [xsp+30h] [xbp+30h]
  const char *v32; // [xsp+48h] [xbp+48h] BYREF

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v9 = *(_QWORD *)(StatusReg + 96);
  if ( !v9 )
    return 0LL;
  if ( v9 == -1LL )
  {
    *(_QWORD *)(StatusReg + 96) = 0LL;
    return "out of memory";
  }
  v10 = *(unsigned __int64 **)(v9 + 16);
  if ( !v10 )
    return 0LL;
  if ( (*(_BYTE *)(v9 + 5) & 1) != 0 )
  {
    *(_QWORD *)(StatusReg + 96) = 0LL;
    v28 = *(unsigned __int8 *)(v9 + 4);
    if ( v28 == 1 )
    {
      dl_error_free((unsigned __int64)v10, a1, a2, a3, a4, a5, a6, a7, a8);
    }
    else if ( v28 == 2 )
    {
      free((unsigned __int64)v10, a1, a2, a3, a4, a5, a6, a7, a8);
    }
    free(v9, a1, a2, a3, a4, a5, a6, a7, a8);
    return 0LL;
  }
  v11 = *(const char **)(v9 + 8);
  if ( *(_DWORD *)v9 )
  {
    v12 = (__int64 *)": ";
    *(_DWORD *)(StatusReg + 40) = *(_DWORD *)v9;
    if ( !*v11 )
      v12 = &qword_454610;
    v29 = (const char *)v12;
    v31 = StatusReg;
    v13 = dcgettext((unsigned __int64 *)"libc", v10, 5u);
    v14 = asprintf((unsigned __int64 *)&v32, (__int64)"%s%s%s: %m", v11, v29, (const char *)v13);
    *(_DWORD *)(v31 + 40) = *(_DWORD *)v9;
    *(_BYTE *)(v9 + 5) = 1;
    if ( v14 < 0 )
      return *(const char **)(v9 + 16);
  }
  else
  {
    v24 = (__int64 *)": ";
    if ( !*v11 )
      v24 = &qword_454610;
    v30 = (const char *)v24;
    v25 = dcgettext((unsigned __int64 *)"libc", v10, 5u);
    v26 = asprintf((unsigned __int64 *)&v32, (__int64)"%s%s%s", v11, v30, (const char *)v25);
    *(_BYTE *)(v9 + 5) = 1;
    if ( v26 < 0 )
      return *(const char **)(v9 + 16);
  }
  v27 = *(unsigned __int8 *)(v9 + 4);
  if ( v27 == 1 )
  {
    dl_error_free(*(_QWORD *)(v9 + 16), v15, v16, v17, v18, v19, v20, v21, v22);
  }
  else if ( v27 == 2 )
  {
    free(*(_QWORD *)(v9 + 16), v15, v16, v17, v18, v19, v20, v21, v22);
  }
  result = v32;
  *(_BYTE *)(v9 + 4) = 2;
  *(_QWORD *)(v9 + 16) = result;
  return result;
}
// 449398: variable 'v15' is possibly undefined
// 449398: variable 'v16' is possibly undefined
// 449398: variable 'v17' is possibly undefined
// 449398: variable 'v18' is possibly undefined
// 449398: variable 'v19' is possibly undefined
// 449398: variable 'v20' is possibly undefined
// 449398: variable 'v21' is possibly undefined
// 449398: variable 'v22' is possibly undefined
// 449400: variable 'a1' is possibly undefined
// 449400: variable 'a2' is possibly undefined
// 449400: variable 'a3' is possibly undefined
// 449400: variable 'a4' is possibly undefined
// 449400: variable 'a5' is possibly undefined
// 449400: variable 'a6' is possibly undefined
// 449400: variable 'a7' is possibly undefined
// 449400: variable 'a8' is possibly undefined
// 454610: using guessed type __int64 qword_454610;

//----- (0000000000449420) ----------------------------------------------------
__int64 __fastcall dlerror_run(
        void (__fastcall *a1)(__int64),
        __int64 a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        __int64 a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  unsigned __int64 StatusReg; // x20
  __int64 v18; // x2
  int v19; // w0
  __int64 v20; // x2
  void *v21; // x4
  void *v22; // x5
  void *v23; // x6
  __int64 v24; // x7
  double v25; // d0
  double v26; // d1
  double v27; // d2
  double v28; // d3
  double v29; // d4
  double v30; // d5
  double v31; // d6
  double v32; // d7
  void *v33; // x3
  __int64 v34; // x1
  unsigned __int64 v35; // x0
  double v36; // d0
  double v37; // d1
  double v38; // d2
  double v39; // d3
  double v40; // d4
  double v41; // d5
  double v42; // d6
  double v43; // d7
  bool v44; // w0
  int v46; // w0
  unsigned __int64 v47; // x0
  void *v48; // [xsp+28h] [xbp+28h]
  __int64 v49; // [xsp+28h] [xbp+28h]
  __int64 v50; // [xsp+28h] [xbp+28h]
  __int64 v51; // [xsp+28h] [xbp+28h]
  __int64 v52; // [xsp+28h] [xbp+28h]
  int v53; // [xsp+30h] [xbp+30h]
  int v54; // [xsp+30h] [xbp+30h]
  void (__fastcall *v55)(__int64); // [xsp+30h] [xbp+30h]
  int v56; // [xsp+30h] [xbp+30h]
  void (__fastcall *v57)(__int64); // [xsp+30h] [xbp+30h]
  __int64 v58; // [xsp+38h] [xbp+38h]
  __int64 v59; // [xsp+38h] [xbp+38h]
  bool v60; // [xsp+4Fh] [xbp+4Fh] BYREF
  __int64 v61; // [xsp+50h] [xbp+50h] BYREF
  void *v62; // [xsp+58h] [xbp+58h] BYREF

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v18 = *(_QWORD *)(StatusReg + 96);
  if ( v18 )
  {
    if ( v18 == -1 )
    {
      *(_QWORD *)(StatusReg + 96) = 0LL;
    }
    else
    {
      v19 = *(unsigned __int8 *)(v18 + 4);
      if ( v19 == 1 )
      {
        v52 = *(_QWORD *)(StatusReg + 96);
        v57 = a1;
        v59 = a2;
        dl_error_free(*(_QWORD *)(v18 + 16), a3, a4, a5, a6, a7, a8, a9, a10);
        a1 = v57;
        *(_QWORD *)(v52 + 16) = 0LL;
        a2 = v59;
      }
      else if ( v19 == 2 )
      {
        v50 = *(_QWORD *)(StatusReg + 96);
        v55 = a1;
        v58 = a2;
        free(*(_QWORD *)(v18 + 16), a3, a4, a5, a6, a7, a8, a9, a10);
        a1 = v55;
        *(_QWORD *)(v50 + 16) = 0LL;
        a2 = v58;
      }
      else
      {
        *(_QWORD *)(v18 + 16) = 0LL;
      }
    }
  }
  v20 = (unsigned int)dl_catch_error(&v61, &v62, &v60, a1, a2, a14, a15, a16);
  v33 = v62;
  v34 = *(_QWORD *)(StatusReg + 96);
  if ( v62 )
  {
    if ( (unsigned __int64)(v34 - 1) <= 0xFFFFFFFFFFFFFFFDLL )
    {
      v46 = *(unsigned __int8 *)(v34 + 4);
      if ( v46 == 1 )
      {
        v51 = *(_QWORD *)(StatusReg + 96);
        v56 = v20;
        dl_error_free(*(_QWORD *)(v34 + 16), v25, v26, v27, v28, v29, v30, v31, v32);
        v34 = v51;
        v33 = v62;
        LODWORD(v20) = v56;
      }
      else if ( v46 == 2 )
      {
        v49 = *(_QWORD *)(StatusReg + 96);
        v54 = v20;
        free(*(_QWORD *)(v34 + 16), v25, v26, v27, v28, v29, v30, v31, v32);
        v34 = v49;
        v33 = v62;
        LODWORD(v20) = v54;
      }
    }
    else
    {
      v48 = v62;
      v53 = v20;
      v35 = malloc(24LL, v34, v20, v62, v21, v22, v23, v24, v25, v26, v27, v28, v29, v30, v31, v32);
      v33 = v48;
      v34 = v35;
      LODWORD(v20) = v53;
      if ( !v35 )
      {
        if ( v60 )
          dl_error_free((unsigned __int64)v48, v36, v37, v38, v39, v40, v41, v42, v43);
        *(_QWORD *)(StatusReg + 96) = -1LL;
        return 1LL;
      }
      *(_QWORD *)(StatusReg + 96) = v35;
    }
    *(_QWORD *)(v34 + 8) = v61;
    *(_QWORD *)(v34 + 16) = v33;
    v44 = v60;
    *(_DWORD *)v34 = v20;
    *(_WORD *)(v34 + 4) = v44;
    return 1LL;
  }
  if ( !v34 || *(_QWORD *)(v34 + 16) )
    return 0LL;
  v47 = *(_QWORD *)(StatusReg + 96);
  *(_QWORD *)(StatusReg + 96) = 0LL;
  free(v47, v25, v26, v27, v28, v29, v30, v31, v32);
  return 0LL;
}
// 449474: variable 'a14' is possibly undefined
// 449474: variable 'a15' is possibly undefined
// 449474: variable 'a16' is possibly undefined
// 4494A0: variable 'v21' is possibly undefined
// 4494A0: variable 'v22' is possibly undefined
// 4494A0: variable 'v23' is possibly undefined
// 4494A0: variable 'v24' is possibly undefined
// 4494A0: variable 'v25' is possibly undefined
// 4494A0: variable 'v26' is possibly undefined
// 4494A0: variable 'v27' is possibly undefined
// 4494A0: variable 'v28' is possibly undefined
// 4494A0: variable 'v29' is possibly undefined
// 4494A0: variable 'v30' is possibly undefined
// 4494A0: variable 'v31' is possibly undefined
// 4494A0: variable 'v32' is possibly undefined
// 4495C8: variable 'v36' is possibly undefined
// 4495C8: variable 'v37' is possibly undefined
// 4495C8: variable 'v38' is possibly undefined
// 4495C8: variable 'v39' is possibly undefined
// 4495C8: variable 'v40' is possibly undefined
// 4495C8: variable 'v41' is possibly undefined
// 4495C8: variable 'v42' is possibly undefined
// 4495C8: variable 'v43' is possibly undefined

//----- (00000000004495E0) ----------------------------------------------------
void __fastcall dlinfo_doit(__int64 a1)
{
  int v1; // w1
  __int64 v2; // x3
  __int64 v3; // x0
  _QWORD *v4; // x1
  __int64 v5; // x2
  int v6; // w0
  __int64 v7; // x1
  __int64 v8; // x1
  char v9; // w2
  __int64 addr_soft; // x0
  __int64 v11; // [xsp+18h] [xbp-8h]

  v1 = *(_DWORD *)(a1 + 8);
  v2 = a1;
  v3 = *(_QWORD *)a1;
  if ( v1 == 6 )
  {
    strcpy(*(_QWORD **)(v2 + 16), *(_QWORD *)(v3 + 912));
    return;
  }
  if ( v1 > 6 )
  {
    switch ( v1 )
    {
      case 10:
        v7 = 0LL;
        if ( *(_QWORD *)(v3 + 1176) )
        {
          v11 = v2;
          addr_soft = dl_tls_get_addr_soft(v3);
          v2 = v11;
          v7 = addr_soft;
        }
        **(_QWORD **)(v2 + 16) = v7;
        break;
      case 11:
        v5 = *(_QWORD *)(v3 + 752);
        v6 = *(unsigned __int16 *)(v3 + 768);
        **(_QWORD **)(v2 + 16) = v5;
        *(_DWORD *)(v2 + 24) = v6;
        break;
      case 9:
        v4 = *(_QWORD **)(v2 + 16);
        *v4 = 0LL;
        *v4 = *(_QWORD *)(v3 + 1176);
        break;
      default:
        goto LABEL_21;
    }
    return;
  }
  if ( v1 == 4 )
  {
    v8 = *(_QWORD *)(v2 + 16);
    v9 = 0;
    goto LABEL_19;
  }
  if ( v1 == 5 )
  {
    v8 = *(_QWORD *)(v2 + 16);
    v9 = 1;
LABEL_19:
    dl_rtld_di_serinfo((__int64 *)v3, v8, v9);
    return;
  }
  if ( v1 != 1 )
  {
    if ( v1 == 2 )
    {
      **(_QWORD **)(v2 + 16) = v3;
      return;
    }
LABEL_21:
    *(_DWORD *)(v2 + 24) = -1;
    dl_signal_error(0, 0LL, 0LL, "unsupported dlinfo request");
  }
  **(_QWORD **)(v2 + 16) = *(_QWORD *)(v3 + 48);
}

//----- (000000000044970C) ----------------------------------------------------
__int64 __fastcall dlinfo(
        __int64 a1,
        int a2,
        __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        __int64 a12,
        __int64 a13,
        __int64 a14,
        __int64 a15,
        __int64 a16)
{
  __int64 v17; // [xsp+0h] [xbp+0h] BYREF
  __int64 v18; // [xsp+10h] [xbp+10h] BYREF
  int v19; // [xsp+18h] [xbp+18h]
  int v20; // [xsp+1Ch] [xbp+1Ch]
  __int64 v21; // [xsp+20h] [xbp+20h]
  unsigned int v22; // [xsp+28h] [xbp+28h]
  int v23; // [xsp+2Ch] [xbp+2Ch]

  v18 = a1;
  v19 = a2;
  v20 = 0;
  v22 = 0;
  v21 = a3;
  v23 = 0;
  dlerror_run(dlinfo_doit, (__int64)&v18, a4, a5, a6, a7, a8, a9, a10, a11, a3, (__int64)&v17 + 4, a13, a14, a15, a16);
  return v22;
}

//----- (0000000000449760) ----------------------------------------------------
ssize_t __fastcall dlmopen_doit(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 *v10; // x0
  ssize_t result; // x0

  if ( *(_QWORD *)a1 )
    dl_signal_error(0x16u, 0LL, 0LL, "invalid namespace");
  v10 = *(__int64 **)(a1 + 8);
  if ( !v10 )
    v10 = &qword_454610;
  result = dl_open(
             (__int64)v10,
             *(_DWORD *)(a1 + 16) | 0x80000000,
             *(_QWORD *)(a1 + 32),
             0LL,
             (unsigned int)_libc_argc,
             (void *)_libc_argv,
             environ,
             a2,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9);
  *(_QWORD *)(a1 + 24) = result;
  return result;
}
// 454610: using guessed type __int64 qword_454610;
// 496D08: using guessed type int _libc_argc;
// 496D10: using guessed type __int64 _libc_argv;

//----- (00000000004497E4) ----------------------------------------------------
__int64 __fastcall _dlmopen(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  bool v16; // zf
  __int64 result; // x0
  _QWORD v18[2]; // [xsp+18h] [xbp+18h] BYREF
  int v19; // [xsp+28h] [xbp+28h]
  __int64 v20; // [xsp+30h] [xbp+30h]

  v18[0] = a1;
  v18[1] = a2;
  v19 = a3;
  v16 = (unsigned int)dlerror_run(
                        (void (__fastcall *)(__int64))dlmopen_doit,
                        (__int64)v18,
                        a9,
                        a10,
                        a11,
                        a12,
                        a13,
                        a14,
                        a15,
                        a16,
                        a3,
                        a4,
                        a5,
                        a6,
                        a7,
                        a8) == 0;
  result = v20;
  if ( !v16 )
    return 0LL;
  return result;
}

//----- (0000000000449820) ----------------------------------------------------
__int64 __fastcall dlmopen(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  bool v16; // zf
  __int64 result; // x0
  _QWORD v18[2]; // [xsp+18h] [xbp+18h] BYREF
  int v19; // [xsp+28h] [xbp+28h]
  __int64 v20; // [xsp+30h] [xbp+30h]

  v18[0] = a1;
  v18[1] = a2;
  v19 = a3;
  v16 = (unsigned int)dlerror_run(
                        (void (__fastcall *)(__int64))dlmopen_doit,
                        (__int64)v18,
                        a9,
                        a10,
                        a11,
                        a12,
                        a13,
                        a14,
                        a15,
                        a16,
                        a3,
                        a4,
                        a5,
                        a6,
                        a7,
                        a8) == 0;
  result = v20;
  if ( !v16 )
    return 0LL;
  return result;
}

//----- (0000000000449860) ----------------------------------------------------
ssize_t __fastcall dlopen_doit(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  int v9; // w1
  __int64 *v11; // x0
  __int64 v12; // x1
  ssize_t result; // x0
  unsigned __int64 *v14; // x0

  v9 = *(_DWORD *)(a1 + 8);
  if ( (v9 & 0xBFFFEEF0) != 0 )
  {
    v14 = dcgettext((unsigned __int64 *)"libc", (unsigned __int64 *)"invalid mode parameter", 5u);
    dl_signal_error(0, 0LL, 0LL, (const char *)v14);
  }
  v11 = *(__int64 **)a1;
  v12 = v9 | 0x80000000;
  if ( !*(_QWORD *)a1 )
    v11 = &qword_454610;
  result = dl_open(
             (__int64)v11,
             v12,
             *(_QWORD *)(a1 + 24),
             0LL,
             (unsigned int)_libc_argc,
             (void *)_libc_argv,
             environ,
             a2,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}
// 454610: using guessed type __int64 qword_454610;
// 496D08: using guessed type int _libc_argc;
// 496D10: using guessed type __int64 _libc_argv;

//----- (0000000000449900) ----------------------------------------------------
__int64 __fastcall _dlopen(
        __int64 a1,
        int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  bool v16; // zf
  __int64 result; // x0
  __int64 v18; // [xsp+10h] [xbp+10h] BYREF
  int v19; // [xsp+18h] [xbp+18h]
  __int64 v20; // [xsp+20h] [xbp+20h]
  __int64 v21; // [xsp+28h] [xbp+28h]

  v18 = a1;
  v19 = a2;
  v21 = a3;
  v16 = (unsigned int)dlerror_run(
                        (void (__fastcall *)(__int64))dlopen_doit,
                        (__int64)&v18,
                        a9,
                        a10,
                        a11,
                        a12,
                        a13,
                        a14,
                        a15,
                        a16,
                        a3,
                        a4,
                        a5,
                        a6,
                        a7,
                        a8) == 0;
  result = v20;
  if ( !v16 )
    return 0LL;
  return result;
}

//----- (0000000000449940) ----------------------------------------------------
__int64 __fastcall dlopen(
        __int64 a1,
        int a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        __int64 a6,
        __int64 a7,
        __int64 a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15,
        double a16)
{
  bool v16; // zf
  __int64 result; // x0
  __int64 v18; // [xsp+10h] [xbp+10h] BYREF
  int v19; // [xsp+18h] [xbp+18h]
  __int64 v20; // [xsp+20h] [xbp+20h]

  v18 = a1;
  v19 = a2;
  v16 = (unsigned int)dlerror_run(
                        (void (__fastcall *)(__int64))dlopen_doit,
                        (__int64)&v18,
                        a9,
                        a10,
                        a11,
                        a12,
                        a13,
                        a14,
                        a15,
                        a16,
                        a3,
                        a4,
                        a5,
                        a6,
                        a7,
                        a8) == 0;
  result = v20;
  if ( !v16 )
    return 0LL;
  return result;
}

//----- (0000000000449980) ----------------------------------------------------
__int64 __fastcall dlsym_doit(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 result; // x0

  result = dl_sym(*(_QWORD *)a1, *(const char **)(a1 + 8), *(_QWORD *)(a1 + 16), a2, a3, a4, a5, a6, a7, a8, a9);
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

//----- (00000000004499AC) ----------------------------------------------------
__int64 __fastcall _dlsym(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        void *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  __int64 v15; // x2
  __int64 v16; // x3
  __int64 v17; // x4
  __int64 v18; // x5
  __int64 v19; // x6
  __int64 v20; // x7
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  bool v29; // zf
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  __int64 v38; // x19
  _QWORD v40[4]; // [xsp+20h] [xbp+20h] BYREF

  v40[0] = a1;
  v40[1] = a2;
  v40[2] = a3;
  pthread_mutex_lock(dl_load_lock, a8, a9, a10, a11, a12, a13, a14, a15, a2, a3, a4, a5, a6, a7);
  v29 = (unsigned int)dlerror_run(
                        (void (__fastcall *)(__int64))dlsym_doit,
                        (__int64)v40,
                        v21,
                        v22,
                        v23,
                        v24,
                        v25,
                        v26,
                        v27,
                        v28,
                        v15,
                        v16,
                        v17,
                        v18,
                        v19,
                        v20) == 0;
  v38 = v40[3];
  if ( !v29 )
    v38 = 0LL;
  pthread_mutex_unlock(dl_load_lock, v30, v31, v32, v33, v34, v35, v36, v37);
  return v38;
}
// 4499D8: variable 'v21' is possibly undefined
// 4499D8: variable 'v22' is possibly undefined
// 4499D8: variable 'v23' is possibly undefined
// 4499D8: variable 'v24' is possibly undefined
// 4499D8: variable 'v25' is possibly undefined
// 4499D8: variable 'v26' is possibly undefined
// 4499D8: variable 'v27' is possibly undefined
// 4499D8: variable 'v28' is possibly undefined
// 4499D8: variable 'v15' is possibly undefined
// 4499D8: variable 'v16' is possibly undefined
// 4499D8: variable 'v17' is possibly undefined
// 4499D8: variable 'v18' is possibly undefined
// 4499D8: variable 'v19' is possibly undefined
// 4499D8: variable 'v20' is possibly undefined
// 4499F0: variable 'v30' is possibly undefined
// 4499F0: variable 'v31' is possibly undefined
// 4499F0: variable 'v32' is possibly undefined
// 4499F0: variable 'v33' is possibly undefined
// 4499F0: variable 'v34' is possibly undefined
// 4499F0: variable 'v35' is possibly undefined
// 4499F0: variable 'v36' is possibly undefined
// 4499F0: variable 'v37' is possibly undefined
// 490F90: using guessed type int dl_load_lock[12];

//----- (0000000000449A04) ----------------------------------------------------
__int64 __fastcall dlsym(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        void *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  __int64 v15; // x2
  __int64 v16; // x3
  __int64 v17; // x4
  __int64 v18; // x5
  __int64 v19; // x6
  __int64 v20; // x7
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  bool v29; // zf
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  __int64 v38; // x19
  _QWORD v40[4]; // [xsp+20h] [xbp+20h] BYREF

  v40[0] = a1;
  v40[1] = a2;
  pthread_mutex_lock(dl_load_lock, a8, a9, a10, a11, a12, a13, a14, a15, a2, a3, a4, a5, a6, a7);
  v29 = (unsigned int)dlerror_run(
                        (void (__fastcall *)(__int64))dlsym_doit,
                        (__int64)v40,
                        v21,
                        v22,
                        v23,
                        v24,
                        v25,
                        v26,
                        v27,
                        v28,
                        v15,
                        v16,
                        v17,
                        v18,
                        v19,
                        v20) == 0;
  v38 = v40[3];
  if ( !v29 )
    v38 = 0LL;
  pthread_mutex_unlock(dl_load_lock, v30, v31, v32, v33, v34, v35, v36, v37);
  return v38;
}
// 449A34: variable 'v21' is possibly undefined
// 449A34: variable 'v22' is possibly undefined
// 449A34: variable 'v23' is possibly undefined
// 449A34: variable 'v24' is possibly undefined
// 449A34: variable 'v25' is possibly undefined
// 449A34: variable 'v26' is possibly undefined
// 449A34: variable 'v27' is possibly undefined
// 449A34: variable 'v28' is possibly undefined
// 449A34: variable 'v15' is possibly undefined
// 449A34: variable 'v16' is possibly undefined
// 449A34: variable 'v17' is possibly undefined
// 449A34: variable 'v18' is possibly undefined
// 449A34: variable 'v19' is possibly undefined
// 449A34: variable 'v20' is possibly undefined
// 449A4C: variable 'v30' is possibly undefined
// 449A4C: variable 'v31' is possibly undefined
// 449A4C: variable 'v32' is possibly undefined
// 449A4C: variable 'v33' is possibly undefined
// 449A4C: variable 'v34' is possibly undefined
// 449A4C: variable 'v35' is possibly undefined
// 449A4C: variable 'v36' is possibly undefined
// 449A4C: variable 'v37' is possibly undefined
// 490F90: using guessed type int dl_load_lock[12];

//----- (0000000000449A60) ----------------------------------------------------
__int64 __fastcall dlvsym_doit(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 result; // x0

  result = dl_vsym(
             *(_QWORD *)a1,
             *(const char **)(a1 + 8),
             *(const char **)(a1 + 16),
             *(_QWORD *)(a1 + 24),
             a2,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

//----- (0000000000449A8C) ----------------------------------------------------
__int64 __fastcall _dlvsym(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        void *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  __int64 v15; // x2
  __int64 v16; // x3
  __int64 v17; // x4
  __int64 v18; // x5
  __int64 v19; // x6
  __int64 v20; // x7
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  bool v29; // zf
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  __int64 v38; // x19
  _QWORD v40[6]; // [xsp+20h] [xbp+20h] BYREF

  v40[0] = a1;
  v40[1] = a2;
  v40[2] = a3;
  v40[3] = a4;
  pthread_mutex_lock(dl_load_lock, a8, a9, a10, a11, a12, a13, a14, a15, a2, a3, a4, a5, a6, a7);
  v29 = (unsigned int)dlerror_run(
                        (void (__fastcall *)(__int64))dlvsym_doit,
                        (__int64)v40,
                        v21,
                        v22,
                        v23,
                        v24,
                        v25,
                        v26,
                        v27,
                        v28,
                        v15,
                        v16,
                        v17,
                        v18,
                        v19,
                        v20) == 0;
  v38 = v40[4];
  if ( !v29 )
    v38 = 0LL;
  pthread_mutex_unlock(dl_load_lock, v30, v31, v32, v33, v34, v35, v36, v37);
  return v38;
}
// 449AB8: variable 'v21' is possibly undefined
// 449AB8: variable 'v22' is possibly undefined
// 449AB8: variable 'v23' is possibly undefined
// 449AB8: variable 'v24' is possibly undefined
// 449AB8: variable 'v25' is possibly undefined
// 449AB8: variable 'v26' is possibly undefined
// 449AB8: variable 'v27' is possibly undefined
// 449AB8: variable 'v28' is possibly undefined
// 449AB8: variable 'v15' is possibly undefined
// 449AB8: variable 'v16' is possibly undefined
// 449AB8: variable 'v17' is possibly undefined
// 449AB8: variable 'v18' is possibly undefined
// 449AB8: variable 'v19' is possibly undefined
// 449AB8: variable 'v20' is possibly undefined
// 449AD0: variable 'v30' is possibly undefined
// 449AD0: variable 'v31' is possibly undefined
// 449AD0: variable 'v32' is possibly undefined
// 449AD0: variable 'v33' is possibly undefined
// 449AD0: variable 'v34' is possibly undefined
// 449AD0: variable 'v35' is possibly undefined
// 449AD0: variable 'v36' is possibly undefined
// 449AD0: variable 'v37' is possibly undefined
// 490F90: using guessed type int dl_load_lock[12];

//----- (0000000000449AE4) ----------------------------------------------------
__int64 __fastcall dlvsym(
        __int64 a1,
        __int64 a2,
        __int64 a3,
        __int64 a4,
        __int64 a5,
        void *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  __int64 v15; // x2
  __int64 v16; // x3
  __int64 v17; // x4
  __int64 v18; // x5
  __int64 v19; // x6
  __int64 v20; // x7
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  bool v29; // zf
  double v30; // d0
  double v31; // d1
  double v32; // d2
  double v33; // d3
  double v34; // d4
  double v35; // d5
  double v36; // d6
  double v37; // d7
  __int64 v38; // x19
  _QWORD v40[6]; // [xsp+20h] [xbp+20h] BYREF

  v40[0] = a1;
  v40[1] = a2;
  v40[2] = a3;
  pthread_mutex_lock(dl_load_lock, a8, a9, a10, a11, a12, a13, a14, a15, a2, a3, a4, a5, a6, a7);
  v29 = (unsigned int)dlerror_run(
                        (void (__fastcall *)(__int64))dlvsym_doit,
                        (__int64)v40,
                        v21,
                        v22,
                        v23,
                        v24,
                        v25,
                        v26,
                        v27,
                        v28,
                        v15,
                        v16,
                        v17,
                        v18,
                        v19,
                        v20) == 0;
  v38 = v40[4];
  if ( !v29 )
    v38 = 0LL;
  pthread_mutex_unlock(dl_load_lock, v30, v31, v32, v33, v34, v35, v36, v37);
  return v38;
}
// 449B14: variable 'v21' is possibly undefined
// 449B14: variable 'v22' is possibly undefined
// 449B14: variable 'v23' is possibly undefined
// 449B14: variable 'v24' is possibly undefined
// 449B14: variable 'v25' is possibly undefined
// 449B14: variable 'v26' is possibly undefined
// 449B14: variable 'v27' is possibly undefined
// 449B14: variable 'v28' is possibly undefined
// 449B14: variable 'v15' is possibly undefined
// 449B14: variable 'v16' is possibly undefined
// 449B14: variable 'v17' is possibly undefined
// 449B14: variable 'v18' is possibly undefined
// 449B14: variable 'v19' is possibly undefined
// 449B14: variable 'v20' is possibly undefined
// 449B2C: variable 'v30' is possibly undefined
// 449B2C: variable 'v31' is possibly undefined
// 449B2C: variable 'v32' is possibly undefined
// 449B2C: variable 'v33' is possibly undefined
// 449B2C: variable 'v34' is possibly undefined
// 449B2C: variable 'v35' is possibly undefined
// 449B2C: variable 'v36' is possibly undefined
// 449B2C: variable 'v37' is possibly undefined
// 490F90: using guessed type int dl_load_lock[12];

//----- (0000000000449B40) ----------------------------------------------------
void __fastcall _libc_dlerror_result_free(
        double a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8)
{
  unsigned __int64 StatusReg; // x2
  unsigned __int64 v9; // x0
  int v10; // w3
  double v11; // d0
  double v12; // d1
  double v13; // d2
  double v14; // d3
  double v15; // d4
  double v16; // d5
  double v17; // d6
  double v18; // d7
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7
  unsigned __int64 v27; // [xsp+10h] [xbp-10h]
  unsigned __int64 v28; // [xsp+10h] [xbp-10h]

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v9 = *(_QWORD *)(StatusReg + 96);
  if ( v9 )
  {
    if ( v9 == -1LL )
    {
      *(_QWORD *)(StatusReg + 96) = 0LL;
    }
    else
    {
      v10 = *(unsigned __int8 *)(v9 + 4);
      if ( v10 == 1 )
      {
        v28 = StatusReg;
        dl_error_free(*(_QWORD *)(v9 + 16), a1, a2, a3, a4, a5, a6, a7, a8);
        free(*(_QWORD *)(v28 + 96), v19, v20, v21, v22, v23, v24, v25, v26);
        *(_QWORD *)(v28 + 96) = 0LL;
      }
      else
      {
        v27 = StatusReg;
        if ( v10 == 2 )
        {
          free(*(_QWORD *)(v9 + 16), a1, a2, a3, a4, a5, a6, a7, a8);
          free(*(_QWORD *)(v27 + 96), v11, v12, v13, v14, v15, v16, v17, v18);
        }
        else
        {
          free(v9, a1, a2, a3, a4, a5, a6, a7, a8);
        }
        *(_QWORD *)(v27 + 96) = 0LL;
      }
    }
  }
}
// 449BB4: variable 'v11' is possibly undefined
// 449BB4: variable 'v12' is possibly undefined
// 449BB4: variable 'v13' is possibly undefined
// 449BB4: variable 'v14' is possibly undefined
// 449BB4: variable 'v15' is possibly undefined
// 449BB4: variable 'v16' is possibly undefined
// 449BB4: variable 'v17' is possibly undefined
// 449BB4: variable 'v18' is possibly undefined
// 449BE0: variable 'v19' is possibly undefined
// 449BE0: variable 'v20' is possibly undefined
// 449BE0: variable 'v21' is possibly undefined
// 449BE0: variable 'v22' is possibly undefined
// 449BE0: variable 'v23' is possibly undefined
// 449BE0: variable 'v24' is possibly undefined
// 449BE0: variable 'v25' is possibly undefined
// 449BE0: variable 'v26' is possibly undefined

//----- (0000000000449C00) ----------------------------------------------------
__int64 __fastcall dl_call_libc_early_init(__int64 result, unsigned int a2)
{
  __int64 *v3; // x20
  unsigned int *v4; // x0
  __int64 v5; // x2

  if ( result )
  {
    v3 = (__int64 *)result;
    v4 = dl_lookup_direct(
           result,
           (unsigned __int64)"__libc_early_init",
           0x69682ACu,
           (unsigned __int64)"GLIBC_PRIVATE",
           157536133);
    if ( !v4 )
      _libc_assert_fail(
        (__int64)"sym != NULL",
        (__int64)"dl-call-libc-early-init.c",
        0x25u,
        (__int64)"_dl_call_libc_early_init");
    if ( *((unsigned __int16 *)v4 + 3) == 65521 )
      v5 = 0LL;
    else
      v5 = *v3;
    return ((__int64 (__fastcall *)(_QWORD))(v5 + *((_QWORD *)v4 + 1)))(a2);
  }
  return result;
}

//----- (0000000000449CA0) ----------------------------------------------------
__int64 __fastcall dl_call_fini(__int64 a1)
{
  __int64 v2; // x0
  __int64 v3; // x19
  __int64 v4; // x20
  void (**v5)(void); // x19
  void (*v6)(void); // t1
  __int64 result; // x0

  if ( (dl_debug_mask & 2) != 0 )
    dl_debug_printf("\ncalling fini: %s [%lu]\n\n", *(const char **)(a1 + 8), *(_QWORD *)(a1 + 48));
  *(_WORD *)(a1 + 868) &= ~0x10u;
  v2 = *(_QWORD *)(a1 + 272);
  if ( v2 )
  {
    v3 = *(_QWORD *)(*(_QWORD *)(a1 + 288) + 8LL) >> 3;
    if ( v3 )
    {
      v4 = *(_QWORD *)a1 + *(_QWORD *)(v2 + 8) - 8LL;
      v5 = (void (**)(void))(v4 + 8 * v3);
      do
      {
        v6 = *v5--;
        v6();
      }
      while ( (void (**)(void))v4 != v5 );
    }
  }
  result = *(_QWORD *)(a1 + 168);
  if ( result )
    return ((__int64 (*)(void))(*(_QWORD *)(result + 8) + *(_QWORD *)a1))();
  return result;
}
// 496C20: using guessed type __int64 dl_debug_mask;

//----- (0000000000449D60) ----------------------------------------------------
__int64 *__fastcall openaux(__int64 a1)
{
  __int64 v1; // x2
  __int64 v3; // x0
  __int64 *result; // x0

  LOBYTE(v1) = 1;
  v3 = *(_QWORD *)a1;
  if ( (*(_WORD *)(v3 + 868) & 3LL) != 0 )
    v1 = HIDWORD(*(_QWORD *)(v3 + 864)) & 3LL;
  result = dl_map_object(
             v3,
             *(unsigned __int8 **)(a1 + 24),
             v1,
             *(_DWORD *)(a1 + 8),
             *(_DWORD *)(a1 + 12),
             *(_QWORD *)(v3 + 48));
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

//----- (0000000000449DAC) ----------------------------------------------------
__int64 __fastcall dl_map_object_deps(
        __int64 a1,
        __int64 a2,
        unsigned int a3,
        int a4,
        __int64 a5,
        __int64 a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14)
{
  __int64 v14; // x6
  __int64 v15; // x7
  __int64 *v17; // x20
  __int64 v18; // x3
  __int64 v19; // x0
  unsigned int v20; // w5
  __int64 v21; // x22
  unsigned __int64 StatusReg; // x0
  unsigned __int64 v23; // x26
  __int64 v24; // x2
  unsigned __int64 v25; // x1
  unsigned int v26; // w25
  _QWORD *v27; // x0
  double v28; // d0
  double v29; // d1
  double v30; // d2
  double v31; // d3
  double v32; // d4
  double v33; // d5
  double v34; // d6
  double v35; // d7
  _QWORD *v36; // x19
  char v37; // w0
  bool v38; // zf
  unsigned __int64 *v39; // x21
  unsigned __int64 v40; // x0
  char *v41; // x19
  __int64 v42; // x1
  unsigned __int64 (__fastcall *v43)(__int64); // x2
  __int64 v44; // x3
  void *v45; // x4
  __int64 v46; // x5
  void *v47; // x6
  __int64 v48; // x7
  double v49; // d0
  double v50; // d1
  double v51; // d2
  double v52; // d3
  double v53; // d4
  double v54; // d5
  double v55; // d6
  double v56; // d7
  __int64 v57; // x0
  unsigned __int8 *v58; // x0
  unsigned int v59; // w19
  __int64 v60; // x0
  unsigned __int64 v61; // t1
  __int64 v62; // x1
  unsigned __int64 (__fastcall *v63)(__int64); // x2
  __int64 v64; // x3
  void *v65; // x4
  __int64 v66; // x5
  void *v67; // x6
  __int64 v68; // x7
  double v69; // d0
  double v70; // d1
  double v71; // d2
  double v72; // d3
  double v73; // d4
  double v74; // d5
  double v75; // d6
  double v76; // d7
  __int64 v77; // x0
  unsigned __int8 *v78; // x0
  __int64 v79; // x0
  unsigned __int64 v80; // x0
  __int64 v81; // x1
  bool v82; // zf
  unsigned __int64 v83; // x3
  __int64 v84; // x4
  unsigned int *v85; // x5
  void *v86; // x6
  unsigned __int64 *v87; // x26
  double v88; // d0
  double v89; // d1
  double v90; // d2
  double v91; // d3
  double v92; // d4
  double v93; // d5
  double v94; // d6
  double v95; // d7
  int v96; // w0
  unsigned int v97; // w2
  unsigned int v98; // w28
  unsigned __int64 *v99; // x23
  __int64 v100; // x1
  unsigned int v101; // w27
  unsigned int *v102; // x7
  __int64 *v103; // x0
  __int64 v104; // t1
  __int64 v105; // x2
  unsigned int *v106; // x22
  _DWORD *v107; // x25
  unsigned int v108; // w21
  __int64 v109; // x0
  unsigned __int64 v110; // x0
  unsigned int v111; // w8
  unsigned int *v112; // x2
  _DWORD *v113; // x0
  unsigned __int16 *v114; // x0
  __int64 v115; // t1
  __int64 v116; // x3
  unsigned __int64 v117; // x1
  __int64 v118; // x2
  unsigned __int64 *v119; // x23
  unsigned __int64 *v120; // x2
  __int64 v121; // x1
  __int64 v122; // x1
  __int64 v123; // x2
  void *v124; // x3
  void *v125; // x4
  void *v126; // x5
  void *v127; // x6
  __int64 v128; // x7
  double v129; // d0
  double v130; // d1
  double v131; // d2
  double v132; // d3
  double v133; // d4
  double v134; // d5
  double v135; // d6
  double v136; // d7
  char v137; // w0
  unsigned __int64 v138; // x0
  __int64 result; // x0
  __int64 *v140; // x0
  __int64 *v141; // x1
  __int64 v142; // x0
  __int64 v143; // x0
  __int64 v144; // x1
  __int64 v145; // x3
  __int64 v146; // x1
  __int64 v147; // x0
  unsigned __int64 origin; // x0
  __int64 *v149; // x1
  __int64 v150; // x0
  unsigned __int64 v151; // x3
  __int64 v152; // x1
  const char *v153; // x2
  unsigned int v154; // w2
  __int64 v155; // [xsp+0h] [xbp-40h] BYREF
  __int64 v156; // [xsp+8h] [xbp-38h]
  __int64 v157; // [xsp+10h] [xbp-30h]
  int v158; // [xsp+20h] [xbp-20h] BYREF
  __int64 v159; // [xsp+28h] [xbp-18h]
  __int64 v160; // [xsp+30h] [xbp-10h]
  __int64 v161; // [xsp+40h] [xbp+0h] BYREF
  __int64 v162; // [xsp+48h] [xbp+8h]
  __int64 *v163; // [xsp+50h] [xbp+10h]
  __int64 v164; // [xsp+58h] [xbp+18h] BYREF
  _BYTE *v165; // [xsp+A8h] [xbp+68h]
  __int64 v166; // [xsp+B0h] [xbp+70h]
  unsigned __int64 v167; // [xsp+B8h] [xbp+78h]
  unsigned int v168; // [xsp+C4h] [xbp+84h]
  __int64 *v169; // [xsp+C8h] [xbp+88h]
  __int64 *v170; // [xsp+D0h] [xbp+90h]
  __int64 *v171; // [xsp+D8h] [xbp+98h]
  unsigned __int64 (__fastcall *v172)(__int64); // [xsp+E0h] [xbp+A0h]
  int v173; // [xsp+E8h] [xbp+A8h]
  int v174; // [xsp+ECh] [xbp+ACh]
  __int64 *v175; // [xsp+F0h] [xbp+B0h]
  __int64 *v176; // [xsp+F8h] [xbp+B8h]
  unsigned int *v177; // [xsp+100h] [xbp+C0h]
  unsigned int *v178; // [xsp+108h] [xbp+C8h]
  const char *v179; // [xsp+110h] [xbp+D0h] BYREF
  __int64 v180; // [xsp+118h] [xbp+D8h]
  __int64 v181; // [xsp+128h] [xbp+E8h] BYREF
  int v182; // [xsp+130h] [xbp+F0h]
  int v183; // [xsp+134h] [xbp+F4h]
  unsigned int *v184; // [xsp+138h] [xbp+F8h]
  void *v185; // [xsp+140h] [xbp+100h]
  __int64 v186; // [xsp+148h] [xbp+108h]
  unsigned __int64 v187[2]; // [xsp+150h] [xbp+110h] BYREF
  _BYTE v188[1024]; // [xsp+160h] [xbp+120h] BYREF

  v14 = 24LL;
  v15 = 1LL;
  v17 = &v161;
  v173 = a5;
  v174 = a4;
  v18 = (__int64)&v164;
  LODWORD(v161) = 0;
  v162 = a1;
  v163 = &v164;
  *(_WORD *)(a1 + 868) = *(_WORD *)(a1 + 868) & 0xFF3F | 0x40;
  if ( a3 )
  {
    v19 = 0LL;
    do
    {
      v20 = v19 + 2;
      *(_DWORD *)v18 = 0;
      a5 = *(_QWORD *)(a2 + 8 * v19++);
      v18 += 24LL;
      *(_QWORD *)(v18 - 16) = a5;
      *(_QWORD *)(v18 - 8) = &v161 + 3 * v20;
      a6 = *(_WORD *)(a5 + 868) & 0xFF3F | 0x40u;
      *(_WORD *)(a5 + 868) = *(_WORD *)(a5 + 868) & 0xFF3F | 0x40;
    }
    while ( a3 != v19 );
    v21 = v162;
    LODWORD(v177) = a3 + 1;
    v176 = &v161 + 3 * a3;
  }
  else
  {
    v21 = a1;
    v176 = &v161;
    LODWORD(v177) = 1;
  }
  v171 = &v161;
  v176[2] = 0LL;
  v165 = v188;
  v166 = 40LL;
  v187[0] = (unsigned __int64)v188;
  v187[1] = 1024LL;
  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v23 = *(_QWORD *)(v21 + 776);
  v167 = StatusReg;
  v24 = *(unsigned int *)(StatusReg + 40);
  *(_DWORD *)(StatusReg + 40) = 0;
  v25 = (unsigned __int64)v171;
  v168 = v24;
  v170 = &dl_debug_mask;
  *(_DWORD *)v171 = 1;
  if ( !v23 )
    goto LABEL_15;
LABEL_6:
  v23 = 0LL;
  while ( !*(_QWORD *)(v21 + 72) )
  {
    if ( *(_QWORD *)(v21 + 560) )
      break;
    v26 = 0;
    if ( *(_QWORD *)(v21 + 544) )
      break;
LABEL_10:
    if ( v23 )
    {
      *(_QWORD *)(v23 + 8LL * v26) = 0LL;
      v27 = (_QWORD *)malloc(
                        8LL * (2 * (v26 + 1) + 1),
                        v25,
                        v24,
                        (void *)v18,
                        (void *)a5,
                        (void *)a6,
                        (void *)v14,
                        v15,
                        a7,
                        a8,
                        a9,
                        a10,
                        a11,
                        a12,
                        a13,
                        a14);
      v36 = v27;
      if ( !v27 )
      {
        if ( (_BYTE *)v187[0] != v165 )
          free(v187[0], v28, v29, v30, v31, v32, v33, v34, v35);
        dl_signal_error(0xCu, *(_QWORD *)(a1 + 8), 0LL, "cannot allocate dependency list");
      }
      *v27 = v21;
      j_memcpy();
      j_memcpy();
      __dmb(0xBu);
      v37 = *(_BYTE *)(v21 + 870);
      *(_QWORD *)(v21 + 1032) = v36;
      *(_BYTE *)(v21 + 870) = v37 | 0x10;
    }
    if ( *(_DWORD *)v171 )
    {
      while ( 1 )
      {
        v140 = (__int64 *)v171[2];
        v171 = v140;
        if ( !v140 )
          break;
        if ( !*(_DWORD *)v140 )
          goto LABEL_14;
      }
      v59 = 0;
      goto LABEL_57;
    }
LABEL_14:
    v25 = (unsigned __int64)v171;
    v21 = v171[1];
    v23 = *(_QWORD *)(v21 + 776);
    *(_DWORD *)v171 = 1;
    if ( v23 )
      goto LABEL_6;
LABEL_15:
    if ( *(_QWORD *)(v21 + 1032) )
      v38 = 1;
    else
      v38 = a1 == v21;
    if ( !v38 )
    {
      v25 = *(unsigned __int16 *)(v21 + 770);
      if ( *(_WORD *)(v21 + 770) )
      {
        if ( (_libc_scratch_buffer_set_array_size(
                v187,
                v25,
                8LL,
                (void *)v18,
                (void *)a5,
                (void *)a6,
                (void *)v14,
                v15,
                a7,
                a8,
                a9,
                a10,
                a11,
                a12,
                a13,
                a14) & 1) == 0 )
          dl_signal_error(0xCu, *(_QWORD *)(a1 + 8), 0LL, "cannot allocate dependency buffer");
        v23 = v187[0];
      }
    }
  }
  v25 = *(_QWORD *)(*(_QWORD *)(v21 + 104) + 8LL);
  v178 = (unsigned int *)v25;
  if ( (*(_BYTE *)(v21 + 870) & 0x20) != 0 )
    v178 = (unsigned int *)(v25 + *(_QWORD *)v21);
  v39 = *(unsigned __int64 **)(v21 + 16);
  v181 = v21;
  v184 = v178;
  v182 = v174;
  v183 = v173;
  v40 = *v39;
  if ( !*v39 )
  {
    v26 = 0;
    goto LABEL_10;
  }
  v169 = v171;
  v175 = &v181;
  v26 = 0;
  if ( v40 != 1 )
  {
    while ( 1 )
    {
      v25 = 2147483645LL;
      if ( (v40 & 0xFFFFFFFFFFFFFFFDLL) == 0x7FFFFFFD )
        break;
LABEL_37:
      v61 = v39[2];
      v39 += 2;
      v40 = v61;
      if ( !v61 )
        goto LABEL_10;
      if ( v40 == 1 )
        goto LABEL_26;
    }
    v41 = (char *)v178 + v39[1];
    if ( !dl_dst_count((__int64)v41) )
    {
LABEL_115:
      v185 = v41;
      if ( (dl_debug_mask & 1) != 0 )
      {
        v153 = *(const char **)(v21 + 8);
        if ( !*v153 )
        {
          v153 = (const char *)program_invocation_short_name[0];
          if ( !program_invocation_short_name[0] )
            v153 = "<main program>";
        }
        dl_debug_printf("load auxiliary object=%s requested by file=%s\n", v41, v153);
      }
      v59 = dl_catch_exception(&v179, (void (__fastcall *)(__int64))openaux, (__int64)&v181, v18, a5, a6, v14, v15);
      if ( v180 )
      {
        if ( *v39 != 2147483645 )
          goto LABEL_55;
        dl_exception_free(&v179, a7, a8, a9, a10, a11, a12, a13, a14);
        goto LABEL_37;
      }
      v141 = v169;
      v24 = (__int64)&v155;
      a5 = *v169;
      a6 = v169[1];
      v142 = v169[2];
      v155 = *v169;
      v156 = a6;
      v157 = v142;
      v143 = v186;
      *(_DWORD *)v169 = 0;
      v141[1] = v143;
      if ( v23 )
      {
        *(_QWORD *)(v23 + 8LL * v26++) = v143;
        v143 = v186;
      }
      if ( (*(_WORD *)(v143 + 868) & 0xC0) != 0 )
      {
        v149 = &v155;
        do
        {
          a5 = (__int64)v149;
          v149 = (__int64 *)v149[2];
          if ( !v149 )
          {
            v25 = (unsigned __int64)v169;
            a5 = v155;
            a6 = v156;
            v150 = v157;
            *v169 = v155;
            *(_QWORD *)(v25 + 8) = a6;
            *(_QWORD *)(v25 + 16) = v150;
            goto LABEL_37;
          }
          v18 = v149[1];
        }
        while ( v18 != v143 );
        v151 = (unsigned __int64)v176;
        v169[2] = (__int64)&v155;
        v152 = *(_QWORD *)(a5 + 16);
        v38 = v152 == v151;
        *(_QWORD *)(a5 + 16) = *(_QWORD *)(v152 + 16);
        v144 = *(_QWORD *)(v143 + 32);
        if ( v38 )
          v151 = a5;
        v176 = (__int64 *)v151;
        if ( !v144 )
          goto LABEL_122;
      }
      else
      {
        v169[2] = (__int64)&v155;
        LODWORD(v177) = (_DWORD)v177 + 1;
        *(_WORD *)(v143 + 868) = *(_WORD *)(v143 + 868) & 0xFF3F | 0x40;
        v144 = *(_QWORD *)(v143 + 32);
        if ( !v144 )
        {
LABEL_122:
          v145 = *(_QWORD *)(v143 + 24);
          if ( v145 )
            *(_QWORD *)(v145 + 32) = v144;
          v146 = v156;
          *(_QWORD *)(v143 + 32) = *(_QWORD *)(v156 + 32);
          *(_QWORD *)(v146 + 32) = v143;
          v18 = *(_QWORD *)(v143 + 32);
          if ( v18 )
            *(_QWORD *)(v18 + 24) = v143;
          *(_QWORD *)(v143 + 24) = v146;
          v25 = (unsigned __int64)v169;
          if ( v176 == v169 )
          {
            v169 = &v155;
            v176 = &v155;
          }
          else
          {
            v169 = &v155;
          }
          goto LABEL_37;
        }
      }
      *(_QWORD *)(v144 + 24) = *(_QWORD *)(v143 + 24);
      goto LABEL_122;
    }
    if ( _libc_enable_secure )
      goto LABEL_159;
    v63 = strlen();
    v77 = *(_QWORD *)(v21 + 912);
    if ( v77 )
    {
      if ( v77 == -1 )
        goto LABEL_45;
    }
    else
    {
      v147 = **(unsigned __int8 **)(v21 + 8);
      if ( **(_BYTE **)(v21 + 8) )
      {
        v154 = 271;
LABEL_161:
        _libc_assert_fail(
          (__int64)"(l)->l_name[0] == '\\0' || is_rtld_link_map (l)",
          (__int64)"dl-deps.c",
          v154,
          (__int64)"_dl_map_object_deps");
      }
      v172 = v63;
      origin = dl_get_origin(v69, v70, v71, v72, v73, v74, v75, v76, v147, v62, (__int64)v63, v64, v65, v66, v67, v68);
      *(_QWORD *)(v21 + 912) = origin;
      v63 = v172;
      if ( origin - 1 > 0xFFFFFFFFFFFFFFFDLL )
        goto LABEL_45;
    }
    v172 = v63;
    strlen();
LABEL_45:
    v78 = dl_dst_substitute(v21, (unsigned __int8 *)v41, (unsigned __int8 *)&v158);
    if ( !*v78 )
    {
      v25 = *v39;
      if ( *v39 == 2147483645 )
        dl_signal_error(0, (__int64)v41, 0LL, "empty dynamic string token substitution");
      if ( (dl_debug_mask & 1) != 0 )
        goto LABEL_48;
      goto LABEL_37;
    }
    v41 = (char *)v78;
    goto LABEL_115;
  }
LABEL_26:
  v41 = (char *)v178 + v39[1];
  if ( dl_dst_count((__int64)v41) )
  {
    if ( _libc_enable_secure )
LABEL_159:
      dl_signal_error(0, (__int64)v41, 0LL, "DST not allowed in SUID/SGID programs");
    v43 = strlen();
    v57 = *(_QWORD *)(v21 + 912);
    if ( v57 )
    {
      if ( v57 != -1 )
        goto LABEL_30;
    }
    else
    {
      v79 = **(unsigned __int8 **)(v21 + 8);
      if ( **(_BYTE **)(v21 + 8) )
      {
        v154 = 228;
        goto LABEL_161;
      }
      v172 = v43;
      v80 = dl_get_origin(v49, v50, v51, v52, v53, v54, v55, v56, v79, v42, (__int64)v43, v44, v45, v46, v47, v48);
      *(_QWORD *)(v21 + 912) = v80;
      v43 = v172;
      if ( v80 - 1 <= 0xFFFFFFFFFFFFFFFDLL )
      {
LABEL_30:
        v172 = v43;
        strlen();
      }
    }
    v58 = dl_dst_substitute(v21, (unsigned __int8 *)v41, (unsigned __int8 *)&v161);
    v25 = *v58;
    if ( !*v58 )
    {
      if ( (*(_DWORD *)v170 & 1) == 0 )
        goto LABEL_37;
LABEL_48:
      dl_debug_printf("cannot load auxiliary `%s' because of empty dynamic string token substitution\n", v41);
      goto LABEL_37;
    }
  }
  else
  {
    v58 = (unsigned __int8 *)v41;
  }
  v185 = v58;
  v59 = dl_catch_exception(&v179, (void (__fastcall *)(__int64))openaux, (__int64)v175, v18, a5, a6, v14, v15);
  if ( !v180 )
  {
    v60 = v186;
    v25 = *(unsigned __int16 *)(v186 + 868);
    if ( (v25 & 0xC0) == 0 )
    {
      v18 = 1LL;
      v25 = (unsigned __int64)&v158;
      v159 = v186;
      v160 = 0LL;
      v158 = 0;
      v176[2] = (__int64)&v158;
      LODWORD(v177) = (_DWORD)v177 + 1;
      v24 = *(_WORD *)(v60 + 868) & 0xFF3F | 0x40u;
      *(_WORD *)(v60 + 868) = *(_WORD *)(v60 + 868) & 0xFF3F | 0x40;
      v176 = (__int64 *)&v158;
    }
    if ( v23 )
      *(_QWORD *)(v23 + 8LL * v26++) = v60;
    goto LABEL_37;
  }
LABEL_55:
  if ( !v59 )
    v59 = -1;
LABEL_57:
  if ( (_BYTE *)v187[0] != v165 )
    free(v187[0], a7, a8, a9, a10, a11, a12, a13, a14);
  v81 = v166;
  if ( *(_DWORD *)(v167 + v166) )
    v82 = 1;
  else
    v82 = v168 == 0;
  if ( !v82 )
  {
    v24 = v168;
    *(_DWORD *)(v167 + v166) = v168;
  }
  v176 = *(__int64 **)(a1 + 1032);
  if ( v176 )
  {
    if ( (*(_WORD *)(a1 + 868) & 3) == 2 )
    {
      if ( *(_QWORD *)(a1 + 776) )
        _libc_assert_fail(
          (__int64)"map->l_searchlist.r_list == NULL",
          (__int64)"dl-deps.c",
          0x1C8u,
          (__int64)"_dl_map_object_deps");
    }
    else
    {
      v176 = 0LL;
    }
  }
  v87 = (unsigned __int64 *)malloc(
                              8LL * (unsigned int)(2 * (_DWORD)v177 + 1),
                              v81,
                              v24,
                              (void *)v18,
                              (void *)a5,
                              (void *)a6,
                              (void *)v14,
                              v15,
                              a7,
                              a8,
                              a9,
                              a10,
                              a11,
                              a12,
                              a13,
                              a14);
  if ( !v87 )
    dl_signal_error(0xCu, *(_QWORD *)(a1 + 8), 0LL, "cannot allocate symbol search list");
  v96 = (int)v177;
  v97 = 0;
  v98 = -1;
  *(_DWORD *)(a1 + 784) = (_DWORD)v177;
  v99 = &v87[v96 + 1];
  *(_QWORD *)(a1 + 776) = v99;
  while ( 1 )
  {
    v100 = v17[1];
    if ( v174 )
    {
      while ( (*(_WORD *)(v100 + 868) & 0x4000) != 0 )
      {
        --*(_DWORD *)(a1 + 784);
        *(_WORD *)(v100 + 868) &= 0xFF3Fu;
        v17 = (__int64 *)v17[2];
        if ( !v17 )
        {
          v101 = v97;
          goto LABEL_74;
        }
        v100 = v17[1];
      }
    }
    v99[v97] = v100;
    if ( a1 == v100 )
      v98 = v97;
    v101 = v97 + 1;
    *(_WORD *)(v100 + 868) &= 0xFF3Fu;
    v17 = (__int64 *)v17[2];
    if ( !v17 )
      break;
    ++v97;
  }
LABEL_74:
  v102 = *(unsigned int **)(a1 + 1040);
  if ( !v102 )
  {
    v107 = 0LL;
    goto LABEL_94;
  }
  if ( !v101 )
  {
    *(_WORD *)(a1 + 868) &= 0xFF3Fu;
    v105 = *v102;
    if ( (_DWORD)v105 )
    {
LABEL_79:
      v106 = v102 + 2;
      v107 = 0LL;
      v108 = 0;
      v175 = (__int64 *)(v102 + 4);
      do
      {
        while ( (*(_WORD *)(*(_QWORD *)&v106[2 * v108] + 868LL) & 0xC0) == 0 )
        {
          if ( (unsigned int)v105 <= ++v108 )
            goto LABEL_90;
        }
        v109 = *(unsigned int *)(a1 + 1048);
        v178 = v102;
        v110 = malloc(
                 8 * (v109 + 1),
                 v100,
                 v105,
                 (void *)v83,
                 (void *)v84,
                 v85,
                 v86,
                 (__int64)v102,
                 v88,
                 v89,
                 v90,
                 v91,
                 v92,
                 v93,
                 v94,
                 v95);
        v102 = v178;
        v107 = (_DWORD *)v110;
        if ( v110 )
        {
          v177 = v178;
          LODWORD(v178) = v108 + 1;
          j_memcpy();
          v102 = v177;
          v83 = (unsigned int)v178;
          v111 = *v177;
          if ( *v177 <= (unsigned int)v178 )
          {
            *v107 = v108;
            v108 = v83;
          }
          else
          {
            v112 = &v106[2 * v108];
            v85 = (unsigned int *)&v175[v111 - 2 - v108 + (unsigned __int64)v108];
            do
            {
              v83 = *((_QWORD *)v112 + 1);
              v84 = *(unsigned __int16 *)(v83 + 868);
              if ( (v84 & 0xC0) == 0 )
              {
                v113 = &v107[2 * v108++];
                *((_QWORD *)v113 + 1) = v83;
              }
              v112 += 2;
            }
            while ( v85 != v112 );
            *v107 = v108;
            v108 = v111;
          }
        }
        v105 = *v102;
        ++v108;
      }
      while ( (unsigned int)v105 > v108 );
LABEL_90:
      if ( v101 )
      {
        v83 = (unsigned __int64)&v99[v101];
        goto LABEL_92;
      }
    }
    goto LABEL_143;
  }
  v103 = (__int64 *)&v87[v96 + 1];
  v83 = (unsigned __int64)&v99[v101];
  v84 = 1LL;
  do
  {
    v104 = *v103++;
    v100 = v104;
    *(_WORD *)(v104 + 868) = *(_WORD *)(v104 + 868) & 0xFF3F | 0x40;
  }
  while ( (__int64 *)v83 != v103 );
  *(_WORD *)(a1 + 868) &= 0xFF3Fu;
  v105 = *v102;
  if ( (_DWORD)v105 )
    goto LABEL_79;
  v107 = 0LL;
LABEL_92:
  v114 = (unsigned __int16 *)v99;
  do
  {
    v115 = *(_QWORD *)v114;
    v114 += 4;
    *(_WORD *)(v115 + 868) &= 0xFF3Fu;
  }
  while ( (unsigned __int16 *)v83 != v114 );
LABEL_94:
  if ( v98 >= v101 )
LABEL_143:
    _libc_assert_fail((__int64)"map_index < nlist", (__int64)"dl-deps.c", 0x214u, (__int64)"_dl_map_object_deps");
  if ( v98 )
  {
    v116 = 8LL * v98;
    v117 = 0LL;
    *v87 = v99[(unsigned __int64)v116 / 8];
    do
    {
      v87[v117 / 8 + 1] = v99[v117 / 8];
      v117 += 8LL;
    }
    while ( v116 != v117 );
    if ( v98 + 1 < v101 )
    {
      v118 = v98 + 1;
      v119 = &v99[v118];
      v120 = &v87[v118];
      v121 = 0LL;
      do
      {
        v120[v121] = v119[v121];
        ++v121;
      }
      while ( v101 - 2 - v98 + 1LL != v121 );
    }
  }
  else
  {
    j_memcpy();
  }
  dl_sort_maps(v87, v101, (&dl_ns)[21 * *(_QWORD *)(*v87 + 48) + 4] != (__int64 *)*v87, 0);
  v87[v101] = 0LL;
  __dmb(0xBu);
  v137 = *(_BYTE *)(a1 + 870);
  *(_QWORD *)(a1 + 1032) = v87;
  *(_BYTE *)(a1 + 870) = v137 | 0x10;
  if ( v107 )
  {
    __dmb(0xBu);
    v138 = *(_QWORD *)(a1 + 1040);
    *(_QWORD *)(a1 + 1040) = v107;
    dl_scope_free(v138, v129, v130, v131, v132, v133, v134, v135, v136, v122, v123, v124, v125, v126, v127, v128);
  }
  result = (__int64)v176;
  if ( v176 )
    result = dl_scope_free(
               (unsigned __int64)v176,
               v129,
               v130,
               v131,
               v132,
               v133,
               v134,
               v135,
               v136,
               v122,
               v123,
               v124,
               v125,
               v126,
               v127,
               v128);
  if ( v59 )
  {
    if ( v59 == -1 )
      v59 = 0;
    dl_signal_exception(v59, &v179, 0LL);
  }
  return result;
}
// 449F08: variable 'v25' is possibly undefined
// 449F08: variable 'v24' is possibly undefined
// 449F08: variable 'v18' is possibly undefined
// 449F08: variable 'a5' is possibly undefined
// 449F08: variable 'a6' is possibly undefined
// 449F08: variable 'v14' is possibly undefined
// 449F08: variable 'v15' is possibly undefined
// 449F08: variable 'a7' is possibly undefined
// 449F08: variable 'a8' is possibly undefined
// 449F08: variable 'a9' is possibly undefined
// 449F08: variable 'a10' is possibly undefined
// 449F08: variable 'a11' is possibly undefined
// 449F08: variable 'a12' is possibly undefined
// 449F08: variable 'a13' is possibly undefined
// 449F08: variable 'a14' is possibly undefined
// 44A21C: variable 'v49' is possibly undefined
// 44A21C: variable 'v50' is possibly undefined
// 44A21C: variable 'v51' is possibly undefined
// 44A21C: variable 'v52' is possibly undefined
// 44A21C: variable 'v53' is possibly undefined
// 44A21C: variable 'v54' is possibly undefined
// 44A21C: variable 'v55' is possibly undefined
// 44A21C: variable 'v56' is possibly undefined
// 44A21C: variable 'v42' is possibly undefined
// 44A21C: variable 'v44' is possibly undefined
// 44A21C: variable 'v45' is possibly undefined
// 44A21C: variable 'v46' is possibly undefined
// 44A21C: variable 'v47' is possibly undefined
// 44A21C: variable 'v48' is possibly undefined
// 44A3B0: variable 'v100' is possibly undefined
// 44A3B0: variable 'v83' is possibly undefined
// 44A3B0: variable 'v84' is possibly undefined
// 44A3B0: variable 'v85' is possibly undefined
// 44A3B0: variable 'v86' is possibly undefined
// 44A3B0: variable 'v88' is possibly undefined
// 44A3B0: variable 'v89' is possibly undefined
// 44A3B0: variable 'v90' is possibly undefined
// 44A3B0: variable 'v91' is possibly undefined
// 44A3B0: variable 'v92' is possibly undefined
// 44A3B0: variable 'v93' is possibly undefined
// 44A3B0: variable 'v94' is possibly undefined
// 44A3B0: variable 'v95' is possibly undefined
// 44A554: variable 'v129' is possibly undefined
// 44A554: variable 'v130' is possibly undefined
// 44A554: variable 'v131' is possibly undefined
// 44A554: variable 'v132' is possibly undefined
// 44A554: variable 'v133' is possibly undefined
// 44A554: variable 'v134' is possibly undefined
// 44A554: variable 'v135' is possibly undefined
// 44A554: variable 'v136' is possibly undefined
// 44A554: variable 'v122' is possibly undefined
// 44A554: variable 'v123' is possibly undefined
// 44A554: variable 'v124' is possibly undefined
// 44A554: variable 'v125' is possibly undefined
// 44A554: variable 'v126' is possibly undefined
// 44A554: variable 'v127' is possibly undefined
// 44A554: variable 'v128' is possibly undefined
// 44A74C: variable 'v69' is possibly undefined
// 44A74C: variable 'v70' is possibly undefined
// 44A74C: variable 'v71' is possibly undefined
// 44A74C: variable 'v72' is possibly undefined
// 44A74C: variable 'v73' is possibly undefined
// 44A74C: variable 'v74' is possibly undefined
// 44A74C: variable 'v75' is possibly undefined
// 44A74C: variable 'v76' is possibly undefined
// 44A74C: variable 'v62' is possibly undefined
// 44A74C: variable 'v64' is possibly undefined
// 44A74C: variable 'v65' is possibly undefined
// 44A74C: variable 'v66' is possibly undefined
// 44A74C: variable 'v67' is possibly undefined
// 44A74C: variable 'v68' is possibly undefined
// 44A958: variable 'v28' is possibly undefined
// 44A958: variable 'v29' is possibly undefined
// 44A958: variable 'v30' is possibly undefined
// 44A958: variable 'v31' is possibly undefined
// 44A958: variable 'v32' is possibly undefined
// 44A958: variable 'v33' is possibly undefined
// 44A958: variable 'v34' is possibly undefined
// 44A958: variable 'v35' is possibly undefined
// 4914A8: using guessed type __int64 *dl_ns;
// 491570: using guessed type int _libc_enable_secure;
// 491928: using guessed type __int64 *program_invocation_short_name[2];
// 496C20: using guessed type __int64 dl_debug_mask;
// 496C58: using guessed type __int64 dl_platformlen;

//----- (000000000044A980) ----------------------------------------------------
__int64 __fastcall call_init(__int64 a1, unsigned int a2, __int64 a3, __int64 a4)
{
  __int64 result; // x0
  const char *v9; // x1
  __int64 v10; // x0
  __int64 v11; // x23
  __int64 (__fastcall **v12)(_QWORD, __int64, __int64); // x4
  __int64 (__fastcall **v13)(_QWORD, __int64, __int64); // x19
  __int64 v14; // x23

  result = *(_QWORD *)(a1 + 40);
  if ( result == a1 )
  {
    result = *(unsigned __int16 *)(result + 868);
    if ( (result & 8) == 0 && (result & 3) != 0 )
      _libc_assert_fail(
        (__int64)"l->l_relocated || l->l_type == lt_executable",
        (__int64)"dl-init.c",
        0x23u,
        (__int64)"call_init");
    if ( (result & 0x10) == 0 )
    {
      v9 = *(const char **)(a1 + 8);
      result = *(unsigned __int16 *)(a1 + 868) | 0x10u;
      *(_WORD *)(a1 + 868) |= 0x10u;
      if ( *v9 )
      {
        if ( (dl_debug_mask & 2) == 0 )
        {
LABEL_7:
          v10 = *(_QWORD *)(a1 + 160);
          if ( v10 )
            ((void (__fastcall *)(_QWORD, __int64, __int64))(*(_QWORD *)a1 + *(_QWORD *)(v10 + 8)))(a2, a3, a4);
          result = *(_QWORD *)(a1 + 264);
          if ( result )
          {
            v11 = *(_QWORD *)(*(_QWORD *)(a1 + 280) + 8LL) >> 3;
            if ( (_DWORD)v11 )
            {
              v12 = (__int64 (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)(result + 8) + *(_QWORD *)a1);
              v13 = v12 + 1;
              v14 = (__int64)&v12[(unsigned int)(v11 - 1) + 1];
              while ( 1 )
              {
                result = (*v12)(a2, a3, a4);
                v12 = v13;
                if ( v13 == (__int64 (__fastcall **)(_QWORD, __int64, __int64))v14 )
                  break;
                ++v13;
              }
            }
          }
          return result;
        }
      }
      else
      {
        if ( (result & 3) == 0 )
          return result;
        if ( (dl_debug_mask & 2) == 0 )
          goto LABEL_7;
        v9 = (const char *)program_invocation_short_name[0];
        if ( !program_invocation_short_name[0] )
          v9 = "<main program>";
      }
      dl_debug_printf("\ncalling init: %s\n\n", v9);
      goto LABEL_7;
    }
  }
  return result;
}
// 44AB04: using guessed type __int64 dl_init(void);
// 491928: using guessed type __int64 *program_invocation_short_name[2];
// 496C20: using guessed type __int64 dl_debug_mask;

//----- (000000000044AB04) ----------------------------------------------------
void (__fastcall **__fastcall dl_init(__int64 a1, unsigned int a2, __int64 a3, __int64 a4))(_QWORD, __int64, __int64)
{
  __int64 v8; // x4
  __int64 v9; // x5
  void (__fastcall **result)(_QWORD, __int64, __int64); // x0
  bool v11; // zf
  int v12; // w19
  __int64 v13; // x19
  __int64 v14; // x0
  __int64 v15; // x19
  unsigned int v16; // w1
  void (__fastcall **v17)(_QWORD, __int64, __int64); // x19
  __int64 v18; // x24
  const char *v19; // x1
  __int64 v20; // [xsp+40h] [xbp+40h]
  __int64 v21; // [xsp+40h] [xbp+40h]
  __int64 v22; // [xsp+48h] [xbp+48h]

  v9 = *(_QWORD *)(a1 + 320);
  v8 = *(_QWORD *)(a1 + 328);
  result = (void (__fastcall **)(_QWORD, __int64, __int64))dl_initfirst;
  if ( dl_initfirst )
  {
    v20 = v9;
    v22 = v8;
    result = (void (__fastcall **)(_QWORD, __int64, __int64))call_init(dl_initfirst, a2, a3, a4);
    v9 = v20;
    v8 = v22;
    dl_initfirst = 0LL;
  }
  if ( v9 )
    v11 = v8 == 0;
  else
    v11 = 1;
  if ( !v11 )
  {
    v15 = *(_QWORD *)(v8 + 8) >> 3;
    if ( (_DWORD)v15 )
    {
      if ( (dl_debug_mask & 2) != 0 )
      {
        v19 = *(const char **)(a1 + 8);
        if ( !*v19 )
        {
          v19 = (const char *)program_invocation_short_name[0];
          if ( !program_invocation_short_name[0] )
            v19 = "<main program>";
        }
        v21 = v9;
        dl_debug_printf("\ncalling preinit: %s\n\n", v19);
        v9 = v21;
      }
      result = (void (__fastcall **)(_QWORD, __int64, __int64))(*(_QWORD *)(v9 + 8) + *(_QWORD *)a1);
      v16 = v15 - 1;
      v17 = result + 1;
      v18 = (__int64)&result[v16 + 1];
      while ( 1 )
      {
        (*result)(a2, a3, a4);
        result = v17;
        if ( (void (__fastcall **)(_QWORD, __int64, __int64))v18 == v17 )
          break;
        ++v17;
      }
    }
  }
  v12 = *(_DWORD *)(a1 + 784);
  if ( v12 )
  {
    v13 = 8LL * (unsigned int)(v12 - 1);
    do
    {
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 1032) + v13);
      v13 -= 8LL;
      result = (void (__fastcall **)(_QWORD, __int64, __int64))call_init(v14, a2, a3, a4);
    }
    while ( v13 != -8 );
  }
  return result;
}
// 491928: using guessed type __int64 *program_invocation_short_name[2];
// 496C20: using guessed type __int64 dl_debug_mask;
// 496CB8: using guessed type __int64 dl_initfirst;

//----- (000000000044AC60) ----------------------------------------------------
unsigned int *__fastcall check_match_0(__int64 *a1, unsigned __int64 a2, unsigned __int64 a3, int a4, unsigned int a5)
{
  __int64 v5; // x6
  __int64 v6; // x5
  unsigned int *v7; // x19
  int v8; // w6
  __int64 v13; // x2

  v5 = *(_QWORD *)(a1[14] + 8);
  v6 = 0LL;
  if ( (*((_BYTE *)a1 + 870) & 0x20) != 0 )
  {
    v6 = *a1;
    v5 += *a1;
  }
  v7 = (unsigned int *)(v5 + 24LL * a5);
  v8 = v7[1] & 0xF;
  if ( !*((_QWORD *)v7 + 1) && *((unsigned __int16 *)v7 + 3) != 65521 && v8 != 6 )
    return 0LL;
  if ( ((-1128 >> v8) & 1) != 0 )
    return 0LL;
  if ( (unsigned int)strcmp((unsigned __int64 *)(v6 + *(_QWORD *)(a1[13] + 8) + *v7), a2) )
    return 0LL;
  v13 = a1[102];
  if ( *(_DWORD *)(v13 + 24LL * (*(_WORD *)(a1[113] + 2LL * a5) & 0x7FFF) + 8) != a4 )
    return 0LL;
  if ( (unsigned int)strcmp(*(unsigned __int64 **)(v13 + 24LL * (*(_WORD *)(a1[113] + 2LL * a5) & 0x7FFF)), a3) )
    return 0LL;
  return v7;
}

//----- (000000000044AD80) ----------------------------------------------------
unsigned int *__fastcall dl_lookup_direct(
        __int64 a1,
        unsigned __int64 a2,
        unsigned int a3,
        unsigned __int64 a4,
        int a5)
{
  unsigned __int8 *v5; // x22
  unsigned int *result; // x0
  unsigned int v11; // w19
  __int64 v12; // x25
  int *i; // x19
  int v14; // w20
  unsigned int v15; // w2
  __int64 v16; // x2
  unsigned __int8 *v17; // x3
  unsigned int v18; // t1
  unsigned int j; // w19

  v5 = (unsigned __int8 *)a2;
  result = *(unsigned int **)(a1 + 840);
  if ( result )
  {
    v11 = *(_DWORD *)(*(_QWORD *)(a1 + 848) + 4LL * (a3 % *(_DWORD *)(a1 + 828)));
    result = 0LL;
    if ( v11 )
    {
      v12 = *(_QWORD *)(a1 + 856);
      for ( i = (int *)(v12 + 4LL * v11); ; ++i )
      {
        v14 = *i;
        if ( !((*i ^ a3) >> 1) )
        {
          result = check_match_0((__int64 *)a1, (unsigned __int64)v5, a4, a5, ((unsigned __int64)i - v12) >> 2);
          if ( result )
            break;
        }
        if ( (v14 & 1) != 0 )
          return 0LL;
      }
    }
  }
  else
  {
    v15 = *(unsigned __int8 *)a2;
    LODWORD(a2) = 0;
    if ( v15 )
    {
      if ( v5[1] )
      {
        a2 = v5[1] + 16LL * v15;
        if ( v5[2] )
        {
          a2 = v5[2] + 16 * a2;
          if ( v5[3] )
          {
            a2 = v5[3] + 16 * a2;
            if ( v5[4] )
            {
              a2 = v5[4] + 16 * a2;
              v16 = v5[5];
              if ( v5[5] )
              {
                v17 = v5 + 5;
                do
                {
                  a2 = (v16 + 16 * a2) ^ (((v16 + 16 * a2) & 0xF0000000) >> 24);
                  v18 = *++v17;
                  v16 = v18;
                }
                while ( v18 );
              }
              LODWORD(a2) = a2 & 0xFFFFFFF;
            }
          }
        }
      }
      else
      {
        LODWORD(a2) = v15;
      }
    }
    for ( j = *(_DWORD *)(*(_QWORD *)(a1 + 856) + 4LL * ((unsigned int)a2 % *(_DWORD *)(a1 + 828)));
          j;
          j = *(_DWORD *)(*(_QWORD *)(a1 + 848) + 4LL * j) )
    {
      result = check_match_0((__int64 *)a1, (unsigned __int64)v5, a4, a5, j);
      if ( result )
        break;
    }
  }
  return result;
}

//----- (000000000044AF00) ----------------------------------------------------
__int64 __fastcall dl_addr(
        unsigned __int64 a1,
        _QWORD *a2,
        __int64 **a3,
        _QWORD *a4,
        __int64 a5,
        void *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  unsigned int v19; // w23
  __int64 *dso_for_object; // x0
  double v21; // d0
  double v22; // d1
  double v23; // d2
  double v24; // d3
  double v25; // d4
  double v26; // d5
  double v27; // d6
  double v28; // d7
  _BYTE *v29; // x1
  __int64 v30; // x2
  __int64 v31; // x2
  unsigned int *v32; // x10
  unsigned int *v33; // x1
  unsigned int *v34; // x12
  unsigned int v35; // w3
  int v36; // w13
  _DWORD *v37; // x8
  _DWORD *v38; // x13
  __int64 v39; // x9
  int *v40; // x5
  unsigned __int64 v41; // x1
  unsigned __int64 v42; // x7
  __int64 v43; // x6
  int v44; // t1
  unsigned int *v45; // x4
  __int64 v46; // x1
  __int64 v47; // x1
  __int64 v49; // x4
  unsigned __int64 v50; // x6
  unsigned __int64 v51; // x5
  unsigned __int64 v52; // x4
  __int64 v53; // x8

  pthread_mutex_lock(
    dl_load_lock,
    a8,
    a9,
    a10,
    a11,
    a12,
    a13,
    a14,
    a15,
    (__int64)a2,
    (__int64)a3,
    (__int64)a4,
    a5,
    a6,
    a7);
  v19 = 0;
  dso_for_object = dl_find_dso_for_object(a1);
  if ( !dso_for_object )
    goto LABEL_29;
  v29 = (_BYTE *)dso_for_object[1];
  v30 = dso_for_object[115];
  *a2 = v29;
  a2[1] = v30;
  if ( !*v29 && (*((_WORD *)dso_for_object + 434) & 3LL) == 0 )
    *a2 = program_invocation_short_name[0];
  v31 = 0LL;
  v32 = *(unsigned int **)(dso_for_object[14] + 8);
  if ( (*((_BYTE *)dso_for_object + 870) & 0x20) != 0 )
  {
    v31 = *dso_for_object;
    v32 = (unsigned int *)((char *)v32 + *dso_for_object);
  }
  v33 = v32;
  v34 = (unsigned int *)dso_for_object[93];
  v35 = *(_DWORD *)(dso_for_object[18] + 8);
  if ( v34 )
  {
    v36 = *((_DWORD *)dso_for_object + 207);
    if ( v36 )
    {
      v37 = (_DWORD *)dso_for_object[106];
      v34 = 0LL;
      v38 = &v37[v36];
      while ( !*v37 )
      {
LABEL_8:
        if ( ++v37 == v38 )
          goto LABEL_21;
      }
      v39 = dso_for_object[107];
      v40 = (int *)(v39 + 4LL * (unsigned int)*v37);
      while ( 1 )
      {
        v45 = &v32[6 * (unsigned int)(((unsigned __int64)v40 - v39) >> 2)];
        if ( *((_WORD *)v45 + 3) )
        {
          if ( *((unsigned __int16 *)v45 + 3) == 65521 )
            goto LABEL_17;
        }
        else if ( !*((_QWORD *)v45 + 1) )
        {
          goto LABEL_17;
        }
        if ( (v45[1] & 0xF) == 6 )
          goto LABEL_17;
        v41 = *((_QWORD *)v45 + 1);
        v42 = v41 + *dso_for_object;
        if ( a1 < v42 )
          goto LABEL_17;
        if ( *((_WORD *)v45 + 3) )
        {
          v43 = *((_QWORD *)v45 + 2);
          if ( !v43 )
          {
            if ( a1 == v42 )
              goto LABEL_51;
            goto LABEL_17;
          }
        }
        else
        {
          if ( a1 == v42 )
            goto LABEL_51;
          v43 = *((_QWORD *)v45 + 2);
        }
        if ( a1 < v42 + v43 )
        {
LABEL_51:
          if ( (!v34 || v41 > *((_QWORD *)v34 + 1)) && v35 > *v45 )
            v34 = &v32[6 * (unsigned int)(((unsigned __int64)v40 - v39) >> 2)];
        }
LABEL_17:
        v44 = *v40++;
        if ( (v44 & 1) != 0 )
          goto LABEL_8;
      }
    }
    goto LABEL_56;
  }
  v49 = dso_for_object[12];
  if ( !v49
    || (v50 = (unsigned __int64)&v32[6 * *(unsigned int *)(v31 + *(_QWORD *)(v49 + 8) + 4)], (unsigned __int64)v32 >= v50) )
  {
LABEL_56:
    if ( a3 )
    {
      *a3 = dso_for_object;
      if ( a4 )
        *a4 = 0LL;
    }
    else if ( a4 )
    {
      *a4 = 0LL;
    }
    goto LABEL_59;
  }
  do
  {
    if ( (unsigned __int8)((*((_BYTE *)v33 + 4) >> 4) - 1) > 1u
      || (*((_BYTE *)v33 + 5) & 3u) - 1 <= 1
      || (v33[1] & 0xF) == 6 )
    {
      goto LABEL_33;
    }
    if ( *((_WORD *)v33 + 3) )
    {
      if ( *((unsigned __int16 *)v33 + 3) == 65521 )
        goto LABEL_33;
      v51 = *((_QWORD *)v33 + 1);
      v52 = v51 + *dso_for_object;
      if ( a1 < v52 )
        goto LABEL_33;
      v53 = *((_QWORD *)v33 + 2);
      if ( !v53 )
      {
        if ( a1 != v52 )
          goto LABEL_33;
        goto LABEL_43;
      }
    }
    else
    {
      v51 = *((_QWORD *)v33 + 1);
      if ( !v51 )
        goto LABEL_33;
      v52 = v51 + *dso_for_object;
      if ( a1 < v52 )
        goto LABEL_33;
      if ( a1 == v52 )
        goto LABEL_43;
      v53 = *((_QWORD *)v33 + 2);
    }
    if ( a1 >= v52 + v53 )
      goto LABEL_33;
LABEL_43:
    if ( (!v34 || *((_QWORD *)v34 + 1) < v51) && v35 > *v33 )
      v34 = v33;
LABEL_33:
    v33 += 6;
  }
  while ( v50 > (unsigned __int64)v33 );
LABEL_21:
  v46 = *(_QWORD *)(dso_for_object[13] + 8);
  if ( a3 )
    *a3 = dso_for_object;
  if ( a4 )
    *a4 = v34;
  if ( !v34 )
  {
LABEL_59:
    v19 = 1;
    a2[2] = 0LL;
    a2[3] = 0LL;
    goto LABEL_29;
  }
  a2[2] = v31 + v46 + *v34;
  if ( *((unsigned __int16 *)v34 + 3) == 65521 )
    v47 = 0LL;
  else
    v47 = *dso_for_object;
  v19 = 1;
  a2[3] = *((_QWORD *)v34 + 1) + v47;
LABEL_29:
  pthread_mutex_unlock(dl_load_lock, v21, v22, v23, v24, v25, v26, v27, v28);
  return v19;
}
// 44B080: variable 'v21' is possibly undefined
// 44B080: variable 'v22' is possibly undefined
// 44B080: variable 'v23' is possibly undefined
// 44B080: variable 'v24' is possibly undefined
// 44B080: variable 'v25' is possibly undefined
// 44B080: variable 'v26' is possibly undefined
// 44B080: variable 'v27' is possibly undefined
// 44B080: variable 'v28' is possibly undefined
// 490F90: using guessed type int dl_load_lock[12];
// 491928: using guessed type __int64 *program_invocation_short_name[2];

//----- (000000000044B220) ----------------------------------------------------
__int64 __fastcall call_dl_lookup(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9)
{
  __int64 result; // x0

  result = dl_lookup_symbol_x(
             *(const char **)(a1 + 8),
             *(_QWORD *)a1,
             *(__int64 **)(a1 + 40),
             *(void ****)(*(_QWORD *)a1 + 976LL),
             *(const char ***)(a1 + 16),
             0,
             *(_DWORD *)(a1 + 24),
             0LL,
             a2,
             a3,
             a4,
             a5,
             a6,
             a7,
             a8,
             a9);
  *(_QWORD *)a1 = result;
  return result;
}

//----- (000000000044B260) ----------------------------------------------------
__int64 __fastcall do_sym(
        __int64 a1,
        const char *a2,
        unsigned __int64 a3,
        const char **a4,
        int a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13)
{
  __int64 *v13; // x1
  __int64 result; // x0
  __int64 v15; // x2
  bool v16; // zf
  __int64 (__fastcall *v17)(__int64, __int64 *); // x2
  __int64 *dso_for_object; // x7
  double v19; // d0
  double v20; // d1
  double v21; // d2
  double v22; // d3
  double v23; // d4
  double v24; // d5
  double v25; // d6
  double v26; // d7
  __int64 *v27; // x2
  __int64 *v28; // x1
  __int64 *v29; // x1
  __int64 v30; // x5
  __int64 v31; // x6
  __int64 v32; // x7
  double v33; // d0
  double v34; // d1
  double v35; // d2
  double v36; // d3
  double v37; // d4
  double v38; // d5
  double v39; // d6
  double v40; // d7
  __int64 v41; // x4
  __int64 StatusReg; // x3
  unsigned int v43; // w20
  void *v44; // x4
  void *v45; // x5
  void *v46; // x6
  int v47; // w0
  signed __int64 v48; // x0
  __int64 v51; // [xsp+20h] [xbp+20h]
  void *v52; // [xsp+20h] [xbp+20h]
  char v57; // [xsp+3Ch] [xbp+3Ch]
  __int64 v58; // [xsp+40h] [xbp+40h] BYREF
  const char *v59[3]; // [xsp+48h] [xbp+48h] BYREF
  __int64 v60; // [xsp+60h] [xbp+60h] BYREF
  __int64 v61; // [xsp+68h] [xbp+68h]
  __int64 v62; // [xsp+70h] [xbp+70h]
  int v63; // [xsp+78h] [xbp+78h]
  __int64 *v64; // [xsp+88h] [xbp+88h]

  v58 = 0LL;
  if ( a1 )
  {
    if ( a1 != -1 )
    {
      v13 = (__int64 *)dl_lookup_symbol_x(
                         a2,
                         a1,
                         &v58,
                         (void ***)(a1 + 984),
                         a4,
                         0,
                         a5,
                         0LL,
                         a6,
                         a7,
                         a8,
                         a9,
                         a10,
                         a11,
                         a12,
                         a13);
      goto LABEL_4;
    }
    v57 = a5;
    dso_for_object = dl_find_dso_for_object(a3);
    if ( dso_for_object )
    {
      if ( dl_ns != dso_for_object )
      {
LABEL_15:
        v27 = dso_for_object;
        do
        {
          v28 = v27;
          v27 = (__int64 *)v27[101];
        }
        while ( v27 );
        v13 = (__int64 *)dl_lookup_symbol_x(
                           a2,
                           (__int64)dso_for_object,
                           &v58,
                           (void ***)v28 + 123,
                           a4,
                           0,
                           v57,
                           (__int64)dso_for_object,
                           v19,
                           v20,
                           v21,
                           v22,
                           v23,
                           v24,
                           v25,
                           v26);
        goto LABEL_4;
      }
    }
    else if ( !dl_ns )
    {
      goto LABEL_21;
    }
    if ( dl_ns[115] <= a3 )
    {
      dso_for_object = dl_ns;
      if ( dl_ns[116] > a3 )
        goto LABEL_15;
    }
LABEL_21:
    dl_signal_error(0, 0LL, 0LL, "RTLD_NEXT used in code not dynamically loaded");
  }
  v29 = dl_find_dso_for_object(a3);
  if ( !v29 )
    v29 = dl_ns;
  if ( _libc_single_threaded )
  {
    v13 = (__int64 *)dl_lookup_symbol_x(
                       a2,
                       (__int64)v29,
                       &v58,
                       (void ***)v29[122],
                       a4,
                       0,
                       a5 | 1u,
                       0LL,
                       v33,
                       v34,
                       v35,
                       v36,
                       v37,
                       v38,
                       v39,
                       v40);
  }
  else
  {
    v41 = a5 | 5u;
    v62 = (__int64)a4;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
    v64 = &v58;
    v60 = (__int64)v29;
    v61 = (__int64)a2;
    *(_DWORD *)(StatusReg - 1820) = 1;
    v51 = StatusReg;
    v63 = v41;
    __dmb(0xBu);
    v43 = dl_catch_exception(
            v59,
            (void (__fastcall *)(__int64))call_dl_lookup,
            (__int64)&v60,
            StatusReg,
            v41,
            v30,
            v31,
            v32);
    v52 = (void *)(v51 - 1820);
    _aarch64_swp4_rel();
    if ( v47 == 2 )
      v48 = linux_eabi_syscall(__NR_futex, v52, (void *)0x81, (void *)1, 0LL, v44, v45, v46);
    if ( v59[1] )
      dl_signal_exception(v43, v59, 0LL);
    v13 = (__int64 *)v60;
  }
LABEL_4:
  result = v58;
  if ( v58 )
  {
    v15 = 0LL;
    if ( v13 )
      v16 = *(unsigned __int16 *)(v58 + 6) == 65521;
    else
      v16 = 1;
    if ( !v16 )
      v15 = *v13;
    v17 = (__int64 (__fastcall *)(__int64, __int64 *))(v15 + *(_QWORD *)(v58 + 8));
    if ( (*(_BYTE *)(v58 + 4) & 0xF) == 0xA )
    {
      v60 = 24LL;
      v62 = dl_hwcap2;
      v61 = dl_hwcap;
      return v17(dl_hwcap | 0x4000000000000000LL, &v60);
    }
    else
    {
      return (__int64)v17;
    }
  }
  return result;
}
// 44B354: variable 'v19' is possibly undefined
// 44B354: variable 'v20' is possibly undefined
// 44B354: variable 'v21' is possibly undefined
// 44B354: variable 'v22' is possibly undefined
// 44B354: variable 'v23' is possibly undefined
// 44B354: variable 'v24' is possibly undefined
// 44B354: variable 'v25' is possibly undefined
// 44B354: variable 'v26' is possibly undefined
// 44B3E8: variable 'v33' is possibly undefined
// 44B3E8: variable 'v34' is possibly undefined
// 44B3E8: variable 'v35' is possibly undefined
// 44B3E8: variable 'v36' is possibly undefined
// 44B3E8: variable 'v37' is possibly undefined
// 44B3E8: variable 'v38' is possibly undefined
// 44B3E8: variable 'v39' is possibly undefined
// 44B3E8: variable 'v40' is possibly undefined
// 44B440: variable 'v30' is possibly undefined
// 44B440: variable 'v31' is possibly undefined
// 44B440: variable 'v32' is possibly undefined
// 44B460: variable 'v47' is possibly undefined
// 44B478: variable 'v44' is possibly undefined
// 44B478: variable 'v45' is possibly undefined
// 44B478: variable 'v46' is possibly undefined
// 490F08: using guessed type char _libc_single_threaded;
// 4914A8: using guessed type __int64 *dl_ns;
// 496BE0: using guessed type __int64 dl_hwcap;
// 496BE8: using guessed type __int64 dl_hwcap2;

//----- (000000000044B4E8) ----------------------------------------------------
__int64 __fastcall dl_vsym(
        __int64 a1,
        const char *a2,
        const char *a3,
        unsigned __int64 a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12)
{
  unsigned __int64 v13; // x2
  unsigned int v14; // w5
  __int64 v15; // x5
  unsigned __int8 *v16; // x4
  unsigned int v17; // t1
  const char *v19; // [xsp+18h] [xbp+18h] BYREF
  int v20; // [xsp+20h] [xbp+20h]
  int v21; // [xsp+24h] [xbp+24h]
  __int64 v22; // [xsp+28h] [xbp+28h]

  v13 = a4;
  v14 = *(unsigned __int8 *)a3;
  v19 = a3;
  v21 = 1;
  LODWORD(a4) = 0;
  if ( !v14 )
  {
LABEL_10:
    v20 = a4;
    v22 = 0LL;
    return do_sym(a1, a2, v13, &v19, 0, a5, a6, a7, a8, a9, a10, a11, a12);
  }
  if ( a3[1] )
  {
    a4 = *((unsigned __int8 *)a3 + 1) + 16LL * v14;
    if ( a3[2] )
    {
      a4 = *((unsigned __int8 *)a3 + 2) + 16 * a4;
      if ( a3[3] )
      {
        a4 = *((unsigned __int8 *)a3 + 3) + 16 * a4;
        if ( a3[4] )
        {
          a4 = *((unsigned __int8 *)a3 + 4) + 16 * a4;
          v15 = *((unsigned __int8 *)a3 + 5);
          if ( a3[5] )
          {
            v16 = (unsigned __int8 *)(a3 + 5);
            do
            {
              a4 = (v15 + 16 * a4) ^ (((v15 + 16 * a4) & 0xF0000000) >> 24);
              v17 = *++v16;
              v15 = v17;
            }
            while ( v17 );
            LODWORD(a4) = a4 & 0xFFFFFFF;
          }
        }
      }
    }
    goto LABEL_10;
  }
  v20 = v14;
  v22 = 0LL;
  return do_sym(a1, a2, v13, &v19, 0, a5, a6, a7, a8, a9, a10, a11, a12);
}

//----- (000000000044B5A0) ----------------------------------------------------
__int64 __fastcall dl_sym(
        __int64 a1,
        const char *a2,
        unsigned __int64 a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        double a10,
        double a11)
{
  return do_sym(a1, a2, a3, 0LL, 2, a4, a5, a6, a7, a8, a9, a10, a11);
}

//----- (000000000044B5B0) ----------------------------------------------------
void __cdecl _aarch64_cas4_relax()
{
  int v0; // w0
  unsigned int v1; // w1
  atomic_uint *v2; // x2
  int v3; // w16
  unsigned int v4; // w0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_compare_exchange_strong_explicit(v2, (unsigned int *)&v0, v1, memory_order_relaxed, memory_order_relaxed);
  }
  else
  {
    v3 = v0;
    do
      v4 = __ldxr((unsigned int *)v2);
    while ( v4 == v3 && __stxr(v1, (unsigned int *)v2) );
  }
}
// 44B5BC: variable 'v2' is possibly undefined
// 44B5BC: variable 'v1' is possibly undefined
// 44B5C4: variable 'v0' is possibly undefined

//----- (000000000044B5E0) ----------------------------------------------------
void __cdecl _aarch64_cas4_acq()
{
  int v0; // w0
  unsigned int v1; // w1
  atomic_uint *v2; // x2
  int v3; // w16
  unsigned int v4; // w0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_compare_exchange_strong_explicit(v2, (unsigned int *)&v0, v1, memory_order_acquire, memory_order_acquire);
  }
  else
  {
    v3 = v0;
    do
      v4 = __ldaxr((unsigned int *)v2);
    while ( v4 == v3 && __stxr(v1, (unsigned int *)v2) );
  }
}
// 44B5EC: variable 'v2' is possibly undefined
// 44B5EC: variable 'v1' is possibly undefined
// 44B5F4: variable 'v0' is possibly undefined

//----- (000000000044B610) ----------------------------------------------------
void __cdecl _aarch64_cas8_acq()
{
  __int64 v0; // x0
  unsigned __int64 v1; // x1
  atomic_ullong *v2; // x2
  __int64 v3; // x16
  unsigned __int64 v4; // x0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_compare_exchange_strong_explicit(v2, (unsigned __int64 *)&v0, v1, memory_order_acquire, memory_order_acquire);
  }
  else
  {
    v3 = v0;
    do
      v4 = __ldaxr((unsigned __int64 *)v2);
    while ( v4 == v3 && __stxr(v1, (unsigned __int64 *)v2) );
  }
}
// 44B61C: variable 'v2' is possibly undefined
// 44B61C: variable 'v1' is possibly undefined
// 44B624: variable 'v0' is possibly undefined

//----- (000000000044B640) ----------------------------------------------------
void __cdecl _aarch64_cas4_rel()
{
  int v0; // w0
  unsigned int v1; // w1
  atomic_uint *v2; // x2
  int v3; // w16
  unsigned int v4; // w0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_compare_exchange_strong_explicit(v2, (unsigned int *)&v0, v1, memory_order_release, memory_order_relaxed);
  }
  else
  {
    v3 = v0;
    do
      v4 = __ldxr((unsigned int *)v2);
    while ( v4 == v3 && __stlxr(v1, (unsigned int *)v2) );
  }
}
// 44B64C: variable 'v2' is possibly undefined
// 44B64C: variable 'v1' is possibly undefined
// 44B654: variable 'v0' is possibly undefined

//----- (000000000044B670) ----------------------------------------------------
void __cdecl _aarch64_cas8_rel()
{
  __int64 v0; // x0
  unsigned __int64 v1; // x1
  atomic_ullong *v2; // x2
  __int64 v3; // x16
  unsigned __int64 v4; // x0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_compare_exchange_strong_explicit(v2, (unsigned __int64 *)&v0, v1, memory_order_release, memory_order_relaxed);
  }
  else
  {
    v3 = v0;
    do
      v4 = __ldxr((unsigned __int64 *)v2);
    while ( v4 == v3 && __stlxr(v1, (unsigned __int64 *)v2) );
  }
}
// 44B67C: variable 'v2' is possibly undefined
// 44B67C: variable 'v1' is possibly undefined
// 44B684: variable 'v0' is possibly undefined

//----- (000000000044B6A0) ----------------------------------------------------
void __cdecl _aarch64_swp4_relax()
{
  unsigned int v0; // w0
  unsigned int *v1; // x1

  if ( _aarch64_have_lse_atomics )
  {
    __swp(v0, v1);
  }
  else
  {
    do
      __ldxr(v1);
    while ( __stxr(v0, v1) );
  }
}
// 44B6AC: variable 'v0' is possibly undefined
// 44B6AC: variable 'v1' is possibly undefined

//----- (000000000044B6D0) ----------------------------------------------------
void __cdecl _aarch64_ldadd4_relax()
{
  unsigned int v0; // w0
  atomic_uint *v1; // x1
  unsigned int v2; // w16
  unsigned int v3; // w0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_fetch_add_explicit(v1, v0, memory_order_relaxed);
  }
  else
  {
    v2 = v0;
    do
      v3 = __ldxr((unsigned int *)v1);
    while ( __stxr(v3 + v2, (unsigned int *)v1) );
  }
}
// 44B6DC: variable 'v1' is possibly undefined
// 44B6DC: variable 'v0' is possibly undefined

//----- (000000000044B700) ----------------------------------------------------
void __cdecl _aarch64_ldset4_relax()
{
  unsigned int v0; // w0
  atomic_uint *v1; // x1
  unsigned int v2; // w16
  unsigned int v3; // w0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_fetch_or_explicit(v1, v0, memory_order_relaxed);
  }
  else
  {
    v2 = v0;
    do
      v3 = __ldxr((unsigned int *)v1);
    while ( __stxr(v3 | v2, (unsigned int *)v1) );
  }
}
// 44B70C: variable 'v1' is possibly undefined
// 44B70C: variable 'v0' is possibly undefined

//----- (000000000044B730) ----------------------------------------------------
void __cdecl _aarch64_ldadd8_relax()
{
  unsigned __int64 v0; // x0
  atomic_ullong *v1; // x1
  unsigned __int64 v2; // x16
  unsigned __int64 v3; // x0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_fetch_add_explicit(v1, v0, memory_order_relaxed);
  }
  else
  {
    v2 = v0;
    do
      v3 = __ldxr((unsigned __int64 *)v1);
    while ( __stxr(v3 + v2, (unsigned __int64 *)v1) );
  }
}
// 44B73C: variable 'v1' is possibly undefined
// 44B73C: variable 'v0' is possibly undefined

//----- (000000000044B760) ----------------------------------------------------
void __cdecl _aarch64_swp4_acq()
{
  unsigned int v0; // w0
  atomic_uint *v1; // x1

  if ( _aarch64_have_lse_atomics )
  {
    atomic_exchange_explicit(v1, v0, memory_order_acquire);
  }
  else
  {
    do
      __ldaxr((unsigned int *)v1);
    while ( __stxr(v0, (unsigned int *)v1) );
  }
}
// 44B76C: variable 'v1' is possibly undefined
// 44B76C: variable 'v0' is possibly undefined

//----- (000000000044B790) ----------------------------------------------------
void __cdecl _aarch64_ldadd4_acq()
{
  unsigned int v0; // w0
  atomic_uint *v1; // x1
  unsigned int v2; // w16
  unsigned int v3; // w0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_fetch_add_explicit(v1, v0, memory_order_acquire);
  }
  else
  {
    v2 = v0;
    do
      v3 = __ldaxr((unsigned int *)v1);
    while ( __stxr(v3 + v2, (unsigned int *)v1) );
  }
}
// 44B79C: variable 'v1' is possibly undefined
// 44B79C: variable 'v0' is possibly undefined

//----- (000000000044B7C0) ----------------------------------------------------
void __cdecl _aarch64_ldclr4_acq()
{
  int v0; // w0
  atomic_uint *v1; // x1
  int v2; // w16
  unsigned int v3; // w0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_fetch_and_explicit(v1, ~v0, memory_order_acquire);
  }
  else
  {
    v2 = v0;
    do
      v3 = __ldaxr((unsigned int *)v1);
    while ( __stxr(v3 & ~v2, (unsigned int *)v1) );
  }
}
// 44B7CC: variable 'v1' is possibly undefined
// 44B7CC: variable 'v0' is possibly undefined

//----- (000000000044B7F0) ----------------------------------------------------
void __cdecl _aarch64_ldset4_acq()
{
  unsigned int v0; // w0
  atomic_uint *v1; // x1
  unsigned int v2; // w16
  unsigned int v3; // w0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_fetch_or_explicit(v1, v0, memory_order_acquire);
  }
  else
  {
    v2 = v0;
    do
      v3 = __ldaxr((unsigned int *)v1);
    while ( __stxr(v3 | v2, (unsigned int *)v1) );
  }
}
// 44B7FC: variable 'v1' is possibly undefined
// 44B7FC: variable 'v0' is possibly undefined

//----- (000000000044B820) ----------------------------------------------------
void __cdecl _aarch64_swp8_acq()
{
  unsigned __int64 v0; // x0
  atomic_ullong *v1; // x1

  if ( _aarch64_have_lse_atomics )
  {
    atomic_exchange_explicit(v1, v0, memory_order_acquire);
  }
  else
  {
    do
      __ldaxr((unsigned __int64 *)v1);
    while ( __stxr(v0, (unsigned __int64 *)v1) );
  }
}
// 44B82C: variable 'v1' is possibly undefined
// 44B82C: variable 'v0' is possibly undefined

//----- (000000000044B850) ----------------------------------------------------
void __cdecl _aarch64_swp4_rel()
{
  unsigned int v0; // w0
  atomic_uint *v1; // x1

  if ( _aarch64_have_lse_atomics )
  {
    atomic_exchange_explicit(v1, v0, memory_order_release);
  }
  else
  {
    do
      __ldxr((unsigned int *)v1);
    while ( __stlxr(v0, (unsigned int *)v1) );
  }
}
// 44B85C: variable 'v1' is possibly undefined
// 44B85C: variable 'v0' is possibly undefined

//----- (000000000044BAC0) ----------------------------------------------------
void __fastcall _sfp_handle_exceptions(int _fex)
{
  if ( (_fex & 1) != 0 )
    _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 4, 1));
  if ( (_fex & 2) != 0 )
    _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 4, 1));
  if ( (_fex & 4) != 0 )
    _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 4, 1));
  if ( (_fex & 8) != 0 )
    _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 4, 1));
  if ( (_fex & 0x10) != 0 )
    _ReadStatusReg(ARM64_SYSREG(3, 3, 4, 4, 1));
}

//----- (000000000044BB40) ----------------------------------------------------
void __cdecl init_dwarf_reg_size_table()
{
  memset(dwarf_reg_size_table, 8, 32);
  dwarf_reg_size_table[64] = 0;
  dwarf_reg_size_table[46] = 8;
  dwarf_reg_size_table[65] = 0;
  dwarf_reg_size_table[66] = 0;
  dwarf_reg_size_table[67] = 0;
  dwarf_reg_size_table[68] = 0;
  dwarf_reg_size_table[69] = 0;
  dwarf_reg_size_table[70] = 0;
  dwarf_reg_size_table[71] = 0;
  dwarf_reg_size_table[72] = 8;
  dwarf_reg_size_table[73] = 8;
  dwarf_reg_size_table[74] = 8;
  dwarf_reg_size_table[75] = 8;
  dwarf_reg_size_table[76] = 8;
  dwarf_reg_size_table[77] = 8;
  dwarf_reg_size_table[78] = 8;
  dwarf_reg_size_table[79] = 8;
  dwarf_reg_size_table[80] = 0;
  dwarf_reg_size_table[81] = 0;
  dwarf_reg_size_table[82] = 0;
  dwarf_reg_size_table[83] = 0;
  dwarf_reg_size_table[84] = 0;
  dwarf_reg_size_table[85] = 0;
  dwarf_reg_size_table[86] = 0;
  dwarf_reg_size_table[87] = 0;
  dwarf_reg_size_table[88] = 0;
  dwarf_reg_size_table[89] = 0;
  dwarf_reg_size_table[90] = 0;
  dwarf_reg_size_table[91] = 0;
  dwarf_reg_size_table[92] = 0;
  dwarf_reg_size_table[93] = 0;
  dwarf_reg_size_table[94] = 0;
  dwarf_reg_size_table[95] = 0;
  dwarf_reg_size_table[48] = 0;
  dwarf_reg_size_table[49] = 0;
  dwarf_reg_size_table[50] = 0;
  dwarf_reg_size_table[51] = 0;
  dwarf_reg_size_table[52] = 0;
  dwarf_reg_size_table[53] = 0;
  dwarf_reg_size_table[54] = 0;
  dwarf_reg_size_table[55] = 0;
  dwarf_reg_size_table[56] = 0;
  dwarf_reg_size_table[57] = 0;
  dwarf_reg_size_table[58] = 0;
  dwarf_reg_size_table[59] = 0;
  dwarf_reg_size_table[60] = 0;
  dwarf_reg_size_table[61] = 0;
  dwarf_reg_size_table[62] = 0;
  dwarf_reg_size_table[63] = 0;
  dwarf_reg_size_table[96] = 8;
}

//----- (000000000044BCA0) ----------------------------------------------------
__int64 __fastcall uw_install_context_1(_Unwind_Context *current, _Unwind_Context *target)
{
  _Unwind_Word flags; // x0
  char *by_value; // x22
  __int64 i; // x19
  _QWORD *v7; // x0
  __int64 v8; // x2
  _QWORD *v9; // x1
  bool v10; // zf
  __int64 result; // x0
  char *v13; // x0
  _Unwind_SpTmp sp_slot; // [xsp+48h] [xbp+48h] BYREF

  flags = target->flags;
  if ( ((flags & 0x4000000000000000LL) == 0 || !target->by_value[31]) && !target->reg[31] )
  {
    if ( dwarf_reg_size_table[31] != 8 )
      goto LABEL_37;
    sp_slot.ptr = (_Unwind_Ptr)target->cfa;
    if ( (flags & 0x4000000000000000LL) != 0 )
      target->by_value[31] = 0;
    target->reg[31] = &sp_slot;
  }
  by_value = target->by_value;
  for ( i = 0LL; i != 97; ++i )
  {
    while ( 1 )
    {
      if ( i == 34 )
      {
        v9 = target->reg[35];
        i = 35LL;
        v7 = current->reg[35];
        v8 = 35LL;
      }
      else
      {
        v7 = current->reg[i];
        v8 = i;
        v9 = target->reg[i];
      }
      if ( current->by_value[v8] )
        goto LABEL_37;
      if ( by_value[v8] )
      {
        if ( v7 )
        {
          if ( dwarf_reg_size_table[v8] != 8 )
            goto LABEL_37;
          *v7 = v9;
        }
        goto LABEL_8;
      }
      v10 = !v9 || v7 == 0LL;
      if ( !v10 && v9 != v7 )
        break;
LABEL_8:
      if ( ++i == 97 )
        goto LABEL_21;
    }
    j_memcpy();
  }
LABEL_21:
  if ( (current->flags & 0x4000000000000000LL) != 0 && current->by_value[31] )
    return 0LL;
  result = 0LL;
  if ( !current->reg[31] )
  {
    v13 = (char *)target->reg[31];
    if ( (target->flags & 0x4000000000000000LL) != 0 && target->by_value[31] )
      return v13 - (char *)current->cfa + target->args_size;
    if ( dwarf_reg_size_table[31] == 8 )
    {
      v13 = *(char **)v13;
      return v13 - (char *)current->cfa + target->args_size;
    }
LABEL_37:
    abort();
  }
  return result;
}

//----- (000000000044BE2C) ----------------------------------------------------
const unsigned __int8 *__fastcall read_encoded_value(
        _Unwind_Context *context,
        unsigned __int8 encoding,
        const unsigned __int8 *p,
        _Unwind_Ptr *val)
{
  unsigned int v4; // w6
  void *dbase; // x9
  unsigned __int64 v6; // x2
  const unsigned __int8 *result; // x0
  unsigned int v8; // w0
  _Unwind_Ptr v9; // x4
  int v10; // w7
  char v11; // t1
  unsigned __int64 v12; // x5
  unsigned int v13; // w7
  char v14; // w8
  char v15; // t1
  unsigned __int64 v16; // x5

  if ( encoding == 255 )
    goto LABEL_26;
  v4 = encoding & 0x70;
  if ( v4 == 48 )
  {
    dbase = context->bases.dbase;
LABEL_9:
    if ( encoding == 80 )
      goto LABEL_6;
    goto LABEL_10;
  }
  if ( v4 > 0x30 )
  {
    if ( v4 == 64 )
    {
      dbase = context->bases.func;
    }
    else
    {
      dbase = 0LL;
      if ( v4 != 80 )
        goto LABEL_26;
    }
    goto LABEL_9;
  }
  if ( v4 != 32 )
  {
    if ( v4 > 0x20 )
      goto LABEL_26;
    dbase = 0LL;
    goto LABEL_9;
  }
  dbase = context->bases.tbase;
  if ( encoding == 80 )
  {
LABEL_6:
    v6 = (unsigned __int64)(p + 7);
    result = (const unsigned __int8 *)((v6 & 0xFFFFFFFFFFFFFFF8LL) + 8);
    *val = *(_QWORD *)(v6 & 0xFFFFFFFFFFFFFFF8LL);
    return result;
  }
LABEL_10:
  v8 = encoding & 0xF;
  if ( v8 == 4 )
    goto LABEL_33;
  if ( v8 <= 4 )
  {
    if ( v8 == 2 )
    {
      result = p + 2;
      v9 = *(unsigned __int16 *)p;
      goto LABEL_17;
    }
    if ( v8 == 3 )
    {
      result = p + 4;
      v9 = *(unsigned int *)p;
      goto LABEL_17;
    }
    if ( (encoding & 0xF) != 0 )
    {
      result = p;
      v9 = 0LL;
      v10 = 0;
      do
      {
        v11 = *result++;
        v12 = (unsigned __int64)(v11 & 0x7F) << v10;
        v10 += 7;
        v9 |= v12;
      }
      while ( v11 < 0 );
      goto LABEL_17;
    }
LABEL_33:
    result = p + 8;
    v9 = *(_QWORD *)p;
    goto LABEL_17;
  }
  if ( v8 == 11 )
  {
    result = p + 4;
    v9 = *(int *)p;
    goto LABEL_17;
  }
  if ( v8 > 0xB )
  {
    if ( v8 == 12 )
      goto LABEL_33;
LABEL_26:
    abort();
  }
  if ( v8 != 9 )
  {
    if ( v8 == 10 )
    {
      result = p + 2;
      v9 = *(__int16 *)p;
      goto LABEL_17;
    }
    goto LABEL_26;
  }
  result = p;
  v9 = 0LL;
  v13 = 0;
  do
  {
    v15 = *result++;
    v14 = v15;
    v16 = (unsigned __int64)(v15 & 0x7F) << v13;
    v13 += 7;
    v9 |= v16;
  }
  while ( v15 < 0 );
  if ( v13 <= 0x3F && (v14 & 0x40) != 0 )
  {
    v9 |= -1LL << v13;
    goto LABEL_18;
  }
LABEL_17:
  if ( v9 )
  {
LABEL_18:
    if ( v4 == 16 )
      dbase = (void *)p;
    v9 += (_Unwind_Ptr)dbase;
    if ( (encoding & 0x80) != 0 )
      v9 = *(_QWORD *)v9;
  }
  *val = v9;
  return result;
}

//----- (000000000044BFCC) ----------------------------------------------------
_Unwind_Word __fastcall execute_stack_op(
        const unsigned __int8 *op_ptr,
        const unsigned __int8 *op_end,
        _Unwind_Context *context,
        _Unwind_Word initial)
{
  const unsigned __int8 *v5; // x6
  _Unwind_Word *v6; // x7
  int v7; // w5
  unsigned int v8; // w3
  const unsigned __int8 *v9; // x4
  _Unwind_Word v10; // x3
  unsigned int v11; // w1
  __int64 v13; // x1
  __int64 v14; // x2
  int v15; // w10
  int v16; // w1
  char v17; // t1
  unsigned __int64 v18; // x0
  __int64 v19; // x10
  unsigned int v20; // w1
  char v21; // w2
  char v22; // t1
  unsigned __int64 v23; // x0
  unsigned int v24; // w3
  _Unwind_Context_Reg_Val v25; // x3
  __int64 v26; // x0
  __int64 v27; // x5
  __int64 v28; // x2
  __int64 v29; // x1
  int8x16_t v30; // q31
  __int64 v31; // x2
  __int64 v32; // x3
  __int64 v33; // x1
  _Unwind_Word v34; // x10
  _Unwind_Word v35; // x11
  unsigned int v36; // w2
  char v37; // w4
  char v38; // t1
  unsigned __int64 v39; // x1
  __int64 v40; // x2
  int v41; // w2
  char v42; // t1
  unsigned __int64 v43; // x1
  int v44; // w10
  int v45; // w1
  char v46; // t1
  unsigned __int64 v47; // x0
  __int64 v48; // x11
  unsigned int v49; // w1
  char v50; // w2
  char v51; // t1
  unsigned __int64 v52; // x0
  _QWORD *v53; // x3
  unsigned int v54; // w3
  unsigned int *v55; // x3
  const unsigned __int8 *v56; // x2
  unsigned int v57; // w0
  bool v58; // cc
  bool v59; // zf
  __int64 v60; // x5
  int v61; // w4
  char v62; // t1
  unsigned __int64 v63; // x3
  _Unwind_Context *v64; // [xsp+10h] [xbp+10h]
  int stack_elt; // [xsp+1Ch] [xbp+1Ch]
  _Unwind_Word *v66; // [xsp+20h] [xbp+20h]
  const unsigned __int8 *v67; // [xsp+28h] [xbp+28h]
  _Unwind_Ptr presult; // [xsp+38h] [xbp+38h] BYREF
  _Unwind_Word stack[64]; // [xsp+40h] [xbp+40h] BYREF

  stack[0] = initial;
  if ( op_ptr >= op_end )
    return initial;
  v5 = op_end;
  v6 = stack;
  v7 = 1;
  do
  {
    v9 = op_ptr + 1;
    v8 = *op_ptr;
    if ( v8 <= 0x17 )
    {
      if ( v8 > 2 )
      {
        switch ( *op_ptr )
        {
          case 3u:
          case 0xEu:
          case 0xFu:
            v10 = *(_QWORD *)(op_ptr + 1);
            v11 = v7;
            op_ptr += 9;
            goto LABEL_8;
          case 6u:
            if ( !v7 )
              goto LABEL_5;
            v11 = v7 - 1;
            v10 = *(_QWORD *)stack[v7 - 1];
            ++op_ptr;
            goto LABEL_8;
          case 8u:
            v10 = op_ptr[1];
            v11 = v7;
            op_ptr += 2;
            goto LABEL_8;
          case 9u:
            v10 = *((char *)op_ptr + 1);
            v11 = v7;
            op_ptr += 2;
            goto LABEL_8;
          case 0xAu:
            v10 = *(unsigned __int16 *)(op_ptr + 1);
            v11 = v7;
            op_ptr += 3;
            goto LABEL_8;
          case 0xBu:
            v10 = *(__int16 *)(op_ptr + 1);
            v11 = v7;
            op_ptr += 3;
            goto LABEL_8;
          case 0xCu:
            v10 = *(unsigned int *)(op_ptr + 1);
            v11 = v7;
            op_ptr += 5;
            goto LABEL_8;
          case 0xDu:
            v10 = *(int *)(op_ptr + 1);
            v11 = v7;
            op_ptr += 5;
            goto LABEL_8;
          case 0x10u:
            ++op_ptr;
            v10 = 0LL;
            v41 = 0;
            do
            {
              v42 = *op_ptr++;
              v43 = (unsigned __int64)(v42 & 0x7F) << v41;
              v41 += 7;
              v10 |= v43;
            }
            while ( v42 < 0 );
            v11 = v7;
            goto LABEL_8;
          case 0x11u:
            ++op_ptr;
            v10 = 0LL;
            v36 = 0;
            do
            {
              v38 = *op_ptr++;
              v37 = v38;
              v39 = (unsigned __int64)(v38 & 0x7F) << v36;
              v36 += 7;
              v10 |= v39;
            }
            while ( v38 < 0 );
            v11 = v7;
            if ( v36 <= 0x3F )
            {
              v40 = v10 | (-1LL << v36);
              if ( (v37 & 0x40) != 0 )
                v10 = v40;
            }
            goto LABEL_8;
          case 0x12u:
            if ( !v7 )
              goto LABEL_5;
            v10 = stack[v7 - 1];
            v11 = v7;
            ++op_ptr;
            goto LABEL_8;
          case 0x13u:
            if ( !v7 )
              goto LABEL_5;
            --v7;
            goto LABEL_43;
          case 0x14u:
            if ( v7 <= 1 )
              goto LABEL_5;
            v10 = stack[v7 - 2];
            v11 = v7;
            ++op_ptr;
            goto LABEL_8;
          case 0x15u:
            v28 = op_ptr[1];
            v29 = v7 - 1;
            if ( v28 >= v29 )
              goto LABEL_5;
            op_ptr += 2;
            v10 = stack[v29 - v28];
            v11 = v7;
            goto LABEL_8;
          case 0x16u:
            if ( v7 <= 1 )
              goto LABEL_5;
            v30 = *(int8x16_t *)&stack[v7 - 2];
            *(int8x16_t *)&stack[v7 - 2] = vextq_s8(v30, v30, 8uLL);
            ++op_ptr;
            continue;
          case 0x17u:
            if ( v7 <= 2 )
              goto LABEL_5;
            v31 = v7 - 2;
            v32 = v7 - 1;
            v33 = v7 - 3;
            v34 = stack[v32];
            v35 = stack[v33];
            stack[v32] = stack[v31];
            stack[v31] = v35;
            stack[v33] = v34;
            ++op_ptr;
            continue;
          default:
            goto LABEL_5;
        }
      }
      goto LABEL_5;
    }
    if ( v8 > 0x6F )
    {
      if ( v8 == 146 )
      {
        v44 = 0;
        v45 = 0;
        do
        {
          v46 = *v9++;
          v47 = (unsigned __int64)(v46 & 0x7F) << v45;
          v45 += 7;
          v44 |= v47;
        }
        while ( v46 < 0 );
        v48 = 0LL;
        v49 = 0;
        do
        {
          v51 = *v9++;
          v50 = v51;
          v52 = (unsigned __int64)(v51 & 0x7F) << v49;
          v49 += 7;
          v48 |= v52;
        }
        while ( v51 < 0 );
        if ( v49 <= 0x3F && (v50 & 0x40) != 0 )
          v48 |= -1LL << v49;
        if ( v44 > 97 )
          goto LABEL_5;
        v53 = context->reg[v44];
        if ( (context->flags & 0x4000000000000000LL) == 0 || !context->by_value[v44] )
        {
          if ( v44 == 46 )
            JUMPOUT(0x44C5A4LL);
          if ( dwarf_reg_size_table[v44] != 8 )
            goto LABEL_5;
          v53 = (_QWORD *)*v53;
        }
        v10 = (_Unwind_Word)v53 + v48;
        v11 = v7;
        op_ptr = v9;
      }
      else if ( v8 > 0x92 )
      {
        if ( v8 == 150 )
        {
LABEL_43:
          ++op_ptr;
          continue;
        }
        if ( v8 == 241 )
        {
          v64 = context;
          stack_elt = v7;
          v66 = v6;
          v67 = v5;
          op_ptr = read_encoded_value(context, op_ptr[1], op_ptr + 2, &presult);
          v11 = stack_elt;
          context = v64;
          v10 = presult;
          v6 = v66;
          v5 = v67;
        }
        else
        {
          if ( v8 != 148 || !v7 )
            goto LABEL_5;
          v11 = v7 - 1;
          v55 = (unsigned int *)stack[v7 - 1];
          v56 = op_ptr + 2;
          v57 = op_ptr[1];
          if ( v57 == 4 )
          {
            v10 = *v55;
            op_ptr = v56;
          }
          else if ( v57 > 4 )
          {
            if ( v57 != 8 )
              goto LABEL_5;
            v10 = *(_QWORD *)v55;
            op_ptr = v56;
          }
          else if ( v57 == 1 )
          {
            v10 = *(unsigned __int8 *)v55;
            op_ptr = v56;
          }
          else
          {
            if ( v57 != 2 )
              goto LABEL_5;
            v10 = *(unsigned __int16 *)v55;
            op_ptr = v56;
          }
        }
      }
      else if ( v8 <= 0x8F )
      {
        v19 = 0LL;
        v20 = 0;
        do
        {
          v22 = *v9++;
          v21 = v22;
          v23 = (unsigned __int64)(v22 & 0x7F) << v20;
          v20 += 7;
          v19 |= v23;
        }
        while ( v22 < 0 );
        if ( v20 <= 0x3F && (v21 & 0x40) != 0 )
          v19 |= -1LL << v20;
        v24 = v8 - 112;
        if ( (context->flags & 0x4000000000000000LL) != 0 && context->by_value[v24] )
        {
          v25 = context->reg[v24];
        }
        else
        {
          if ( dwarf_reg_size_table[v24] != 8 )
            goto LABEL_5;
          v25 = *(_Unwind_Context_Reg_Val *)context->reg[v24];
        }
        v10 = (_Unwind_Word)v25 + v19;
        v11 = v7;
        op_ptr = v9;
      }
      else
      {
        if ( v8 != 144 )
          goto LABEL_5;
        v15 = 0;
        v16 = 0;
        do
        {
          v17 = *v9++;
          v18 = (unsigned __int64)(v17 & 0x7F) << v16;
          v16 += 7;
          v15 |= v18;
        }
        while ( v17 < 0 );
        if ( v15 > 97 )
          goto LABEL_5;
        v10 = (_Unwind_Word)context->reg[v15];
        if ( (context->flags & 0x4000000000000000LL) == 0 || !context->by_value[v15] )
        {
          if ( v15 == 46 )
            JUMPOUT(0x44C5B0LL);
          if ( dwarf_reg_size_table[v15] != 8 )
            goto LABEL_5;
          v10 = *(_QWORD *)v10;
        }
        v11 = v7;
        op_ptr = v9;
      }
      goto LABEL_8;
    }
    if ( v8 > 0x4F )
    {
      v54 = v8 - 80;
      if ( (context->flags & 0x4000000000000000LL) != 0 && context->by_value[v54] )
      {
        v10 = (_Unwind_Word)context->reg[v54];
        v11 = v7;
        ++op_ptr;
      }
      else
      {
        if ( dwarf_reg_size_table[v54] != 8 )
          goto LABEL_5;
        v10 = *(_QWORD *)context->reg[v54];
        v11 = v7;
        ++op_ptr;
      }
LABEL_8:
      if ( v11 > 0x3F )
        goto LABEL_5;
      v7 = v11 + 1;
      v6[v11] = v10;
      continue;
    }
    if ( v8 > 0x28 )
    {
      if ( v8 == 47 )
      {
        op_ptr += *(__int16 *)(op_ptr + 1) + 3;
        continue;
      }
      if ( v8 <= 0x2F )
        goto LABEL_54;
      v10 = v8 - 48;
      v11 = v7;
      ++op_ptr;
      goto LABEL_8;
    }
    if ( v8 == 24 )
      goto LABEL_5;
    v13 = 1LL << ((unsigned __int8)v8 - 25);
    v14 = v13 & 0x7B3E;
    if ( (v13 & 0x7B3E) != 0 )
    {
LABEL_54:
      if ( v7 > 1 )
      {
        v11 = v7 - 2;
        v26 = stack[v7 - 2];
        v27 = stack[v7 - 1];
        switch ( v8 )
        {
          case 0x1Au:
            v10 = v26 & v27;
            op_ptr = v9;
            goto LABEL_8;
          case 0x1Bu:
            v10 = v26 / v27;
            op_ptr = v9;
            goto LABEL_8;
          case 0x1Cu:
            v10 = v26 - v27;
            op_ptr = v9;
            goto LABEL_8;
          case 0x1Du:
            v10 = v26 % (unsigned __int64)v27;
            op_ptr = v9;
            goto LABEL_8;
          case 0x1Eu:
            v10 = v26 * v27;
            op_ptr = v9;
            goto LABEL_8;
          case 0x21u:
            v10 = v26 | v27;
            op_ptr = v9;
            goto LABEL_8;
          case 0x22u:
            v10 = v26 + v27;
            op_ptr = v9;
            goto LABEL_8;
          case 0x24u:
            v10 = v26 << v27;
            op_ptr = v9;
            goto LABEL_8;
          case 0x25u:
            v10 = (unsigned __int64)v26 >> v27;
            op_ptr = v9;
            goto LABEL_8;
          case 0x26u:
            v10 = v26 >> v27;
            op_ptr = v9;
            goto LABEL_8;
          case 0x27u:
            v10 = v26 ^ v27;
            op_ptr = v9;
            goto LABEL_8;
          case 0x29u:
            v59 = v26 == v27;
            op_ptr = v9;
            v10 = v59;
            goto LABEL_8;
          case 0x2Au:
            v58 = v26 < v27;
            op_ptr = v9;
            v10 = !v58;
            goto LABEL_8;
          case 0x2Bu:
            v58 = v26 <= v27;
            op_ptr = v9;
            v10 = !v58;
            goto LABEL_8;
          case 0x2Cu:
            v58 = v26 <= v27;
            op_ptr = v9;
            v10 = v58;
            goto LABEL_8;
          case 0x2Du:
            v58 = v26 < v27;
            op_ptr = v9;
            v10 = v58;
            goto LABEL_8;
          case 0x2Eu:
            v59 = v26 == v27;
            op_ptr = v9;
            v10 = !v59;
            goto LABEL_8;
          default:
            break;
        }
      }
LABEL_5:
      abort();
    }
    if ( (v13 & 0x4C1) != 0 )
    {
      if ( !v7 )
        goto LABEL_5;
      v11 = v7 - 1;
      v60 = stack[v7 - 1];
      if ( v8 == 32 )
      {
        v10 = ~v60;
        ++op_ptr;
      }
      else if ( v8 <= 0x20 )
      {
        if ( v8 == 25 )
        {
          ++op_ptr;
          if ( v60 >= 0 )
            v10 = stack[v11];
          else
            v10 = -v60;
        }
        else
        {
          if ( v8 != 31 )
            goto LABEL_5;
          v10 = -v60;
          ++op_ptr;
        }
      }
      else
      {
        if ( v8 != 35 )
          goto LABEL_5;
        ++op_ptr;
        v61 = 0;
        do
        {
          v62 = *op_ptr++;
          v63 = (unsigned __int64)(v62 & 0x7F) << v61;
          v61 += 7;
          v14 |= v63;
        }
        while ( v62 < 0 );
        v10 = v60 + v14;
      }
      goto LABEL_8;
    }
    if ( !v7 )
      goto LABEL_5;
    if ( stack[--v7] )
      op_ptr += *(__int16 *)(op_ptr + 1) + 3;
    else
      op_ptr += 3;
  }
  while ( v5 > op_ptr );
  if ( !v7 )
    goto LABEL_5;
  return stack[v7 - 1];
}
// 44C144: control flows out of bounds to 44C5B0
// 44C4F4: control flows out of bounds to 44C5A4
// 46B220: using guessed type __int64 _tens[1725];

//----- (000000000044C7C0) ----------------------------------------------------
void __fastcall uw_update_context_1(_Unwind_Context *context, _Unwind_FrameState *fs)
{
  _Unwind_Word v4; // x1
  __int64 v5; // x21
  int v6; // w0
  const unsigned __int8 *cfa_exp; // x0
  __int64 v8; // x1
  int v9; // w3
  char v10; // t1
  unsigned __int64 v11; // x2
  char *v12; // x24
  char *by_value; // x26
  __int64 v14; // x19
  unsigned int v15; // w0
  _Unwind_Word reg; // x0
  char *v17; // x0
  _Unwind_Word v18; // x0
  const unsigned __int8 *exp; // x0
  __int64 v20; // x1
  int v21; // w4
  char v22; // t1
  unsigned __int64 v23; // x2
  const unsigned __int8 *v24; // x0
  __int64 v25; // x1
  int v26; // w4
  char v27; // t1
  unsigned __int64 v28; // x2
  unsigned __int8 *v29; // x2
  _Unwind_Word cfa_reg; // x0
  _QWORD *v31; // x3
  _Unwind_Word flags; // [xsp+68h] [xbp+68h]
  _Unwind_SpTmp tmp_sp; // [xsp+78h] [xbp+78h] BYREF
  _Unwind_Context orig_context; // [xsp+80h] [xbp+80h] BYREF

  j_memcpy();
  v4 = orig_context.flags & 0x4000000000000000LL;
  if ( ((orig_context.flags & 0x4000000000000000LL) == 0 || !orig_context.by_value[31]) && !orig_context.reg[31] )
  {
    if ( dwarf_reg_size_table[31] != 8 )
      goto LABEL_34;
    tmp_sp.ptr = (_Unwind_Ptr)context->cfa;
    if ( v4 )
      orig_context.by_value[31] = 0;
    orig_context.reg[31] = &tmp_sp;
  }
  flags = context->flags;
  v5 = flags & 0x4000000000000000LL;
  if ( (flags & 0x4000000000000000LL) != 0 )
    context->by_value[31] = 0;
  context->reg[31] = 0LL;
  v6 = *((unsigned __int8 *)&fs->regs + 882);
  if ( v6 != 1 )
  {
    if ( v6 == 2 )
    {
      cfa_exp = fs->regs.cfa_exp;
      v8 = 0LL;
      v9 = 0;
      do
      {
        v10 = *cfa_exp++;
        v11 = (unsigned __int64)(v10 & 0x7F) << v9;
        v9 += 7;
        v8 |= v11;
      }
      while ( v10 < 0 );
      v12 = (char *)execute_stack_op(cfa_exp, &cfa_exp[v8], &orig_context, 0LL);
      goto LABEL_11;
    }
LABEL_34:
    abort();
  }
  cfa_reg = fs->regs.cfa_reg;
  if ( (int)cfa_reg > 97 )
    goto LABEL_34;
  v31 = orig_context.reg[(int)cfa_reg];
  if ( !v4 )
  {
    if ( (_DWORD)cfa_reg != 46 )
      goto LABEL_48;
LABEL_53:
    JUMPOUT(0x44CABCLL);
  }
  if ( orig_context.by_value[(int)cfa_reg] )
    goto LABEL_50;
  if ( (_DWORD)cfa_reg == 46 )
    goto LABEL_53;
LABEL_48:
  if ( dwarf_reg_size_table[(int)cfa_reg] != 8 )
    goto LABEL_34;
  v31 = (_QWORD *)*v31;
LABEL_50:
  v12 = (char *)v31 + fs->regs.cfa_offset;
LABEL_11:
  by_value = context->by_value;
  v14 = 0LL;
  context->cfa = v12;
  do
  {
    v15 = (unsigned __int8)fs->regs.how[v14];
    if ( v15 == 3 )
    {
      exp = fs->regs.reg[v14].loc.exp;
      v20 = 0LL;
      v21 = 0;
      do
      {
        v22 = *exp++;
        v23 = (unsigned __int64)(v22 & 0x7F) << v21;
        v21 += 7;
        v20 |= v23;
      }
      while ( v22 < 0 );
      v17 = (char *)execute_stack_op(exp, &exp[v20], &orig_context, (_Unwind_Word)v12);
      if ( !v5 )
        goto LABEL_18;
      goto LABEL_26;
    }
    if ( v15 <= 3 )
    {
      if ( v15 == 1 )
      {
        v17 = &v12[fs->regs.reg[v14].loc.reg];
        if ( v5 )
          *by_value = 0;
        goto LABEL_18;
      }
      if ( v15 != 2 )
        goto LABEL_19;
      reg = fs->regs.reg[v14].loc.reg;
      if ( orig_context.by_value[(int)reg] )
      {
        if ( (int)reg > 97 )
          goto LABEL_34;
        if ( (orig_context.flags & 0x4000000000000000LL) != 0 )
        {
          v17 = (char *)orig_context.reg[(int)reg];
          v29 = (unsigned __int8 *)&unk_497000;
        }
        else
        {
          if ( (_DWORD)reg == 46 )
            JUMPOUT(0x44CA58LL);
          v29 = (_BYTE *)&unk_497000;
          if ( dwarf_reg_size_table[(int)reg] != 8 )
            goto LABEL_34;
          v17 = *(char **)orig_context.reg[(int)reg];
        }
        if ( v29[v14 + 288] > 8u )
          goto LABEL_34;
        *by_value = 1;
        goto LABEL_18;
      }
      v17 = (char *)orig_context.reg[(int)reg];
      if ( !v5 )
      {
LABEL_18:
        context->reg[v14] = v17;
        goto LABEL_19;
      }
LABEL_26:
      *by_value = 0;
      goto LABEL_18;
    }
    if ( v15 == 4 )
    {
      v17 = &v12[fs->regs.reg[v14].loc.reg];
      if ( dwarf_reg_size_table[v14] > 8u )
        goto LABEL_34;
      goto LABEL_32;
    }
    if ( v15 == 5 )
    {
      v24 = fs->regs.reg[v14].loc.exp;
      v25 = 0LL;
      v26 = 0;
      do
      {
        v27 = *v24++;
        v28 = (unsigned __int64)(v27 & 0x7F) << v26;
        v26 += 7;
        v25 |= v28;
      }
      while ( v27 < 0 );
      v17 = (char *)execute_stack_op(v24, &v24[v25], &orig_context, (_Unwind_Word)v12);
      if ( dwarf_reg_size_table[v14] > 8u )
        goto LABEL_34;
LABEL_32:
      *by_value = 1;
      goto LABEL_18;
    }
LABEL_19:
    ++v14;
    ++by_value;
  }
  while ( v14 != 98 );
  v18 = flags & 0x7FFFFFFFFFFFFFFFLL;
  if ( fs->signal_frame )
    v18 = flags | 0x8000000000000000LL;
  context->flags = v18;
}
// 44CAB8: control flows out of bounds to 44CABC
// 44CA3C: control flows out of bounds to 44CA58

//----- (000000000044CB00) ----------------------------------------------------
void __fastcall uw_update_context(_Unwind_Context *context, _Unwind_FrameState *fs)
{
  _Unwind_Word retaddr_column; // x0
  _QWORD *v5; // x17
  _Unwind_Word flags; // x1

  uw_update_context_1(context, fs);
  retaddr_column = fs->retaddr_column;
  v5 = 0LL;
  if ( fs->regs.how[retaddr_column] == register_rule::REG_UNDEFINED )
    goto LABEL_2;
  if ( (int)retaddr_column > 97 )
    goto LABEL_16;
  flags = context->flags;
  v5 = context->reg[(int)retaddr_column];
  if ( (flags & 0x4000000000000000LL) != 0 && context->by_value[(int)retaddr_column] )
    goto LABEL_9;
  if ( (_DWORD)retaddr_column == 46 )
    JUMPOUT(0x44CBE0LL);
  if ( dwarf_reg_size_table[(int)retaddr_column] != 8 )
LABEL_16:
    abort();
  v5 = (_QWORD *)*v5;
LABEL_9:
  if ( fs->regs.how[34] != register_rule::REG_ARCHEXT
    && fs->regs.how[34]
    && ((flags & 0x4000000000000000LL) == 0 || !context->by_value[34])
    && dwarf_reg_size_table[34] != 8 )
  {
    goto LABEL_16;
  }
LABEL_2:
  context->ra = v5;
}
// 44CB64: control flows out of bounds to 44CBE0

//----- (000000000044CC00) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall execute_cfa_program_specialized(
        const unsigned __int8 *insn_ptr,
        const unsigned __int8 *insn_end,
        _Unwind_Context *context,
        _Unwind_FrameState *fs)
{
  char *pc; // x5
  unsigned int v7; // w1
  int v8; // w6
  __int64 v9; // x1
  __int64 v10; // x5
  int v11; // w2
  char v12; // t1
  unsigned __int64 v13; // x4

  fs->regs.prev = 0LL;
  while ( insn_end > insn_ptr )
  {
    pc = (char *)fs->pc;
    if ( pc >= (char *)context->ra + (context->flags >> 63) )
      break;
    v7 = *insn_ptr;
    v8 = v7 & 0xC0;
    if ( v8 == 64 )
    {
      ++insn_ptr;
      fs->pc = &pc[v7 & 0x3F];
    }
    else if ( v8 == 128 )
    {
      v9 = v7 & 0x3F;
      ++insn_ptr;
      v10 = 0LL;
      v11 = 0;
      do
      {
        v12 = *insn_ptr++;
        v13 = (unsigned __int64)(v12 & 0x7F) << v11;
        v11 += 7;
        v10 |= v13;
      }
      while ( v12 < 0 );
      fs->regs.how[v9] = register_rule::REG_SAVED_OFFSET;
      fs->regs.reg[v9].loc.reg = -8 * v10;
    }
    else
    {
      if ( v8 != 192 )
      {
        if ( v7 > 0x2F )
          abort();
        __asm { BR              insn }
      }
      ++insn_ptr;
      fs->regs.how[v7 & 0x3F] = register_rule::REG_UNSAVED;
    }
  }
}
// 44CDA0: positive sp value 50 has been found

//----- (000000000044D468) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall execute_cfa_program_generic(
        const unsigned __int8 *insn_ptr,
        const unsigned __int8 *insn_end,
        _Unwind_Context *context,
        _Unwind_FrameState *fs)
{
  char *pc; // x2
  unsigned int v8; // w1
  int v9; // w3
  __int64 v10; // x1
  __int64 v11; // x2
  int v12; // w3
  char v13; // t1
  unsigned __int64 v14; // x4
  _Unwind_Word v15; // x2

  fs->regs.prev = 0LL;
  while ( insn_end > insn_ptr )
  {
    pc = (char *)fs->pc;
    if ( pc >= (char *)context->ra + (context->flags >> 63) )
      break;
    v8 = *insn_ptr;
    v9 = v8 & 0xC0;
    if ( v9 == 64 )
    {
      ++insn_ptr;
      fs->pc = &pc[(v8 & 0x3F) * fs->code_align];
    }
    else if ( v9 == 128 )
    {
      v10 = v8 & 0x3F;
      ++insn_ptr;
      v11 = 0LL;
      v12 = 0;
      do
      {
        v13 = *insn_ptr++;
        v14 = (unsigned __int64)(v13 & 0x7F) << v12;
        v12 += 7;
        v11 |= v14;
      }
      while ( v13 < 0 );
      v15 = v11 * fs->data_align;
      fs->regs.how[v10] = register_rule::REG_SAVED_OFFSET;
      fs->regs.reg[v10].loc.reg = v15;
    }
    else
    {
      if ( v9 != 192 )
      {
        if ( v8 > 0x2F )
          abort();
        __asm { BR              insn }
      }
      ++insn_ptr;
      fs->regs.how[v8 & 0x3F] = register_rule::REG_UNSAVED;
    }
  }
}
// 44D618: positive sp value 50 has been found

//----- (000000000044DD20) ----------------------------------------------------
_Unwind_Reason_Code __fastcall uw_frame_state_for(_Unwind_Context *context, _Unwind_FrameState *fs)
{
  _Unwind_FrameState *how; // x22
  char *ra; // x0
  const fde *FDE; // x0
  const fde *v7; // x21
  unsigned __int8 *v8; // x22
  char *v9; // x0
  unsigned __int8 *v10; // x9
  char *v11; // x2
  _Unwind_Word v12; // x8
  int v13; // w5
  char v14; // t1
  unsigned __int64 v15; // x4
  _Unwind_Sword v16; // x7
  unsigned int v17; // w5
  const unsigned __int8 *v18; // x1
  char v19; // w6
  char v20; // t1
  unsigned __int64 v21; // x4
  _Unwind_Word v22; // x0
  int v23; // w4
  char v24; // t1
  unsigned __int64 v25; // x3
  unsigned __int64 v26; // x4
  int v27; // w3
  unsigned __int8 *v28; // x9
  const unsigned __int8 *v29; // x1
  int fde_encoding; // w0
  unsigned int v31; // w1
  __int64 v32; // x0
  const unsigned __int8 *v33; // x0
  __int64 v34; // x4
  int v35; // w1
  char v36; // t1
  unsigned __int64 v37; // x2
  int lsda_encoding; // w1
  const unsigned __int8 *v39; // x22
  const unsigned __int8 *v40; // x1
  int v42; // w1
  char v43; // t1
  unsigned __int64 v44; // x0
  unsigned __int8 v45; // t1
  int v46; // t1
  unsigned __int8 v47; // t1
  int v48; // w1
  _DWORD *v49; // x0
  char *cfa; // x4
  int32x2_t v51; // d30
  _Unwind_FrameState *v52; // x0
  int32x2_t v53; // d1
  int32x2_t v54; // d0
  int32x2_t v55; // d24
  int64x2_t v56; // q2
  __int64 i; // x0
  int v58; // w1
  int *v59; // x0
  int64x2_t v60; // q23
  int32x4_t v61; // q22
  int32x4_t v62; // q21
  int32x4_t v63; // q20
  __int128 v64; // q30
  int32x4_t v65; // q19
  int32x4_t v66; // q18
  frame_state_reg_info::$6E51BDA795E734780EF56B12D80BE413 *v67; // x1
  _Unwind_FrameState *v68; // x3
  int32x4_t v69; // q16
  int64x2_t v70; // q17
  int32x4_t v71; // q31
  int32x4_t v72; // q3
  int32x4_t v73; // q5
  unsigned __int8 *v74; // [xsp+30h] [xbp+30h]
  _Unwind_Word v75; // [xsp+38h] [xbp+38h]
  const unsigned __int8 *v76; // [xsp+40h] [xbp+40h]
  _Unwind_Sword v77; // [xsp+48h] [xbp+48h]
  _Unwind_Ptr lsda; // [xsp+58h] [xbp+58h] BYREF

  how = (_Unwind_FrameState *)fs->regs.how;
  *(_OWORD *)fs->regs.how = 0u;
  *(_OWORD *)&fs->regs.how[16] = 0u;
  *(_OWORD *)&fs->regs.how[32] = 0u;
  *(_OWORD *)&fs->regs.how[48] = 0u;
  *(_OWORD *)&fs->regs.how[64] = 0u;
  *(_OWORD *)&fs->regs.how[80] = 0u;
  *(_OWORD *)&fs->regs.how[96] = 0u;
  *(_OWORD *)&fs->regs.cfa_offset = 0u;
  *(_OWORD *)&fs->regs.cfa_exp = 0u;
  *(_OWORD *)&fs->pc = 0u;
  *(_OWORD *)&fs->data_align = 0u;
  *(_OWORD *)&fs->retaddr_column = 0u;
  fs->eh_ptr = 0LL;
  fs->regs.reg[34].loc.reg = 0LL;
  fs->regs.how[34] = register_rule::REG_ARCHEXT;
  context->lsda = 0LL;
  ra = (char *)context->ra;
  context->args_size = 0LL;
  if ( !ra )
    return 5;
  FDE = Unwind_Find_FDE(&ra[vcgezd_s64(context->flags)], &context->bases);
  v7 = FDE;
  if ( FDE )
  {
    fs->pc = context->bases.func;
    v8 = (unsigned __int8 *)&FDE->CIE_delta - FDE->CIE_delta;
    v9 = (char *)strlen() + 1;
    v10 = v8 + 9;
    v11 = &v9[(_QWORD)(v8 + 9)];
    if ( v8[9] == 101 && v8[10] == 104 )
    {
      v11 += 8;
      v10 = v8 + 11;
      fs->eh_ptr = *(void **)&v9[(_QWORD)(v8 + 9)];
    }
    if ( v8[8] > 3u )
    {
      if ( *v11 != 8 || v11[1] )
        return 3;
      v11 += 2;
    }
    v12 = 0LL;
    v13 = 0;
    do
    {
      v14 = *v11++;
      v15 = (unsigned __int64)(v14 & 0x7F) << v13;
      v13 += 7;
      v12 |= v15;
    }
    while ( v14 < 0 );
    v16 = 0LL;
    v17 = 0;
    fs->code_align = v12;
    do
    {
      v18 = (const unsigned __int8 *)v11;
      v20 = *v11++;
      v19 = v20;
      v21 = (unsigned __int64)(v20 & 0x7F) << v17;
      v17 += 7;
      v16 |= v21;
    }
    while ( v20 < 0 );
    if ( v17 <= 0x3F && (v19 & 0x40) != 0 )
      v16 |= -1LL << v17;
    fs->data_align = v16;
    v22 = 0LL;
    v23 = 0;
    if ( v8[8] == 1 )
    {
      v26 = 0LL;
      fs->retaddr_column = (unsigned __int8)*v11;
      v11 = (char *)(v18 + 2);
      fs->lsda_encoding = -1;
      v27 = *v10;
      if ( v27 != 122 )
      {
LABEL_15:
        if ( v27 )
          goto LABEL_16;
        v26 = (unsigned __int64)v11;
LABEL_23:
        v29 = &v8[*(unsigned int *)v8 + 4];
        if ( v16 == -8 && v12 == 1 )
          execute_cfa_program_specialized((const unsigned __int8 *)v26, v29, context, fs);
        else
          execute_cfa_program_generic((const unsigned __int8 *)v26, v29, context, fs);
        fde_encoding = fs->fde_encoding;
        if ( fde_encoding == 255 )
        {
          v32 = 8LL;
        }
        else
        {
          v31 = fde_encoding & 7;
          if ( v31 == 2 )
          {
            v32 = 12LL;
          }
          else if ( v31 <= 2 )
          {
            v32 = 24LL;
            if ( v31 )
              abort();
          }
          else
          {
            v32 = 16LL;
            if ( v31 != 3 )
            {
              v32 = 24LL;
              if ( v31 != 4 )
                abort();
            }
          }
        }
        v33 = (const unsigned __int8 *)v7 + v32;
        if ( fs->saw_z )
        {
          v34 = 0LL;
          v35 = 0;
          do
          {
            v36 = *v33++;
            v37 = (unsigned __int64)(v36 & 0x7F) << v35;
            v35 += 7;
            v34 |= v37;
          }
          while ( v36 < 0 );
          lsda_encoding = fs->lsda_encoding;
          v39 = &v33[v34];
          if ( lsda_encoding == 255 )
          {
            v33 += v34;
          }
          else
          {
            read_encoded_value(context, lsda_encoding, v33, &lsda);
            context->lsda = (void *)lsda;
            v33 = v39;
          }
        }
        else
        {
          v48 = fs->lsda_encoding;
          if ( v48 != 255 )
          {
            v33 = read_encoded_value(context, v48, v33, &lsda);
            context->lsda = (void *)lsda;
          }
        }
        v40 = (const unsigned __int8 *)&v7->CIE_delta + v7->length;
        if ( fs->data_align == -8 && fs->code_align == 1 )
        {
          execute_cfa_program_specialized(v33, v40, context, fs);
          return 0;
        }
        else
        {
          execute_cfa_program_generic(v33, v40, context, fs);
          return 0;
        }
      }
    }
    else
    {
      do
      {
        v24 = *v11++;
        v25 = (unsigned __int64)(v24 & 0x7F) << v23;
        v23 += 7;
        v22 |= v25;
      }
      while ( v24 < 0 );
      fs->retaddr_column = v22;
      fs->lsda_encoding = -1;
      v26 = 0LL;
      v27 = *v10;
      if ( v27 != 122 )
        goto LABEL_15;
    }
    v42 = 0;
    do
    {
      v43 = *v11++;
      v44 = (unsigned __int64)(v43 & 0x7F) << v42;
      v42 += 7;
      v26 |= v44;
    }
    while ( v43 < 0 );
    fs->saw_z = 1;
    v26 += (unsigned __int64)v11;
    v27 = v10[1];
    if ( v10[1] )
    {
      ++v10;
LABEL_16:
      v28 = v10 + 1;
      do
      {
        switch ( v27 )
        {
          case 'L':
            v45 = *v11++;
            fs->lsda_encoding = v45;
            break;
          case 'R':
            v47 = *v11++;
            fs->fde_encoding = v47;
            break;
          case 'P':
            v74 = v28;
            v75 = v12;
            v76 = (const unsigned __int8 *)v26;
            v77 = v16;
            v11 = (char *)read_encoded_value(context, *v11, (const unsigned __int8 *)v11 + 1, &lsda);
            v28 = v74;
            v12 = v75;
            v26 = (unsigned __int64)v76;
            v16 = v77;
            fs->personality = (_Unwind_Personality_Fn)lsda;
            break;
          case 'S':
            fs->signal_frame = 1;
            break;
          case 'B':
            fs->regs.arch_fs.signing_key = AARCH64_PAUTH_KEY_B;
            break;
          default:
            if ( !v26 )
              return 3;
            goto LABEL_23;
        }
        v46 = *v28++;
        v27 = v46;
      }
      while ( v46 );
      if ( v26 )
        goto LABEL_23;
      v26 = (unsigned __int64)v11;
      if ( v11 )
        goto LABEL_23;
      return 3;
    }
    goto LABEL_23;
  }
  v49 = context->ra;
  if ( *v49 != -763358872 || v49[1] != -738197503 )
    return 5;
  cfa = (char *)context->cfa;
  *((_BYTE *)&fs->regs + 882) = 1;
  fs->regs.cfa_reg = 31LL;
  v51.n64_u64[0] = 0x100000000LL;
  fs->regs.cfa_offset = cfa + 304 - (char *)context->cfa;
  v52 = fs;
  do
  {
    v53.n64_u64[0] = vadd_s32(v51, (int32x2_t)0x200000002LL).n64_u64[0];
    v54.n64_u64[0] = vadd_s32(v51, (int32x2_t)0x400000004LL).n64_u64[0];
    v55.n64_u64[0] = vadd_s32(v51, (int32x2_t)0x600000006LL).n64_u64[0];
    how->regs.reg[0].loc.reg = 0x101010101010101LL;
    how = (_Unwind_FrameState *)((char *)how + 8);
    v56 = vaddw_s32((int64x2_t)xmmword_45B7A0, v51);
    v52 = (_Unwind_FrameState *)((char *)v52 + 64);
    v51.n64_u64[0] = vadd_s32(v51, (int32x2_t)0x800000008LL).n64_u64[0];
    *(int64x2_t *)&v52[-1].regs.arch_fs.signing_key = vshlq_n_s64(v56, 3uLL);
    *(int64x2_t *)&v52[-1].personality = vshlq_n_s64(vaddw_s32((int64x2_t)xmmword_45B7A0, v53), 3uLL);
    *(int64x2_t *)&v52[-1].code_align = vshlq_n_s64(vaddw_s32((int64x2_t)xmmword_45B7A0, v54), 3uLL);
    *(int64x2_t *)&v52[-1].fde_encoding = vshlq_n_s64(vaddw_s32((int64x2_t)xmmword_45B7A0, v55), 3uLL);
  }
  while ( &fs->regs.how[24] != (register_rule *)how );
  for ( i = 25LL; i != 32; ++i )
  {
    *((_BYTE *)&fs->regs.reg[97].loc.exp + i + 7) = 1;
    *((_QWORD *)&fs[-1].eh_ptr + i) = 8LL * (unsigned int)i;
  }
  v58 = *((_DWORD *)cfa + 148);
  v59 = (int *)(cfa + 592);
  if ( v58 )
  {
    v60 = vdupq_n_s64((unsigned __int64)(cfa + 304));
    v61.n128_u64[0] = 0x400000004LL;
    v61.n128_u64[1] = 0x400000004LL;
    v62.n128_u64[0] = 0x800000008LL;
    v62.n128_u64[1] = 0x800000008LL;
    v63.n128_u64[0] = 0xC0000000CLL;
    v63.n128_u64[1] = 0xC0000000CLL;
    *(_QWORD *)&v64 = 0x101010101010101LL;
    *((_QWORD *)&v64 + 1) = 0x101010101010101LL;
    v65.n128_u64[0] = 0x100000001LL;
    v65.n128_u64[1] = 0x100000001LL;
    v66.n128_u64[0] = 0x1000000010LL;
    v66.n128_u64[1] = 0x1000000010LL;
    do
    {
      if ( v58 == 1179680769 )
      {
        v67 = &fs->regs.reg[64];
        v68 = (_Unwind_FrameState *)&fs->regs.how[64];
        v69 = (int32x4_t)xmmword_45B7E0;
        v70 = vsubq_s64(vdupq_n_s64((unsigned __int64)v59), v60);
        do
        {
          v71 = vaddq_s32(v69, v61);
          *(_OWORD *)&v68->regs.reg[0].loc.reg = v64;
          v68 = (_Unwind_FrameState *)((char *)v68 + 16);
          v67 += 16;
          v72 = vaddq_s32(v69, v62);
          v73 = vaddq_s32(v69, v63);
          *(int64x2_t *)&v67[-16].loc.reg = vaddq_s64(
                                              vshlq_n_s64(
                                                vaddl_s32((int32x2_t)v69.n128_u64[0], (int32x2_t)v65.n128_u64[0]),
                                                4uLL),
                                              v70);
          *(int64x2_t *)&v67[-14].loc.reg = vaddq_s64(vshlq_n_s64(vaddl_high_s32(v69, v65), 4uLL), v70);
          *(int64x2_t *)&v67[-12].loc.reg = vaddq_s64(
                                              vshlq_n_s64(
                                                vaddl_s32((int32x2_t)v71.n128_u64[0], (int32x2_t)v65.n128_u64[0]),
                                                4uLL),
                                              v70);
          *(int64x2_t *)&v67[-10].loc.reg = vaddq_s64(vshlq_n_s64(vaddl_high_s32(v71, v65), 4uLL), v70);
          *(int64x2_t *)&v67[-8].loc.reg = vaddq_s64(
                                             vshlq_n_s64(
                                               vaddl_s32((int32x2_t)v72.n128_u64[0], (int32x2_t)v65.n128_u64[0]),
                                               4uLL),
                                             v70);
          *(int64x2_t *)&v67[-6].loc.reg = vaddq_s64(vshlq_n_s64(vaddl_high_s32(v72, v65), 4uLL), v70);
          v69 = vaddq_s32(v69, v66);
          *(int64x2_t *)&v67[-4].loc.reg = vaddq_s64(
                                             vshlq_n_s64(
                                               vaddl_s32((int32x2_t)v73.n128_u64[0], (int32x2_t)v65.n128_u64[0]),
                                               4uLL),
                                             v70);
          *(int64x2_t *)&v67[-2].loc.reg = vaddq_s64(vshlq_n_s64(vaddl_high_s32(v73, v65), 4uLL), v70);
        }
        while ( &fs->regs.how[96] != (register_rule *)v68 );
      }
      v59 = (int *)((char *)v59 + (unsigned int)v59[1]);
      v58 = *v59;
    }
    while ( *v59 );
  }
  fs->regs.reg[31].loc.reg = 256LL;
  fs->regs.how[31] = register_rule::REG_SAVED_OFFSET;
  fs->regs.how[96] = register_rule::REG_SAVED_VAL_OFFSET;
  fs->signal_frame = 1;
  fs->regs.reg[96].loc.reg = *((_QWORD *)cfa + 71) - (_QWORD)(cfa + 304);
  fs->retaddr_column = 96LL;
  return 0;
}
// 45B7A0: using guessed type __int128 xmmword_45B7A0;
// 45B7E0: using guessed type __int128 xmmword_45B7E0;

//----- (000000000044E38C) ----------------------------------------------------
void __fastcall uw_init_context_1(_Unwind_Context *context, void *outer_cfa, void *outer_ra)
{
  void *v3; // x30
  _Unwind_Word flags; // x0
  _Unwind_SpTmp sp_slot; // [xsp+40h] [xbp+40h] BYREF
  _Unwind_FrameState fs; // [xsp+48h] [xbp+48h] BYREF

  memset();
  context->ra = v3;
  context->flags = 0x4000000000000000LL;
  if ( uw_frame_state_for(context, &fs) )
    goto LABEL_9;
  if ( (unsigned int)pthread_once((unsigned int *)&once_regsizes_0, init_dwarf_reg_size_table)
    && !dwarf_reg_size_table[0] )
  {
    memset(dwarf_reg_size_table, 8, 32);
    dwarf_reg_size_table[64] = 0;
    dwarf_reg_size_table[46] = 8;
    dwarf_reg_size_table[65] = 0;
    dwarf_reg_size_table[66] = 0;
    dwarf_reg_size_table[67] = 0;
    dwarf_reg_size_table[68] = 0;
    dwarf_reg_size_table[69] = 0;
    dwarf_reg_size_table[70] = 0;
    dwarf_reg_size_table[71] = 0;
    dwarf_reg_size_table[72] = 8;
    dwarf_reg_size_table[73] = 8;
    dwarf_reg_size_table[74] = 8;
    dwarf_reg_size_table[75] = 8;
    dwarf_reg_size_table[76] = 8;
    dwarf_reg_size_table[77] = 8;
    dwarf_reg_size_table[78] = 8;
    dwarf_reg_size_table[79] = 8;
    dwarf_reg_size_table[80] = 0;
    dwarf_reg_size_table[81] = 0;
    dwarf_reg_size_table[82] = 0;
    dwarf_reg_size_table[83] = 0;
    dwarf_reg_size_table[84] = 0;
    dwarf_reg_size_table[85] = 0;
    dwarf_reg_size_table[86] = 0;
    dwarf_reg_size_table[87] = 0;
    dwarf_reg_size_table[88] = 0;
    dwarf_reg_size_table[89] = 0;
    dwarf_reg_size_table[90] = 0;
    dwarf_reg_size_table[91] = 0;
    dwarf_reg_size_table[92] = 0;
    dwarf_reg_size_table[93] = 0;
    dwarf_reg_size_table[94] = 0;
    dwarf_reg_size_table[95] = 0;
    dwarf_reg_size_table[48] = 0;
    dwarf_reg_size_table[49] = 0;
    dwarf_reg_size_table[50] = 0;
    dwarf_reg_size_table[51] = 0;
    dwarf_reg_size_table[52] = 0;
    dwarf_reg_size_table[53] = 0;
    dwarf_reg_size_table[54] = 0;
    dwarf_reg_size_table[55] = 0;
    dwarf_reg_size_table[56] = 0;
    dwarf_reg_size_table[57] = 0;
    dwarf_reg_size_table[58] = 0;
    dwarf_reg_size_table[59] = 0;
    dwarf_reg_size_table[60] = 0;
    dwarf_reg_size_table[61] = 0;
    dwarf_reg_size_table[62] = 0;
    dwarf_reg_size_table[63] = 0;
    dwarf_reg_size_table[96] = 8;
  }
  if ( dwarf_reg_size_table[31] != 8 )
LABEL_9:
    abort();
  flags = context->flags;
  sp_slot.ptr = (_Unwind_Ptr)outer_cfa;
  if ( (flags & 0x4000000000000000LL) != 0 )
    context->by_value[31] = 0;
  context->reg[31] = &sp_slot;
  *((_BYTE *)&fs.regs + 882) = 1;
  fs.regs.cfa_offset = 0LL;
  fs.regs.cfa_reg = 31LL;
  uw_update_context_1(context, &fs);
  context->ra = outer_ra;
}
// 44E3C4: variable 'v3' is possibly undefined

//----- (000000000044E5C0) ----------------------------------------------------
_Unwind_Reason_Code __fastcall Unwind_RaiseException_Phase2(
        _Unwind_Exception *exc,
        _Unwind_Context *context,
        unsigned __int64 *frames_p)
{
  unsigned __int64 v6; // x21
  _Unwind_Reason_Code v7; // w0
  int v8; // w23
  _Unwind_Reason_Code result; // w0
  _Unwind_FrameState fs; // [xsp+48h] [xbp+48h] BYREF

  v6 = 1LL;
  while ( 1 )
  {
    fs.personality = 0LL;
    v7 = uw_frame_state_for(context, &fs);
    if ( (void *)exc->private_2 == (char *)context->cfa - (context->flags >> 63) )
      break;
    if ( v7 )
      return 2;
    v8 = 0;
    if ( !fs.personality )
      goto LABEL_8;
    result = fs.personality(1, 2LL, exc->exception_class, exc, context);
    if ( result == _URC_INSTALL_CONTEXT )
      goto LABEL_13;
LABEL_6:
    if ( result != _URC_CONTINUE_UNWIND )
      return 2;
    if ( v8 )
LABEL_14:
      abort();
LABEL_8:
    uw_update_context(context, &fs);
    ++v6;
    __asm { HINT            #0x28 ; '(' }
  }
  if ( v7 )
    return 2;
  if ( !fs.personality )
    goto LABEL_14;
  v8 = 4;
  result = fs.personality(1, 6LL, exc->exception_class, exc, context);
  if ( result != _URC_INSTALL_CONTEXT )
    goto LABEL_6;
LABEL_13:
  *frames_p = v6;
  return result;
}

//----- (000000000044E700) ----------------------------------------------------
_Unwind_Reason_Code __fastcall Unwind_ForcedUnwind_Phase2(
        _Unwind_Exception *exc,
        _Unwind_Context *context,
        unsigned __int64 *frames_p)
{
  unsigned __int64 v5; // x21
  unsigned int (__fastcall *private_1)(__int64, __int64, _Unwind_Exception_Class, _Unwind_Exception *, _Unwind_Context *, _Unwind_Word); // x24
  _Unwind_Word private_2; // x25
  _Unwind_Reason_Code v9; // w0
  _Unwind_Exception_Class exception_class; // x2
  _Unwind_Reason_Code result; // w0
  _Unwind_FrameState fs; // [xsp+58h] [xbp+58h] BYREF

  v5 = 1LL;
  private_1 = (unsigned int (__fastcall *)(__int64, __int64, _Unwind_Exception_Class, _Unwind_Exception *, _Unwind_Context *, _Unwind_Word))exc->private_1;
  private_2 = exc->private_2;
  while ( 1 )
  {
    v9 = uw_frame_state_for(context, &fs);
    if ( ((0x21uLL >> v9) & 1) == 0 )
      return 2;
    exception_class = exc->exception_class;
    if ( v9 )
      break;
    if ( private_1(1LL, 10LL, exception_class, exc, context, private_2) )
      return 2;
    if ( fs.personality )
    {
      result = fs.personality(1, 10LL, exc->exception_class, exc, context);
      if ( result == _URC_INSTALL_CONTEXT )
        goto LABEL_12;
      if ( result != _URC_CONTINUE_UNWIND )
        return 2;
    }
    uw_update_context(context, &fs);
    ++v5;
    __asm { HINT            #0x28 ; '(' }
  }
  if ( private_1(1LL, 26LL, exception_class, exc, context, private_2) )
    return 2;
  result = _URC_END_OF_STACK;
LABEL_12:
  *frames_p = v5;
  return result;
}

//----- (000000000044E860) ----------------------------------------------------
_Unwind_Word __fastcall Unwind_GetGR(_Unwind_Context *context, int regno)
{
  if ( regno > 97 )
    goto LABEL_8;
  if ( (context->flags & 0x4000000000000000LL) == 0 || !context->by_value[regno] )
  {
    if ( regno == 46 )
      JUMPOUT(0x44E8A4LL);
    if ( dwarf_reg_size_table[regno] == 8 )
      return *(_QWORD *)context->reg[regno];
LABEL_8:
    abort();
  }
  return (_Unwind_Word)context->reg[regno];
}
// 44E884: control flows out of bounds to 44E8A4

//----- (000000000044E8C4) ----------------------------------------------------
_Unwind_Word __fastcall Unwind_GetCFA(_Unwind_Context *context)
{
  return (_Unwind_Word)context->cfa;
}

//----- (000000000044E8CC) ----------------------------------------------------
void __fastcall Unwind_SetGR(_Unwind_Context *context, int index, _Unwind_Word val)
{
  if ( index > 97 )
    goto LABEL_7;
  if ( (context->flags & 0x4000000000000000LL) == 0 || !context->by_value[index] )
  {
    if ( dwarf_reg_size_table[index] == 8 )
    {
      *(_QWORD *)context->reg[index] = val;
      return;
    }
LABEL_7:
    abort();
  }
  context->reg[index] = (_Unwind_Context_Reg_Val)val;
}

//----- (000000000044E920) ----------------------------------------------------
_Unwind_Ptr __fastcall Unwind_GetIP(_Unwind_Context *context)
{
  return (_Unwind_Ptr)context->ra;
}

//----- (000000000044E928) ----------------------------------------------------
_Unwind_Ptr __fastcall Unwind_GetIPInfo(_Unwind_Context *context, int *ip_before_insn)
{
  _Unwind_Word flags; // x2
  _Unwind_Ptr result; // x0

  flags = context->flags;
  result = (_Unwind_Ptr)context->ra;
  *ip_before_insn = flags >> 63;
  return result;
}

//----- (000000000044E940) ----------------------------------------------------
void __fastcall Unwind_SetIP(_Unwind_Context *context, _Unwind_Ptr val)
{
  context->ra = (void *)val;
}

//----- (000000000044E948) ----------------------------------------------------
void *__fastcall Unwind_GetLanguageSpecificData(_Unwind_Context *context)
{
  return context->lsda;
}

//----- (000000000044E950) ----------------------------------------------------
_Unwind_Ptr __fastcall Unwind_GetRegionStart(_Unwind_Context *context)
{
  return (_Unwind_Ptr)context->bases.func;
}

//----- (000000000044E960) ----------------------------------------------------
void *__fastcall Unwind_FindEnclosingFunction(void *pc)
{
  void *result; // x0
  dwarf_eh_bases bases; // [xsp+18h] [xbp+18h] BYREF

  result = (void *)Unwind_Find_FDE((char *)pc - 1, &bases);
  if ( result )
    return bases.func;
  return result;
}

//----- (000000000044E988) ----------------------------------------------------
_Unwind_Ptr __fastcall Unwind_GetDataRelBase(_Unwind_Context *context)
{
  return (_Unwind_Ptr)context->bases.dbase;
}

//----- (000000000044E990) ----------------------------------------------------
_Unwind_Ptr __fastcall Unwind_GetTextRelBase(_Unwind_Context *context)
{
  return (_Unwind_Ptr)context->bases.tbase;
}

//----- (000000000044E9A0) ----------------------------------------------------
frame_state *__fastcall _frame_state_for(void *pc_target, frame_state *state_in)
{
  int8x16_t *(__fastcall *v3)(int8x16_t *, unsigned __int8, unsigned __int64); // x0
  __int64 i; // x2
  int v5; // w3
  _Unwind_Word reg; // x4
  _Unwind_Context context; // [xsp+20h] [xbp+20h]
  _Unwind_FrameState fs; // [xsp+3E0h] [xbp+3E0h] BYREF

  v3 = memset();
  if ( uw_frame_state_for((_Unwind_Context *)v3, &fs) || *((unsigned __int8 *)&fs.regs + 882) == 2 )
    return 0LL;
  for ( i = 1LL; i != 99; ++i )
  {
    v5 = *((unsigned __int8 *)&fs.regs.reg[97].loc.exp + i + 7);
    *((_BYTE *)&state_in->retaddr_column + i + 1) = v5;
    if ( v5 == 1 || (reg = 0LL, v5 == 2) )
      reg = fs.regs.reg[i - 1].loc.reg;
    *(&state_in->args_size + i) = reg;
  }
  state_in->cfa_offset = fs.regs.cfa_offset;
  state_in->cfa_reg = fs.regs.cfa_reg;
  state_in->retaddr_column = fs.retaddr_column;
  state_in->args_size = context.args_size;
  state_in->eh_ptr = fs.eh_ptr;
  return state_in;
}

//----- (000000000044EAA0) ----------------------------------------------------
_Unwind_Reason_Code __fastcall Unwind_RaiseException(_Unwind_Exception *exc)
{
  __int64 v1; // x1
  __int64 v2; // x2
  __int64 v3; // x3
  void *v4; // x30
  _Unwind_Reason_Code v6; // w0
  unsigned int (__fastcall *v7)(_Unwind_Exception *, __int64, __int64, __int64); // x6
  __int64 v8; // x4
  _Unwind_Reason_Code result; // w0
  char *v10; // x0
  unsigned int (__fastcall *ra)(_Unwind_Exception *, __int64, __int64, __int64); // x19
  __int64 v17; // [xsp+18h] [xbp+18h]
  __int64 v18; // [xsp+20h] [xbp+20h]
  __int64 v19; // [xsp+28h] [xbp+28h]
  _Unwind_Context this_context; // [xsp+C8h] [xbp+C8h] BYREF
  _Unwind_Context cur_context; // [xsp+488h] [xbp+488h] BYREF
  _Unwind_FrameState fs; // [xsp+848h] [xbp+848h] BYREF
  char outer_cfa; // [xsp+C20h] [xbp+C20h] BYREF

  v17 = v1;
  v18 = v2;
  v19 = v3;
  uw_init_context_1(&this_context, &outer_cfa, v4);
  j_memcpy();
  while ( 1 )
  {
    if ( uw_frame_state_for(&cur_context, &fs) )
      goto LABEL_7;
    if ( fs.personality )
      break;
LABEL_5:
    uw_update_context(&cur_context, &fs);
  }
  v6 = fs.personality(1, 1LL, exc->exception_class, exc, &cur_context);
  if ( v6 != _URC_HANDLER_FOUND )
  {
    if ( v6 != _URC_CONTINUE_UNWIND )
      goto LABEL_7;
    goto LABEL_5;
  }
  v10 = (char *)cur_context.cfa - (cur_context.flags >> 63);
  exc->private_1 = 0LL;
  exc->private_2 = (_Unwind_Word)v10;
  j_memcpy();
  if ( Unwind_RaiseException_Phase2(exc, &cur_context, (unsigned __int64 *)&fs) != _URC_INSTALL_CONTEXT )
  {
LABEL_7:
    v8 = 0LL;
    goto LABEL_8;
  }
  uw_install_context_1(&this_context, &cur_context);
  ra = (unsigned int (__fastcall *)(_Unwind_Exception *, __int64, __int64, __int64))cur_context.ra;
  Unwind_DebugHook(cur_context.cfa, cur_context.ra);
  _arm_za_disable();
  __asm { HINT            #0x28 ; '(' }
  v7 = ra;
  v8 = 1LL;
LABEL_8:
  result = (int)exc;
  if ( v8 )
    return v7(exc, v17, v18, v19);
  return result;
}
// 44EAB0: variable 'v1' is possibly undefined
// 44EAB8: variable 'v2' is possibly undefined
// 44EAB8: variable 'v3' is possibly undefined
// 44EAF4: variable 'v4' is possibly undefined
// 44EBA0: variable 'v7' is possibly undefined

//----- (000000000044EC44) ----------------------------------------------------
_Unwind_Reason_Code __fastcall Unwind_ForcedUnwind(_Unwind_Exception *exc, _Unwind_Stop_Fn stop, void *stop_argument)
{
  __int64 v3; // x3
  void *v4; // x30
  unsigned int (__fastcall *v8)(_Unwind_Exception *, _Unwind_Stop_Fn, void *, __int64); // x6
  __int64 v9; // x4
  _Unwind_Reason_Code result; // w0
  unsigned int (__fastcall *ra)(_Unwind_Exception *, _Unwind_Stop_Fn, void *, __int64); // x19
  __int64 v19; // [xsp+28h] [xbp+28h]
  unsigned __int64 frames; // [xsp+C8h] [xbp+C8h] BYREF
  _Unwind_Context this_context; // [xsp+D0h] [xbp+D0h] BYREF
  _Unwind_Context cur_context; // [xsp+490h] [xbp+490h] BYREF
  char outer_cfa; // [xsp+850h] [xbp+850h] BYREF

  v19 = v3;
  uw_init_context_1(&this_context, &outer_cfa, v4);
  j_memcpy();
  exc->private_1 = (_Unwind_Word)stop;
  exc->private_2 = (_Unwind_Word)stop_argument;
  if ( Unwind_ForcedUnwind_Phase2(exc, &cur_context, &frames) == _URC_INSTALL_CONTEXT )
  {
    uw_install_context_1(&this_context, &cur_context);
    ra = (unsigned int (__fastcall *)(_Unwind_Exception *, _Unwind_Stop_Fn, void *, __int64))cur_context.ra;
    Unwind_DebugHook(cur_context.cfa, cur_context.ra);
    _arm_za_disable();
    __asm { HINT            #0x28 ; '(' }
    v8 = ra;
    v9 = 1LL;
  }
  else
  {
    v9 = 0LL;
  }
  result = (int)exc;
  if ( v9 )
    return v8(exc, stop, stop_argument, v19);
  return result;
}
// 44EC6C: variable 'v3' is possibly undefined
// 44EC98: variable 'v4' is possibly undefined
// 44ED08: variable 'v8' is possibly undefined

//----- (000000000044ED64) ----------------------------------------------------
void __fastcall __noreturn Unwind_Resume(_Unwind_Exception *exc)
{
  __int64 v1; // x1
  __int64 v2; // x2
  __int64 v3; // x3
  void *v4; // x30
  _Unwind_Reason_Code v6; // w0
  void (__fastcall *ra)(_Unwind_Exception *, __int64, __int64, __int64); // x19
  __int64 v13; // [xsp+18h] [xbp+18h]
  __int64 v14; // [xsp+20h] [xbp+20h]
  __int64 v15; // [xsp+28h] [xbp+28h]
  unsigned __int64 frames; // [xsp+C8h] [xbp+C8h] BYREF
  _Unwind_Context this_context; // [xsp+D0h] [xbp+D0h] BYREF
  _Unwind_Context cur_context; // [xsp+490h] [xbp+490h] BYREF
  char outer_cfa; // [xsp+850h] [xbp+850h] BYREF

  v13 = v1;
  v14 = v2;
  v15 = v3;
  uw_init_context_1(&this_context, &outer_cfa, v4);
  j_memcpy();
  if ( exc->private_1 )
    v6 = Unwind_ForcedUnwind_Phase2(exc, &cur_context, &frames);
  else
    v6 = Unwind_RaiseException_Phase2(exc, &cur_context, &frames);
  if ( v6 != _URC_INSTALL_CONTEXT )
    abort();
  uw_install_context_1(&this_context, &cur_context);
  ra = (void (__fastcall *)(_Unwind_Exception *, __int64, __int64, __int64))cur_context.ra;
  Unwind_DebugHook(cur_context.cfa, cur_context.ra);
  _arm_za_disable();
  __asm { HINT            #0x28 ; '(' }
  ra(exc, v13, v14, v15);
}
// 44ED7C: variable 'v1' is possibly undefined
// 44ED88: variable 'v2' is possibly undefined
// 44ED88: variable 'v3' is possibly undefined
// 44EDB4: variable 'v4' is possibly undefined

//----- (000000000044EE8C) ----------------------------------------------------
_Unwind_Reason_Code __fastcall __noreturn Unwind_Resume_or_Rethrow(_Unwind_Exception *exc)
{
  __int64 v1; // x1
  __int64 v2; // x2
  __int64 v3; // x3
  void *v4; // x30
  _Unwind_Exception *v5; // x6
  __int64 v6; // x4
  _Unwind_Reason_Code result; // w0
  __int64 v13; // [xsp+18h] [xbp+18h]
  __int64 v14; // [xsp+20h] [xbp+20h]
  __int64 v15; // [xsp+28h] [xbp+28h]
  _Unwind_Exception *excb; // [xsp+C0h] [xbp+C0h]
  unsigned __int64 frames; // [xsp+D8h] [xbp+D8h] BYREF
  _Unwind_Context this_context; // [xsp+E0h] [xbp+E0h] BYREF
  _Unwind_Context cur_context; // [xsp+4A0h] [xbp+4A0h] BYREF
  char outer_cfa; // [xsp+860h] [xbp+860h] BYREF

  v13 = v1;
  v14 = v2;
  v15 = v3;
  if ( exc->private_1 )
  {
    uw_init_context_1(&this_context, &outer_cfa, v4);
    j_memcpy();
    if ( Unwind_ForcedUnwind_Phase2(exc, &cur_context, &frames) != _URC_INSTALL_CONTEXT )
      abort();
    uw_install_context_1(&this_context, &cur_context);
    excb = (_Unwind_Exception *)cur_context.ra;
    Unwind_DebugHook(cur_context.cfa, cur_context.ra);
    _arm_za_disable();
    __asm { HINT            #0x28 ; '(' }
    v5 = excb;
    v6 = 1LL;
  }
  else
  {
    Unwind_RaiseException(exc);
    v6 = 0LL;
  }
  result = (int)exc;
  if ( v6 )
    return ((unsigned int (__fastcall *)(_Unwind_Exception *, __int64, __int64, __int64))v5)(exc, v13, v14, v15);
  return result;
}
// 44EE98: variable 'v1' is possibly undefined
// 44EE9C: variable 'v2' is possibly undefined
// 44EE9C: variable 'v3' is possibly undefined
// 44EF14: variable 'v5' is possibly undefined
// 44EF30: variable 'v4' is possibly undefined

//----- (000000000044EFC0) ----------------------------------------------------
void __fastcall Unwind_DeleteException(_Unwind_Exception *exc)
{
  _Unwind_Exception_Cleanup_Fn exception_cleanup; // x2

  exception_cleanup = exc->exception_cleanup;
  if ( exception_cleanup )
    exception_cleanup(_URC_FOREIGN_EXCEPTION_CAUGHT, exc);
}

//----- (000000000044EFE0) ----------------------------------------------------
_Unwind_Reason_Code __fastcall Unwind_Backtrace(_Unwind_Trace_Fn trace, void *trace_argument)
{
  void *v2; // x30
  _Unwind_Reason_Code v5; // w19
  _Unwind_Context context; // [xsp+A8h] [xbp+A8h] BYREF
  _Unwind_FrameState fs; // [xsp+468h] [xbp+468h] BYREF
  char outer_cfa; // [xsp+840h] [xbp+840h] BYREF

  uw_init_context_1(&context, &outer_cfa, v2);
  while ( 1 )
  {
    v5 = uw_frame_state_for(&context, &fs);
    if ( ((0x21uLL >> v5) & 1) == 0 || trace(&context, trace_argument) )
      break;
    if ( v5 == _URC_END_OF_STACK )
      return v5;
    uw_update_context(&context, &fs);
  }
  return 3;
}
// 44F02C: variable 'v2' is possibly undefined

//----- (000000000044F0C0) ----------------------------------------------------
int __fastcall fde_unencoded_compare(object *ob, const fde *x, const fde *y)
{
  unsigned __int64 v3; // x0
  unsigned __int64 v4; // x1
  bool v5; // cc
  int result; // w0

  v3 = *(_QWORD *)y->pc_begin;
  v4 = *(_QWORD *)x->pc_begin;
  v5 = v4 > v3;
  if ( v4 >= v3 )
    result = 0;
  else
    result = -1;
  if ( v5 )
    return 1;
  return result;
}

//----- (000000000044F0E0) ----------------------------------------------------
void __fastcall fde_unencoded_extract(object *ob, _Unwind_Ptr *target, const fde **x, int count)
{
  __int64 v4; // x3
  unsigned __int64 v5; // x0

  if ( count > 0 )
  {
    v4 = 8LL * (unsigned int)count;
    v5 = 0LL;
    do
    {
      target[v5 / 8] = *(_QWORD *)x[v5 / 8]->pc_begin;
      v5 += 8LL;
    }
    while ( v4 != v5 );
  }
}

//----- (000000000044F10C) ----------------------------------------------------
void __fastcall frame_downheap(object *ob, fde_compare_t fde_compare, const fde **a, int lo, int hi)
{
  int v5; // w19
  int i; // w20
  __int64 v11; // x0
  int v12; // w24
  const fde **v13; // x26
  const fde **v14; // x27
  __int64 v15; // x20
  const fde *v16; // x0

  v5 = 2 * lo + 1;
  if ( v5 < hi )
  {
    for ( i = lo; ; i = v12 )
    {
      v11 = v5;
      v12 = v5 + 1;
      v13 = &a[v11];
      if ( v5 + 1 < hi
        && (v14 = &a[v11 + 1],
            (((__int64 (__fastcall *)(object *, const fde *, const fde *))fde_compare)(ob, a[v5], *v14) & 0x80000000) != 0) )
      {
        v13 = v14;
        v15 = i;
        if ( (((__int64 (__fastcall *)(object *, const fde *, const fde *))fde_compare)(ob, a[v15], *v14) & 0x80000000) == 0 )
          return;
      }
      else
      {
        v15 = i;
        v12 = v5;
        if ( (((__int64 (__fastcall *)(object *, const fde *, const fde *))fde_compare)(ob, a[v15], *v13) & 0x80000000) == 0 )
          return;
      }
      v16 = a[v15];
      a[v15] = *v13;
      v5 = 2 * v12 + 1;
      *v13 = v16;
      if ( hi <= v5 )
        return;
    }
  }
}

//----- (000000000044F200) ----------------------------------------------------
void __fastcall version_lock_lock_exclusive(version_lock *vl)
{
  __int64 v1; // x1
  __int64 v2; // x2
  __int64 v3; // x3
  __int64 v4; // x4
  void *v5; // x5
  void *v6; // x6
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  unsigned __int64 v16; // x20
  __int64 v17; // x0
  unsigned __int64 v18; // x20
  unsigned __int64 v19; // x0
  double v20; // d0
  double v21; // d1
  double v22; // d2
  double v23; // d3
  double v24; // d4
  double v25; // d5
  double v26; // d6
  double v27; // d7

  v16 = atomic_load(&vl->version_lock);
  if ( (v16 & 1) != 0 || (_aarch64_cas8_acq_rel(), v17 != v16) )
  {
    pthread_mutex_lock(&version_lock_mutex, v7, v8, v9, v10, v11, v12, v13, v14, v1, v2, v3, v4, v5, v6);
    v18 = atomic_load(&vl->version_lock);
    while ( 1 )
    {
      if ( (v18 & 1) != 0 )
      {
        if ( (v18 & 2) == 0 )
        {
          _aarch64_cas8_acq_rel();
          if ( v19 != v18 )
            goto LABEL_10;
        }
        pthread_cond_wait((__int64)&version_lock_cond, &version_lock_mutex.__data.__lock);
        v18 = atomic_load(&vl->version_lock);
      }
      else
      {
        _aarch64_cas8_acq_rel();
        if ( v19 == v18 )
        {
          pthread_mutex_unlock(&version_lock_mutex.__data.__lock, v20, v21, v22, v23, v24, v25, v26, v27);
          return;
        }
LABEL_10:
        v18 = v19;
      }
    }
  }
}
// 44F22C: variable 'v17' is possibly undefined
// 44F24C: variable 'v7' is possibly undefined
// 44F24C: variable 'v8' is possibly undefined
// 44F24C: variable 'v9' is possibly undefined
// 44F24C: variable 'v10' is possibly undefined
// 44F24C: variable 'v11' is possibly undefined
// 44F24C: variable 'v12' is possibly undefined
// 44F24C: variable 'v13' is possibly undefined
// 44F24C: variable 'v14' is possibly undefined
// 44F24C: variable 'v1' is possibly undefined
// 44F24C: variable 'v2' is possibly undefined
// 44F24C: variable 'v3' is possibly undefined
// 44F24C: variable 'v4' is possibly undefined
// 44F24C: variable 'v5' is possibly undefined
// 44F24C: variable 'v6' is possibly undefined
// 44F26C: variable 'v19' is possibly undefined
// 44F284: variable 'v20' is possibly undefined
// 44F284: variable 'v21' is possibly undefined
// 44F284: variable 'v22' is possibly undefined
// 44F284: variable 'v23' is possibly undefined
// 44F284: variable 'v24' is possibly undefined
// 44F284: variable 'v25' is possibly undefined
// 44F284: variable 'v26' is possibly undefined
// 44F284: variable 'v27' is possibly undefined

//----- (000000000044F2C0) ----------------------------------------------------
const unsigned __int8 *__fastcall read_encoded_value_with_base(
        unsigned __int8 encoding,
        _Unwind_Ptr base,
        const unsigned __int8 *p,
        _Unwind_Ptr *val)
{
  unsigned int v5; // w0
  const unsigned __int8 *result; // x0
  _Unwind_Ptr v7; // x4
  int v8; // w7
  char v9; // t1
  unsigned __int64 v10; // x6
  unsigned __int64 v11; // x2
  unsigned int v12; // w7
  char v13; // w8
  char v14; // t1
  unsigned __int64 v15; // x6

  if ( encoding == 80 )
  {
    v11 = (unsigned __int64)(p + 7);
    result = (const unsigned __int8 *)((v11 & 0xFFFFFFFFFFFFFFF8LL) + 8);
    v7 = *(_QWORD *)(v11 & 0xFFFFFFFFFFFFFFF8LL);
    goto LABEL_21;
  }
  v5 = encoding & 0xF;
  if ( (encoding & 0xF) == 4 )
    goto LABEL_23;
  if ( v5 <= 4 )
  {
    if ( v5 == 2 )
    {
      result = p + 2;
      v7 = *(unsigned __int16 *)p;
      goto LABEL_9;
    }
    if ( v5 == 3 )
    {
      result = p + 4;
      v7 = *(unsigned int *)p;
      goto LABEL_9;
    }
    if ( v5 )
    {
      result = p;
      v7 = 0LL;
      v8 = 0;
      do
      {
        v9 = *result++;
        v10 = (unsigned __int64)(v9 & 0x7F) << v8;
        v8 += 7;
        v7 |= v10;
      }
      while ( v9 < 0 );
      goto LABEL_9;
    }
LABEL_23:
    result = p + 8;
    v7 = *(_QWORD *)p;
    goto LABEL_9;
  }
  if ( v5 == 11 )
  {
    result = p + 4;
    v7 = *(int *)p;
    goto LABEL_9;
  }
  if ( v5 > 0xB )
  {
    if ( v5 != 12 )
      goto LABEL_32;
    goto LABEL_23;
  }
  if ( v5 != 9 )
  {
    if ( v5 == 10 )
    {
      result = p + 2;
      v7 = *(__int16 *)p;
      goto LABEL_9;
    }
LABEL_32:
    abort();
  }
  result = p;
  v7 = 0LL;
  v12 = 0;
  do
  {
    v14 = *result++;
    v13 = v14;
    v15 = (unsigned __int64)(v14 & 0x7F) << v12;
    v12 += 7;
    v7 |= v15;
  }
  while ( v14 < 0 );
  if ( v12 > 0x3F || (v13 & 0x40) == 0 )
  {
LABEL_9:
    if ( !v7 )
      goto LABEL_21;
    goto LABEL_10;
  }
  v7 |= -1LL << v12;
LABEL_10:
  if ( (encoding & 0x70) != 0x10 )
    p = (const unsigned __int8 *)base;
  v7 += (_Unwind_Ptr)p;
  if ( (encoding & 0x80) != 0 )
  {
    *val = *(_QWORD *)v7;
    return result;
  }
LABEL_21:
  *val = v7;
  return result;
}

//----- (000000000044F400) ----------------------------------------------------
void __fastcall fde_radixsort(object *ob, fde_extractor_t fde_extractor, fde_vector *v1, fde_vector *v2)
{
  const dwarf_fde **array; // x23
  size_t count; // x22
  const fde **v8; // x28
  int v9; // w27
  int v10; // w8
  _Unwind_Ptr v11; // x24
  int v12; // w21
  int v13; // w3
  __int64 v14; // x1
  _Unwind_Ptr *v15; // x0
  _Unwind_Ptr v16; // x7
  _Unwind_Ptr *v17; // x0
  int v18; // w1
  int v19; // w3
  int v20; // w7
  int v21; // w24
  _Unwind_Ptr *v22; // x6
  unsigned int v23; // w3
  int v24; // w1
  unsigned __int64 v25; // t1
  __int64 v26; // x0
  unsigned int v27; // w2
  const dwarf_fde *v28; // x0
  const dwarf_fde **v29; // x0
  int v30; // [xsp+60h] [xbp+60h]
  int v31; // [xsp+60h] [xbp+60h]
  unsigned int v32; // [xsp+64h] [xbp+64h]
  const fde **a1; // [xsp+78h] [xbp+78h]
  unsigned int counts[256]; // [xsp+88h] [xbp+88h] BYREF
  _Unwind_Ptr ptrs[129]; // [xsp+488h] [xbp+488h] BYREF

  array = v1->array;
  count = v1->count;
  a1 = v1->array;
  memset();
  if ( (_DWORD)count )
  {
    array = v2->array;
    v8 = a1;
    v9 = 0;
    while ( 1 )
    {
      v10 = 0;
      v11 = 0LL;
      v12 = 0;
      do
      {
        v13 = count - v10;
        if ( (unsigned int)(count - v10) > 0x80 )
          v13 = 128;
        v30 = v10;
        v32 = v13;
        ((void (__fastcall *)(object *, _Unwind_Ptr *, const fde **))fde_extractor)(ob, &ptrs[1], &v8[v10]);
        ptrs[0] = v11;
        if ( (_DWORD)count != v30 )
        {
          v14 = 0LL;
          do
          {
            v15 = &ptrs[v14];
            v16 = v11;
            ++v14;
            v11 = v15[1];
            if ( v11 < v16 )
              ++v12;
            ++counts[(unsigned __int8)(v11 >> v9)];
          }
          while ( v32 > (unsigned int)v14 );
        }
        v10 = v30 + v32;
        v11 = ptrs[v32];
      }
      while ( (unsigned int)count > v30 + v32 );
      if ( !v12 )
        break;
      v17 = (_Unwind_Ptr *)counts;
      v18 = 0;
      do
      {
        v19 = *(_DWORD *)v17;
        *(_DWORD *)v17 = v18;
        v17 = (_Unwind_Ptr *)((char *)v17 + 4);
        v18 += v19;
      }
      while ( v17 != ptrs );
      v20 = 0;
      do
      {
        v21 = count - v20;
        v31 = v20;
        if ( (unsigned int)(count - v20) > 0x80 )
          v21 = 128;
        fde_extractor(ob, ptrs, &v8[v20], v21);
        v22 = ptrs;
        v23 = v21 + v31;
        v24 = v31;
        if ( (_DWORD)count != v31 )
        {
          do
          {
            v25 = *v22++;
            v26 = (unsigned __int8)(v25 >> v9);
            v27 = counts[v26];
            counts[v26] = v27 + 1;
            v28 = v8[v24++];
            array[v27] = v28;
          }
          while ( v24 != v23 );
        }
        v20 = v21 + v31;
      }
      while ( (unsigned int)count > v23 );
      v9 += 8;
      if ( v9 == 64 )
        goto LABEL_2;
      memset();
      v29 = v8;
      v8 = array;
      array = v29;
    }
    array = v8;
  }
LABEL_2:
  if ( a1 != array )
    j_memcpy();
}

//----- (000000000044F620) ----------------------------------------------------
void __fastcall version_lock_unlock_exclusive(version_lock *vl)
{
  __int64 v1; // x2
  __int64 v2; // x3
  __int64 v3; // x4
  void *v4; // x5
  void *v5; // x6
  double v6; // d0
  double v7; // d1
  double v8; // d2
  double v9; // d3
  double v10; // d4
  double v11; // d5
  double v12; // d6
  double v13; // d7
  char v14; // w0
  __int64 v15; // x2
  __int64 v16; // x3
  void *v17; // x4
  void *v18; // x5
  void *v19; // x6
  double v20; // d0
  double v21; // d1
  double v22; // d2
  double v23; // d3
  double v24; // d4
  double v25; // d5
  double v26; // d6
  double v27; // d7
  double v28; // d0
  double v29; // d1
  double v30; // d2
  double v31; // d3
  double v32; // d4
  double v33; // d5
  double v34; // d6
  double v35; // d7

  atomic_load(&vl->version_lock);
  _aarch64_swp8_acq_rel();
  if ( (v14 & 2) != 0 )
  {
    pthread_mutex_lock(
      &version_lock_mutex,
      v6,
      v7,
      v8,
      v9,
      v10,
      v11,
      v12,
      v13,
      (__int64)&version_lock_mutex,
      v1,
      v2,
      v3,
      v4,
      v5);
    pthread_cond_broadcast(
      (__int64 *)&version_lock_cond,
      v20,
      v21,
      v22,
      v23,
      v24,
      v25,
      v26,
      v27,
      (__int64)&version_lock_mutex,
      v15,
      v16,
      v17,
      v18,
      v19);
    pthread_mutex_unlock(&version_lock_mutex.__data.__lock, v28, v29, v30, v31, v32, v33, v34, v35);
  }
}
// 44F63C: variable 'v14' is possibly undefined
// 44F658: variable 'v6' is possibly undefined
// 44F658: variable 'v7' is possibly undefined
// 44F658: variable 'v8' is possibly undefined
// 44F658: variable 'v9' is possibly undefined
// 44F658: variable 'v10' is possibly undefined
// 44F658: variable 'v11' is possibly undefined
// 44F658: variable 'v12' is possibly undefined
// 44F658: variable 'v13' is possibly undefined
// 44F658: variable 'v1' is possibly undefined
// 44F658: variable 'v2' is possibly undefined
// 44F658: variable 'v3' is possibly undefined
// 44F658: variable 'v4' is possibly undefined
// 44F658: variable 'v5' is possibly undefined
// 44F664: variable 'v20' is possibly undefined
// 44F664: variable 'v21' is possibly undefined
// 44F664: variable 'v22' is possibly undefined
// 44F664: variable 'v23' is possibly undefined
// 44F664: variable 'v24' is possibly undefined
// 44F664: variable 'v25' is possibly undefined
// 44F664: variable 'v26' is possibly undefined
// 44F664: variable 'v27' is possibly undefined
// 44F664: variable 'v15' is possibly undefined
// 44F664: variable 'v16' is possibly undefined
// 44F664: variable 'v17' is possibly undefined
// 44F664: variable 'v18' is possibly undefined
// 44F664: variable 'v19' is possibly undefined
// 44F670: variable 'v28' is possibly undefined
// 44F670: variable 'v29' is possibly undefined
// 44F670: variable 'v30' is possibly undefined
// 44F670: variable 'v31' is possibly undefined
// 44F670: variable 'v32' is possibly undefined
// 44F670: variable 'v33' is possibly undefined
// 44F670: variable 'v34' is possibly undefined
// 44F670: variable 'v35' is possibly undefined

//----- (000000000044F680) ----------------------------------------------------
// local variable allocation has failed, the output may be wrong!
btree_node *__fastcall btree_allocate_node(btree *t, bool inner)
{
  __int64 v2; // x2
  void *v3; // x3
  void *v4; // x4
  void *v5; // x5
  void *v6; // x6
  __int64 v7; // x7
  double v8; // d0
  double v9; // d1
  double v10; // d2
  double v11; // d3
  double v12; // d4
  double v13; // d5
  double v14; // d6
  double v15; // d7
  unsigned __int64 *p_free_list; // x23
  unsigned __int64 v18; // x19
  unsigned __int64 v19; // x21
  unsigned __int64 v20; // x20
  __int64 v21; // x0
  __int64 v22; // x0
  btree_node *result; // x0

  p_free_list = (unsigned __int64 *)&t->free_list;
  while ( 1 )
  {
    v18 = atomic_load(p_free_list);
    if ( !v18 )
      break;
    while ( 1 )
    {
      v19 = v18;
      v20 = atomic_load((unsigned __int64 *)v18);
      if ( (v20 & 1) != 0 )
        break;
      _aarch64_cas8_acq_rel();
      if ( v21 != v20 )
        break;
      if ( *(_DWORD *)(v18 + 12) == 2 )
      {
        _aarch64_cas8_acq_rel();
        if ( v18 == v22 )
          goto LABEL_7;
      }
      version_lock_unlock_exclusive((version_lock *)v18);
      v18 = atomic_load(p_free_list);
      if ( !v18 )
        goto LABEL_9;
    }
  }
LABEL_9:
  v19 = malloc(256LL, inner, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15);
  *(_QWORD *)v19 = 1LL;
LABEL_7:
  result = (btree_node *)v19;
  *(_DWORD *)(v19 + 8) = 0;
  *(_DWORD *)(v19 + 12) = !inner;
  return result;
}
// 44F680: variables would overlap: w1.1 and x1.8

//----- (000000000044F740) ----------------------------------------------------
void __fastcall btree_handle_root_split(btree *t, btree_node **node, btree_node **parent)
{
  btree_node *v5; // x0
  btree_node *v6; // x3
  __int128 v7; // q26
  __int128 v8; // q28
  __int128 v9; // q29
  __int128 v10; // q30
  __int128 v11; // q31
  __int128 v12; // q30
  __int128 v13; // q28
  __int128 v14; // q29
  __int128 v15; // q26
  __int128 v16; // q27
  __int128 v17; // q29
  __int128 v18; // q30

  v5 = btree_allocate_node(t, (*node)->type == node_type::btree_node_inner);
  v6 = *node;
  v5->entry_count = (*node)->entry_count;
  v7 = *(_OWORD *)&v6->content.entries[0].ob;
  v9 = *(_OWORD *)&v6->content.entries[1].size;
  v8 = *(_OWORD *)&v6->content.entries[2].base;
  v11 = *(_OWORD *)&v6->content.entries[2].ob;
  v10 = *(_OWORD *)&v6->content.entries[3].size;
  v5->content.children[0] = v6->content.children[0];
  *(_OWORD *)&v5->content.entries[0].ob = v7;
  *(_OWORD *)&v5->content.entries[1].size = v9;
  *(_OWORD *)&v5->content.entries[2].base = v8;
  *(_OWORD *)&v5->content.entries[2].ob = v11;
  *(_OWORD *)&v5->content.entries[3].size = v10;
  v12 = *(_OWORD *)&v6->content.entries[7].size;
  v14 = *(_OWORD *)&v6->content.entries[5].size;
  v13 = *(_OWORD *)&v6->content.entries[6].base;
  v16 = *(_OWORD *)&v6->content.entries[4].base;
  v15 = *(_OWORD *)&v6->content.entries[4].ob;
  *(_OWORD *)&v5->content.entries[6].ob = *(_OWORD *)&v6->content.entries[6].ob;
  *(_OWORD *)&v5->content.entries[7].size = v12;
  *(_OWORD *)&v5->content.entries[5].size = v14;
  *(_OWORD *)&v5->content.entries[6].base = v13;
  *(_OWORD *)&v5->content.entries[4].base = v16;
  *(_OWORD *)&v5->content.entries[4].ob = v15;
  v18 = *(_OWORD *)&v6->content.entries[8].base;
  v17 = *(_OWORD *)&v6->content.entries[8].ob;
  *(_OWORD *)&v5->content.entries[9].size = *(_OWORD *)&v6->content.entries[9].size;
  *(_OWORD *)&v5->content.entries[8].base = v18;
  *(_OWORD *)&v5->content.entries[8].ob = v17;
  v6->content.children[0].separator = -1LL;
  v6->content.entries[0].size = (uintptr_type)v5;
  *(_QWORD *)&v6->entry_count = 1LL;
  *parent = v6;
  *node = v5;
}

//----- (000000000044F7E0) ----------------------------------------------------
bool __fastcall btree_insert(btree *t, uintptr_type base, uintptr_type size, object *ob)
{
  version_lock *p_root_lock; // x21
  btree_node *root; // x19
  btree_node *v9; // x26
  uintptr_type v10; // x21
  btree_node *node; // x25
  unsigned int i; // w19
  unsigned int entry_count; // w1
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v14; // x4
  version_lock *p_version_lock; // x0
  char *v16; // x19
  uintptr_type v17; // x25
  unsigned int v18; // w21
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v19; // x0
  unsigned int v20; // w2
  __int64 v21; // x22
  uintptr_type *v22; // x0
  btree_node *v23; // x27
  uintptr_type separator; // x28
  unsigned int v25; // w4
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *p_content; // x0
  unsigned int v27; // w5
  unsigned int v28; // w2
  unsigned int v29; // w1
  char *v30; // x2
  uintptr_type v31; // x3
  uintptr_type v32; // x24
  unsigned int v33; // w3
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v34; // x0
  unsigned int v35; // w19
  unsigned int v36; // w28
  int v37; // w3
  btree_node *v38; // x27
  btree_node *v39; // x22
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v40; // x2
  unsigned int v41; // w3
  unsigned int v42; // w0
  unsigned int v43; // w1
  __int64 v44; // x0
  uintptr_type *v45; // x0
  uintptr_type v46; // x4
  uintptr_type v47; // x5
  btree_node *v48; // x0
  uintptr_type v49; // x28
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v50; // x0
  unsigned int v51; // w19
  unsigned int v52; // w21
  uintptr_type v53; // x28
  unsigned int v54; // w25
  int v55; // w21
  unsigned int v58; // [xsp+6Ch] [xbp+6Ch]
  btree_node *iter; // [xsp+70h] [xbp+70h] BYREF
  btree_node *parent; // [xsp+78h] [xbp+78h] BYREF

  if ( size )
  {
    p_root_lock = &t->root_lock;
    version_lock_lock_exclusive(&t->root_lock);
    root = t->root;
    iter = root;
    if ( root )
    {
      version_lock_lock_exclusive(&root->version_lock);
    }
    else
    {
      root = btree_allocate_node(t, 0);
      t->root = root;
      iter = root;
    }
    version_lock_unlock_exclusive(p_root_lock);
    if ( root->type == node_type::btree_node_inner )
    {
      v9 = 0LL;
      v10 = base - 1 + size;
      while ( 1 )
      {
        if ( root->entry_count != 15 )
        {
          node = iter;
          i = 0;
          entry_count = iter->entry_count;
          if ( !entry_count )
            goto LABEL_11;
          goto LABEL_8;
        }
        if ( !v9 )
        {
          btree_handle_root_split(t, &iter, &parent);
          v9 = parent;
        }
        v23 = iter;
        separator = iter->content.children[iter->entry_count - 1].separator;
        node = btree_allocate_node(t, 1);
        v25 = v23->entry_count;
        p_content = &node->content;
        v27 = v25 >> 1;
        v28 = v25 - (v25 >> 1);
        node->entry_count = v28;
        v29 = v25 >> 1;
        if ( v28 )
        {
          do
          {
            v30 = (char *)v23 + 16 * v29++;
            v31 = *((_QWORD *)v30 + 3);
            p_content->children[0].separator = *((_QWORD *)v30 + 2);
            p_content->entries[0].size = v31;
            p_content = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)p_content + 16);
          }
          while ( v29 != v25 );
        }
        v32 = *(&v23->version_lock.version_lock + 2 * v27);
        v23->entry_count = v27;
        if ( base > v32 )
        {
          v33 = v9->entry_count;
          if ( !v33 )
          {
            v9->entry_count = 1;
            v9->content.children[0].separator = v32;
            v9->content.entries[1].base = (uintptr_type)node;
            goto LABEL_47;
          }
        }
        else
        {
          v33 = v9->entry_count;
          if ( v32 < v10 )
            v32 = base - 1 + size;
          if ( !v33 )
          {
            v36 = 1;
            v35 = 0;
            v37 = 1;
            goto LABEL_42;
          }
        }
        v34 = &v9->content;
        v35 = 0;
        while ( separator > v34->children[0].separator )
        {
          ++v35;
          v34 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v34 + 16);
          if ( v33 == v35 )
          {
            v37 = v35 + 1;
            v36 = v35 + 1;
            goto LABEL_42;
          }
        }
        v36 = v35 + 1;
        if ( v33 > v35 )
        {
          v58 = v33;
          j_memmove();
          v33 = v58;
        }
        v37 = v33 + 1;
LABEL_42:
        v9->content.children[v35].separator = v32;
        *(&v9->content.entries[0].size + 2 * v36) = (uintptr_type)node;
        v9->entry_count = v37;
        if ( base <= v32 )
        {
          version_lock_unlock_exclusive(&node->version_lock);
          entry_count = v23->entry_count;
          node = v23;
          if ( !entry_count )
          {
            i = 0;
            goto LABEL_12;
          }
          goto LABEL_8;
        }
LABEL_47:
        version_lock_unlock_exclusive(&v23->version_lock);
        entry_count = node->entry_count;
        if ( !entry_count )
        {
          i = 0;
          goto LABEL_12;
        }
LABEL_8:
        v14 = &node->content;
        for ( i = 0; i != entry_count; ++i )
        {
          if ( base <= v14->children[0].separator )
            break;
          v14 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v14 + 16);
        }
LABEL_11:
        if ( !v9 )
        {
          v9 = node;
          goto LABEL_13;
        }
LABEL_12:
        p_version_lock = &v9->version_lock;
        v9 = node;
        version_lock_unlock_exclusive(p_version_lock);
LABEL_13:
        v16 = (char *)node + 16 * i;
        v17 = *((_QWORD *)v16 + 2);
        if ( v17 < v10 )
        {
          v17 = base - 1 + size;
          *((_QWORD *)v16 + 2) = v10;
        }
        root = (btree_node *)*((_QWORD *)v16 + 3);
        iter = root;
        version_lock_lock_exclusive(&root->version_lock);
        if ( root->type )
        {
          if ( root->entry_count != 10 )
            goto LABEL_17;
          goto LABEL_53;
        }
      }
    }
    v18 = root->entry_count;
    if ( v18 == 10 )
    {
      btree_handle_root_split(t, &iter, &parent);
      v9 = parent;
      v17 = -1LL;
LABEL_53:
      v38 = iter;
      v39 = btree_allocate_node(t, 0);
      v40 = &v39->content;
      v41 = v38->entry_count;
      v42 = v41 - (v41 >> 1);
      v39->entry_count = v42;
      v43 = v41 >> 1;
      if ( v42 )
      {
        do
        {
          v40 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v40 + 24);
          v44 = 3LL * v43++;
          v45 = &v38->version_lock.version_lock + v44;
          v46 = v45[2];
          v47 = v45[3];
          v48 = (btree_node *)v45[4];
          v40[-1].entries[9].base = v46;
          v40[-1].children[14].separator = v47;
          v40[-1].children[14].child = v48;
        }
        while ( v41 != v43 );
      }
      v49 = v39->content.children[0].separator;
      v38->entry_count = v41 >> 1;
      v50 = &v9->content;
      v51 = 0;
      v52 = v9->entry_count;
      v53 = v49 - 1;
      if ( v52 )
      {
        while ( v50->children[0].separator < v17 )
        {
          ++v51;
          v50 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v50 + 16);
          if ( v52 == v51 )
          {
            v55 = v51 + 1;
            v54 = v51 + 1;
            goto LABEL_62;
          }
        }
        v54 = v51 + 1;
        if ( v52 > v51 )
          j_memmove();
        v55 = v52 + 1;
      }
      else
      {
        v54 = 1;
        v55 = 1;
      }
LABEL_62:
      v9->content.children[v51].separator = v53;
      *(&v9->content.entries[0].size + 2 * v54) = (uintptr_type)v39;
      v9->entry_count = v55;
      if ( base > v53 )
      {
        iter = v39;
        version_lock_unlock_exclusive(&v38->version_lock);
      }
      else
      {
        version_lock_unlock_exclusive(&v39->version_lock);
      }
LABEL_17:
      version_lock_unlock_exclusive(&v9->version_lock);
      root = iter;
      v18 = iter->entry_count;
    }
    if ( v18 )
    {
      v19 = &root->content;
      v20 = 0;
      while ( base >= v19->children[0].separator + v19->entries[0].size )
      {
        ++v20;
        v19 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v19 + 24);
        if ( v20 == v18 )
        {
          v21 = v18;
          goto LABEL_25;
        }
      }
      v21 = v20;
      if ( v20 >= v18 )
        goto LABEL_25;
      if ( base != *(&root->content.children[0].separator + 3 * v20) )
      {
        j_memmove();
        goto LABEL_25;
      }
    }
    else
    {
      v21 = 0LL;
LABEL_25:
      v22 = &root->version_lock.version_lock + 3 * v21;
      v22[2] = base;
      v22[3] = size;
      v22[4] = (uintptr_type)ob;
      root->entry_count = v18 + 1;
    }
    version_lock_unlock_exclusive(&root->version_lock);
  }
  return (char)t;
}
// 44F7F4: variable 't' is possibly undefined

//----- (000000000044FCE0) ----------------------------------------------------
int __fastcall get_cie_encoding(const dwarf_cie *cie)
{
  ubyte *v2; // x20
  unsigned __int64 (__fastcall *v3)(__int64); // x0
  unsigned int version; // w3
  char *v5; // x0
  const unsigned __int8 *v6; // x2
  int result; // w0
  int v8; // t1
  const unsigned __int8 *v9; // x1
  int v10; // t1
  int v11; // t1
  int v12; // t1
  int v13; // w1
  ubyte *v14; // x19
  int v15; // t1
  int v16; // t1
  int v17; // w1
  _Unwind_Ptr dummy; // [xsp+28h] [xbp+28h] BYREF

  v2 = &cie->version + 1;
  v3 = strlen();
  version = cie->version;
  v5 = (char *)v3 + 1;
  v6 = (const unsigned __int8 *)&v5[(_QWORD)v2];
  if ( version > 3 )
  {
    v17 = (unsigned __int8)v5[(_QWORD)v2];
    result = 255;
    if ( v17 != 8 || v6[1] )
      return result;
    v6 += 2;
  }
  if ( *(&cie->version + 1) != 122 )
    return 0;
  do
    v8 = *(char *)v6++;
  while ( v8 < 0 );
  do
  {
    v9 = v6;
    v10 = *(char *)v6++;
  }
  while ( v10 < 0 );
  if ( version != 1 )
  {
    do
      v11 = *(char *)v6++;
    while ( v11 < 0 );
    goto LABEL_9;
  }
  v6 = v9 + 3;
  if ( (char)v9[2] < 0 )
  {
    do
LABEL_9:
      v12 = *(char *)v6++;
    while ( v12 < 0 );
  }
  v15 = *(&cie->version + 2);
  v14 = &cie->version + 2;
  v13 = v15;
  if ( v15 != 82 )
  {
    do
    {
      if ( v13 == 80 )
      {
        v6 = read_encoded_value_with_base(*v6 & 0x7F, 0LL, v6 + 1, &dummy);
      }
      else
      {
        if ( v13 != 76 && v13 != 66 )
          return 0;
        ++v6;
      }
      v16 = *++v14;
      v13 = v16;
    }
    while ( v16 != 82 );
  }
  return *v6;
}

//----- (000000000044FE04) ----------------------------------------------------
object *__fastcall btree_remove(btree *t, uintptr_type base)
{
  btree_node *root; // x24
  unsigned __int64 *p_free_list; // x20
  unsigned int entry_count; // w19
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *p_content; // x1
  unsigned int v8; // w0
  char *v9; // x28
  __int64 v10; // x26
  unsigned int v11; // w0
  btree_node *v12; // x27
  btree_node *child; // x26
  unsigned int v14; // w0
  node_type type; // w4
  unsigned int v16; // w5
  unsigned int v17; // w6
  unsigned int v18; // w7
  unsigned int v19; // w3
  unsigned int v20; // w1
  __int64 v21; // x2
  uintptr_type *v22; // x1
  uintptr_type *v23; // x2
  uintptr_type v24; // x4
  uintptr_type v25; // x5
  uintptr_type v26; // x2
  __int64 v27; // x0
  unsigned int v28; // w1
  __int64 v29; // x2
  unsigned int v30; // w19
  inner_entry *v31; // x2
  unsigned int v32; // w3
  char *v33; // x0
  uintptr_type v34; // x4
  btree_node *v35; // x5
  unsigned __int64 v36; // x19
  unsigned __int64 v37; // x0
  bool v38; // zf
  unsigned int v39; // w4
  unsigned int v40; // w1
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v41; // x0
  __int64 v42; // x0
  char *v43; // x2
  unsigned int v44; // w3
  object *v45; // x19
  unsigned int v46; // w4
  __int64 v47; // x2
  uintptr_type v48; // x7
  uintptr_type *v49; // x0
  uintptr_type v50; // x1
  version_lock *p_version_lock; // x0
  unsigned int v53; // w1
  char *v54; // x2
  char *v55; // x1
  __int64 v56; // x2
  __int64 v57; // x3
  char *v58; // t2
  unsigned int v59; // w3
  unsigned int v60; // w8
  __int64 v61; // x1
  __int64 v62; // x2
  uintptr_type *v63; // x2
  uintptr_type *v64; // x1
  uintptr_type v65; // x6
  uintptr_type v66; // x7
  uintptr_type v67; // x2
  unsigned int v68; // w5
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v69; // x3
  unsigned int v70; // w2
  __int64 v71; // x1
  uintptr_type *v72; // x1
  uintptr_type v73; // x6
  uintptr_type v74; // x7
  btree_node *v75; // x1
  unsigned int v76; // w8
  uintptr_type v77; // x28
  unsigned int v78; // w1
  unsigned int v79; // w6
  __int64 v80; // x4
  char *v81; // x2
  char *v82; // x4
  __int64 v83; // x3
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v84; // x2
  unsigned int v85; // w1
  char *v86; // x3
  uintptr_type v87; // x5
  uintptr_type v88; // x28
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v89; // x6
  unsigned int v90; // w3
  unsigned int v91; // w9
  unsigned int v92; // w8
  __int64 v93; // x2
  uintptr_type v94; // x1
  uintptr_type *v95; // x2
  btree_node *v96; // x7
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v97; // x6
  unsigned int v98; // w1
  __int64 v99; // x0
  uintptr_type *v100; // x0
  uintptr_type v101; // x2
  uintptr_type v102; // x3
  btree_node *v103; // x0
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v104; // x4
  unsigned int v105; // w1
  unsigned int v106; // w9
  char *v107; // x7
  uintptr_type v108; // x2
  btree_node *v109; // x3
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v110; // x2
  unsigned int v111; // w1
  char *v112; // x3
  uintptr_type v113; // x7
  btree_node *v114; // x1
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v115; // x2
  uintptr_type separator; // x8
  uintptr_type size; // x9
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v118; // x1
  char *v119; // x2
  uintptr_type v120; // x4
  btree_node *v121; // x5
  unsigned __int64 v122; // x19
  unsigned __int64 v123; // x0
  unsigned __int64 v124; // x19
  unsigned __int64 v125; // x0
  __int64 v126; // x1
  uintptr_type *v127; // x3
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v128; // x2
  uintptr_type v129; // x8
  uintptr_type v130; // x9
  uintptr_type v131; // x3
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *v132; // x4
  __int64 v133; // x1
  uintptr_type v134; // x3
  uintptr_type *v135; // x1
  uintptr_type v136; // x5

  version_lock_lock_exclusive(&t->root_lock);
  root = t->root;
  if ( !t->root )
  {
    version_lock_unlock_exclusive(&t->root_lock);
    return 0LL;
  }
  version_lock_lock_exclusive(&t->root->version_lock);
  version_lock_unlock_exclusive(&t->root_lock);
  if ( root->type == node_type::btree_node_inner )
  {
    p_free_list = (unsigned __int64 *)&t->free_list;
    do
    {
      entry_count = root->entry_count;
      if ( entry_count )
      {
        p_content = &root->content;
        v8 = 0;
        while ( base > p_content->children[0].separator )
        {
          ++v8;
          p_content = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)p_content + 16);
          if ( entry_count == v8 )
            goto LABEL_9;
        }
        entry_count = v8;
      }
LABEL_9:
      v9 = (char *)root + 16 * entry_count;
      v10 = *((_QWORD *)v9 + 3);
      version_lock_lock_exclusive((version_lock *)v10);
      if ( *(_DWORD *)(v10 + 12) )
        v11 = 5;
      else
        v11 = 7;
      if ( *(_DWORD *)(v10 + 8) >= v11 )
      {
        p_version_lock = &root->version_lock;
        root = (btree_node *)v10;
        version_lock_unlock_exclusive(p_version_lock);
        continue;
      }
      if ( entry_count )
      {
        v12 = (btree_node *)*((_QWORD *)&root->entry_count + 2 * entry_count);
        if ( root->entry_count <= entry_count + 1
          || (child = root->content.children[entry_count + 1].child, child->entry_count >= v12->entry_count) )
        {
          child = (btree_node *)*((_QWORD *)v9 + 3);
          version_lock_lock_exclusive(*((version_lock **)&root->entry_count + 2 * entry_count));
          v14 = v12->entry_count;
          type = v12->type;
          v16 = child->entry_count;
          --entry_count;
          v17 = v14 + v16;
          if ( type == node_type::btree_node_inner )
            goto LABEL_46;
          goto LABEL_17;
        }
      }
      else
      {
        child = root->content.children[1].child;
      }
      v12 = (btree_node *)*((_QWORD *)v9 + 3);
      version_lock_lock_exclusive(&child->version_lock);
      v16 = child->entry_count;
      v14 = v12->entry_count;
      type = v12->type;
      v17 = v14 + v16;
      if ( type == node_type::btree_node_inner )
      {
LABEL_46:
        if ( v17 <= 0xF )
        {
          v18 = root->entry_count;
          if ( v18 == 2 )
          {
            v114 = v12;
            v115 = &root->content;
            if ( v14 )
            {
              do
              {
                separator = v114->content.children[0].separator;
                size = v114->content.entries[0].size;
                v114 = (btree_node *)((char *)v114 + 16);
                v115->children[0].separator = separator;
                v115->entries[0].size = size;
                v115 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v115 + 16);
              }
              while ( v114 != (btree_node *)((char *)v12 + 16 * v14) );
            }
            v118 = &child->content;
            if ( v16 )
            {
              do
              {
                v119 = (char *)root + 16 * v14++;
                v120 = v118->children[0].separator;
                v121 = v118->children[0].child;
                v118 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v118 + 16);
                *((_QWORD *)v119 + 2) = v120;
                *((_QWORD *)v119 + 3) = v121;
              }
              while ( v17 != v14 );
            }
            goto LABEL_86;
          }
          if ( v16 )
          {
            do
            {
              v53 = v14;
              v54 = (char *)child + 16 * (unsigned int)type;
              ++v14;
              ++type;
              v55 = (char *)v12 + 16 * v53;
              v58 = v54 + 16;
              v56 = *((_QWORD *)v54 + 2);
              v57 = *((_QWORD *)v58 + 1);
              v12->entry_count = v14;
              *((_QWORD *)v55 + 2) = v56;
              *((_QWORD *)v55 + 3) = v57;
            }
            while ( type != child->entry_count );
LABEL_21:
            v18 = root->entry_count;
          }
LABEL_22:
          v27 = entry_count + 1;
          v28 = entry_count + 1;
          v29 = 16LL * entry_count + 16;
          v30 = entry_count + 2;
          *(uintptr_type *)((char *)&root->version_lock.version_lock + v29) = root->content.children[v27].separator;
          v31 = &root->content.children[v30];
          v32 = v18 - 1;
          if ( v18 > v30 )
          {
            while ( 1 )
            {
              v33 = (char *)root + 16 * v27;
              ++v28;
              v34 = v31->separator;
              v35 = v31->child;
              ++v31;
              *((_QWORD *)v33 + 2) = v34;
              *((_QWORD *)v33 + 3) = v35;
              if ( v32 == v28 )
                break;
              v27 = v28;
            }
          }
          root->entry_count = v32;
          child->type = node_type::btree_node_free;
          v36 = atomic_load(p_free_list);
          do
          {
            child->content.entries[0].size = v36;
            _aarch64_cas8_acq_rel();
            v38 = v37 == v36;
            v36 = v37;
          }
          while ( !v38 );
          version_lock_unlock_exclusive(&child->version_lock);
          version_lock_unlock_exclusive(&root->version_lock);
          goto LABEL_30;
        }
        if ( v14 <= v16 )
        {
          v104 = &child->content;
          v105 = v14;
          v106 = (v16 - v14) >> 1;
          if ( v106 )
          {
            do
            {
              v107 = (char *)v12 + 16 * v105++;
              v108 = v104->children[0].separator;
              v109 = v104->children[0].child;
              v104 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v104 + 16);
              *((_QWORD *)v107 + 2) = v108;
              *((_QWORD *)v107 + 3) = v109;
            }
            while ( v105 != v106 + v14 );
          }
          v110 = &child->content;
          v111 = (v16 - v14) >> 1;
          if ( v106 == v16 )
          {
            v12->entry_count = v17;
            child->entry_count -= v106;
            goto LABEL_66;
          }
          do
          {
            v112 = (char *)child + 16 * v111++;
            v113 = *((_QWORD *)v112 + 3);
            v110->children[0].separator = *((_QWORD *)v112 + 2);
            v110->entries[0].size = v113;
            v110 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v110 + 16);
          }
          while ( v16 != v111 );
          v12->entry_count = v106 + v14;
          child->entry_count -= v106;
          v88 = v12->content.children[v12->entry_count - 1].separator;
        }
        else
        {
          v78 = v16 - 1;
          v79 = (v14 - v16) >> 1;
          if ( v16 )
          {
            do
            {
              v80 = v79 + v78;
              v81 = (char *)child + 16 * v78--;
              v82 = (char *)child + 16 * v80;
              v83 = *((_QWORD *)v81 + 3);
              *((_QWORD *)v82 + 2) = *((_QWORD *)v81 + 2);
              *((_QWORD *)v82 + 3) = v83;
            }
            while ( v78 != -1 );
          }
          v84 = &child->content;
          v85 = v14 - v79;
          if ( v79 )
          {
            do
            {
              v86 = (char *)v12 + 16 * v85++;
              v87 = *((_QWORD *)v86 + 3);
              v84->children[0].separator = *((_QWORD *)v86 + 2);
              v84->entries[0].size = v87;
              v84 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v84 + 16);
            }
            while ( v14 != v85 );
            v12->entry_count = v14 - v79;
            child->entry_count += v79;
          }
          else
          {
            v12->entry_count = v14;
          }
LABEL_66:
          v88 = v12->content.children[v12->entry_count - 1].separator;
        }
        root->content.children[entry_count].separator = v88;
        version_lock_unlock_exclusive(&root->version_lock);
        if ( base > v88 )
        {
LABEL_68:
          root = child;
          version_lock_unlock_exclusive(&v12->version_lock);
          continue;
        }
        goto LABEL_59;
      }
LABEL_17:
      if ( v17 <= 0xA )
      {
        v18 = root->entry_count;
        if ( v18 == 2 )
        {
          root->type = node_type::btree_node_leaf;
          if ( v14 )
          {
            v126 = 0LL;
            do
            {
              v127 = (uintptr_type *)((char *)&v12->content + v126);
              v128 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)&root->content + v126);
              v126 += 24LL;
              v129 = *v127;
              v130 = v127[1];
              v131 = v127[2];
              v128->children[0].separator = v129;
              v128->entries[0].size = v130;
              v128->children[1].separator = v131;
            }
            while ( v126 != 24LL * v14 );
          }
          v132 = &child->content;
          if ( v16 )
          {
            do
            {
              v132 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v132 + 24);
              v133 = 3LL * v14++;
              v134 = v132[-1].children[14].separator;
              v135 = &root->version_lock.version_lock + v133;
              v136 = (uintptr_type)v132[-1].children[14].child;
              v135[2] = v132[-1].entries[9].base;
              v135[3] = v134;
              v135[4] = v136;
            }
            while ( v17 != v14 );
          }
LABEL_86:
          root->entry_count = v17;
          v12->type = node_type::btree_node_free;
          v122 = atomic_load(p_free_list);
          do
          {
            v12->content.entries[0].size = v122;
            _aarch64_cas8_acq_rel();
            v38 = v123 == v122;
            v122 = v123;
          }
          while ( !v38 );
          version_lock_unlock_exclusive(&v12->version_lock);
          child->type = node_type::btree_node_free;
          v124 = atomic_load(p_free_list);
          do
          {
            child->content.entries[0].size = v124;
            _aarch64_cas8_acq_rel();
            v38 = v125 == v124;
            v124 = v125;
          }
          while ( !v38 );
          version_lock_unlock_exclusive(&child->version_lock);
          continue;
        }
        v19 = 0;
        if ( v16 )
        {
          do
          {
            v20 = v14++;
            v21 = 3LL * v19++;
            v22 = &v12->version_lock.version_lock + 3 * v20;
            v23 = &child->version_lock.version_lock + v21;
            v24 = v23[2];
            v25 = v23[3];
            v26 = v23[4];
            v12->entry_count = v14;
            v22[2] = v24;
            v22[3] = v25;
            v22[4] = v26;
          }
          while ( v19 != child->entry_count );
          goto LABEL_21;
        }
        goto LABEL_22;
      }
      if ( v14 <= v16 )
      {
        v89 = &child->content;
        v90 = v14;
        v91 = (v16 - v14) >> 1;
        v92 = v14 + v91;
        if ( v91 )
        {
          do
          {
            v89 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v89 + 24);
            v93 = 3LL * v90++;
            v94 = v89[-1].children[14].separator;
            v95 = &v12->version_lock.version_lock + v93;
            v96 = v89[-1].children[14].child;
            v95[2] = v89[-1].entries[9].base;
            v95[3] = v94;
            v95[4] = (uintptr_type)v96;
          }
          while ( v90 != v92 );
        }
        else
        {
          v92 = v14;
        }
        v97 = &child->content;
        v98 = (v16 - v14) >> 1;
        if ( v16 != v91 )
        {
          do
          {
            v97 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v97 + 24);
            v99 = 3LL * v98++;
            v100 = &child->version_lock.version_lock + v99;
            v101 = v100[2];
            v102 = v100[3];
            v103 = (btree_node *)v100[4];
            v97[-1].entries[9].base = v101;
            v97[-1].children[14].separator = v102;
            v97[-1].children[14].child = v103;
          }
          while ( v16 != v98 );
        }
        v12->entry_count = v92;
        v76 = child->entry_count - v91;
      }
      else
      {
        v59 = v16 - 1;
        v60 = (v14 - v16) >> 1;
        if ( v16 )
        {
          do
          {
            v61 = v60 + v59;
            v62 = 3LL * v59--;
            v63 = &child->version_lock.version_lock + v62;
            v64 = &child->version_lock.version_lock + 3 * v61;
            v65 = v63[2];
            v66 = v63[3];
            v67 = v63[4];
            v64[2] = v65;
            v64[3] = v66;
            v64[4] = v67;
          }
          while ( v59 != -1 );
        }
        v68 = v14 - v60;
        v69 = &child->content;
        v70 = v14 - v60;
        if ( v60 )
        {
          do
          {
            v69 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v69 + 24);
            v71 = 3LL * v70++;
            v72 = &v12->version_lock.version_lock + v71;
            v73 = v72[2];
            v74 = v72[3];
            v75 = (btree_node *)v72[4];
            v69[-1].entries[9].base = v73;
            v69[-1].children[14].separator = v74;
            v69[-1].children[14].child = v75;
          }
          while ( v14 != v70 );
        }
        else
        {
          v68 = v14;
        }
        v12->entry_count = v68;
        v76 = v60 + child->entry_count;
      }
      child->entry_count = v76;
      if ( type != node_type::btree_node_leaf )
        goto LABEL_66;
      v77 = child->content.children[0].separator - 1;
      root->content.children[entry_count].separator = v77;
      version_lock_unlock_exclusive(&root->version_lock);
      if ( base > v77 )
        goto LABEL_68;
LABEL_59:
      version_lock_unlock_exclusive(&child->version_lock);
LABEL_30:
      root = v12;
    }
    while ( root->type == node_type::btree_node_inner );
  }
  v39 = root->entry_count;
  if ( !v39 )
    goto LABEL_81;
  v40 = 0;
  v41 = &root->content;
  while ( base >= v41->children[0].separator + v41->entries[0].size )
  {
    ++v40;
    v41 = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)v41 + 24);
    if ( v39 == v40 )
      goto LABEL_81;
  }
  if ( v39 <= v40 || (v42 = v40, v43 = (char *)root + 24 * v40, *((_QWORD *)v43 + 2) != base) )
  {
LABEL_81:
    version_lock_unlock_exclusive(&root->version_lock);
    return 0LL;
  }
  v44 = v40 + 1;
  v45 = (object *)*((_QWORD *)v43 + 4);
  if ( v39 <= v40 + 1 )
  {
    v46 = v39 - 1;
  }
  else
  {
    v46 = v39 - 1;
    v47 = (__int64)&root->content + 24 * v44;
    while ( 1 )
    {
      v47 += 24LL;
      v48 = *(_QWORD *)(v47 - 16);
      v49 = &root->version_lock.version_lock + 3 * v42;
      v50 = *(_QWORD *)(v47 - 8);
      v49[2] = *(_QWORD *)(v47 - 24);
      v49[3] = v48;
      v49[4] = v50;
      if ( v46 == v44 )
        break;
      v42 = v44++;
    }
  }
  root->entry_count = v46;
  version_lock_unlock_exclusive(&root->version_lock);
  return v45;
}
// 44FFFC: variable 'v37' is possibly undefined
// 45049C: variable 'v123' is possibly undefined
// 4504CC: variable 'v125' is possibly undefined

//----- (00000000004505A0) ----------------------------------------------------
void __fastcall fde_mixed_encoding_extract(object *ob, _Unwind_Ptr *target, const fde **x, int count)
{
  unsigned __int64 v4; // x19
  __int64 v6; // x21
  void *dbase; // x1
  _Unwind_Ptr *v10; // x3
  const fde *v11; // x20
  int cie_encoding; // w0
  unsigned int v13; // w3
  _Unwind_Ptr *v14; // x3

  if ( count > 0 )
  {
    v4 = 0LL;
    v6 = 8LL * (unsigned int)count;
    do
    {
      while ( 1 )
      {
        v11 = x[v4 / 8];
        cie_encoding = get_cie_encoding((const dwarf_cie *)((char *)&v11->CIE_delta - v11->CIE_delta));
        if ( cie_encoding == 255 )
          goto LABEL_12;
        v13 = cie_encoding & 0x70;
        if ( v13 != 32 )
          break;
        v14 = &target[v4 / 8];
        v4 += 8LL;
        read_encoded_value_with_base(cie_encoding, (_Unwind_Ptr)ob->tbase, v11->pc_begin, v14);
        if ( v6 == v4 )
          return;
      }
      if ( v13 <= 0x20 )
        goto LABEL_12;
      if ( v13 != 48 )
      {
        if ( v13 != 80 )
          abort();
LABEL_12:
        dbase = 0LL;
        goto LABEL_6;
      }
      dbase = ob->dbase;
LABEL_6:
      v10 = &target[v4 / 8];
      v4 += 8LL;
      read_encoded_value_with_base(cie_encoding, (_Unwind_Ptr)dbase, v11->pc_begin, v10);
    }
    while ( v6 != v4 );
  }
}

//----- (0000000000450680) ----------------------------------------------------
size_t __fastcall classify_object_over_fdes(object *ob, const fde *this_fde, uintptr_type *range)
{
  uword length; // w19
  const fde *v6; // x27
  void *dbase; // x23
  int v8; // w28
  size_t v9; // x24
  __int64 v10; // x26
  sword CIE_delta; // w0
  __int64 v12; // x20
  int cie_encoding; // w0
  unsigned __int8 v14; // w25
  unsigned int v15; // w0
  const unsigned __int8 *v16; // x2
  unsigned int v17; // w0
  bool v18; // cc
  __int64 v19; // x1
  uintptr_type v20; // x2
  uintptr_type v21; // x0
  int b; // w0
  _Unwind_Ptr v24; // [xsp+70h] [xbp+70h]
  _Unwind_Ptr pc_begin; // [xsp+80h] [xbp+80h] BYREF
  _Unwind_Ptr pc_range; // [xsp+88h] [xbp+88h] BYREF

  length = this_fde->length;
  if ( this_fde->length )
  {
    v6 = this_fde;
    dbase = 0LL;
    LOBYTE(v8) = 0;
    v9 = 0LL;
    v10 = 0LL;
    while ( 1 )
    {
      CIE_delta = v6->CIE_delta;
      if ( !CIE_delta )
        goto LABEL_21;
      v12 = (__int64)&v6->CIE_delta - CIE_delta;
      if ( v12 != v10 )
        break;
      v14 = v8;
      v16 = read_encoded_value_with_base(v8, (_Unwind_Ptr)dbase, v6->pc_begin, &pc_begin);
      if ( (unsigned __int8)v8 == 255 )
        goto LABEL_21;
      v17 = v8 & 7;
      v18 = v17 > 2;
      if ( v17 == 2 )
      {
LABEL_25:
        v19 = 0xFFFFLL;
        goto LABEL_15;
      }
LABEL_12:
      if ( v18 )
      {
        v19 = 0xFFFFFFFFLL;
        if ( v17 == 3 )
          goto LABEL_15;
        if ( v17 != 4 )
LABEL_42:
          abort();
      }
      else if ( v17 )
      {
        goto LABEL_42;
      }
      v19 = -1LL;
LABEL_15:
      v10 = v12;
      if ( (pc_begin & v19) != 0 )
      {
        ++v9;
        if ( !range )
        {
          if ( ob->pc_begin > (void *)pc_begin )
            ob->pc_begin = (void *)pc_begin;
          goto LABEL_20;
        }
        v24 = pc_begin;
        read_encoded_value_with_base(v14 & 0xF, 0LL, v16, &pc_range);
        v20 = range[1];
        v21 = v24 + pc_range;
        if ( *range )
        {
          if ( v24 < *range )
            *range = v24;
        }
        else if ( !v20 )
        {
          *range = v24;
          range[1] = v21;
LABEL_20:
          v10 = v12;
          goto LABEL_21;
        }
        if ( v21 > v20 )
          range[1] = v21;
        goto LABEL_20;
      }
LABEL_21:
      v6 = (const fde *)((char *)v6 + length + 4);
      length = v6->length;
      if ( !v6->length )
        return v9;
    }
    cie_encoding = get_cie_encoding((const dwarf_cie *)((char *)&v6->CIE_delta - CIE_delta));
    v8 = cie_encoding;
    if ( cie_encoding == 255 )
      return -1LL;
    v14 = cie_encoding;
    v15 = cie_encoding & 0x70;
    if ( v15 != 32 )
    {
      if ( v15 > 0x20 )
      {
        if ( v15 == 48 )
        {
          dbase = ob->dbase;
          goto LABEL_10;
        }
        if ( v15 != 80 )
          goto LABEL_42;
      }
      dbase = 0LL;
      if ( range )
        goto LABEL_11;
      goto LABEL_34;
    }
    dbase = ob->tbase;
LABEL_10:
    if ( range )
      goto LABEL_11;
LABEL_34:
    b = (int)ob->s.b;
    if ( (b & 0x7F8) == 0x7F8 )
    {
      *(_DWORD *)&ob->s.b = b & 0xFFFFF807 | (8 * v14);
    }
    else if ( (unsigned __int8)((unsigned int)ob->s.i >> 3) != v8 )
    {
      *(_DWORD *)&ob->s.b = b | 4;
    }
LABEL_11:
    v16 = read_encoded_value_with_base(v14, (_Unwind_Ptr)dbase, v6->pc_begin, &pc_begin);
    v17 = v14 & 7;
    v18 = v17 > 2;
    if ( v17 == 2 )
      goto LABEL_25;
    goto LABEL_12;
  }
  return 0LL;
}

//----- (00000000004508E0) ----------------------------------------------------
void __fastcall get_pc_range(const object *ob, uintptr_type *range)
{
  int b; // w2
  const dwarf_fde *single; // x19
  const fde *v5; // x1
  const fde *v7; // t1
  uintptr_type *v8; // x2
  const fde *v9; // x1

  *range = 0LL;
  range[1] = 0LL;
  b = (int)ob->s.b;
  single = ob->u.single;
  if ( (b & 1) != 0 )
  {
    v8 = range;
    v9 = (const fde *)*single;
    goto LABEL_7;
  }
  if ( (b & 2) == 0 )
  {
    v8 = range;
    v9 = ob->u.single;
LABEL_7:
    classify_object_over_fdes((object *)ob, v9, v8);
    return;
  }
  v5 = (const fde *)*single;
  if ( *single )
  {
    do
    {
      classify_object_over_fdes((object *)ob, v5, range);
      v7 = *(const fde **)single->pc_begin;
      ++single;
      v5 = v7;
    }
    while ( v7 );
  }
}

//----- (000000000045096C) ----------------------------------------------------
void *__fastcall _deregister_frame_info_bases_0(const void *begin)
{
  object *v1; // x0
  object *v2; // x20
  double v3; // d0
  double v4; // d1
  double v5; // d2
  double v6; // d3
  double v7; // d4
  double v8; // d5
  double v9; // d6
  double v10; // d7
  uintptr_type range[2]; // [xsp+20h] [xbp+20h] BYREF

  v1 = btree_remove(&registered_objects, (uintptr_type)begin);
  v2 = v1;
  if ( !v1 )
  {
    if ( !in_shutdown )
      abort();
    return v2;
  }
  get_pc_range(v1, range);
  if ( range[0] == range[1] )
  {
    if ( (*(_DWORD *)&v2->s.b & 1) == 0 )
      return v2;
  }
  else
  {
    btree_remove(&registered_frames, range[0]);
    if ( (*(_DWORD *)&v2->s.b & 1) == 0 )
      return v2;
  }
  free((unsigned __int64)v2->u.single, v3, v4, v5, v6, v7, v8, v9, v10);
  return v2;
}
// 4509E4: variable 'v3' is possibly undefined
// 4509E4: variable 'v4' is possibly undefined
// 4509E4: variable 'v5' is possibly undefined
// 4509E4: variable 'v6' is possibly undefined
// 4509E4: variable 'v7' is possibly undefined
// 4509E4: variable 'v8' is possibly undefined
// 4509E4: variable 'v9' is possibly undefined
// 4509E4: variable 'v10' is possibly undefined

//----- (0000000000450A00) ----------------------------------------------------
void __fastcall fde_single_encoding_extract(object *ob, _Unwind_Ptr *target, const fde **x, int count)
{
  int v5; // w0
  unsigned int v6; // w4
  void *tbase; // x22
  const fde **v8; // x21
  const fde **v9; // x19
  __int64 v11; // t1

  v5 = (unsigned __int8)((unsigned int)ob->s.i >> 3);
  if ( v5 == 255 )
    goto LABEL_11;
  v6 = v5 & 0x70;
  if ( v6 == 32 )
  {
    tbase = ob->tbase;
    goto LABEL_6;
  }
  if ( v6 <= 0x20 )
  {
LABEL_11:
    tbase = 0LL;
    goto LABEL_6;
  }
  if ( v6 == 48 )
  {
    tbase = ob->dbase;
  }
  else
  {
    tbase = 0LL;
    if ( v6 != 80 )
      abort();
  }
LABEL_6:
  if ( count > 0 )
  {
    v8 = &x[count];
    v9 = x;
    while ( 1 )
    {
      v11 = (__int64)*v9++;
      read_encoded_value_with_base(v5, (_Unwind_Ptr)tbase, (const unsigned __int8 *)(v11 + 8), target);
      if ( v9 == v8 )
        break;
      ++target;
      LOBYTE(v5) = (unsigned int)ob->s.i >> 3;
    }
  }
}

//----- (0000000000450AC0) ----------------------------------------------------
int __fastcall fde_single_encoding_compare(object *ob, const fde *x, const fde *y)
{
  int v4; // w19
  unsigned int v5; // w2
  void *tbase; // x20
  int result; // w0
  _Unwind_Ptr x_ptr; // [xsp+30h] [xbp+30h] BYREF
  _Unwind_Ptr y_ptr; // [xsp+38h] [xbp+38h] BYREF

  v4 = (unsigned __int8)((unsigned int)ob->s.i >> 3);
  if ( v4 == 255 )
    goto LABEL_12;
  v5 = ((unsigned int)ob->s.i >> 3) & 0x70;
  if ( v5 == 32 )
  {
    tbase = ob->tbase;
    goto LABEL_6;
  }
  if ( v5 <= 0x20 )
  {
LABEL_12:
    tbase = 0LL;
    goto LABEL_6;
  }
  if ( v5 == 48 )
  {
    tbase = ob->dbase;
  }
  else
  {
    tbase = 0LL;
    if ( v5 != 80 )
      abort();
  }
LABEL_6:
  read_encoded_value_with_base(v4, (_Unwind_Ptr)tbase, x->pc_begin, &x_ptr);
  read_encoded_value_with_base(v4, (_Unwind_Ptr)tbase, y->pc_begin, &y_ptr);
  if ( x_ptr >= y_ptr )
    result = 0;
  else
    result = -1;
  if ( x_ptr > y_ptr )
    return 1;
  return result;
}

//----- (0000000000450B68) ----------------------------------------------------
int __fastcall fde_mixed_encoding_compare(object *ob, const fde *x, const fde *y)
{
  int cie_encoding; // w0
  unsigned __int8 v7; // w4
  unsigned int v8; // w0
  void *tbase; // x1
  int v10; // w0
  unsigned __int8 v11; // w4
  unsigned int v12; // w0
  void *dbase; // x1
  int result; // w0
  _Unwind_Ptr x_ptr; // [xsp+30h] [xbp+30h] BYREF
  _Unwind_Ptr y_ptr; // [xsp+38h] [xbp+38h] BYREF

  cie_encoding = get_cie_encoding((const dwarf_cie *)((char *)&x->CIE_delta - x->CIE_delta));
  v7 = cie_encoding;
  if ( cie_encoding != 255 )
  {
    v8 = cie_encoding & 0x70;
    if ( v8 == 32 )
    {
      tbase = ob->tbase;
      goto LABEL_6;
    }
    if ( v8 > 0x20 )
    {
      if ( v8 == 48 )
      {
        tbase = ob->dbase;
      }
      else
      {
        tbase = 0LL;
        if ( v8 != 80 )
          goto LABEL_22;
      }
      goto LABEL_6;
    }
  }
  tbase = 0LL;
LABEL_6:
  read_encoded_value_with_base(v7, (_Unwind_Ptr)tbase, x->pc_begin, &x_ptr);
  v10 = get_cie_encoding((const dwarf_cie *)((char *)&y->CIE_delta - y->CIE_delta));
  v11 = v10;
  if ( v10 == 255 )
    goto LABEL_18;
  v12 = v10 & 0x70;
  if ( v12 == 32 )
  {
    dbase = ob->tbase;
    goto LABEL_11;
  }
  if ( v12 <= 0x20 )
  {
LABEL_18:
    dbase = 0LL;
    goto LABEL_11;
  }
  if ( v12 == 48 )
  {
    dbase = ob->dbase;
    goto LABEL_11;
  }
  dbase = 0LL;
  if ( v12 != 80 )
LABEL_22:
    abort();
LABEL_11:
  read_encoded_value_with_base(v11, (_Unwind_Ptr)dbase, y->pc_begin, &y_ptr);
  if ( x_ptr >= y_ptr )
    result = 0;
  else
    result = -1;
  if ( x_ptr > y_ptr )
    return 1;
  return result;
}

//----- (0000000000450C80) ----------------------------------------------------
void __fastcall add_fdes(object *ob, fde_accumulator *accu, const fde *this_fde)
{
  const fde *v3; // x20
  int v6; // w21
  unsigned int v7; // w0
  void *tbase; // x24
  __int64 v9; // x26
  uword length; // w19
  sword CIE_delta; // w0
  __int64 v12; // x22
  int cie_encoding; // w0
  unsigned __int8 v14; // w25
  unsigned int v15; // w0
  unsigned int v16; // w25
  bool v17; // cc
  __int64 v18; // x0
  fde_vector *aux; // x0
  _Unwind_Ptr pc_begin; // [xsp+68h] [xbp+68h] BYREF

  v3 = this_fde;
  v6 = (unsigned __int8)((unsigned int)ob->s.i >> 3);
  if ( v6 == 255 )
    goto LABEL_25;
  v7 = ((unsigned int)ob->s.i >> 3) & 0x70;
  if ( v7 == 32 )
  {
    tbase = ob->tbase;
    goto LABEL_6;
  }
  if ( v7 <= 0x20 )
  {
LABEL_25:
    tbase = 0LL;
    goto LABEL_6;
  }
  if ( v7 == 48 )
  {
    tbase = ob->dbase;
  }
  else
  {
    tbase = 0LL;
    if ( v7 != 80 )
      abort();
  }
LABEL_6:
  v9 = 0LL;
  length = this_fde->length;
  if ( this_fde->length )
  {
    do
    {
      CIE_delta = v3->CIE_delta;
      if ( !CIE_delta )
        goto LABEL_23;
      if ( (*(_DWORD *)&ob->s.b & 4) == 0 || (v12 = (__int64)&v3->CIE_delta - CIE_delta, v12 == v9) )
      {
        if ( v6 )
        {
          read_encoded_value_with_base(v6, (_Unwind_Ptr)tbase, v3->pc_begin, &pc_begin);
          if ( (unsigned __int8)v6 == 255 )
            goto LABEL_23;
          v16 = v6 & 7;
          v17 = v16 > 2;
          if ( v16 != 2 )
            goto LABEL_17;
          goto LABEL_31;
        }
      }
      else
      {
        cie_encoding = get_cie_encoding((const dwarf_cie *)((char *)&v3->CIE_delta - CIE_delta));
        v6 = cie_encoding;
        if ( cie_encoding == 255 )
        {
          v9 = v12;
          tbase = 0LL;
          read_encoded_value_with_base(0xFFu, 0LL, v3->pc_begin, &pc_begin);
          goto LABEL_23;
        }
        v14 = cie_encoding;
        v15 = cie_encoding & 0x70;
        if ( v15 == 32 )
        {
          tbase = ob->tbase;
LABEL_15:
          v9 = v12;
          read_encoded_value_with_base(v14, (_Unwind_Ptr)tbase, v3->pc_begin, &pc_begin);
          goto LABEL_16;
        }
        if ( v15 > 0x20 )
        {
          if ( v15 == 48 )
          {
            tbase = ob->dbase;
            goto LABEL_15;
          }
          if ( v15 != 80 )
LABEL_40:
            abort();
LABEL_36:
          v9 = v12;
          tbase = 0LL;
          read_encoded_value_with_base(v14, 0LL, v3->pc_begin, &pc_begin);
LABEL_16:
          v16 = v14 & 7;
          v17 = v16 > 2;
          if ( v16 != 2 )
          {
LABEL_17:
            if ( v17 )
            {
              v18 = 0xFFFFFFFFLL;
              if ( v16 != 3 )
              {
                if ( v16 != 4 )
                  goto LABEL_40;
                goto LABEL_38;
              }
            }
            else
            {
              if ( v16 )
                goto LABEL_40;
LABEL_38:
              v18 = -1LL;
            }
LABEL_20:
            if ( (v18 & pc_begin) != 0 )
              goto LABEL_21;
            goto LABEL_23;
          }
LABEL_31:
          v18 = 0xFFFFLL;
          goto LABEL_20;
        }
        v9 = v12;
        tbase = 0LL;
        if ( v6 )
          goto LABEL_36;
      }
      if ( *(_QWORD *)v3->pc_begin )
      {
LABEL_21:
        if ( accu )
        {
          aux = accu->aux;
          accu->aux = (fde_vector *)((char *)&aux->orig_data + 1);
          *((_QWORD *)&accu->linear + (_QWORD)&aux->orig_data + 2) = v3;
        }
      }
LABEL_23:
      v3 = (const fde *)((char *)v3 + length + 4);
      length = v3->length;
    }
    while ( v3->length );
  }
}

//----- (0000000000450EC0) ----------------------------------------------------
const fde *__fastcall linear_search_fdes(object *ob, const fde *this_fde, void *pc)
{
  const fde *v3; // x20
  int v6; // w25
  unsigned int v7; // w0
  void *tbase; // x22
  uword length; // w19
  __int64 v10; // x28
  __int64 v11; // x26
  int cie_encoding; // w0
  unsigned __int8 v13; // w27
  unsigned int v14; // w0
  const unsigned __int8 *v15; // x0
  unsigned int v16; // w27
  bool v17; // cc
  __int64 v18; // x0
  sword CIE_delta; // w0
  __int64 v20; // x1
  const unsigned __int8 *v22; // x0
  const unsigned __int8 *v23; // x0
  const unsigned __int8 *v24; // x0
  const unsigned __int8 *v25; // x0
  _Unwind_Ptr pc_begin; // [xsp+70h] [xbp+70h] BYREF
  _Unwind_Ptr pc_range; // [xsp+78h] [xbp+78h] BYREF

  v3 = this_fde;
  v6 = (unsigned __int8)((unsigned int)ob->s.i >> 3);
  if ( v6 == 255 )
    goto LABEL_28;
  v7 = ((unsigned int)ob->s.i >> 3) & 0x70;
  if ( v7 == 32 )
  {
    tbase = ob->tbase;
    goto LABEL_6;
  }
  if ( v7 <= 0x20 )
  {
LABEL_28:
    tbase = 0LL;
    goto LABEL_6;
  }
  if ( v7 == 48 )
  {
    tbase = ob->dbase;
  }
  else
  {
    tbase = 0LL;
    if ( v7 != 80 )
      abort();
  }
LABEL_6:
  length = this_fde->length;
  v10 = 0LL;
  if ( this_fde->length )
  {
    while ( 1 )
    {
      CIE_delta = v3->CIE_delta;
      if ( !CIE_delta )
        goto LABEL_21;
      if ( (*(_DWORD *)&ob->s.b & 4) == 0 || (v11 = (__int64)&v3->CIE_delta - CIE_delta, v11 == v10) )
      {
        if ( !v6 )
          goto LABEL_25;
        v22 = read_encoded_value_with_base(v6, (_Unwind_Ptr)tbase, v3->pc_begin, &pc_begin);
        read_encoded_value_with_base(v6 & 0xF, 0LL, v22, &pc_range);
        if ( (unsigned __int8)v6 == 255 )
          goto LABEL_21;
        v16 = v6 & 7;
        v17 = v16 > 2;
        if ( v16 == 2 )
        {
LABEL_33:
          v18 = 0xFFFFLL;
          goto LABEL_19;
        }
LABEL_16:
        if ( !v17 )
        {
          if ( v16 )
            goto LABEL_41;
LABEL_39:
          v18 = -1LL;
          goto LABEL_19;
        }
        v18 = 0xFFFFFFFFLL;
        if ( v16 != 3 )
        {
          if ( v16 != 4 )
            goto LABEL_41;
          goto LABEL_39;
        }
LABEL_19:
        if ( (pc_begin & v18) != 0 && (char *)pc - pc_begin < (char *)pc_range )
          return v3;
LABEL_21:
        v3 = (const fde *)((char *)v3 + length + 4);
        length = v3->length;
        if ( !v3->length )
          return 0LL;
      }
      else
      {
        cie_encoding = get_cie_encoding((const dwarf_cie *)((char *)&v3->CIE_delta - CIE_delta));
        v6 = cie_encoding;
        if ( cie_encoding == 255 )
        {
          v23 = read_encoded_value_with_base(0xFFu, 0LL, v3->pc_begin, &pc_begin);
          v10 = v11;
          tbase = 0LL;
          read_encoded_value_with_base(0xFu, 0LL, v23, &pc_range);
          goto LABEL_21;
        }
        v13 = cie_encoding;
        v14 = cie_encoding & 0x70;
        if ( v14 == 32 )
        {
          tbase = ob->tbase;
LABEL_14:
          v10 = v11;
          v15 = read_encoded_value_with_base(v13, (_Unwind_Ptr)tbase, v3->pc_begin, &pc_begin);
          read_encoded_value_with_base(v13 & 0xF, 0LL, v15, &pc_range);
          goto LABEL_15;
        }
        if ( v14 > 0x20 )
        {
          if ( v14 == 48 )
          {
            tbase = ob->dbase;
            goto LABEL_14;
          }
          if ( v14 != 80 )
LABEL_41:
            abort();
          v25 = read_encoded_value_with_base(v6, 0LL, v3->pc_begin, &pc_begin);
          v10 = v11;
          tbase = 0LL;
          read_encoded_value_with_base(v6 & 0xF, 0LL, v25, &pc_range);
LABEL_15:
          v16 = v13 & 7;
          v17 = v16 > 2;
          if ( v16 == 2 )
            goto LABEL_33;
          goto LABEL_16;
        }
        v10 = v11;
        tbase = 0LL;
        if ( v6 )
        {
          v24 = read_encoded_value_with_base(v6, 0LL, v3->pc_begin, &pc_begin);
          read_encoded_value_with_base(v6 & 0xF, 0LL, v24, &pc_range);
          goto LABEL_15;
        }
LABEL_25:
        v20 = *(_QWORD *)v3->pc_begin;
        if ( v20 )
        {
          if ( (char *)pc - v20 < (char *)*(_QWORD *)&v3->pc_begin[8] )
            return v3;
          goto LABEL_21;
        }
        v6 = 0;
        v3 = (const fde *)((char *)v3 + length + 4);
        length = v3->length;
        if ( !v3->length )
          return 0LL;
      }
    }
  }
  return 0LL;
}

//----- (00000000004511A8) ----------------------------------------------------
void __fastcall _register_frame_info_bases(const void *begin, object *ob, void *tbase, void *dbase)
{
  uintptr_type range[2]; // [xsp+20h] [xbp-10h] BYREF

  if ( begin )
  {
    if ( *(_DWORD *)begin )
    {
      ob->pc_begin = (void *)-1LL;
      ob->tbase = tbase;
      ob->dbase = dbase;
      ob->u.single = (const dwarf_fde *)begin;
      ob->s.i = 2040LL;
      btree_insert(&registered_objects, (uintptr_type)begin, 1uLL, ob);
      get_pc_range(ob, range);
      btree_insert(&registered_frames, range[0], range[1] - range[0], ob);
    }
  }
}

//----- (0000000000451220) ----------------------------------------------------
void __fastcall _register_frame_info(const void *begin, object *ob)
{
  uintptr_type range[2]; // [xsp+20h] [xbp-10h] BYREF

  if ( begin )
  {
    if ( *(_DWORD *)begin )
    {
      ob->pc_begin = (void *)-1LL;
      ob->tbase = 0LL;
      ob->dbase = 0LL;
      ob->u.single = (const dwarf_fde *)begin;
      ob->s.i = 2040LL;
      btree_insert(&registered_objects, (uintptr_type)begin, 1uLL, ob);
      get_pc_range(ob, range);
      btree_insert(&registered_frames, range[0], range[1] - range[0], ob);
    }
  }
}

//----- (0000000000451290) ----------------------------------------------------
void __fastcall _register_frame(void *begin)
{
  __int64 v1; // x2
  void *v2; // x3
  void *v3; // x4
  void *v4; // x5
  void *v5; // x6
  __int64 v6; // x7
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  object *v15; // x0
  void *v16; // x1
  object *beginb; // [xsp+10h] [xbp-20h]
  uintptr_type range[2]; // [xsp+20h] [xbp-10h] BYREF

  if ( *(_DWORD *)begin )
  {
    v15 = (object *)malloc(48LL, (__int64)begin, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);
    v15->pc_begin = (void *)-1LL;
    v15->tbase = 0LL;
    v16 = begin;
    v15->dbase = 0LL;
    v15->u.single = (const dwarf_fde *)begin;
    v15->s.i = 2040LL;
    beginb = v15;
    btree_insert(&registered_objects, (uintptr_type)v16, 1uLL, v15);
    get_pc_range(beginb, range);
    btree_insert(&registered_frames, range[0], range[1] - range[0], beginb);
  }
}
// 4512B0: variable 'v1' is possibly undefined
// 4512B0: variable 'v2' is possibly undefined
// 4512B0: variable 'v3' is possibly undefined
// 4512B0: variable 'v4' is possibly undefined
// 4512B0: variable 'v5' is possibly undefined
// 4512B0: variable 'v6' is possibly undefined
// 4512B0: variable 'v7' is possibly undefined
// 4512B0: variable 'v8' is possibly undefined
// 4512B0: variable 'v9' is possibly undefined
// 4512B0: variable 'v10' is possibly undefined
// 4512B0: variable 'v11' is possibly undefined
// 4512B0: variable 'v12' is possibly undefined
// 4512B0: variable 'v13' is possibly undefined
// 4512B0: variable 'v14' is possibly undefined

//----- (000000000045130C) ----------------------------------------------------
void __fastcall _register_frame_info_table_bases(void *begin, object *ob, void *tbase, void *dbase)
{
  uintptr_type range[2]; // [xsp+20h] [xbp+20h] BYREF

  ob->pc_begin = (void *)-1LL;
  ob->tbase = tbase;
  ob->dbase = dbase;
  ob->u.single = (const dwarf_fde *)begin;
  ob->s.i = 2042LL;
  btree_insert(&registered_objects, (uintptr_type)begin, 1uLL, ob);
  get_pc_range(ob, range);
  btree_insert(&registered_frames, range[0], range[1] - range[0], ob);
}

//----- (0000000000451380) ----------------------------------------------------
void __fastcall _register_frame_info_table(void *begin, object *ob)
{
  uintptr_type range[2]; // [xsp+20h] [xbp+20h] BYREF

  ob->pc_begin = (void *)-1LL;
  ob->tbase = 0LL;
  ob->dbase = 0LL;
  ob->u.single = (const dwarf_fde *)begin;
  ob->s.i = 2042LL;
  btree_insert(&registered_objects, (uintptr_type)begin, 1uLL, ob);
  get_pc_range(ob, range);
  btree_insert(&registered_frames, range[0], range[1] - range[0], ob);
}

//----- (00000000004513E8) ----------------------------------------------------
void __fastcall _register_frame_table(void *begin)
{
  __int64 v1; // x2
  void *v2; // x3
  void *v3; // x4
  void *v4; // x5
  void *v5; // x6
  __int64 v6; // x7
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  object *v15; // x19
  uintptr_type range[2]; // [xsp+30h] [xbp+30h] BYREF

  v15 = (object *)malloc(48LL, (__int64)begin, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14);
  v15->pc_begin = (void *)-1LL;
  v15->tbase = 0LL;
  v15->dbase = 0LL;
  v15->u.single = (const dwarf_fde *)begin;
  v15->s.i = 2042LL;
  btree_insert(&registered_objects, (uintptr_type)begin, 1uLL, v15);
  get_pc_range(v15, range);
  btree_insert(&registered_frames, range[0], range[1] - range[0], v15);
}
// 451408: variable 'v1' is possibly undefined
// 451408: variable 'v2' is possibly undefined
// 451408: variable 'v3' is possibly undefined
// 451408: variable 'v4' is possibly undefined
// 451408: variable 'v5' is possibly undefined
// 451408: variable 'v6' is possibly undefined
// 451408: variable 'v7' is possibly undefined
// 451408: variable 'v8' is possibly undefined
// 451408: variable 'v9' is possibly undefined
// 451408: variable 'v10' is possibly undefined
// 451408: variable 'v11' is possibly undefined
// 451408: variable 'v12' is possibly undefined
// 451408: variable 'v13' is possibly undefined
// 451408: variable 'v14' is possibly undefined

//----- (0000000000451460) ----------------------------------------------------
void *__fastcall _deregister_frame_info_bases(const void *begin)
{
  if ( begin && *(_DWORD *)begin )
    return _deregister_frame_info_bases_0(begin);
  else
    return 0LL;
}

//----- (0000000000451480) ----------------------------------------------------
void *__fastcall _deregister_frame_info(const void *begin)
{
  if ( begin && *(_DWORD *)begin )
    return _deregister_frame_info_bases_0(begin);
  else
    return 0LL;
}

//----- (00000000004514A0) ----------------------------------------------------
void __fastcall _deregister_frame(void *begin)
{
  void *v1; // x0
  double v2; // d0
  double v3; // d1
  double v4; // d2
  double v5; // d3
  double v6; // d4
  double v7; // d5
  double v8; // d6
  double v9; // d7

  if ( *(_DWORD *)begin )
  {
    v1 = _deregister_frame_info_bases_0(begin);
    free((unsigned __int64)v1, v2, v3, v4, v5, v6, v7, v8, v9);
  }
}
// 4514BC: variable 'v2' is possibly undefined
// 4514BC: variable 'v3' is possibly undefined
// 4514BC: variable 'v4' is possibly undefined
// 4514BC: variable 'v5' is possibly undefined
// 4514BC: variable 'v6' is possibly undefined
// 4514BC: variable 'v7' is possibly undefined
// 4514BC: variable 'v8' is possibly undefined
// 4514BC: variable 'v9' is possibly undefined

//----- (00000000004514C0) ----------------------------------------------------
const fde *__fastcall Unwind_Find_FDE(void *pc, dwarf_eh_bases *bases)
{
  double v2; // d0
  double v3; // d1
  double v4; // d2
  double v5; // d3
  double v6; // d4
  double v7; // d5
  double v8; // d6
  double v9; // d7
  unsigned __int8 *dlfo_eh_frame; // x28
  int v13; // w0
  const unsigned __int8 *v14; // x2
  const unsigned __int8 *v15; // x2
  int v16; // w0
  const fde *v17; // x0
  unsigned __int8 v18; // w0
  void *v19; // x0
  unsigned __int64 v21; // x0
  btree_node *root; // x4
  unsigned __int64 v23; // x1
  unsigned __int64 v24; // x5
  unsigned __int64 v25; // x1
  node_type type; // w2
  unsigned int entry_count; // w1
  unsigned __int64 *p_version_lock; // x7
  unsigned __int64 v29; // x0
  btree_node::$A8A0F332F17269724BDA12CB89177C85 *p_content; // x2
  __int64 v31; // x1
  __int64 i; // x0
  unsigned __int64 separator; // x3
  unsigned __int64 *v34; // x1
  unsigned __int64 v35; // x0
  unsigned __int64 v36; // x0
  unsigned __int64 v37; // x1
  const unsigned __int8 *v38; // x0
  _Unwind_Ptr v39; // x1
  _Unwind_Ptr v40; // x3
  unsigned __int8 *v41; // x19
  _Unwind_Ptr v42; // x1
  const unsigned __int8 *v43; // x20
  _Unwind_Ptr v44; // x2
  __int64 *p_child; // x0
  __int64 v46; // x3
  unsigned __int64 *v47; // x7
  unsigned __int64 v48; // x1
  __int64 v49; // x2
  object *v50; // x19
  unsigned __int64 v51; // x0
  unsigned __int64 v52; // x1
  unsigned __int64 v53; // x0
  int v54; // w21
  const dwarf_fde *v55; // x4
  unsigned __int64 v56; // x2
  unsigned __int64 v57; // x1
  unsigned __int64 v58; // x0
  const fde *v59; // x28
  unsigned __int64 v60; // x3
  const dwarf_fde *v61; // x20
  const fde *v62; // x1
  const fde *v63; // t1
  void *dbase; // x20
  void *tbase; // x23
  int v66; // w24
  int cie_encoding; // w0
  unsigned int v68; // w0
  _Unwind_Ptr v69; // x1
  __int64 v70; // x1
  __int64 v71; // x2
  void *v72; // x3
  void *v73; // x4
  void *v74; // x5
  void *v75; // x6
  __int64 v76; // x7
  double v77; // d0
  double v78; // d1
  double v79; // d2
  double v80; // d3
  double v81; // d4
  double v82; // d5
  double v83; // d6
  double v84; // d7
  int b; // w0
  sword *p_CIE_delta; // x26
  unsigned int v87; // w0
  const dwarf_fde *v88; // x23
  unsigned __int64 v89; // x26
  unsigned __int64 v90; // x25
  unsigned __int64 v91; // x21
  const unsigned __int8 *v92; // x0
  size_t v93; // x23
  const dwarf_fde *single; // x24
  const fde *v95; // x1
  const fde *v96; // t1
  size_t v97; // x0
  _Unwind_Ptr v98; // x23
  _Unwind_Ptr v99; // x24
  _Unwind_Ptr v100; // x21
  __int64 CIE_delta; // t1
  int v102; // w0
  unsigned __int8 v103; // w5
  unsigned int v104; // w0
  _Unwind_Ptr v105; // x1
  const unsigned __int8 *encoded_value_with_base; // x0
  int v107; // w0
  unsigned __int64 v108; // x0
  __int64 v109; // x1
  __int64 v110; // x2
  void *v111; // x3
  void *v112; // x4
  void *v113; // x5
  void *v114; // x6
  __int64 v115; // x7
  unsigned __int64 v116; // x24
  unsigned __int64 v117; // x0
  fde_vector *v118; // x25
  int v119; // w26
  const dwarf_fde *v120; // x28
  const fde *v121; // x2
  const fde *v122; // t1
  unsigned __int64 v123; // x28
  void (*v124)(object *, _Unwind_Ptr *, const fde **, int); // x1
  double v125; // d0
  double v126; // d1
  double v127; // d2
  double v128; // d3
  double v129; // d4
  double v130; // d5
  double v131; // d6
  double v132; // d7
  size_t v133; // x0
  int (*v134)(object *, const fde *, const fde *); // x25
  unsigned __int64 v135; // x26
  int v136; // w23
  int v137; // w3
  int v138; // w0
  __int64 v139; // x28
  int v140; // w4
  __int64 v141; // x0
  int v142; // w0
  unsigned int v143; // w1
  __int64 v144; // x2
  void *pc_begin; // x1
  unsigned __int8 *v146; // x0
  _Unwind_Ptr base; // [xsp+60h] [xbp+60h]
  unsigned __int8 basea; // [xsp+60h] [xbp+60h]
  unsigned __int8 encoding[8]; // [xsp+68h] [xbp+68h]
  _Unwind_Ptr *v150; // [xsp+70h] [xbp+70h]
  fde *this_fde; // [xsp+80h] [xbp+80h] BYREF
  _Unwind_Ptr val; // [xsp+88h] [xbp+88h] BYREF
  object ob; // [xsp+90h] [xbp+90h] BYREF
  dl_find_object dlfo; // [xsp+C0h] [xbp+C0h] BYREF

  if ( !registered_frames.root )
    goto LABEL_2;
  do
  {
    while ( 1 )
    {
      do
      {
        do
LABEL_13:
          v21 = atomic_load(&registered_frames.root_lock.version_lock);
        while ( (v21 & 1) != 0 );
        root = registered_frames.root;
        __dmb(9u);
        v23 = atomic_load(&registered_frames.root_lock.version_lock);
      }
      while ( v21 != v23 );
      if ( !root )
        goto LABEL_2;
      v24 = atomic_load(&root->version_lock.version_lock);
      if ( (v24 & 1) == 0 )
      {
        __dmb(9u);
        v25 = atomic_load(&registered_frames.root_lock.version_lock);
        if ( v21 == v25 )
          break;
      }
    }
    while ( 1 )
    {
      type = root->type;
      entry_count = root->entry_count;
      __dmb(9u);
      p_version_lock = &root->version_lock.version_lock;
      v29 = atomic_load(&root->version_lock.version_lock);
      if ( v24 != v29 )
        goto LABEL_13;
      if ( !entry_count )
        goto LABEL_2;
      if ( type )
        break;
      p_content = &root->content;
      v31 = entry_count - 1;
      for ( i = 0LL; i != v31; ++i )
      {
        separator = p_content->children[0].separator;
        p_content = (btree_node::$A8A0F332F17269724BDA12CB89177C85 *)((char *)p_content + 16);
        if ( (unsigned __int64)pc <= separator )
          break;
      }
      v34 = &root->content.children[(unsigned int)i].child->version_lock.version_lock;
      __dmb(9u);
      v35 = atomic_load(&root->version_lock.version_lock);
      if ( v24 != v35 )
        goto LABEL_13;
      root = (btree_node *)v34;
      v36 = atomic_load(v34);
      if ( (v36 & 1) != 0 )
        goto LABEL_13;
      __dmb(9u);
      v37 = atomic_load(p_version_lock);
      if ( v24 != v37 )
        goto LABEL_13;
      v24 = v36;
    }
    p_child = (__int64 *)&root->content.children[0].child;
    LODWORD(v46) = 0;
    while ( 1 )
    {
      v46 = (unsigned int)(v46 + 1);
      v47 = (unsigned __int64 *)(p_child - 1);
      if ( entry_count <= (unsigned int)v46 || (unsigned __int64)pc < *v47 + *p_child )
        break;
      p_child += 3;
    }
    v48 = *v47;
    v49 = *p_child;
    v50 = (object *)p_child[1];
    __dmb(9u);
    v51 = atomic_load(&root->version_lock.version_lock);
  }
  while ( v24 != v51 );
  if ( (unsigned __int64)pc < v48 )
    goto LABEL_2;
  v52 = v48 + v49;
  if ( (unsigned __int64)pc >= v52 || !v50 )
    goto LABEL_2;
  v53 = atomic_load((unsigned __int64 *)&v50->s);
  dlfo.dlfo_eh_frame = (void *)v53;
  if ( (v53 & 1) == 0 )
  {
    pthread_mutex_lock(
      &object_mutex,
      v2,
      v3,
      v4,
      v5,
      v6,
      v7,
      v8,
      v9,
      v52,
      v49,
      v46,
      (__int64)root,
      (void *)v24,
      &registered_frames.root_lock);
    b = (int)v50->s.b;
    if ( (b & 1) != 0 )
    {
LABEL_73:
      pthread_mutex_unlock(&object_mutex.__data.__lock, v77, v78, v79, v80, v81, v82, v83, v84);
      goto LABEL_52;
    }
    v93 = (unsigned int)v50->s.i >> 11;
    if ( !((unsigned int)v50->s.i >> 11) )
    {
      single = v50->u.single;
      if ( (b & 2) != 0 )
      {
        v95 = (const fde *)*single;
        if ( !*(_QWORD *)single )
          goto LABEL_73;
        while ( 1 )
        {
          v97 = classify_object_over_fdes(v50, v95, 0LL);
          if ( v97 == -1LL )
            goto LABEL_100;
          v96 = *(const fde **)single->pc_begin;
          ++single;
          v95 = v96;
          v93 += v97;
          if ( !v96 )
            goto LABEL_123;
        }
      }
      v93 = classify_object_over_fdes(v50, v50->u.single, 0LL);
      if ( v93 == -1LL )
      {
LABEL_100:
        v50->u.single = (const dwarf_fde *)&terminator_0;
        v50->s.i = 2040LL;
        goto LABEL_73;
      }
LABEL_123:
      v70 = 0x1FFFFFLL;
      v107 = *(_DWORD *)&v50->s.b & 0x7FF | ((_DWORD)v93 << 11);
      *(_DWORD *)&v50->s.b = v107;
      if ( v93 <= 0x1FFFFF )
      {
        if ( !v93 )
          goto LABEL_73;
      }
      else
      {
        *(_DWORD *)&v50->s.b = v107 & 0x7FF;
      }
    }
    v108 = malloc(8 * (v93 + 2), v70, v71, v72, v73, v74, v75, v76, v77, v78, v79, v80, v81, v82, v83, v84);
    v116 = v108;
    if ( v108 )
    {
      *(_QWORD *)(v108 + 8) = 0LL;
      v117 = malloc(8 * (v93 + 2), v109, v110, v111, v112, v113, v114, v115, v77, v78, v79, v80, v81, v82, v83, v84);
      v118 = (fde_vector *)v117;
      if ( v117 )
        *(_QWORD *)(v117 + 8) = 0LL;
      v119 = (int)v50->s.b;
      v120 = v50->u.single;
      if ( (v119 & 2) != 0 )
      {
        v121 = (const fde *)*v120;
        if ( !*(_QWORD *)v120 )
          goto LABEL_120;
        do
        {
          add_fdes(v50, (fde_accumulator *)v116, v121);
          v122 = *(const fde **)v120->pc_begin;
          ++v120;
          v121 = v122;
        }
        while ( v122 );
      }
      else
      {
        add_fdes(v50, (fde_accumulator *)v116, v50->u.single);
      }
      v123 = *(_QWORD *)(v116 + 8);
      if ( v93 != v123 )
LABEL_120:
        abort();
      if ( v118 )
      {
        if ( (v119 & 4) != 0 )
        {
          v124 = fde_mixed_encoding_extract;
        }
        else
        {
          v124 = fde_single_encoding_extract;
          if ( (v119 & 0x7F8) == 0 )
            v124 = fde_unencoded_extract;
        }
        fde_radixsort(v50, v124, (fde_vector *)v116, v118);
        free((unsigned __int64)v118, v125, v126, v127, v128, v129, v130, v131, v132);
      }
      else
      {
        if ( (v119 & 4) != 0 )
        {
          v134 = fde_mixed_encoding_compare;
        }
        else
        {
          v134 = fde_single_encoding_compare;
          if ( (v119 & 0x7F8) == 0 )
            v134 = fde_unencoded_compare;
        }
        v135 = v116 + 16;
        v136 = (v123 >> 1) - 1;
        if ( v136 >= 0 )
        {
          do
          {
            v137 = v136--;
            frame_downheap(v50, v134, (const fde **)(v116 + 16), v137, v123);
          }
          while ( v136 != -1 );
        }
        v138 = v123 - 1;
        v139 = (unsigned int)(v123 - 1);
        if ( v138 > 0 )
        {
          do
          {
            v140 = v139;
            v141 = *(_QWORD *)(v116 + 16);
            *(_QWORD *)(v116 + 16) = *(_QWORD *)(v135 + 8 * v139);
            *(_QWORD *)(v135 + 8 * v139--) = v141;
            frame_downheap(v50, v134, (const fde **)(v116 + 16), 0, v140);
          }
          while ( (int)v139 > 0 );
        }
      }
      *(_QWORD *)v116 = v50->u.single;
      v133 = v50->s.i;
      v50->u.single = (const dwarf_fde *)v116;
      dlfo.dlfo_eh_frame = (void *)(v133 | 1);
      atomic_store(v133 | 1, (unsigned __int64 *)&v50->s);
    }
    goto LABEL_73;
  }
LABEL_52:
  v54 = (int)v50->s.b;
  if ( (v54 & 1) == 0 )
  {
    v61 = v50->u.single;
    if ( (v54 & 2) != 0 )
    {
      v62 = (const fde *)*v61;
      if ( !*(_QWORD *)v61 )
        goto LABEL_2;
      while ( 1 )
      {
        v59 = linear_search_fdes(v50, v62, pc);
        if ( v59 )
          break;
        v63 = *(const fde **)v61->pc_begin;
        ++v61;
        v62 = v63;
        if ( !v63 )
          goto LABEL_2;
      }
    }
    else
    {
      v59 = linear_search_fdes(v50, v50->u.single, pc);
      if ( !v59 )
        goto LABEL_2;
    }
    tbase = v50->tbase;
    dbase = v50->dbase;
    bases->tbase = tbase;
    bases->dbase = dbase;
    if ( (v54 & 4) != 0 )
    {
      p_CIE_delta = &v59->CIE_delta;
      *(_QWORD *)encoding = -(__int64)v59->CIE_delta;
LABEL_76:
      cie_encoding = get_cie_encoding((const dwarf_cie *)((char *)p_CIE_delta + *(_QWORD *)encoding));
      LOBYTE(v66) = cie_encoding;
      goto LABEL_67;
    }
LABEL_66:
    LOBYTE(v66) = (unsigned int)v50->s.i >> 3;
    cie_encoding = (unsigned __int8)v66;
    goto LABEL_67;
  }
  if ( (v54 & 4) != 0 )
  {
    v150 = (_Unwind_Ptr *)v50->u.single;
    v98 = v150[1];
    if ( !v98 )
      goto LABEL_2;
    v99 = 0LL;
    while ( 1 )
    {
      v100 = (v99 + v98) >> 1;
      v59 = (const fde *)v150[v100 + 2];
      CIE_delta = v59->CIE_delta;
      p_CIE_delta = &v59->CIE_delta;
      *(_QWORD *)encoding = -CIE_delta;
      v102 = get_cie_encoding((const dwarf_cie *)((char *)&v59->CIE_delta - CIE_delta));
      v103 = v102;
      if ( v102 == 255 )
        goto LABEL_114;
      v104 = v102 & 0x70;
      if ( v104 != 32 )
        break;
      v105 = (_Unwind_Ptr)v50->tbase;
LABEL_111:
      basea = v103;
      encoded_value_with_base = read_encoded_value_with_base(v103, v105, v59->pc_begin, (_Unwind_Ptr *)&ob);
      read_encoded_value_with_base(basea & 0xF, 0LL, encoded_value_with_base, &dlfo.dlfo_flags);
      if ( pc >= ob.pc_begin )
      {
        if ( pc < (char *)ob.pc_begin + dlfo.dlfo_flags )
        {
          tbase = v50->tbase;
          dbase = v50->dbase;
          bases->tbase = tbase;
          bases->dbase = dbase;
          goto LABEL_76;
        }
        v99 = v100 + 1;
      }
      else
      {
        v98 = (v99 + v98) >> 1;
      }
      if ( v99 >= v98 )
        goto LABEL_2;
    }
    if ( v104 > 0x20 )
    {
      if ( v104 == 48 )
      {
        v105 = (_Unwind_Ptr)v50->dbase;
        goto LABEL_111;
      }
      if ( v104 != 80 )
        goto LABEL_120;
    }
LABEL_114:
    v105 = 0LL;
    goto LABEL_111;
  }
  if ( (v54 & 0x7F8) == 0 )
  {
    v55 = v50->u.single;
    v56 = 0LL;
    v57 = *(_QWORD *)v55->pc_begin;
    while ( 1 )
    {
      while ( 1 )
      {
        if ( v56 >= v57 )
          goto LABEL_2;
        v58 = (v56 + v57) >> 1;
        v59 = *(const fde **)&v55->pc_begin[8 * v58 + 8];
        v60 = *(_QWORD *)v59->pc_begin;
        if ( (unsigned __int64)pc >= v60 )
          break;
        v57 = (v56 + v57) >> 1;
      }
      if ( (unsigned __int64)pc < v60 + *(_QWORD *)&v59->pc_begin[8] )
        break;
      v56 = v58 + 1;
    }
    tbase = v50->tbase;
    dbase = v50->dbase;
    bases->tbase = tbase;
    bases->dbase = dbase;
    goto LABEL_66;
  }
  v66 = (unsigned __int8)((unsigned int)v50->s.i >> 3);
  if ( v66 != 255 )
  {
    v87 = ((unsigned int)v50->s.i >> 3) & 0x70;
    if ( v87 == 32 )
    {
      base = (_Unwind_Ptr)v50->tbase;
      goto LABEL_82;
    }
    if ( v87 > 0x20 )
    {
      if ( v87 == 48 )
      {
        base = (_Unwind_Ptr)v50->dbase;
      }
      else
      {
        base = 0LL;
        if ( v87 != 80 )
          abort();
      }
      goto LABEL_82;
    }
  }
  base = 0LL;
LABEL_82:
  v88 = v50->u.single;
  v89 = *(_QWORD *)v88->pc_begin;
  if ( !v89 )
    goto LABEL_2;
  v90 = 0LL;
  while ( 1 )
  {
    v91 = (v89 + v90) >> 1;
    v59 = *(const fde **)&v88->pc_begin[8 * v91 + 8];
    v92 = read_encoded_value_with_base(v66, base, v59->pc_begin, (_Unwind_Ptr *)&ob);
    read_encoded_value_with_base(v66 & 0xF, 0LL, v92, &dlfo.dlfo_flags);
    if ( pc < ob.pc_begin )
    {
      v89 = (v89 + v90) >> 1;
      goto LABEL_86;
    }
    if ( pc < (char *)ob.pc_begin + dlfo.dlfo_flags )
      break;
    v90 = v91 + 1;
LABEL_86:
    if ( v90 >= v89 )
      goto LABEL_2;
  }
  if ( v59 )
  {
    tbase = v50->tbase;
    dbase = v50->dbase;
    cie_encoding = v66;
    bases->tbase = tbase;
    bases->dbase = dbase;
LABEL_67:
    if ( cie_encoding == 255 )
      goto LABEL_74;
    v68 = v66 & 0x70;
    if ( v68 == 32 )
    {
      v69 = (_Unwind_Ptr)tbase;
      goto LABEL_71;
    }
    if ( v68 <= 0x20 )
    {
LABEL_74:
      v69 = 0LL;
    }
    else
    {
      v69 = (_Unwind_Ptr)dbase;
      if ( v68 != 48 )
      {
        v69 = 0LL;
        if ( v68 != 80 )
          goto LABEL_120;
      }
    }
LABEL_71:
    read_encoded_value_with_base(v66, v69, v59->pc_begin, &dlfo.dlfo_flags);
    bases->func = (void *)dlfo.dlfo_flags;
    return v59;
  }
LABEL_2:
  if ( (unsigned int)dl_find_object((unsigned __int64)pc, (__int64)&dlfo) )
    return 0LL;
  dlfo_eh_frame = (unsigned __int8 *)dlfo.dlfo_eh_frame;
  if ( !dlfo.dlfo_eh_frame )
    return (const fde *)dlfo_eh_frame;
  if ( *(_BYTE *)dlfo.dlfo_eh_frame != 1 )
    return 0LL;
  v13 = *((unsigned __int8 *)dlfo.dlfo_eh_frame + 1);
  v14 = (const unsigned __int8 *)dlfo.dlfo_eh_frame + 4;
  if ( v13 == 27 )
  {
    this_fde = (fde *)&v14[*((int *)dlfo.dlfo_eh_frame + 1)];
    v15 = (const unsigned __int8 *)dlfo.dlfo_eh_frame + 8;
  }
  else
  {
    v15 = read_encoded_value_with_base(v13, 0LL, v14, (_Unwind_Ptr *)&this_fde);
  }
  v16 = dlfo_eh_frame[2];
  if ( v16 == 255 || dlfo_eh_frame[3] != 59 )
    goto LABEL_9;
  if ( v16 == 3 )
  {
    v38 = v15 + 4;
    v39 = *(unsigned int *)v15;
    val = v39;
  }
  else
  {
    v38 = read_encoded_value_with_base(v16, 0LL, v15, &val);
    v39 = val;
  }
  if ( !v39 )
    return 0LL;
  v40 = (unsigned __int8)v38 & 3;
  if ( ((unsigned __int8)v38 & 3) != 0 )
  {
LABEL_9:
    memset(&ob, 0, 24);
    ob.u.single = this_fde;
    ob.s.i = 4LL;
    v17 = linear_search_fdes(&ob, this_fde, pc);
    dlfo_eh_frame = (unsigned __int8 *)v17;
    if ( v17 )
    {
      v18 = get_cie_encoding((const dwarf_cie *)((char *)&v17->CIE_delta - v17->CIE_delta));
      read_encoded_value_with_base(v18, 0LL, dlfo_eh_frame + 8, &val);
      v19 = (void *)val;
      bases->tbase = 0LL;
      bases->dbase = 0LL;
      bases->func = v19;
    }
    return (const fde *)dlfo_eh_frame;
  }
  v41 = dlfo_eh_frame;
  if ( pc < &dlfo_eh_frame[*(int *)v38] )
    return 0LL;
  v42 = v39 - 1;
  v43 = &v38[8 * v42];
  if ( pc >= &dlfo_eh_frame[*(int *)v43] )
    goto LABEL_157;
  if ( !v42 )
LABEL_166:
    abort();
  while ( 2 )
  {
    v44 = (v42 + v40) >> 1;
    v43 = &v38[8 * v44];
    if ( pc < &dlfo_eh_frame[*(int *)v43] )
    {
      v42 = (v42 + v40) >> 1;
LABEL_40:
      if ( v40 >= v42 )
        goto LABEL_166;
      continue;
    }
    break;
  }
  if ( pc >= &dlfo_eh_frame[*((int *)v43 + 2)] )
  {
    v40 = v44 + 1;
    goto LABEL_40;
  }
  if ( v42 <= v40 )
    goto LABEL_166;
LABEL_157:
  dlfo_eh_frame += *((int *)v43 + 1);
  v142 = get_cie_encoding((const dwarf_cie *)&dlfo_eh_frame[-*((int *)dlfo_eh_frame + 1) + 4]);
  if ( v142 == 255 )
  {
    v144 = 8LL;
    goto LABEL_170;
  }
  v143 = v142 & 7;
  if ( v143 == 2 )
  {
    v144 = 10LL;
    goto LABEL_161;
  }
  if ( v143 <= 2 )
  {
    v144 = 16LL;
    if ( (v142 & 7) == 0 )
      goto LABEL_161;
    goto LABEL_166;
  }
  v144 = 12LL;
  if ( v143 == 3 )
    goto LABEL_161;
  if ( v143 != 4 )
    goto LABEL_166;
  v144 = 16LL;
LABEL_161:
  if ( v142 == 27 )
  {
    pc_begin = (void *)*(int *)&dlfo_eh_frame[v144];
    goto LABEL_163;
  }
LABEL_170:
  read_encoded_value_with_base(v142 & 0xF, 0LL, &dlfo_eh_frame[v144], (_Unwind_Ptr *)&ob);
  pc_begin = ob.pc_begin;
LABEL_163:
  v146 = &v41[*(int *)v43];
  if ( pc < (char *)pc_begin + (unsigned __int64)v146 )
  {
    bases->tbase = 0LL;
    bases->dbase = 0LL;
    bases->func = v146;
    return (const fde *)dlfo_eh_frame;
  }
  return 0LL;
}
// 4514C0: could not find valid save-restore pair for x23
// 4514C0: could not find valid save-restore pair for x24
// 4514C0: could not find valid save-restore pair for x25
// 4514C0: could not find valid save-restore pair for x26
// 4518E8: variable 'v2' is possibly undefined
// 4518E8: variable 'v3' is possibly undefined
// 4518E8: variable 'v4' is possibly undefined
// 4518E8: variable 'v5' is possibly undefined
// 4518E8: variable 'v6' is possibly undefined
// 4518E8: variable 'v7' is possibly undefined
// 4518E8: variable 'v8' is possibly undefined
// 4518E8: variable 'v9' is possibly undefined
// 4518FC: variable 'v77' is possibly undefined
// 4518FC: variable 'v78' is possibly undefined
// 4518FC: variable 'v79' is possibly undefined
// 4518FC: variable 'v80' is possibly undefined
// 4518FC: variable 'v81' is possibly undefined
// 4518FC: variable 'v82' is possibly undefined
// 4518FC: variable 'v83' is possibly undefined
// 4518FC: variable 'v84' is possibly undefined
// 451BEC: variable 'v70' is possibly undefined
// 451BEC: variable 'v71' is possibly undefined
// 451BEC: variable 'v72' is possibly undefined
// 451BEC: variable 'v73' is possibly undefined
// 451BEC: variable 'v74' is possibly undefined
// 451BEC: variable 'v75' is possibly undefined
// 451BEC: variable 'v76' is possibly undefined
// 451C00: variable 'v109' is possibly undefined
// 451C00: variable 'v110' is possibly undefined
// 451C00: variable 'v111' is possibly undefined
// 451C00: variable 'v112' is possibly undefined
// 451C00: variable 'v113' is possibly undefined
// 451C00: variable 'v114' is possibly undefined
// 451C00: variable 'v115' is possibly undefined
// 451C7C: variable 'v125' is possibly undefined
// 451C7C: variable 'v126' is possibly undefined
// 451C7C: variable 'v127' is possibly undefined
// 451C7C: variable 'v128' is possibly undefined
// 451C7C: variable 'v129' is possibly undefined
// 451C7C: variable 'v130' is possibly undefined
// 451C7C: variable 'v131' is possibly undefined
// 451C7C: variable 'v132' is possibly undefined

//----- (0000000000451EA0) ----------------------------------------------------
_Unwind_Ptr __fastcall base_of_encoded_value(unsigned __int8 encoding, _Unwind_Context *context)
{
  unsigned int v2; // w2

  if ( encoding == 255 )
    return 0LL;
  v2 = encoding & 0x70;
  if ( v2 != 48 )
  {
    if ( v2 > 0x30 )
    {
      if ( v2 == 64 )
        return Unwind_GetRegionStart(context);
      if ( v2 == 80 )
        return 0LL;
    }
    else
    {
      if ( v2 == 32 )
        return Unwind_GetTextRelBase(context);
      if ( v2 <= 0x20 )
        return 0LL;
    }
    abort();
  }
  return Unwind_GetDataRelBase(context);
}

//----- (0000000000451F04) ----------------------------------------------------
const unsigned __int8 *__fastcall read_encoded_value_with_base_0(
        unsigned __int8 encoding,
        _Unwind_Ptr base,
        const unsigned __int8 *p,
        _Unwind_Ptr *val)
{
  unsigned int v5; // w0
  const unsigned __int8 *result; // x0
  _Unwind_Ptr v7; // x4
  int v8; // w7
  char v9; // t1
  unsigned __int64 v10; // x6
  unsigned __int64 v11; // x2
  unsigned int v12; // w7
  char v13; // w8
  char v14; // t1
  unsigned __int64 v15; // x6

  if ( encoding == 80 )
  {
    v11 = (unsigned __int64)(p + 7);
    result = (const unsigned __int8 *)((v11 & 0xFFFFFFFFFFFFFFF8LL) + 8);
    v7 = *(_QWORD *)(v11 & 0xFFFFFFFFFFFFFFF8LL);
    goto LABEL_21;
  }
  v5 = encoding & 0xF;
  if ( (encoding & 0xF) == 4 )
    goto LABEL_23;
  if ( v5 <= 4 )
  {
    if ( v5 == 2 )
    {
      result = p + 2;
      v7 = *(unsigned __int16 *)p;
      goto LABEL_9;
    }
    if ( v5 == 3 )
    {
      result = p + 4;
      v7 = *(unsigned int *)p;
      goto LABEL_9;
    }
    if ( v5 )
    {
      result = p;
      v7 = 0LL;
      v8 = 0;
      do
      {
        v9 = *result++;
        v10 = (unsigned __int64)(v9 & 0x7F) << v8;
        v8 += 7;
        v7 |= v10;
      }
      while ( v9 < 0 );
      goto LABEL_9;
    }
LABEL_23:
    result = p + 8;
    v7 = *(_QWORD *)p;
    goto LABEL_9;
  }
  if ( v5 == 11 )
  {
    result = p + 4;
    v7 = *(int *)p;
    goto LABEL_9;
  }
  if ( v5 > 0xB )
  {
    if ( v5 != 12 )
      goto LABEL_32;
    goto LABEL_23;
  }
  if ( v5 != 9 )
  {
    if ( v5 == 10 )
    {
      result = p + 2;
      v7 = *(__int16 *)p;
      goto LABEL_9;
    }
LABEL_32:
    abort();
  }
  result = p;
  v7 = 0LL;
  v12 = 0;
  do
  {
    v14 = *result++;
    v13 = v14;
    v15 = (unsigned __int64)(v14 & 0x7F) << v12;
    v12 += 7;
    v7 |= v15;
  }
  while ( v14 < 0 );
  if ( v12 > 0x3F || (v13 & 0x40) == 0 )
  {
LABEL_9:
    if ( !v7 )
      goto LABEL_21;
    goto LABEL_10;
  }
  v7 |= -1LL << v12;
LABEL_10:
  if ( (encoding & 0x70) != 0x10 )
    p = (const unsigned __int8 *)base;
  v7 += (_Unwind_Ptr)p;
  if ( (encoding & 0x80) != 0 )
  {
    *val = *(_QWORD *)v7;
    return result;
  }
LABEL_21:
  *val = v7;
  return result;
}

//----- (0000000000452040) ----------------------------------------------------
_Unwind_Reason_Code __fastcall _gcc_personality_v0(
        int version,
        _Unwind_Action actions,
        _Unwind_Exception_Class exception_class,
        _Unwind_Exception *ue_header,
        _Unwind_Context *context)
{
  unsigned __int8 *LanguageSpecificData; // x19
  _Unwind_Ptr RegionStart; // x22
  const unsigned __int8 *v10; // x19
  unsigned __int8 v11; // w20
  int v12; // t1
  _Unwind_Ptr v13; // x28
  unsigned int v14; // w0
  _Unwind_Ptr TextRelBase; // x1
  const unsigned __int8 *v16; // x0
  _BYTE *v17; // x19
  int v18; // t1
  int v19; // t1
  const unsigned __int8 *encoded_value_with_base_0; // x19
  unsigned __int8 v21; // w20
  unsigned __int8 v22; // t1
  __int64 v23; // x21
  int v24; // w1
  char v25; // t1
  unsigned __int64 v26; // x0
  _Unwind_Ptr IPInfo; // x0
  const unsigned __int8 *v28; // x21
  _Unwind_Ptr v29; // x26
  _Unwind_Ptr v30; // x0
  const unsigned __int8 *v31; // x19
  _Unwind_Ptr v32; // x0
  const unsigned __int8 *v33; // x19
  _Unwind_Ptr v34; // x0
  int v35; // t1
  _Unwind_Ptr v36; // x19
  int ip_before_insn; // [xsp+74h] [xbp+74h] BYREF
  _Unwind_Ptr cs_start; // [xsp+78h] [xbp+78h] BYREF
  _Unwind_Ptr cs_len; // [xsp+80h] [xbp+80h] BYREF
  _Unwind_Ptr cs_lp[2]; // [xsp+88h] [xbp+88h] BYREF
  _Unwind_Ptr val; // [xsp+98h] [xbp+98h] BYREF

  ip_before_insn = 0;
  if ( version != 1 )
    return 3;
  if ( (actions & 2) == 0 )
    return 8;
  LanguageSpecificData = (unsigned __int8 *)Unwind_GetLanguageSpecificData(context);
  if ( !LanguageSpecificData )
    return 8;
  RegionStart = 0LL;
  if ( context )
    RegionStart = Unwind_GetRegionStart(context);
  v12 = *LanguageSpecificData;
  v10 = LanguageSpecificData + 1;
  v11 = v12;
  v13 = RegionStart;
  if ( v12 != 255 )
  {
    v14 = v11 & 0x70;
    if ( v14 != 48 )
    {
      if ( v14 > 0x30 )
      {
        if ( v14 == 64 )
        {
          TextRelBase = Unwind_GetRegionStart(context);
          goto LABEL_13;
        }
        TextRelBase = 0LL;
        if ( v14 == 80 )
          goto LABEL_13;
      }
      else
      {
        if ( v14 == 32 )
        {
          TextRelBase = Unwind_GetTextRelBase(context);
LABEL_13:
          v16 = read_encoded_value_with_base_0(v11, TextRelBase, v10, &val);
          v13 = val;
          v10 = v16;
          goto LABEL_15;
        }
        if ( v14 <= 0x20 )
        {
          TextRelBase = 0LL;
          goto LABEL_13;
        }
      }
      abort();
    }
    TextRelBase = Unwind_GetDataRelBase(context);
    goto LABEL_13;
  }
LABEL_15:
  v18 = *v10;
  v17 = v10 + 1;
  if ( v18 != 255 )
  {
    do
      v19 = (char)*v17++;
    while ( v19 < 0 );
  }
  v22 = *v17;
  encoded_value_with_base_0 = v17 + 1;
  v21 = v22;
  v23 = 0LL;
  v24 = 0;
  do
  {
    v25 = *encoded_value_with_base_0++;
    v26 = (unsigned __int64)(v25 & 0x7F) << v24;
    v24 += 7;
    v23 |= v26;
  }
  while ( v25 < 0 );
  IPInfo = Unwind_GetIPInfo(context, &ip_before_insn);
  v28 = &encoded_value_with_base_0[v23];
  v29 = IPInfo - (ip_before_insn == 0);
  while ( encoded_value_with_base_0 < v28 )
  {
    v30 = base_of_encoded_value(v21, 0LL);
    v31 = read_encoded_value_with_base_0(v21, v30, encoded_value_with_base_0, &cs_start);
    v32 = base_of_encoded_value(v21, 0LL);
    v33 = read_encoded_value_with_base_0(v21, v32, v31, &cs_len);
    v34 = base_of_encoded_value(v21, 0LL);
    encoded_value_with_base_0 = read_encoded_value_with_base_0(v21, v34, v33, cs_lp);
    do
      v35 = *(char *)encoded_value_with_base_0++;
    while ( v35 < 0 );
    if ( RegionStart + cs_start > v29 )
      break;
    if ( RegionStart + cs_start + cs_len > v29 )
    {
      if ( cs_lp[0] )
      {
        v36 = cs_lp[0] + v13;
        if ( cs_lp[0] + v13 )
        {
          Unwind_SetGR(context, 0, (_Unwind_Word)ue_header);
          Unwind_SetGR(context, 1, 0LL);
          Unwind_SetIP(context, v36);
          return 7;
        }
      }
      return 8;
    }
  }
  return 8;
}

//----- (0000000000452300) ----------------------------------------------------
void __cdecl _arm_za_disable()
{
  if ( _aarch64_have_sme )
  {
    if ( _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 5)) )
    {
      _arm_tpidr2_save();
      _WriteStatusReg(ARM64_SYSREG(3, 3, 13, 0, 5), 0LL);
      __asm { MSR             SVCRZA, #0 }
    }
  }
}

//----- (0000000000452330) ----------------------------------------------------
void __cdecl _arm_tpidr2_save()
{
  unsigned __int64 StatusReg; // x14

  if ( _aarch64_have_sme )
  {
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 5));
    if ( StatusReg )
    {
      if ( *(unsigned __int16 *)(StatusReg + 10) | *(_DWORD *)(StatusReg + 12) )
        JUMPOUT(0x4523C0LL);
      if ( *(_QWORD *)StatusReg )
      {
        if ( *(_WORD *)(StatusReg + 8) )
          JUMPOUT(0x452364LL);
      }
    }
  }
}
// 452360: control flows out of bounds to 452364
// 4523BC: control flows out of bounds to 4523C0

//----- (00000000004523E0) ----------------------------------------------------
__int64 __fastcall pthread_cond_broadcast(
        __int64 *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        void *a13,
        void *a14,
        void *a15)
{
  int v16; // w22
  int *v17; // x21
  int v18; // w19
  int v19; // w0
  int v20; // w0
  bool v21; // zf
  unsigned __int64 v22; // x23
  bool v23; // w25
  __int64 v24; // x1
  __int64 v25; // x24
  char *v26; // x19
  void *v27; // x4
  void *v28; // x5
  void *v29; // x6
  unsigned __int64 v30; // x0
  __int64 v31; // x24
  __int64 v32; // x0
  __int64 v33; // x2
  void *v34; // x5
  void *v35; // x6
  char v36; // w0
  unsigned int v38; // w2
  unsigned __int64 v39; // x0
  int v40; // w19
  unsigned __int8 v41; // w0
  int v42; // w0
  __int64 v43; // x4
  char v44; // w0
  __int64 *v45; // x3
  void *v46; // x1
  unsigned __int64 v47; // x0
  unsigned __int64 v48; // x0
  int v49; // w0
  unsigned __int64 v50; // x0
  unsigned int v51; // [xsp+50h] [xbp+50h]
  int v52; // [xsp+50h] [xbp+50h]
  __int64 v53; // [xsp+68h] [xbp+68h]

  if ( !(*((_DWORD *)a1 + 7) >> 3) )
    return 0LL;
  v16 = (*((_DWORD *)a1 + 7) & 1) << 7;
  v17 = (int *)(a1 + 3);
  v18 = *((_DWORD *)a1 + 6);
  do
  {
    v19 = v18 & 3;
    if ( (v18 & 3) != 0 )
    {
      while ( 1 )
      {
        if ( v19 != 2 )
        {
          _aarch64_cas4_acq();
          v21 = v49 == v18;
          v18 = v49;
          if ( !v21 )
            goto LABEL_35;
          if ( (v49 & 3) == 0 )
            goto LABEL_6;
        }
        v50 = linux_eabi_syscall(
                __NR_futex,
                v17,
                (void *)(v16 ^ 0x80),
                (void *)(v18 & 0xFFFFFFFC | 2LL),
                0LL,
                a13,
                a14,
                a15);
        if ( v50 <= 0xFFFFFFFFFFFFF000LL || (_DWORD)v50 == -11 )
        {
          v18 = *v17;
        }
        else
        {
          if ( (_DWORD)v50 != -4 )
            goto LABEL_18;
          v18 = *v17;
        }
LABEL_35:
        v19 = v18 & 3;
      }
    }
    _aarch64_cas4_acq();
    v21 = v20 == v18;
    v18 = v20;
  }
  while ( !v21 );
LABEL_6:
  v22 = *a1;
  v23 = (*a1 & 1) == 0;
  v24 = 4LL * v23;
  v25 = (__int64)a1 + v24;
  if ( *(_DWORD *)((char *)a1 + v24 + 16) )
  {
    v26 = (char *)a1 + v24 + 32;
    _aarch64_ldadd4_relax();
    *(_DWORD *)(v25 + 16) = 0;
    v30 = linux_eabi_syscall(__NR_futex, v26, (void *)(v16 ^ 0x81u), (void *)0x7FFFFFFF, 0LL, v27, v28, v29);
    if ( v30 > 0xFFFFFFFFFFFFF000LL && (((_DWORD)v30 + 22) & 0xFFFFFFF7) != 0 )
LABEL_18:
      _libc_fatal((__int64)"The futex facility returned an unexpected error code.\n", a2, a3, a4, a5, a6, a7, a8, a9);
  }
  v31 = 4 * (v22 & 1);
  v32 = (unsigned int)*v17 >> 2;
  v33 = a1[1] + v32;
  if ( *(_DWORD *)((char *)a1 + v31 + 16) + (unsigned int)(v22 >> 1) == (_DWORD)v33 )
    goto LABEL_9;
  a1[1] += v32;
  v51 = v33;
  v53 = (__int64)a1 + v31;
  _aarch64_ldeor8_rel();
  v38 = v51;
  atomic_store(v51, (unsigned int *)((char *)a1 + v31 + 32));
  v40 = (v39 >> 1) - v38;
  v52 = *v17 & 3 | (4 * v40);
  _aarch64_swp4_relax();
  if ( (((unsigned __int8)v52 ^ v41) & 3) != 0 )
    *v17 = (4 * v40) | 2;
  v42 = v40 + *(_DWORD *)(v53 + 16);
  *(_DWORD *)(v53 + 16) = v42;
  if ( !v42 )
  {
    v23 = v22 & 1;
LABEL_9:
    _aarch64_ldclr4_rel();
    if ( (v36 & 3) != 2 )
      return 0LL;
    v43 = 0LL;
    goto LABEL_20;
  }
  _aarch64_ldadd4_relax();
  *(_DWORD *)(v53 + 16) = 0;
  _aarch64_ldclr4_rel();
  if ( (v44 & 3) != 2 )
  {
    v45 = a1 + 4;
    v46 = (void *)(v16 ^ 0x81);
    goto LABEL_16;
  }
  v23 = v22 & 1;
  v43 = 1LL;
LABEL_20:
  v46 = (void *)(v16 ^ 0x81);
  v48 = linux_eabi_syscall(__NR_futex, v17, v46, (void *)1, 0LL, (void *)v43, v34, v35);
  if ( v48 > 0xFFFFFFFFFFFFF000LL && (((_DWORD)v48 + 22) & 0xFFFFFFF7) != 0 )
    goto LABEL_18;
  if ( !(_DWORD)v43 )
    return 0LL;
  v31 = 4LL * v23;
  v45 = a1 + 4;
LABEL_16:
  v47 = linux_eabi_syscall(__NR_futex, (char *)v45 + v31, v46, (void *)0x7FFFFFFF, 0LL, (void *)v43, v34, v35);
  if ( v47 > 0xFFFFFFFFFFFFF000LL && (((_DWORD)v47 + 22) & 0xFFFFFFF7) != 0 )
    goto LABEL_18;
  return 0LL;
}
// 452430: variable 'v20' is possibly undefined
// 452484: variable 'v27' is possibly undefined
// 452484: variable 'v28' is possibly undefined
// 452484: variable 'v29' is possibly undefined
// 4524CC: variable 'v36' is possibly undefined
// 452528: variable 'v39' is possibly undefined
// 452558: variable 'v41' is possibly undefined
// 452598: variable 'v44' is possibly undefined
// 4525C4: variable 'v43' is possibly undefined
// 4525C4: variable 'v34' is possibly undefined
// 4525C4: variable 'v35' is possibly undefined
// 4525E4: variable 'a2' is possibly undefined
// 4525E4: variable 'a3' is possibly undefined
// 4525E4: variable 'a4' is possibly undefined
// 4525E4: variable 'a5' is possibly undefined
// 4525E4: variable 'a6' is possibly undefined
// 4525E4: variable 'a7' is possibly undefined
// 4525E4: variable 'a8' is possibly undefined
// 4525E4: variable 'a9' is possibly undefined
// 45268C: variable 'v49' is possibly undefined
// 4526B8: variable 'a13' is possibly undefined
// 4526B8: variable 'a14' is possibly undefined
// 4526B8: variable 'a15' is possibly undefined

//----- (0000000000452700) ----------------------------------------------------
unsigned __int64 __fastcall _condvar_confirm_wakeup(__int64 a1, int a2)
{
  void *v2; // x19
  void *v4; // x4
  void *v5; // x5
  void *v6; // x6
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  unsigned int v15; // w0
  unsigned __int64 result; // x0

  v2 = (void *)(a1 + 28);
  _aarch64_ldadd4_rel();
  result = v15 >> 2;
  if ( (_DWORD)result == 3 )
  {
    result = linux_eabi_syscall(__NR_futex, v2, (void *)(a2 ^ 0x81), (void *)0x7FFFFFFF, 0LL, v4, v5, v6);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      result = (unsigned int)(result + 22);
      if ( (result & 0xFFFFFFF7) != 0 )
        _libc_fatal(
          (__int64)"The futex facility returned an unexpected error code.\n",
          v7,
          v8,
          v9,
          v10,
          v11,
          v12,
          v13,
          v14);
    }
  }
  return result;
}
// 452720: variable 'v15' is possibly undefined
// 452754: variable 'v4' is possibly undefined
// 452754: variable 'v5' is possibly undefined
// 452754: variable 'v6' is possibly undefined
// 452774: variable 'v7' is possibly undefined
// 452774: variable 'v8' is possibly undefined
// 452774: variable 'v9' is possibly undefined
// 452774: variable 'v10' is possibly undefined
// 452774: variable 'v11' is possibly undefined
// 452774: variable 'v12' is possibly undefined
// 452774: variable 'v13' is possibly undefined
// 452774: variable 'v14' is possibly undefined

//----- (0000000000452780) ----------------------------------------------------
unsigned __int64 __fastcall _condvar_release_lock(__int64 a1, int a2)
{
  void *v2; // x19
  void *v4; // x4
  void *v5; // x5
  void *v6; // x6
  double v7; // d0
  double v8; // d1
  double v9; // d2
  double v10; // d3
  double v11; // d4
  double v12; // d5
  double v13; // d6
  double v14; // d7
  char v15; // w0
  unsigned __int64 result; // x0

  v2 = (void *)(a1 + 24);
  _aarch64_ldclr4_rel();
  result = v15 & 3;
  if ( (_DWORD)result == 2 )
  {
    result = linux_eabi_syscall(__NR_futex, v2, (void *)(a2 ^ 0x81), (void *)1, 0LL, v4, v5, v6);
    if ( result > 0xFFFFFFFFFFFFF000LL )
    {
      result = (unsigned int)(result + 22);
      if ( (result & 0xFFFFFFF7) != 0 )
        _libc_fatal(
          (__int64)"The futex facility returned an unexpected error code.\n",
          v7,
          v8,
          v9,
          v10,
          v11,
          v12,
          v13,
          v14);
    }
  }
  return result;
}
// 4527A0: variable 'v15' is possibly undefined
// 4527D4: variable 'v4' is possibly undefined
// 4527D4: variable 'v5' is possibly undefined
// 4527D4: variable 'v6' is possibly undefined
// 4527F4: variable 'v7' is possibly undefined
// 4527F4: variable 'v8' is possibly undefined
// 4527F4: variable 'v9' is possibly undefined
// 4527F4: variable 'v10' is possibly undefined
// 4527F4: variable 'v11' is possibly undefined
// 4527F4: variable 'v12' is possibly undefined
// 4527F4: variable 'v13' is possibly undefined
// 4527F4: variable 'v14' is possibly undefined

//----- (0000000000452800) ----------------------------------------------------
unsigned __int64 __fastcall _condvar_cancel_waiting(
        __int64 a1,
        unsigned __int64 a2,
        unsigned int a3,
        int a4,
        void *a5,
        void *a6,
        void *a7,
        double a8,
        double a9,
        double a10,
        double a11,
        double a12,
        double a13,
        double a14,
        double a15)
{
  int *v15; // x20
  int v20; // w19
  int v21; // w0
  int v22; // w0
  bool v23; // zf
  unsigned __int64 v24; // x0
  __int64 v25; // x1
  __int64 v26; // x2
  __int64 v27; // x3
  void *v28; // x4
  void *v29; // x5
  void *v30; // x6
  double v31; // d0
  double v32; // d1
  double v33; // d2
  double v34; // d3
  double v35; // d4
  double v36; // d5
  double v37; // d6
  double v38; // d7
  __int64 v40; // x1
  int v41; // w3
  __int64 v42; // x1
  __int64 v43; // x2
  __int64 v44; // x3
  void *v45; // x4
  void *v46; // x5
  void *v47; // x6
  double v48; // d0
  double v49; // d1
  double v50; // d2
  double v51; // d3
  double v52; // d4
  double v53; // d5
  double v54; // d6
  double v55; // d7
  int v56; // w0
  unsigned __int64 v57; // x0

  v15 = (int *)(a1 + 24);
  v20 = *(_DWORD *)(a1 + 24);
  do
  {
    v21 = v20 & 3;
    if ( (v20 & 3) != 0 )
    {
      while ( 1 )
      {
        if ( v21 != 2 )
        {
          _aarch64_cas4_acq();
          v23 = v56 == v20;
          v20 = v56;
          if ( !v23 )
            goto LABEL_18;
          if ( (v56 & 3) == 0 )
            goto LABEL_5;
        }
        v57 = linux_eabi_syscall(
                __NR_futex,
                v15,
                (void *)(a4 ^ 0x80),
                (void *)(v20 & 0xFFFFFFFC | 2LL),
                0LL,
                a5,
                a6,
                a7);
        if ( v57 > 0xFFFFFFFFFFFFF000LL && (_DWORD)v57 != -11 && (_DWORD)v57 != -4 )
          _libc_fatal(
            (__int64)"The futex facility returned an unexpected error code.\n",
            a8,
            a9,
            a10,
            a11,
            a12,
            a13,
            a14,
            a15);
        v20 = *v15;
LABEL_18:
        v21 = v20 & 3;
      }
    }
    _aarch64_cas4_acq();
    v23 = v22 == v20;
    v20 = v22;
  }
  while ( !v23 );
LABEL_5:
  v24 = *(_QWORD *)(a1 + 8);
  if ( a2 < v24 )
  {
LABEL_6:
    _condvar_release_lock(a1, a4);
    return pthread_cond_signal((__int64 *)a1, v31, v32, v33, v34, v35, v36, v37, v38, v25, v26, v27, v28, v29, v30);
  }
  v40 = a1 + 4LL * a3;
  v41 = *(_DWORD *)(v40 + 16);
  if ( ((unsigned int)*v15 >> 2) + v24 > a2 )
  {
    if ( !v41 )
      goto LABEL_6;
    goto LABEL_9;
  }
  if ( v41 != -536870912 )
  {
LABEL_9:
    *(_DWORD *)(v40 + 16) = v41 - 1;
    return _condvar_release_lock(a1, a4);
  }
  _condvar_release_lock(a1, a4);
  return pthread_cond_broadcast((__int64 *)a1, v48, v49, v50, v51, v52, v53, v54, v55, v42, v43, v44, v45, v46, v47);
}
// 452848: variable 'v22' is possibly undefined
// 452888: variable 'v31' is possibly undefined
// 452888: variable 'v32' is possibly undefined
// 452888: variable 'v33' is possibly undefined
// 452888: variable 'v34' is possibly undefined
// 452888: variable 'v35' is possibly undefined
// 452888: variable 'v36' is possibly undefined
// 452888: variable 'v37' is possibly undefined
// 452888: variable 'v38' is possibly undefined
// 452888: variable 'v25' is possibly undefined
// 452888: variable 'v26' is possibly undefined
// 452888: variable 'v27' is possibly undefined
// 452888: variable 'v28' is possibly undefined
// 452888: variable 'v29' is possibly undefined
// 452888: variable 'v30' is possibly undefined
// 452904: variable 'v48' is possibly undefined
// 452904: variable 'v49' is possibly undefined
// 452904: variable 'v50' is possibly undefined
// 452904: variable 'v51' is possibly undefined
// 452904: variable 'v52' is possibly undefined
// 452904: variable 'v53' is possibly undefined
// 452904: variable 'v54' is possibly undefined
// 452904: variable 'v55' is possibly undefined
// 452904: variable 'v42' is possibly undefined
// 452904: variable 'v43' is possibly undefined
// 452904: variable 'v44' is possibly undefined
// 452904: variable 'v45' is possibly undefined
// 452904: variable 'v46' is possibly undefined
// 452904: variable 'v47' is possibly undefined
// 45292C: variable 'v56' is possibly undefined
// 452958: variable 'a5' is possibly undefined
// 452958: variable 'a6' is possibly undefined
// 452958: variable 'a7' is possibly undefined
// 452988: variable 'a8' is possibly undefined
// 452988: variable 'a9' is possibly undefined
// 452988: variable 'a10' is possibly undefined
// 452988: variable 'a11' is possibly undefined
// 452988: variable 'a12' is possibly undefined
// 452988: variable 'a13' is possibly undefined
// 452988: variable 'a14' is possibly undefined
// 452988: variable 'a15' is possibly undefined

//----- (000000000045298C) ----------------------------------------------------
__int64 __fastcall _condvar_cleanup_waiting(
        __int64 a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        void *a13,
        void *a14,
        void *a15)
{
  __int64 v16; // x21
  __int64 v17; // x20
  double v18; // d0
  double v19; // d1
  double v20; // d2
  double v21; // d3
  double v22; // d4
  double v23; // d5
  double v24; // d6
  double v25; // d7
  void *v26; // x4
  void *v27; // x5
  void *v28; // x6
  unsigned __int64 v29; // x0
  __int64 v30; // x1
  __int64 v31; // x2
  __int64 v32; // x3
  void *v33; // x4
  void *v34; // x5
  void *v35; // x6
  double v36; // d0
  double v37; // d1
  double v38; // d2
  double v39; // d3
  double v40; // d4
  double v41; // d5
  double v42; // d6
  double v43; // d7

  v16 = *(_QWORD *)(a1 + 8);
  v17 = *(_QWORD *)a1 & 1LL;
  _condvar_cancel_waiting(
    v16,
    *(_QWORD *)a1 >> 1,
    v17,
    *(_DWORD *)(a1 + 24),
    a13,
    a14,
    a15,
    a2,
    a3,
    a4,
    a5,
    a6,
    a7,
    a8,
    a9);
  v29 = linux_eabi_syscall(
          __NR_futex,
          (void *)(v16 + 32 + 4 * (v17 & 1)),
          (void *)(*(_DWORD *)(a1 + 24) ^ 0x81),
          (void *)1,
          0LL,
          v26,
          v27,
          v28);
  if ( v29 > 0xFFFFFFFFFFFFF000LL && (((_DWORD)v29 + 22) & 0xFFFFFFF7) != 0 )
    _libc_fatal(
      (__int64)"The futex facility returned an unexpected error code.\n",
      v18,
      v19,
      v20,
      v21,
      v22,
      v23,
      v24,
      v25);
  _condvar_confirm_wakeup(v16, *(_DWORD *)(a1 + 24));
  return _pthread_mutex_cond_lock(
           *(_DWORD **)(a1 + 16),
           v36,
           v37,
           v38,
           v39,
           v40,
           v41,
           v42,
           v43,
           v30,
           v31,
           v32,
           v33,
           v34,
           v35);
}
// 4529E4: variable 'v26' is possibly undefined
// 4529E4: variable 'v27' is possibly undefined
// 4529E4: variable 'v28' is possibly undefined
// 452A0C: variable 'v36' is possibly undefined
// 452A0C: variable 'v37' is possibly undefined
// 452A0C: variable 'v38' is possibly undefined
// 452A0C: variable 'v39' is possibly undefined
// 452A0C: variable 'v40' is possibly undefined
// 452A0C: variable 'v41' is possibly undefined
// 452A0C: variable 'v42' is possibly undefined
// 452A0C: variable 'v43' is possibly undefined
// 452A0C: variable 'v30' is possibly undefined
// 452A0C: variable 'v31' is possibly undefined
// 452A0C: variable 'v32' is possibly undefined
// 452A0C: variable 'v33' is possibly undefined
// 452A0C: variable 'v34' is possibly undefined
// 452A0C: variable 'v35' is possibly undefined
// 452A24: variable 'v18' is possibly undefined
// 452A24: variable 'v19' is possibly undefined
// 452A24: variable 'v20' is possibly undefined
// 452A24: variable 'v21' is possibly undefined
// 452A24: variable 'v22' is possibly undefined
// 452A24: variable 'v23' is possibly undefined
// 452A24: variable 'v24' is possibly undefined
// 452A24: variable 'v25' is possibly undefined

//----- (0000000000452A28) ----------------------------------------------------
__int64 __fastcall pthread_cond_wait(__int64 a1, int *a2)
{
  unsigned __int64 v4; // x0
  unsigned __int64 v5; // x22
  unsigned int v6; // w26
  unsigned __int64 v7; // x25
  char v8; // w0
  int v9; // w24
  double v10; // d0
  double v11; // d1
  double v12; // d2
  double v13; // d3
  double v14; // d4
  double v15; // d5
  double v16; // d6
  double v17; // d7
  void *v18; // x4
  void *v19; // x5
  void *v20; // x6
  unsigned int v21; // w20
  double v22; // d0
  double v23; // d1
  double v24; // d2
  double v25; // d3
  double v26; // d4
  double v27; // d5
  double v28; // d6
  double v29; // d7
  unsigned int *v30; // x21
  unsigned __int64 *v31; // x27
  unsigned int v32; // w28
  int v33; // w0
  __int64 v34; // x1
  __int64 v35; // x2
  __int64 v36; // x3
  void *v37; // x4
  void *v38; // x5
  void *v39; // x6
  double v40; // d0
  double v41; // d1
  double v42; // d2
  double v43; // d3
  double v44; // d4
  double v45; // d5
  double v46; // d6
  double v47; // d7
  unsigned int v48; // w0
  unsigned int v50; // w28
  void *v51; // x4
  void *v52; // x5
  void *v53; // x6
  double v54; // d0
  double v55; // d1
  double v56; // d2
  double v57; // d3
  double v58; // d4
  double v59; // d5
  double v60; // d6
  double v61; // d7
  _QWORD v63[3]; // [xsp+70h] [xbp+70h] BYREF
  int v64; // [xsp+88h] [xbp+88h]
  _QWORD v65[4]; // [xsp+90h] [xbp+90h] BYREF

  _aarch64_ldadd8_acq();
  v5 = v4;
  v6 = v4 & 1;
  v7 = v4 >> 1;
  _aarch64_ldadd4_relax();
  v9 = (v8 & 1) << 7;
  v21 = _pthread_mutex_unlock_usercnt(a2, 0, v10, v11, v12, v13, v14, v15, v16, v17);
  if ( v21 )
  {
    _condvar_cancel_waiting(a1, v7, v6, v9, v18, v19, v20, v22, v23, v24, v25, v26, v27, v28, v29);
    _condvar_confirm_wakeup(a1, v9);
    return v21;
  }
  else
  {
    v30 = (unsigned int *)(a1 + 32 + 4LL * (v6 & 1));
    v31 = (unsigned __int64 *)(a1 + 8);
    while ( 1 )
    {
      v32 = atomic_load(v30);
      if ( v7 < *v31 )
        break;
      if ( (int)(v32 - *v31) <= 0 )
      {
        v63[0] = v5;
        v63[1] = a1;
        v63[2] = a2;
        v64 = v9;
        pthread_cleanup_push(v65, (__int64)_condvar_cleanup_waiting, (__int64)v63);
        v50 = _futex_abstimed_wait_cancelable64(v30, v32, 0, 0LL, v9);
        pthread_cleanup_pop((__int64)v65, 0);
        if ( v50 == 110 || v50 == 75 )
        {
          v21 = v50;
          _condvar_cancel_waiting(a1, v7, v6, v9, v51, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61);
          break;
        }
      }
      else
      {
        _aarch64_cas4_acq();
        if ( v33 == v32 )
          break;
      }
    }
    _condvar_confirm_wakeup(a1, v9);
    v48 = _pthread_mutex_cond_lock(a2, v40, v41, v42, v43, v44, v45, v46, v47, v34, v35, v36, v37, v38, v39);
    if ( v48 )
      return v48;
    return v21;
  }
}
// 452A58: variable 'v4' is possibly undefined
// 452A70: variable 'v8' is possibly undefined
// 452A78: variable 'v10' is possibly undefined
// 452A78: variable 'v11' is possibly undefined
// 452A78: variable 'v12' is possibly undefined
// 452A78: variable 'v13' is possibly undefined
// 452A78: variable 'v14' is possibly undefined
// 452A78: variable 'v15' is possibly undefined
// 452A78: variable 'v16' is possibly undefined
// 452A78: variable 'v17' is possibly undefined
// 452AC8: variable 'v33' is possibly undefined
// 452ADC: variable 'v40' is possibly undefined
// 452ADC: variable 'v41' is possibly undefined
// 452ADC: variable 'v42' is possibly undefined
// 452ADC: variable 'v43' is possibly undefined
// 452ADC: variable 'v44' is possibly undefined
// 452ADC: variable 'v45' is possibly undefined
// 452ADC: variable 'v46' is possibly undefined
// 452ADC: variable 'v47' is possibly undefined
// 452ADC: variable 'v34' is possibly undefined
// 452ADC: variable 'v35' is possibly undefined
// 452ADC: variable 'v36' is possibly undefined
// 452ADC: variable 'v37' is possibly undefined
// 452ADC: variable 'v38' is possibly undefined
// 452ADC: variable 'v39' is possibly undefined
// 452B7C: variable 'v51' is possibly undefined
// 452B7C: variable 'v52' is possibly undefined
// 452B7C: variable 'v53' is possibly undefined
// 452B7C: variable 'v54' is possibly undefined
// 452B7C: variable 'v55' is possibly undefined
// 452B7C: variable 'v56' is possibly undefined
// 452B7C: variable 'v57' is possibly undefined
// 452B7C: variable 'v58' is possibly undefined
// 452B7C: variable 'v59' is possibly undefined
// 452B7C: variable 'v60' is possibly undefined
// 452B7C: variable 'v61' is possibly undefined
// 452B94: variable 'v18' is possibly undefined
// 452B94: variable 'v19' is possibly undefined
// 452B94: variable 'v20' is possibly undefined
// 452B94: variable 'v22' is possibly undefined
// 452B94: variable 'v23' is possibly undefined
// 452B94: variable 'v24' is possibly undefined
// 452B94: variable 'v25' is possibly undefined
// 452B94: variable 'v26' is possibly undefined
// 452B94: variable 'v27' is possibly undefined
// 452B94: variable 'v28' is possibly undefined
// 452B94: variable 'v29' is possibly undefined

//----- (0000000000452BC0) ----------------------------------------------------
__int64 __fastcall pthread_cond_timedwait(__int64 a1, int *a2, _QWORD *a3)
{
  unsigned __int64 v5; // x26
  unsigned __int64 v6; // x0
  unsigned __int64 v7; // x22
  unsigned int v8; // w27
  unsigned __int64 v9; // x25
  char v10; // w0
  int v11; // w23
  double v12; // d0
  double v13; // d1
  double v14; // d2
  double v15; // d3
  double v16; // d4
  double v17; // d5
  double v18; // d6
  double v19; // d7
  void *v20; // x4
  void *v21; // x5
  void *v22; // x6
  unsigned int v23; // w20
  double v24; // d0
  double v25; // d1
  double v26; // d2
  double v27; // d3
  double v28; // d4
  double v29; // d5
  double v30; // d6
  double v31; // d7
  unsigned __int64 *v32; // x26
  unsigned int *v33; // x28
  unsigned int v34; // w24
  int v35; // w0
  __int64 v36; // x1
  __int64 v37; // x2
  __int64 v38; // x3
  void *v39; // x4
  void *v40; // x5
  void *v41; // x6
  double v42; // d0
  double v43; // d1
  double v44; // d2
  double v45; // d3
  double v46; // d4
  double v47; // d5
  double v48; // d6
  double v49; // d7
  unsigned int v50; // w0
  void *v52; // x5
  void *v53; // x6
  double v54; // d0
  double v55; // d1
  double v56; // d2
  double v57; // d3
  double v58; // d4
  double v59; // d5
  double v60; // d6
  double v61; // d7
  __int64 v64; // [xsp+68h] [xbp+68h]
  unsigned int v65; // [xsp+74h] [xbp+74h]
  _QWORD v66[3]; // [xsp+80h] [xbp+80h] BYREF
  int v67; // [xsp+98h] [xbp+98h]
  _QWORD v68[4]; // [xsp+A0h] [xbp+A0h] BYREF

  if ( a3[1] > 0x3B9AC9FFuLL )
    return 22LL;
  v5 = *(unsigned int *)(a1 + 28);
  _aarch64_ldadd8_acq();
  v7 = v6;
  v8 = v6 & 1;
  v9 = v6 >> 1;
  _aarch64_ldadd4_relax();
  v11 = (v10 & 1) << 7;
  v23 = _pthread_mutex_unlock_usercnt(a2, 0, v12, v13, v14, v15, v16, v17, v18, v19);
  if ( v23 )
  {
    _condvar_cancel_waiting(a1, v9, v8, v11, v20, v21, v22, v24, v25, v26, v27, v28, v29, v30, v31);
    _condvar_confirm_wakeup(a1, v11);
  }
  else
  {
    v64 = (v5 >> 1) & 1;
    v32 = (unsigned __int64 *)(a1 + 8);
    v33 = (unsigned int *)(a1 + 32 + 4LL * (v8 & 1));
    while ( 1 )
    {
      v34 = atomic_load(v33);
      if ( v9 < *v32 )
        break;
      if ( (int)(v34 - *v32) <= 0 )
      {
        v66[0] = v7;
        v66[1] = a1;
        v66[2] = a2;
        v67 = v11;
        pthread_cleanup_push(v68, (__int64)_condvar_cleanup_waiting, (__int64)v66);
        v65 = _futex_abstimed_wait_cancelable64(v33, v34, v64, a3, v11);
        pthread_cleanup_pop((__int64)v68, 0);
        if ( v65 == 110 || v65 == 75 )
        {
          _condvar_cancel_waiting(a1, v9, v8, v11, (void *)v65, v52, v53, v54, v55, v56, v57, v58, v59, v60, v61);
          v23 = v65;
          break;
        }
      }
      else
      {
        _aarch64_cas4_acq();
        if ( v35 == v34 )
          break;
      }
    }
    _condvar_confirm_wakeup(a1, v11);
    v50 = _pthread_mutex_cond_lock(a2, v42, v43, v44, v45, v46, v47, v48, v49, v36, v37, v38, v39, v40, v41);
    if ( v50 )
      return v50;
  }
  return v23;
}
// 452C14: variable 'v6' is possibly undefined
// 452C2C: variable 'v10' is possibly undefined
// 452C34: variable 'v12' is possibly undefined
// 452C34: variable 'v13' is possibly undefined
// 452C34: variable 'v14' is possibly undefined
// 452C34: variable 'v15' is possibly undefined
// 452C34: variable 'v16' is possibly undefined
// 452C34: variable 'v17' is possibly undefined
// 452C34: variable 'v18' is possibly undefined
// 452C34: variable 'v19' is possibly undefined
// 452C88: variable 'v35' is possibly undefined
// 452C9C: variable 'v42' is possibly undefined
// 452C9C: variable 'v43' is possibly undefined
// 452C9C: variable 'v44' is possibly undefined
// 452C9C: variable 'v45' is possibly undefined
// 452C9C: variable 'v46' is possibly undefined
// 452C9C: variable 'v47' is possibly undefined
// 452C9C: variable 'v48' is possibly undefined
// 452C9C: variable 'v49' is possibly undefined
// 452C9C: variable 'v36' is possibly undefined
// 452C9C: variable 'v37' is possibly undefined
// 452C9C: variable 'v38' is possibly undefined
// 452C9C: variable 'v39' is possibly undefined
// 452C9C: variable 'v40' is possibly undefined
// 452C9C: variable 'v41' is possibly undefined
// 452D44: variable 'v52' is possibly undefined
// 452D44: variable 'v53' is possibly undefined
// 452D44: variable 'v54' is possibly undefined
// 452D44: variable 'v55' is possibly undefined
// 452D44: variable 'v56' is possibly undefined
// 452D44: variable 'v57' is possibly undefined
// 452D44: variable 'v58' is possibly undefined
// 452D44: variable 'v59' is possibly undefined
// 452D44: variable 'v60' is possibly undefined
// 452D44: variable 'v61' is possibly undefined
// 452D78: variable 'v20' is possibly undefined
// 452D78: variable 'v21' is possibly undefined
// 452D78: variable 'v22' is possibly undefined
// 452D78: variable 'v24' is possibly undefined
// 452D78: variable 'v25' is possibly undefined
// 452D78: variable 'v26' is possibly undefined
// 452D78: variable 'v27' is possibly undefined
// 452D78: variable 'v28' is possibly undefined
// 452D78: variable 'v29' is possibly undefined
// 452D78: variable 'v30' is possibly undefined
// 452D78: variable 'v31' is possibly undefined

//----- (0000000000452DA0) ----------------------------------------------------
__int64 __fastcall pthread_cond_clockwait(__int64 a1, int *a2, unsigned int a3, _QWORD *a4)
{
  unsigned int v6; // w20
  unsigned __int64 v11; // x0
  char v12; // w23
  unsigned __int64 v13; // x22
  char v14; // w0
  int v15; // w24
  double v16; // d0
  double v17; // d1
  double v18; // d2
  double v19; // d3
  double v20; // d4
  double v21; // d5
  double v22; // d6
  double v23; // d7
  unsigned int v24; // w0
  void *v25; // x4
  void *v26; // x5
  void *v27; // x6
  double v28; // d0
  double v29; // d1
  double v30; // d2
  double v31; // d3
  double v32; // d4
  double v33; // d5
  double v34; // d6
  double v35; // d7
  unsigned int *v36; // x5
  unsigned int v37; // w6
  unsigned __int64 v38; // x0
  int v39; // w0
  __int64 v40; // x1
  __int64 v41; // x2
  __int64 v42; // x3
  void *v43; // x4
  void *v44; // x5
  void *v45; // x6
  double v46; // d0
  double v47; // d1
  double v48; // d2
  double v49; // d3
  double v50; // d4
  double v51; // d5
  double v52; // d6
  double v53; // d7
  unsigned int v54; // w0
  unsigned int v55; // w1
  void *v56; // x6
  double v57; // d0
  double v58; // d1
  double v59; // d2
  double v60; // d3
  double v61; // d4
  double v62; // d5
  double v63; // d6
  double v64; // d7
  unsigned int v66; // [xsp+60h] [xbp+60h]
  unsigned int *v67; // [xsp+60h] [xbp+60h]
  unsigned int v68; // [xsp+60h] [xbp+60h]
  unsigned int *v69; // [xsp+68h] [xbp+68h]
  unsigned int v70; // [xsp+68h] [xbp+68h]
  unsigned int *v71; // [xsp+68h] [xbp+68h]
  unsigned int v72; // [xsp+74h] [xbp+74h]
  _QWORD v73[3]; // [xsp+80h] [xbp+80h] BYREF
  int v74; // [xsp+98h] [xbp+98h]
  _QWORD v75[4]; // [xsp+A0h] [xbp+A0h] BYREF

  v6 = 22;
  if ( a4[1] > 0x3B9AC9FFuLL || a3 > 1 )
    return v6;
  _aarch64_ldadd8_acq();
  v12 = v11 & 1;
  v13 = v11;
  v72 = v11 & 1;
  _aarch64_ldadd4_relax();
  v15 = (v14 & 1) << 7;
  v24 = _pthread_mutex_unlock_usercnt(a2, 0, v16, v17, v18, v19, v20, v21, v22, v23);
  v6 = v24;
  if ( v24 )
  {
    _condvar_cancel_waiting(a1, v13 >> 1, v72, v15, v25, v26, v27, v28, v29, v30, v31, v32, v33, v34, v35);
    _condvar_confirm_wakeup(a1, v15);
    return v6;
  }
  v36 = (unsigned int *)(a1 + 32 + 4LL * (v12 & 1));
  while ( 1 )
  {
    v37 = atomic_load(v36);
    v38 = *(_QWORD *)(a1 + 8);
    if ( v13 >> 1 < v38 )
      break;
    if ( (int)(v37 - v38) <= 0 )
    {
      v67 = v36;
      v70 = v37;
      v73[0] = v13;
      v73[1] = a1;
      v73[2] = a2;
      v74 = v15;
      pthread_cleanup_push(v75, (__int64)_condvar_cleanup_waiting, (__int64)v73);
      v55 = v70;
      v71 = v67;
      v68 = _futex_abstimed_wait_cancelable64(v67, v55, a3, a4, v15);
      pthread_cleanup_pop((__int64)v75, 0);
      v36 = v71;
      if ( v68 == 110 || v68 == 75 )
      {
        _condvar_cancel_waiting(a1, v13 >> 1, v72, v15, (void *)v68, v71, v56, v57, v58, v59, v60, v61, v62, v63, v64);
        v6 = v68;
        break;
      }
    }
    else
    {
      v66 = v37;
      v69 = v36;
      _aarch64_cas4_acq();
      v36 = v69;
      if ( v39 == v66 )
        break;
    }
  }
  _condvar_confirm_wakeup(a1, v15);
  v54 = _pthread_mutex_cond_lock(a2, v46, v47, v48, v49, v50, v51, v52, v53, v40, v41, v42, v43, v44, v45);
  if ( v54 )
    return v54;
  return v6;
}
// 452E04: variable 'v11' is possibly undefined
// 452E1C: variable 'v14' is possibly undefined
// 452E28: variable 'v16' is possibly undefined
// 452E28: variable 'v17' is possibly undefined
// 452E28: variable 'v18' is possibly undefined
// 452E28: variable 'v19' is possibly undefined
// 452E28: variable 'v20' is possibly undefined
// 452E28: variable 'v21' is possibly undefined
// 452E28: variable 'v22' is possibly undefined
// 452E28: variable 'v23' is possibly undefined
// 452E88: variable 'v39' is possibly undefined
// 452E9C: variable 'v46' is possibly undefined
// 452E9C: variable 'v47' is possibly undefined
// 452E9C: variable 'v48' is possibly undefined
// 452E9C: variable 'v49' is possibly undefined
// 452E9C: variable 'v50' is possibly undefined
// 452E9C: variable 'v51' is possibly undefined
// 452E9C: variable 'v52' is possibly undefined
// 452E9C: variable 'v53' is possibly undefined
// 452E9C: variable 'v40' is possibly undefined
// 452E9C: variable 'v41' is possibly undefined
// 452E9C: variable 'v42' is possibly undefined
// 452E9C: variable 'v43' is possibly undefined
// 452E9C: variable 'v44' is possibly undefined
// 452E9C: variable 'v45' is possibly undefined
// 452F54: variable 'v56' is possibly undefined
// 452F54: variable 'v57' is possibly undefined
// 452F54: variable 'v58' is possibly undefined
// 452F54: variable 'v59' is possibly undefined
// 452F54: variable 'v60' is possibly undefined
// 452F54: variable 'v61' is possibly undefined
// 452F54: variable 'v62' is possibly undefined
// 452F54: variable 'v63' is possibly undefined
// 452F54: variable 'v64' is possibly undefined
// 452F70: variable 'v25' is possibly undefined
// 452F70: variable 'v26' is possibly undefined
// 452F70: variable 'v27' is possibly undefined
// 452F70: variable 'v28' is possibly undefined
// 452F70: variable 'v29' is possibly undefined
// 452F70: variable 'v30' is possibly undefined
// 452F70: variable 'v31' is possibly undefined
// 452F70: variable 'v32' is possibly undefined
// 452F70: variable 'v33' is possibly undefined
// 452F70: variable 'v34' is possibly undefined
// 452F70: variable 'v35' is possibly undefined

//----- (0000000000452FA0) ----------------------------------------------------
__int64 __fastcall _pthread_mutex_cond_lock_full(
        _DWORD *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        void *a13,
        void *a14,
        void *a15)
{
  unsigned __int64 StatusReg; // x20
  unsigned __int64 v16; // x19
  _DWORD *v18; // x24
  int v19; // w27
  int v20; // w1
  unsigned int v21; // w0
  _DWORD *v22; // x23
  unsigned int v23; // w22
  unsigned int v24; // w0
  __int64 v25; // x0
  __int64 result; // x0
  unsigned int v27; // w19
  int v28; // w20
  int v29; // w26
  __int64 v30; // x2
  void *v31; // x3
  __int64 v32; // x4
  void *v33; // x5
  __int64 v34; // x6
  __int64 v35; // x7
  double v36; // d0
  double v37; // d1
  double v38; // d2
  double v39; // d3
  double v40; // d4
  double v41; // d5
  double v42; // d6
  double v43; // d7
  unsigned int v44; // w20
  unsigned int v45; // w22
  int v46; // w0
  int v47; // w0
  unsigned int v48; // w0
  void *v49; // x4
  void *v50; // x5
  void *v51; // x6
  unsigned __int64 v52; // x0
  int v53; // w23
  unsigned __int64 v54; // x22
  void *v55; // x4
  void *v56; // x5
  void *v57; // x6
  int v58; // w0
  int v59; // w0
  __int64 v60; // x0
  int v61; // w0
  __int64 v62; // x4
  void *v63; // x5
  void *v64; // x6
  double v65; // d0
  double v66; // d1
  double v67; // d2
  double v68; // d3
  double v69; // d4
  double v70; // d5
  double v71; // d6
  double v72; // d7
  int v73; // w0
  int v74; // w19
  int v75; // w0
  int v76; // w0
  int v77; // w0
  __int64 v78; // x0
  unsigned int v79; // w0
  unsigned __int64 v80; // x0
  __int64 v81; // x0
  int v82; // w0
  __int64 v83; // x2
  __int64 v84; // x3
  void *v85; // x4
  void *v86; // x5
  void *v87; // x6
  int v88; // w0
  unsigned __int64 v89; // x0
  int v90; // [xsp+6Ch] [xbp+6Ch] BYREF

  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2));
  v16 = StatusReg - 1824;
  v18 = a1 + 4;
  v19 = *(_DWORD *)(StatusReg - 1824 + 0xD0);
  v20 = a1[4];
  v21 = v20 & 0x7F;
  if ( v21 > 0x33 )
  {
    if ( v21 - 64 > 3 )
      return 22LL;
    v27 = *a1;
    v28 = -1;
    if ( a1[2] != v19 )
      goto LABEL_95;
    v76 = *v18 & 3;
    if ( v76 == 2 )
      return 35LL;
    if ( v76 != 1 )
    {
LABEL_95:
      while ( 1 )
      {
        v29 = v27 >> 19;
        if ( (int)(v27 >> 19) < (int)_pthread_current_priority() )
          break;
        result = _pthread_tpp_change_priority(
                   v28,
                   v29,
                   v36,
                   v37,
                   v38,
                   v39,
                   v40,
                   v41,
                   v42,
                   v43,
                   v30,
                   v31,
                   v32,
                   v33,
                   v34,
                   v35);
        if ( (_DWORD)result )
          return result;
        v44 = v27 & 0xFFF80000;
        v45 = v27 & 0xFFF80000 | 2;
        _aarch64_cas4_acq();
        if ( (v27 & 0xFFF80000) == v46 )
        {
LABEL_24:
          if ( a1[2] )
            _libc_assert_fail(
              (__int64)"mutex->__data.__owner == 0",
              (__int64)"../nptl/pthread_mutex_lock.c",
              0x25Fu,
              (__int64)"__pthread_mutex_cond_lock_full");
LABEL_25:
          a1[1] = 1;
          a1[2] = v19;
          return 0LL;
        }
        while ( 1 )
        {
          _aarch64_cas4_acq();
          v27 = v48;
          if ( (v48 & 0xFFF80000) != v44 )
            break;
          if ( v44 != v48 )
          {
            v52 = linux_eabi_syscall(
                    __NR_futex,
                    a1,
                    (void *)((unsigned __int8)~(unsigned __int8)*v18 & 0x80),
                    (void *)v45,
                    0LL,
                    v49,
                    v50,
                    v51);
            if ( v52 > 0xFFFFFFFFFFFFF000LL && (_DWORD)v52 != -11 && (_DWORD)v52 != -4 )
              goto LABEL_23;
          }
          _aarch64_cas4_acq();
          if ( v44 == v47 )
            goto LABEL_24;
        }
        v28 = v29;
      }
      if ( v28 != -1 )
      {
        _pthread_tpp_change_priority(v28, -1, v36, v37, v38, v39, v40, v41, v42, v43, v30, v31, v32, v33, v34, v35);
        return 22LL;
      }
      return 22LL;
    }
    v77 = a1[1];
    if ( v77 != -1 )
    {
      a1[1] = v77 + 1;
      return 0LL;
    }
    return 11LL;
  }
  if ( v21 > 0x2F )
  {
LABEL_28:
    v53 = *v18 & 3;
    if ( (*v18 & 0x10) != 0 )
    {
      v54 = (unsigned __int64)(a1 + 8);
      *(_QWORD *)(v16 + 0xF0) = (unsigned __int64)(a1 + 8) | 1;
      if ( v19 != (*a1 & 0x3FFFFFFF) )
      {
LABEL_30:
        _aarch64_cas4_acq();
        if ( !v58 )
        {
LABEL_46:
          if ( a1[2] == 2147483646 )
          {
            a1[1] = 0;
            v89 = linux_eabi_syscall(__NR_futex, a1, (void *)7, 0LL, 0LL, v55, v56, v57);
            if ( v89 <= 0xFFFFFFFFFFFFF000LL
              || (_DWORD)v89 == -110
              || (unsigned int)v89 > 0xFFFFFFD9 && ((0x2C08000009uLL >> ((unsigned __int8)v89 + 38)) & 1) != 0 )
            {
              goto LABEL_75;
            }
LABEL_23:
            _libc_fatal(
              (__int64)"The futex facility returned an unexpected error code.\n",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              a9);
          }
          a1[1] = 1;
          *(_QWORD *)((*(_QWORD *)(v16 + 0xE0) & 0xFFFFFFFFFFFFFFFELL) - 8) = v54;
          v78 = *(_QWORD *)(v16 + 0xE0);
          *((_QWORD *)a1 + 3) = StatusReg - 1600;
          *((_QWORD *)a1 + 4) = v78;
          *(_QWORD *)(v16 + 0xE0) = v54 | 1;
          *(_QWORD *)(v16 + 0xF0) = 0LL;
          a1[2] = v19;
          return 0LL;
        }
        v59 = _futex_lock_pi64(a1, 0, 0LL, 128, a2, a3, a4, a5, a6, a7, a8, a9, (__int64)v55, v56, v57);
        if ( (v59 & 0xFFFFFFDF) != 3 )
        {
          if ( (*a1 & 0x40000000) != 0 )
          {
            _aarch64_ldclr4_acq();
            *(_QWORD *)(a1 + 1) = 0x7FFFFFFF00000001LL;
            *(_QWORD *)((*(_QWORD *)(v16 + 0xE0) & 0xFFFFFFFFFFFFFFFELL) - 8) = v54;
            v60 = *(_QWORD *)(v16 + 0xE0);
            *((_QWORD *)a1 + 3) = StatusReg - 1600;
            *((_QWORD *)a1 + 4) = v60;
            *(_QWORD *)(v16 + 0xE0) = v54 | 1;
            *(_QWORD *)(v16 + 0xF0) = 0LL;
            v61 = a1[3] - 1;
LABEL_34:
            a1[3] = v61;
            return 130LL;
          }
          goto LABEL_46;
        }
        if ( v59 != 35 )
          _libc_assert_fail(
            (__int64)"e != ESRCH || !robust",
            (__int64)"../nptl/pthread_mutex_lock.c",
            0x1C2u,
            (__int64)"__pthread_mutex_cond_lock_full");
        v74 = 128;
        goto LABEL_60;
      }
      if ( v53 != 2 )
      {
        if ( v53 != 1 )
          goto LABEL_30;
        goto LABEL_68;
      }
LABEL_89:
      result = 35LL;
      *(_QWORD *)(v16 + 0xF0) = 0LL;
      return result;
    }
    if ( v19 == (*a1 & 0x3FFFFFFF) )
    {
      if ( v53 == 2 )
        goto LABEL_89;
      if ( v53 == 1 )
      {
LABEL_68:
        *(_QWORD *)(v16 + 0xF0) = 0LL;
        v82 = a1[1];
        if ( v82 != -1 )
        {
          a1[1] = v82 + 1;
          return 0LL;
        }
        return 11LL;
      }
    }
    _aarch64_cas4_acq();
    if ( !v73 )
      goto LABEL_25;
    v74 = *v18 & 0x80;
    v75 = _futex_lock_pi64(a1, 0, 0LL, v74, v65, v66, v67, v68, v69, v70, v71, v72, v62, v63, v64);
    if ( (v75 & 0xFFFFFFDF) != 3 )
    {
      if ( (*a1 & 0x40000000) != 0 )
        _libc_assert_fail(
          (__int64)"robust || (oldval & FUTEX_OWNER_DIED) == 0",
          (__int64)"../nptl/pthread_mutex_lock.c",
          0x1CCu,
          (__int64)"__pthread_mutex_cond_lock_full");
      goto LABEL_25;
    }
    if ( v75 != 35 )
    {
      while ( 1 )
      {
LABEL_61:
        v90 = 0;
        _futex_abstimed_wait64(&v90, 0, 0, 0LL, v74, a2, a3, a4, a5, a6, a7, a8, a9, (__int64)v56, v57);
      }
    }
LABEL_60:
    if ( (unsigned int)(v53 - 1) <= 1 )
      _libc_assert_fail(
        (__int64)"e != EDEADLK || (kind != PTHREAD_MUTEX_ERRORCHECK_NP && kind != PTHREAD_MUTEX_RECURSIVE_NP)",
        (__int64)"../nptl/pthread_mutex_lock.c",
        0x1BDu,
        (__int64)"__pthread_mutex_cond_lock_full");
    goto LABEL_61;
  }
  if ( v21 > 0x13 )
  {
    if ( v21 - 32 > 3 )
      return 22LL;
    goto LABEL_28;
  }
  if ( (v20 & 0x70) == 0 )
    return 22LL;
  v22 = a1 + 8;
  *(_QWORD *)(v16 + 0xF0) = a1 + 8;
  v23 = *a1;
  while ( 1 )
  {
    if ( !v23 )
    {
      _aarch64_cas4_acq();
      v23 = v24;
      if ( !v24 )
        break;
    }
    if ( (v23 & 0x40000000) != 0 )
    {
      _aarch64_cas4_acq();
      if ( v23 == v79 )
      {
        *(_QWORD *)(a1 + 1) = 0x7FFFFFFF00000001LL;
        *(_QWORD *)((*(_QWORD *)(v16 + 0xE0) & 0xFFFFFFFFFFFFFFFELL) - 8) = v22;
        v81 = *(_QWORD *)(v16 + 0xE0);
        *((_QWORD *)a1 + 3) = StatusReg - 1600;
        *((_QWORD *)a1 + 4) = v81;
        *(_QWORD *)(v16 + 0xE0) = v22;
        *(_QWORD *)(v16 + 0xF0) = 0LL;
        v61 = a1[3] - 1;
        goto LABEL_34;
      }
LABEL_50:
      v23 = v79;
    }
    else
    {
      if ( (v23 & 0x3FFFFFFF) == v19 )
      {
        if ( (*v18 & 0x7F) == 0x12 )
          goto LABEL_89;
        if ( (*v18 & 0x7F) == 0x11 )
          goto LABEL_68;
      }
      if ( (v23 & 0x80000000) == 0 )
      {
        _aarch64_cas4_acq();
        if ( v23 != v79 )
          goto LABEL_50;
        v23 |= 0x80000000;
      }
      v80 = linux_eabi_syscall(__NR_futex, a1, 0LL, (void *)v23, 0LL, a13, a14, a15);
      if ( v80 > 0xFFFFFFFFFFFFF000LL && (_DWORD)v80 != -11 && (_DWORD)v80 != -4 )
        goto LABEL_23;
      v23 = *a1;
    }
  }
  if ( a1[2] != 2147483646 )
  {
    a1[1] = 1;
    *(_QWORD *)((*(_QWORD *)(v16 + 0xE0) & 0xFFFFFFFFFFFFFFFELL) - 8) = v22;
    v25 = *(_QWORD *)(v16 + 0xE0);
    *((_QWORD *)a1 + 3) = StatusReg - 1600;
    *((_QWORD *)a1 + 4) = v25;
    *(_QWORD *)(v16 + 0xE0) = v22;
    *(_QWORD *)(v16 + 0xF0) = 0LL;
    a1[2] = v19;
    return 0LL;
  }
  a1[1] = 0;
  _aarch64_swp4_rel();
  if ( v88 > 1 )
    _lll_lock_wake(a1, 128, v83, v84, v85, v86, v87);
LABEL_75:
  result = 131LL;
  *(_QWORD *)(v16 + 0xF0) = 0LL;
  return result;
}
// 453014: variable 'v24' is possibly undefined
// 4530B8: variable 'v36' is possibly undefined
// 4530B8: variable 'v37' is possibly undefined
// 4530B8: variable 'v38' is possibly undefined
// 4530B8: variable 'v39' is possibly undefined
// 4530B8: variable 'v40' is possibly undefined
// 4530B8: variable 'v41' is possibly undefined
// 4530B8: variable 'v42' is possibly undefined
// 4530B8: variable 'v43' is possibly undefined
// 4530B8: variable 'v30' is possibly undefined
// 4530B8: variable 'v31' is possibly undefined
// 4530B8: variable 'v32' is possibly undefined
// 4530B8: variable 'v33' is possibly undefined
// 4530B8: variable 'v34' is possibly undefined
// 4530B8: variable 'v35' is possibly undefined
// 4530DC: variable 'v46' is possibly undefined
// 453100: variable 'v47' is possibly undefined
// 453114: variable 'v48' is possibly undefined
// 453148: variable 'v49' is possibly undefined
// 453148: variable 'v50' is possibly undefined
// 453148: variable 'v51' is possibly undefined
// 45316C: variable 'a2' is possibly undefined
// 45316C: variable 'a3' is possibly undefined
// 45316C: variable 'a4' is possibly undefined
// 45316C: variable 'a5' is possibly undefined
// 45316C: variable 'a6' is possibly undefined
// 45316C: variable 'a7' is possibly undefined
// 45316C: variable 'a8' is possibly undefined
// 45316C: variable 'a9' is possibly undefined
// 4531D8: variable 'v58' is possibly undefined
// 4531EC: variable 'v55' is possibly undefined
// 4531EC: variable 'v56' is possibly undefined
// 4531EC: variable 'v57' is possibly undefined
// 453274: variable 'v73' is possibly undefined
// 453290: variable 'v65' is possibly undefined
// 453290: variable 'v66' is possibly undefined
// 453290: variable 'v67' is possibly undefined
// 453290: variable 'v68' is possibly undefined
// 453290: variable 'v69' is possibly undefined
// 453290: variable 'v70' is possibly undefined
// 453290: variable 'v71' is possibly undefined
// 453290: variable 'v72' is possibly undefined
// 453290: variable 'v62' is possibly undefined
// 453290: variable 'v63' is possibly undefined
// 453290: variable 'v64' is possibly undefined
// 45336C: variable 'v79' is possibly undefined
// 4533C0: variable 'a13' is possibly undefined
// 4533C0: variable 'a14' is possibly undefined
// 4533C0: variable 'a15' is possibly undefined
// 4534C4: variable 'v88' is possibly undefined
// 453564: variable 'v83' is possibly undefined
// 453564: variable 'v84' is possibly undefined
// 453564: variable 'v85' is possibly undefined
// 453564: variable 'v86' is possibly undefined
// 453564: variable 'v87' is possibly undefined
// 4535EC: using guessed type __int64 _pthread_mutex_cond_lock(void);

//----- (00000000004535EC) ----------------------------------------------------
__int64 __fastcall _pthread_mutex_cond_lock(
        _DWORD *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        void *a13,
        void *a14,
        void *a15)
{
  _DWORD *v15; // x20
  __int64 v16; // x1
  __int64 v18; // x2
  __int64 v19; // x3
  void *v20; // x4
  void *v21; // x5
  void *v22; // x6
  double v23; // d0
  double v24; // d1
  double v25; // d2
  double v26; // d3
  double v27; // d4
  double v28; // d5
  double v29; // d6
  double v30; // d7
  int v31; // w0
  unsigned __int64 v32; // x2
  unsigned __int64 v34; // x2
  int v35; // w0
  __int64 v36; // x3
  void *v37; // x4
  void *v38; // x5
  void *v39; // x6
  double v40; // d0
  double v41; // d1
  double v42; // d2
  double v43; // d3
  double v44; // d4
  double v45; // d5
  double v46; // d6
  double v47; // d7
  int v48; // w0
  int v49; // w0
  unsigned int v50; // w2
  int v51; // w1
  int v52; // w0
  int v53; // w21
  int v54; // w3
  int v55; // w0
  __int64 v56; // x2
  __int64 v57; // x3
  void *v58; // x4
  void *v59; // x5
  void *v60; // x6
  double v61; // d0
  double v62; // d1
  double v63; // d2
  double v64; // d3
  double v65; // d4
  double v66; // d5
  double v67; // d6
  double v68; // d7
  int v69; // w0
  __int64 v70; // [xsp+38h] [xbp+38h]
  int v71; // [xsp+38h] [xbp+38h]

  v15 = a1 + 4;
  v16 = (unsigned int)a1[4];
  if ( (v16 & 0x7C) != 0 )
    return _pthread_mutex_cond_lock_full(a1, a2, a3, a4, a5, a6, a7, a8, a9, v16, a11, a12, a13, a14, a15);
  if ( (v16 & 0x17F) == 0 )
    goto LABEL_3;
  if ( (*v15 & 0x7F) == 1 )
  {
    v34 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
    if ( a1[2] != *(_DWORD *)(v34 + 0xD0) )
    {
      v70 = v34;
      _aarch64_swp4_acq();
      v32 = v70;
      if ( v48 )
      {
        _lll_lock_wait(a1, *v15 & 0x80, v40, v41, v42, v43, v44, v45, v46, v47, v70, v36, v37, v38, v39);
        v32 = v70;
      }
      if ( !a1[2] )
      {
        a1[1] = 1;
        goto LABEL_7;
      }
      v50 = 130;
      goto LABEL_22;
    }
    v35 = a1[1];
    if ( v35 != -1 )
    {
      a1[1] = v35 + 1;
      return 0LL;
    }
    return 11LL;
  }
  else
  {
    if ( (*v15 & 0x7F) == 3 )
    {
      _aarch64_cas4_acq();
      if ( v49 )
      {
        v52 = 2 * (a1[5] + 5);
        if ( v52 > (__int16)_mutex_aconf )
          v52 = (__int16)_mutex_aconf;
        v53 = v52;
        if ( v52 <= 1 )
        {
          v53 = 1;
LABEL_35:
          _aarch64_swp4_acq();
          if ( v69 )
            _lll_lock_wait(a1, *v15 & 0x80, v61, v62, v63, v64, v65, v66, v67, v68, v56, v57, v58, v59, v60);
          v54 = v53;
        }
        else
        {
          v54 = 1;
          while ( 1 )
          {
            if ( !*a1 )
            {
              v71 = v54;
              _aarch64_cas4_acq();
              v54 = v71;
              if ( !v55 )
                break;
            }
            if ( ++v54 == v53 )
              goto LABEL_35;
          }
        }
        a1[5] += (v54 - a1[5]) / 8;
      }
      if ( !a1[2] )
        goto LABEL_6;
      v50 = 167;
      goto LABEL_22;
    }
    v51 = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824 + 0xD0);
    if ( (*v15 & 0x7F) != 2 )
      _libc_assert_fail(
        (__int64)"PTHREAD_MUTEX_TYPE (mutex) == PTHREAD_MUTEX_ERRORCHECK_NP",
        (__int64)"../nptl/pthread_mutex_lock.c",
        0xACu,
        (__int64)"__pthread_mutex_cond_lock");
    if ( a1[2] != v51 )
    {
LABEL_3:
      _aarch64_swp4_acq();
      if ( v31 )
        _lll_lock_wait(a1, *v15 & 0x80, v23, v24, v25, v26, v27, v28, v29, v30, v18, v19, v20, v21, v22);
      if ( !a1[2] )
      {
LABEL_6:
        v32 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824;
LABEL_7:
        a1[2] = *(_DWORD *)(v32 + 208);
        return 0LL;
      }
      v50 = 94;
LABEL_22:
      _libc_assert_fail(
        (__int64)"mutex->__data.__owner == 0",
        (__int64)"../nptl/pthread_mutex_lock.c",
        v50,
        (__int64)"__pthread_mutex_cond_lock");
    }
    return 35LL;
  }
}
// 4535EC: could not find valid save-restore pair for x21
// 453624: variable 'v31' is possibly undefined
// 4536A8: variable 'v23' is possibly undefined
// 4536A8: variable 'v24' is possibly undefined
// 4536A8: variable 'v25' is possibly undefined
// 4536A8: variable 'v26' is possibly undefined
// 4536A8: variable 'v27' is possibly undefined
// 4536A8: variable 'v28' is possibly undefined
// 4536A8: variable 'v29' is possibly undefined
// 4536A8: variable 'v30' is possibly undefined
// 4536A8: variable 'v18' is possibly undefined
// 4536A8: variable 'v19' is possibly undefined
// 4536A8: variable 'v20' is possibly undefined
// 4536A8: variable 'v21' is possibly undefined
// 4536A8: variable 'v22' is possibly undefined
// 4536C4: variable 'v48' is possibly undefined
// 453740: variable 'v40' is possibly undefined
// 453740: variable 'v41' is possibly undefined
// 453740: variable 'v42' is possibly undefined
// 453740: variable 'v43' is possibly undefined
// 453740: variable 'v44' is possibly undefined
// 453740: variable 'v45' is possibly undefined
// 453740: variable 'v46' is possibly undefined
// 453740: variable 'v47' is possibly undefined
// 453740: variable 'v36' is possibly undefined
// 453740: variable 'v37' is possibly undefined
// 453740: variable 'v38' is possibly undefined
// 453740: variable 'v39' is possibly undefined
// 4536FC: variable 'v49' is possibly undefined
// 4537C8: variable 'v55' is possibly undefined
// 453804: variable 'v69' is possibly undefined
// 453830: variable 'v61' is possibly undefined
// 453830: variable 'v62' is possibly undefined
// 453830: variable 'v63' is possibly undefined
// 453830: variable 'v64' is possibly undefined
// 453830: variable 'v65' is possibly undefined
// 453830: variable 'v66' is possibly undefined
// 453830: variable 'v67' is possibly undefined
// 453830: variable 'v68' is possibly undefined
// 453830: variable 'v56' is possibly undefined
// 453830: variable 'v57' is possibly undefined
// 453830: variable 'v58' is possibly undefined
// 453830: variable 'v59' is possibly undefined
// 453830: variable 'v60' is possibly undefined
// 453880: using guessed type __int64 _pthread_mutex_cond_lock_adjust(void);
// 491918: using guessed type int _mutex_aconf;

//----- (0000000000453880) ----------------------------------------------------
_DWORD *__fastcall _pthread_mutex_cond_lock_adjust(_DWORD *result)
{
  int v1; // w1

  v1 = result[4];
  if ( (v1 & 0x20) == 0 )
    _libc_assert_fail(
      (__int64)"(mutex_kind & PTHREAD_MUTEX_PRIO_INHERIT_NP) != 0",
      (__int64)"../nptl/pthread_mutex_lock.c",
      0x28Au,
      (__int64)"__pthread_mutex_cond_lock_adjust");
  if ( (v1 & 0x10) != 0 )
    _libc_assert_fail(
      (__int64)"(mutex_kind & PTHREAD_MUTEX_ROBUST_NORMAL_NP) == 0",
      (__int64)"../nptl/pthread_mutex_lock.c",
      0x28Bu,
      (__int64)"__pthread_mutex_cond_lock_adjust");
  if ( (v1 & 0x80) != 0 )
    _libc_assert_fail(
      (__int64)"(mutex_kind & PTHREAD_MUTEX_PSHARED_BIT) == 0",
      (__int64)"../nptl/pthread_mutex_lock.c",
      0x28Cu,
      (__int64)"__pthread_mutex_cond_lock_adjust");
  result[2] = *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) - 1824 + 0xD0);
  if ( v1 == 33 )
    ++result[1];
  return result;
}

//----- (0000000000453940) ----------------------------------------------------
__int64 __fastcall _getauxval2(__int64 a1, __int64 *a2)
{
  __int64 v2; // x3
  __int64 v3; // x2
  __int64 v4; // t1
  __int64 v5; // x0

  if ( a1 == 16 )
  {
    v5 = dl_hwcap;
LABEL_8:
    *a2 = v5;
    return 1LL;
  }
  if ( a1 == 26 )
  {
    v5 = dl_hwcap2;
    goto LABEL_8;
  }
  v2 = dl_auxv;
  v3 = *(_QWORD *)dl_auxv;
  if ( *(_QWORD *)dl_auxv )
  {
    while ( a1 != v3 )
    {
      v4 = *(_QWORD *)(v2 + 16);
      v2 += 16LL;
      v3 = v4;
      if ( !v4 )
        return 0LL;
    }
    v5 = *(_QWORD *)(v2 + 8);
    goto LABEL_8;
  }
  return 0LL;
}
// 496BD0: using guessed type __int64 dl_auxv;
// 496BE0: using guessed type __int64 dl_hwcap;
// 496BE8: using guessed type __int64 dl_hwcap2;

//----- (00000000004539B0) ----------------------------------------------------
__int64 __fastcall getauxval(__int64 a1)
{
  __int64 v1; // x2
  __int64 v2; // x1
  __int64 v3; // t1

  if ( a1 == 16 )
    return dl_hwcap;
  if ( a1 == 26 )
    return dl_hwcap2;
  v1 = dl_auxv;
  v2 = *(_QWORD *)dl_auxv;
  if ( *(_QWORD *)dl_auxv )
  {
    while ( a1 != v2 )
    {
      v3 = *(_QWORD *)(v1 + 16);
      v1 += 16LL;
      v2 = v3;
      if ( !v3 )
        goto LABEL_8;
    }
    return *(_QWORD *)(v1 + 8);
  }
  else
  {
LABEL_8:
    *(_DWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40) = 2;
    return 0LL;
  }
}
// 496BD0: using guessed type __int64 dl_auxv;
// 496BE0: using guessed type __int64 dl_hwcap;
// 496BE8: using guessed type __int64 dl_hwcap2;

//----- (0000000000453A40) ----------------------------------------------------
__int64 __fastcall pthread_cond_signal(
        __int64 *a1,
        double a2,
        double a3,
        double a4,
        double a5,
        double a6,
        double a7,
        double a8,
        double a9,
        __int64 a10,
        __int64 a11,
        __int64 a12,
        void *a13,
        void *a14,
        void *a15)
{
  int *v16; // x21
  int v17; // w23
  int v18; // w19
  int v19; // w0
  int v20; // w0
  bool v21; // zf
  unsigned __int64 v22; // x2
  unsigned __int8 v23; // w24
  __int64 v24; // x19
  __int64 v25; // x22
  __int64 v26; // x4
  void *v27; // x5
  void *v28; // x6
  char v29; // w0
  void *v30; // x1
  unsigned __int64 v31; // x0
  __int64 v33; // x0
  __int64 v34; // x4
  char v35; // w0
  unsigned __int64 v36; // x0
  unsigned int v37; // w4
  unsigned __int64 v38; // x0
  int v39; // w19
  unsigned __int8 v40; // w0
  int v41; // w19
  int v42; // w0
  unsigned __int64 v43; // x0
  unsigned int v44; // [xsp+48h] [xbp+48h]
  int v45; // [xsp+48h] [xbp+48h]
  __int64 v46; // [xsp+50h] [xbp+50h]
  char v47; // [xsp+58h] [xbp+58h]

  if ( !(*((_DWORD *)a1 + 7) >> 3) )
    return 0LL;
  v16 = (int *)(a1 + 3);
  v17 = (*((_DWORD *)a1 + 7) & 1) << 7;
  v18 = *((_DWORD *)a1 + 6);
  do
  {
    v19 = v18 & 3;
    if ( (v18 & 3) != 0 )
    {
      while ( 1 )
      {
        if ( v19 != 2 )
        {
          _aarch64_cas4_acq();
          v21 = v42 == v18;
          v18 = v42;
          if ( !v21 )
            goto LABEL_34;
          if ( (v42 & 3) == 0 )
            goto LABEL_6;
        }
        v43 = linux_eabi_syscall(
                __NR_futex,
                v16,
                (void *)(v17 ^ 0x80),
                (void *)(v18 & 0xFFFFFFFC | 2LL),
                0LL,
                a13,
                a14,
                a15);
        if ( v43 <= 0xFFFFFFFFFFFFF000LL || (_DWORD)v43 == -11 )
        {
          v18 = *v16;
        }
        else
        {
          if ( (_DWORD)v43 != -4 )
            goto LABEL_24;
          v18 = *v16;
        }
LABEL_34:
        v19 = v18 & 3;
      }
    }
    _aarch64_cas4_acq();
    v21 = v20 == v18;
    v18 = v20;
  }
  while ( !v21 );
LABEL_6:
  v22 = *a1;
  v23 = (*a1 & 1) == 0;
  v24 = v23;
  if ( *((_DWORD *)a1 + v23 + 4) )
  {
    v25 = 4LL * v23;
  }
  else
  {
    v25 = 4 * (*a1 & 1);
    v33 = (unsigned int)*v16 >> 2;
    v34 = a1[1] + v33;
    if ( (_DWORD)v34 == *(_DWORD *)((char *)a1 + v25 + 16) + (unsigned int)(v22 >> 1) )
      goto LABEL_13;
    a1[1] += v33;
    v44 = v34;
    v46 = (__int64)a1 + v25;
    v47 = v22;
    _aarch64_ldeor8_rel();
    v37 = v44;
    atomic_store(v44, (unsigned int *)((char *)a1 + v25 + 32));
    v39 = (v38 >> 1) - v37;
    v45 = *v16 & 3 | (4 * v39);
    _aarch64_swp4_relax();
    if ( (((unsigned __int8)v45 ^ v40) & 3) != 0 )
      *v16 = (4 * v39) | 2;
    v23 = v47 & 1;
    v41 = v39 + *(_DWORD *)(v46 + 16);
    *(_DWORD *)(v46 + 16) = v41;
    if ( !v41 )
    {
LABEL_13:
      _aarch64_ldclr4_rel();
      if ( (v35 & 3) != 2 )
        return 0LL;
      v26 = 0LL;
      goto LABEL_15;
    }
    v24 = v47 & 1;
  }
  _aarch64_ldadd4_relax();
  --*((_DWORD *)a1 + v24 + 4);
  _aarch64_ldclr4_rel();
  if ( (v29 & 3) != 2 )
  {
    v30 = (void *)(v17 ^ 0x81);
LABEL_10:
    v31 = linux_eabi_syscall(__NR_futex, (char *)a1 + v25 + 32, v30, (void *)1, 0LL, (void *)v26, v27, v28);
    if ( v31 > 0xFFFFFFFFFFFFF000LL && (((_DWORD)v31 + 22) & 0xFFFFFFF7) != 0 )
LABEL_24:
      _libc_fatal((__int64)"The futex facility returned an unexpected error code.\n", a2, a3, a4, a5, a6, a7, a8, a9);
    return 0LL;
  }
  v26 = 1LL;
LABEL_15:
  v30 = (void *)(v17 ^ 0x81);
  v36 = linux_eabi_syscall(__NR_futex, v16, v30, (void *)1, 0LL, (void *)v26, v27, v28);
  if ( v36 <= 0xFFFFFFFFFFFFF000LL )
  {
    if ( !(_DWORD)v26 )
      return 0LL;
    goto LABEL_17;
  }
  if ( (((_DWORD)v36 + 22) & 0xFFFFFFF7) != 0 )
    goto LABEL_24;
  if ( (_DWORD)v26 )
  {
LABEL_17:
    v25 = 4LL * (v23 & 1);
    goto LABEL_10;
  }
  return 0LL;
}
// 453A8C: variable 'v20' is possibly undefined
// 453AE4: variable 'v29' is possibly undefined
// 453B10: variable 'v26' is possibly undefined
// 453B10: variable 'v27' is possibly undefined
// 453B10: variable 'v28' is possibly undefined
// 453B70: variable 'v35' is possibly undefined
// 453BE0: variable 'v38' is possibly undefined
// 453C0C: variable 'v40' is possibly undefined
// 453C60: variable 'a2' is possibly undefined
// 453C60: variable 'a3' is possibly undefined
// 453C60: variable 'a4' is possibly undefined
// 453C60: variable 'a5' is possibly undefined
// 453C60: variable 'a6' is possibly undefined
// 453C60: variable 'a7' is possibly undefined
// 453C60: variable 'a8' is possibly undefined
// 453C60: variable 'a9' is possibly undefined
// 453C9C: variable 'v42' is possibly undefined
// 453CC8: variable 'a13' is possibly undefined
// 453CC8: variable 'a14' is possibly undefined
// 453CC8: variable 'a15' is possibly undefined

//----- (0000000000453D00) ----------------------------------------------------
void __cdecl _aarch64_cas8_acq_rel()
{
  __int64 v0; // x0
  unsigned __int64 v1; // x1
  atomic_ullong *v2; // x2
  __int64 v3; // x16
  unsigned __int64 v4; // x0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_compare_exchange_strong(v2, (unsigned __int64 *)&v0, v1);
  }
  else
  {
    v3 = v0;
    do
      v4 = __ldaxr((unsigned __int64 *)v2);
    while ( v4 == v3 && __stlxr(v1, (unsigned __int64 *)v2) );
  }
}
// 453D0C: variable 'v2' is possibly undefined
// 453D0C: variable 'v1' is possibly undefined
// 453D14: variable 'v0' is possibly undefined

//----- (0000000000453D30) ----------------------------------------------------
void __cdecl _aarch64_ldadd8_acq()
{
  unsigned __int64 v0; // x0
  atomic_ullong *v1; // x1
  unsigned __int64 v2; // x16
  unsigned __int64 v3; // x0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_fetch_add_explicit(v1, v0, memory_order_acquire);
  }
  else
  {
    v2 = v0;
    do
      v3 = __ldaxr((unsigned __int64 *)v1);
    while ( __stxr(v3 + v2, (unsigned __int64 *)v1) );
  }
}
// 453D3C: variable 'v1' is possibly undefined
// 453D3C: variable 'v0' is possibly undefined

//----- (0000000000453D60) ----------------------------------------------------
void __cdecl _aarch64_ldadd4_rel()
{
  unsigned int v0; // w0
  atomic_uint *v1; // x1
  unsigned int v2; // w16
  unsigned int v3; // w0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_fetch_add_explicit(v1, v0, memory_order_release);
  }
  else
  {
    v2 = v0;
    do
      v3 = __ldxr((unsigned int *)v1);
    while ( __stlxr(v3 + v2, (unsigned int *)v1) );
  }
}
// 453D6C: variable 'v1' is possibly undefined
// 453D6C: variable 'v0' is possibly undefined

//----- (0000000000453D90) ----------------------------------------------------
void __cdecl _aarch64_ldclr4_rel()
{
  int v0; // w0
  atomic_uint *v1; // x1
  int v2; // w16
  unsigned int v3; // w0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_fetch_and_explicit(v1, ~v0, memory_order_release);
  }
  else
  {
    v2 = v0;
    do
      v3 = __ldxr((unsigned int *)v1);
    while ( __stlxr(v3 & ~v2, (unsigned int *)v1) );
  }
}
// 453D9C: variable 'v1' is possibly undefined
// 453D9C: variable 'v0' is possibly undefined

//----- (0000000000453DC0) ----------------------------------------------------
void __cdecl _aarch64_ldeor8_rel()
{
  unsigned __int64 v0; // x0
  atomic_ullong *v1; // x1
  unsigned __int64 v2; // x16
  unsigned __int64 v3; // x0

  if ( _aarch64_have_lse_atomics )
  {
    atomic_fetch_xor_explicit(v1, v0, memory_order_release);
  }
  else
  {
    v2 = v0;
    do
      v3 = __ldxr((unsigned __int64 *)v1);
    while ( __stlxr(v3 ^ v2, (unsigned __int64 *)v1) );
  }
}
// 453DCC: variable 'v1' is possibly undefined
// 453DCC: variable 'v0' is possibly undefined

//----- (0000000000453DF0) ----------------------------------------------------
void __cdecl _aarch64_swp8_acq_rel()
{
  unsigned __int64 v0; // x0
  atomic_ullong *v1; // x1

  if ( _aarch64_have_lse_atomics )
  {
    atomic_exchange(v1, v0);
  }
  else
  {
    do
      __ldaxr((unsigned __int64 *)v1);
    while ( __stlxr(v0, (unsigned __int64 *)v1) );
  }
}
// 453DFC: variable 'v1' is possibly undefined
// 453DFC: variable 'v0' is possibly undefined

//----- (0000000000453E18) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=960 queued=949 decompiled=949 lumina nreq=0 worse=0 better=0
// ALL OK, 949 function(s) have been successfully decompiled
