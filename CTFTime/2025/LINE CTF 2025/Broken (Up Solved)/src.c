/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (*sub_1000())(void);
__int64 sub_1320(); // weak
__int64 __fastcall sub_1328(_QWORD); // weak
__int64 __fastcall sub_1330(__int64 a1, __int64 a2);
__int64 __fastcall sub_1420(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6);
void __fastcall __noreturn start(__int64 a1, __int64 a2, __int64 a3);
void *sub_16C0();
__int64 sub_16F0();
void *sub_1730();
__int64 sub_1770();
void __fastcall sub_1780(__int64 *a1);
void term_proc();

//-------------------------------------------------------------------------
// Data declarations

int dword_0 = 1179403647; // weak
__int64 (__fastcall *off_3F60)(_QWORD, _QWORD, _QWORD) = &sub_1080; // weak
_UNKNOWN *off_3F68 = &sub_10A0; // weak
__int64 qword_3F78 = 0LL; // weak
__int64 (__fastcall *off_3F80)(_QWORD) = &sub_10C0; // weak
__int64 qword_3F88 = 0LL; // weak
__int64 (*off_3F90)(void) = &sub_10E0; // weak
__int64 (__fastcall *off_3F98)(_QWORD) = &sub_1100; // weak
__int64 (__fastcall *off_3FA0)(_QWORD, _QWORD, _QWORD) = &sub_1120; // weak
__int64 (__fastcall *off_3FA8)(_QWORD) = &sub_1140; // weak
__int64 (*qword_3FB0)(void) = &dword_0; // weak
__int64 (__fastcall *off_3FB8)(_QWORD) = &sub_1160; // weak
__int64 (*off_3FC0)(_QWORD, const char *, ...) = &sub_1180; // weak
__int64 (__fastcall *off_3FC8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD) = &sub_11A0; // weak
__int64 (__fastcall *off_3FD0)(_QWORD) = &sub_11C0; // weak
__int64 (__fastcall *off_3FE0)(_QWORD) = &sub_11E0; // weak
_UNKNOWN *off_3FE8 = &sub_1200; // weak
__int64 (*off_3FF0)(void) = &sub_1220; // weak
_UNKNOWN *off_4008 = &off_4008; // weak
_UNKNOWN unk_44D8; // weak
char byte_44E0 = '\0'; // weak
__int64 qword_4500[] = { 0LL }; // weak
_BYTE algn_4508[248] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // weak
__int64 qword_4600 = 0LL; // weak
int dword_4608 = 0; // weak
int dword_460C = 0; // weak
int dword_4610 = 0; // weak


//----- (0000000000001000) ----------------------------------------------------
__int64 (*sub_1000())(void)
{
  __int64 (*result)(void); // rax

  result = qword_3FB0;
  if ( qword_3FB0 )
    return (__int64 (*)(void))qword_3FB0();
  return result;
}
// 3FB0: using guessed type __int64 (*qword_3FB0)(void);

//----- (0000000000001320) ----------------------------------------------------
__int64 sub_1320()
{
  return 0;
}
// 1320: using guessed type __int64 sub_1320();

//----- (0000000000001330) ----------------------------------------------------
__int64 __fastcall sub_1330(__int64 a1, __int64 a2)
{
  __int64 *v2; // rbp
  __int64 v3; // rbx
  __int64 v4; // r13
  __int64 v5; // rbx
  __int64 v7; // rbx
  __int64 *v8; // rdx
  __int64 v9; // rcx
  __int64 v10; // r8
  __int64 v11; // r9
  unsigned __int64 v12; // [rsp+8h] [rbp-30h]

  v2 = qword_4500;
  v12 = __readfsqword(0x28u);
  off_3FA8(0);
  v3 = off_3FB8(0);
  qword_4500[0] = off_3FB8(0) | (v3 << 32);
  do
  {
    while ( 1 )
    {
      v4 = *v2;
      if ( (*v2 & 1) != 0 )
        break;
      ++v2;
      v5 = (unsigned int)off_3FF0();
      *v2 = (v4 + (int)off_3FF0()) | (v5 << 32);
      if ( v2 == (__int64 *)&algn_4508[240] )
        goto LABEL_4;
    }
    off_3FF0();
    ++v2;
    v7 = (unsigned int)off_3FF0();
    *v2 = (v4 + (int)off_3FF0()) | (v7 << 32);
  }
  while ( &algn_4508[240] != (_BYTE *)v2 );
LABEL_4:
  if ( v12 == __readfsqword(0x28u) )
    return 0;
  off_3F90();
  return sub_1420(0, a2, v8, v9, v10, v11);
}
// 141A: variable 'v8' is possibly undefined
// 141A: variable 'v9' is possibly undefined
// 141A: variable 'v10' is possibly undefined
// 141A: variable 'v11' is possibly undefined
// 3F90: using guessed type __int64 (*off_3F90)(void);
// 3FA8: using guessed type __int64 (__fastcall *off_3FA8)(_QWORD);
// 3FB8: using guessed type __int64 (__fastcall *off_3FB8)(_QWORD);
// 3FF0: using guessed type __int64 (*off_3FF0)(void);
// 4500: using guessed type __int64 qword_4500[];
// 4508: using guessed type _BYTE algn_4508[248];

//----- (0000000000001420) ----------------------------------------------------
__int64 __fastcall sub_1420(__int64 a1, __int64 a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6)
{
  const char *v7; // rsi
  __int64 v8; // r8
  __int64 v9; // r9
  __int64 *v10; // rdi
  int v11; // eax
  __int64 v12; // rax
  int v13; // edx
  const char *v14; // r9
  __int64 v15; // rcx
  int v16; // eax
  int v17; // edx
  __int64 v19; // rdx
  __int128 v20; // [rsp+0h] [rbp-78h] BYREF
  _QWORD v21[5]; // [rsp+10h] [rbp-68h] BYREF
  unsigned __int64 v22; // [rsp+38h] [rbp-40h]

  v22 = __readfsqword(0x28u);
  memset(v21, 0, 28);
  off_3FC8(*(_QWORD *)qword_3F88, 0, 2, 0, a5, a6, 0, 0, 0, v21[1], 0, 0);
  v7 = 0;
  off_3FC8(*(_QWORD *)qword_3F78, 0, 2, 0, v8, v9, v20, *((_QWORD *)&v20 + 1), v21[0], v21[1], v21[2], v21[3]);
  v10 = a3;
  sub_1780(a3);
  v11 = dword_4610;
  if ( dword_4610 > 31 )
    goto LABEL_21;
LABEL_2:
  off_3FC0(2, "[%d / %d] # ", 32 - v11, dword_460C);
  memset(v21, 0, 28);
  v20 = 0;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        v7 = (const char *)&v20;
        v10 = 0;
        DWORD1(v20) = off_3FA0(0, &v20, 1);
        if ( !DWORD1(v20) )
          goto LABEL_24;
        v12 = SDWORD2(v20);
        if ( DWORD2(v20) != 1 )
          break;
        if ( BYTE12(v20) == 113 )
        {
          while ( 1 )
          {
LABEL_23:
            off_3F80("bye!");
LABEL_24:
            v10 = 0;
            v16 = off_3FD0(0);
LABEL_25:
            ++dword_460C;
            v17 = dword_4608;
LABEL_19:
            if ( v17 <= 7 )
            {
              v11 = v16 + 1;
              dword_4610 = v11;
              if ( v11 > 31 )
                goto LABEL_21;
              goto LABEL_2;
            }
          }
        }
        if ( (_BYTE)v20 == 10 )
          goto LABEL_15;
        DWORD2(v20) = 2;
        BYTE13(v20) = v20;
      }
      if ( DWORD2(v20) != 2 )
        break;
      if ( WORD6(v20) == 28974 )
        goto LABEL_23;
      if ( (_BYTE)v20 == 10 )
        goto LABEL_15;
      DWORD2(v20) = 3;
      BYTE14(v20) = v20;
    }
    if ( (_BYTE)v20 == 10 )
      break;
    v13 = DWORD2(v20) + 1;
    *((_BYTE *)&v20 + SDWORD2(v20) + 12) = v20;
    DWORD2(v20) = v13;
    if ( v13 > 1023 )
    {
      v12 = v13;
      goto LABEL_15;
    }
  }
  if ( DWORD2(v20) )
  {
LABEL_15:
    *((_BYTE *)&v20 + v12 + 12) = 0;
    DWORD2(v20) = v12 + 1;
    qword_4600 = off_3F60((char *)&v20 + 12, 0, 10);
    off_3FC0(2, "You entered: %lu\n", qword_4600);
    v14 = "OK";
    v7 = "number[%d]: %lu vs %lu -> %s\n";
    v10 = (_QWORD *)(&dword_0 + 2);
    v15 = qword_4500[dword_4610];
    if ( v15 != qword_4600 )
      v14 = "FAIL";
    off_3FC0(2, "number[%d]: %lu vs %lu -> %s\n", dword_4610, v15, qword_4600, v14, (_QWORD)v20);
    v16 = dword_4610;
    if ( qword_4500[dword_4610] != qword_4600 )
    {
      v17 = ++dword_4608;
      goto LABEL_19;
    }
    goto LABEL_25;
  }
LABEL_21:
  if ( v22 != __readfsqword(0x28u) )
  {
    off_3F90();
    start((__int64)v10, (__int64)v7, v19);
  }
  return 0;
}
// 147F: variable 'v8' is possibly undefined
// 147F: variable 'v9' is possibly undefined
// 168F: variable 'v19' is possibly undefined
// 0: using guessed type int dword_0;
// 3F60: using guessed type __int64 (__fastcall *off_3F60)(_QWORD, _QWORD, _QWORD);
// 3F78: using guessed type __int64 qword_3F78;
// 3F80: using guessed type __int64 (__fastcall *off_3F80)(_QWORD);
// 3F88: using guessed type __int64 qword_3F88;
// 3F90: using guessed type __int64 (*off_3F90)(void);
// 3FA0: using guessed type __int64 (__fastcall *off_3FA0)(_QWORD, _QWORD, _QWORD);
// 3FC0: using guessed type __int64 (*off_3FC0)(_QWORD, const char *, ...);
// 3FC8: using guessed type __int64 (__fastcall *off_3FC8)(_QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD);
// 3FD0: using guessed type __int64 (__fastcall *off_3FD0)(_QWORD);
// 4500: using guessed type __int64 qword_4500[];
// 4600: using guessed type __int64 qword_4600;
// 4608: using guessed type int dword_4608;
// 460C: using guessed type int dword_460C;
// 4610: using guessed type int dword_4610;

//----- (0000000000001690) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // rsi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  _UNKNOWN *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  ((void (__fastcall *)(__int64 (__fastcall *)(__int64, __int64, __int64 *, __int64, __int64, __int64), __int64, _UNKNOWN **, _QWORD, _QWORD, __int64, __int64 *))off_3F68)(
    sub_1420,
    v4,
    &retaddr,
    0,
    0,
    a3,
    &v5);
  __halt();
}
// 169A: positive sp value 8 has been found
// 16A1: variable 'v3' is possibly undefined
// 3F68: using guessed type _UNKNOWN *off_3F68;

//----- (00000000000016C0) ----------------------------------------------------
void *sub_16C0()
{
  return &unk_44D8;
}

//----- (00000000000016F0) ----------------------------------------------------
__int64 sub_16F0()
{
  return 0;
}

//----- (0000000000001730) ----------------------------------------------------
void *sub_1730()
{
  void *result; // rax

  if ( !byte_44E0 )
  {
    if ( off_3FE8 )
      sub_1328(off_4008);
    result = sub_16C0();
    byte_44E0 = 1;
  }
  return result;
}
// 1328: using guessed type __int64 __fastcall sub_1328(_QWORD);
// 3FE8: using guessed type _UNKNOWN *off_3FE8;
// 4008: using guessed type _UNKNOWN *off_4008;
// 44E0: using guessed type char byte_44E0;

//----- (0000000000001770) ----------------------------------------------------
// attributes: thunk
__int64 sub_1770()
{
  return sub_16F0();
}

//----- (0000000000001780) ----------------------------------------------------
void __fastcall sub_1780(__int64 *a1)
{
  __int16 v2; // bp
  int v3; // ebp
  __int64 i; // rax
  __int64 *v5; // rbp
  __int64 v6; // rbx
  __int64 v7; // r13
  __int64 v8; // rax
  unsigned __int64 v9; // [rsp+8h] [rbp-30h]

  v9 = __readfsqword(0x28u);
  v2 = off_3FB8(0);
  off_3F98(30);
  v3 = v2 & 0xFFF;
  off_3F80("Generating random numbers...\n");
  do
    ++a1;
  while ( *(a1 - 1) );
  for ( i = *a1; *a1; i = *a1 )
  {
    while ( i != 3 )
    {
      i = a1[2];
      a1 += 2;
      if ( !i )
        goto LABEL_6;
    }
    v8 = a1[1];
    a1 += 2;
    qword_4500[0] = v3 | (unsigned __int64)(v8 << 12);
  }
LABEL_6:
  v5 = qword_4500;
  do
  {
    v7 = *v5;
    if ( (*v5 & 1) != 0 )
      off_3FF0();
    ++v5;
    v6 = (unsigned int)off_3FF0();
    *v5 = (v7 + (int)off_3FF0()) | (v6 << 32);
  }
  while ( &algn_4508[240] != (_BYTE *)v5 );
  off_3FE0(1);
  if ( v9 == __readfsqword(0x28u) )
  {
    off_3F80("...OK\n\n");
  }
  else
  {
    off_3F90();
    term_proc();
  }
}
// 3F80: using guessed type __int64 (__fastcall *off_3F80)(_QWORD);
// 3F90: using guessed type __int64 (*off_3F90)(void);
// 3F98: using guessed type __int64 (__fastcall *off_3F98)(_QWORD);
// 3FB8: using guessed type __int64 (__fastcall *off_3FB8)(_QWORD);
// 3FE0: using guessed type __int64 (__fastcall *off_3FE0)(_QWORD);
// 3FF0: using guessed type __int64 (*off_3FF0)(void);
// 4500: using guessed type __int64 qword_4500[];
// 4508: using guessed type _BYTE algn_4508[248];

//----- (00000000000018A8) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=55 queued=11 decompiled=11 lumina nreq=0 worse=0 better=0
// ALL OK, 11 function(s) have been successfully decompiled
