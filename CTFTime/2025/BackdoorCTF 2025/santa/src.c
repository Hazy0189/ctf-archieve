/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_1020();
void sub_1030();
void sub_1040();
void sub_1050();
void sub_1060();
void sub_1070();
void sub_1080();
void sub_1090();
void sub_10A0();
void sub_10B0();
void sub_10C0();
void sub_10D0();
void sub_10E0();
void sub_10F0();
void sub_1100();
void sub_1110();
void sub_1120();
void sub_1130();
// int _cxa_finalize(void *);
// void free(void *ptr);
// int putchar(int c);
// int puts(const char *s);
// ssize_t write(int fd, const void *buf, size_t n);
// void setbuf(FILE *stream, char *buf);
// int printf(const char *format, ...);
// int close(int fd);
// ssize_t read(int fd, void *buf, size_t nbytes);
// int memcmp(const void *s1, const void *s2, size_t n);
// char *fgets(char *s, int n, FILE *stream);
// int getchar(void);
// void *malloc(size_t size);
// int open(const char *file, int oflag, ...);
// FILE *fopen(const char *filename, const char *modes);
// __int64 __isoc99_scanf(const char *, ...); weak
// void __noreturn exit(int status);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)());
void *sub_1290();
__int64 sub_12C0();
void *sub_1300();
__int64 sub_1340();
int sub_1349();
int sub_13F1();
void sub_1500();
unsigned __int64 sub_1547();
unsigned __int64 sub_1623();
int sub_16DD();
unsigned __int64 sub_1765();
void sub_18E6();
unsigned __int64 sub_192A();
unsigned __int64 sub_1A57();
unsigned __int64 sub_1B63();
void term_proc();
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// int __cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN main;
const char byte_22A0 = '\xE2'; // idb
const char byte_2328 = '\xE2'; // idb
const char byte_2360 = '\xE2'; // idb
const char byte_2398 = '\xE2'; // idb
const char byte_23D0 = '\xE2'; // idb
const char byte_2408 = '\xE2'; // idb
void *off_4008 = &off_4008; // idb
_UNKNOWN unk_4010; // weak
FILE *stdout; // idb
FILE *stdin; // idb
FILE *stderr; // idb
char byte_4048; // weak
int dword_4060; // weak
__int64 qword_4080; // weak
__int64 qword_4088; // weak
_QWORD qword_40C0[16]; // weak
_QWORD qword_4140[16]; // weak


//----- (0000000000001000) ----------------------------------------------------
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 4260: using guessed type __int64 _gmon_start__(void);

//----- (0000000000001020) ----------------------------------------------------
void sub_1020()
{
  JUMPOUT(0);
}
// 1026: control flows out of bounds to 0

//----- (0000000000001030) ----------------------------------------------------
void sub_1030()
{
  sub_1020();
}

//----- (0000000000001040) ----------------------------------------------------
void sub_1040()
{
  sub_1020();
}

//----- (0000000000001050) ----------------------------------------------------
void sub_1050()
{
  sub_1020();
}

//----- (0000000000001060) ----------------------------------------------------
void sub_1060()
{
  sub_1020();
}

//----- (0000000000001070) ----------------------------------------------------
void sub_1070()
{
  sub_1020();
}

//----- (0000000000001080) ----------------------------------------------------
void sub_1080()
{
  sub_1020();
}

//----- (0000000000001090) ----------------------------------------------------
void sub_1090()
{
  sub_1020();
}

//----- (00000000000010A0) ----------------------------------------------------
void sub_10A0()
{
  sub_1020();
}

//----- (00000000000010B0) ----------------------------------------------------
void sub_10B0()
{
  sub_1020();
}

//----- (00000000000010C0) ----------------------------------------------------
void sub_10C0()
{
  sub_1020();
}

//----- (00000000000010D0) ----------------------------------------------------
void sub_10D0()
{
  sub_1020();
}

//----- (00000000000010E0) ----------------------------------------------------
void sub_10E0()
{
  sub_1020();
}

//----- (00000000000010F0) ----------------------------------------------------
void sub_10F0()
{
  sub_1020();
}

//----- (0000000000001100) ----------------------------------------------------
void sub_1100()
{
  sub_1020();
}

//----- (0000000000001110) ----------------------------------------------------
void sub_1110()
{
  sub_1020();
}

//----- (0000000000001120) ----------------------------------------------------
void sub_1120()
{
  sub_1020();
}

//----- (0000000000001130) ----------------------------------------------------
void sub_1130()
{
  sub_1020();
}

//----- (0000000000001260) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)())
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (*)(int, char **, char **))main, v4, &retaddr, 0, 0, a3, &v5);
  __halt();
}
// 126A: positive sp value 8 has been found
// 1271: variable 'v3' is possibly undefined

//----- (0000000000001290) ----------------------------------------------------
void *sub_1290()
{
  return &unk_4010;
}

//----- (00000000000012C0) ----------------------------------------------------
__int64 sub_12C0()
{
  return 0;
}

//----- (0000000000001300) ----------------------------------------------------
void *sub_1300()
{
  void *result; // rax

  if ( !byte_4048 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(off_4008);
    result = sub_1290();
    byte_4048 = 1;
  }
  return result;
}
// 4048: using guessed type char byte_4048;

//----- (0000000000001340) ----------------------------------------------------
// attributes: thunk
__int64 sub_1340()
{
  return sub_12C0();
}

//----- (0000000000001349) ----------------------------------------------------
int sub_1349()
{
  int result; // eax
  __int64 v1; // rdx
  int fd; // [rsp+4h] [rbp-Ch]
  _QWORD *v3; // [rsp+8h] [rbp-8h]

  if ( dword_4060 )
    return puts("Secret manifest already loaded into the workshop!");
  fd = open("/dev/urandom", 0);
  read(fd, &qword_4080, 0x10u);
  close(fd);
  dword_4060 = 1;
  puts("Secret manifest loaded into the workshop!");
  v3 = malloc(0x20u);
  result = qword_4080;
  v1 = qword_4088;
  *v3 = qword_4080;
  v3[1] = v1;
  return result;
}
// 4060: using guessed type int dword_4060;
// 4080: using guessed type __int64 qword_4080;
// 4088: using guessed type __int64 qword_4088;

//----- (00000000000013F1) ----------------------------------------------------
int sub_13F1()
{
  putchar(10);
  puts("  *    *     *                             `}-'   *   `}-'   *   *");
  puts(" ___   *  *       *  `}-' `}-'  ____/`-,  _____/`-,  *   *");
  puts("\"-_/}__   *  *  `}-'_/`-, /`-,( _,,.{-,_(__,,,.(   *   *");
  puts("  [(_.-'`--,__   ____/`-,.(,-`}-'_,>___\\/`-, >|`---\\  *   *   *");
  puts("  [(__\\___\\  _`-(--...(..-'_`./`-,/(--,,.(  //    / >  *   *");
  puts("  |_______/-'    >`---\\ / (   `{    >`---\\    *    *");
  puts("  __|___|__)    / \\  / \\  /`--/<   / \\   /|  *   *   *");
  puts("   *   *    *           /  \\/  \\      *    *   *    *");
  puts("      *   *    *    *       *    *    *   *    *");
  putchar(10);
  puts(&byte_22A0);
  puts(&byte_2328);
  puts(&byte_2360);
  puts(&byte_2398);
  puts(&byte_23D0);
  puts(&byte_2328);
  return puts(&byte_2408);
}

//----- (0000000000001500) ----------------------------------------------------
void sub_1500()
{
  setbuf(stdin, 0);
  setbuf(stdout, 0);
  setbuf(stderr, 0);
}

//----- (0000000000001547) ----------------------------------------------------
unsigned __int64 sub_1547()
{
  FILE *stream; // [rsp+8h] [rbp-78h]
  char s[104]; // [rsp+10h] [rbp-70h] BYREF
  unsigned __int64 v3; // [rsp+78h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  stream = fopen("flag.txt", "r");
  if ( stream )
  {
    fgets(s, 100, stream);
    putchar(10);
    puts("    *  .  *  .  *  .  *  .  *  .  *  .  *");
    puts("  .   _\\/__  Ho Ho Ho! You've earned   .  ");
    puts("    . ( o.o )    your present!        *");
    puts("  *   />   <\\                           .  ");
    puts("    *  *  .  *  .  *  .  *  .  *  .  *\n");
    puts(s);
  }
  else
  {
    puts("Error while loading flag.txt contact the author");
  }
  return v3 - __readfsqword(0x28u);
}

//----- (0000000000001623) ----------------------------------------------------
unsigned __int64 sub_1623()
{
  _BYTE buf[24]; // [rsp+0h] [rbp-20h] BYREF
  unsigned __int64 v2; // [rsp+18h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  if ( dword_4060 )
  {
    printf("Enter Santa's Secret Code: ");
    read(0, buf, 0x10u);
    if ( memcmp(buf, &qword_4080, 0x10u) )
    {
      puts("Wrong! You're going on the naughty list!");
      exit(0);
    }
    sub_1547();
  }
  else
  {
    puts("Santa's Workshop is CLOSED! Load the secret first!");
  }
  return v2 - __readfsqword(0x28u);
}
// 4060: using guessed type int dword_4060;
// 4080: using guessed type __int64 qword_4080;

//----- (00000000000016DD) ----------------------------------------------------
int sub_16DD()
{
  puts("\n1. Prepare Gift");
  puts("2. Rewrite Card");
  puts("3. Check Gift");
  puts("4. Deliver Gift");
  puts("5. Master Key");
  puts("6. Load List");
  puts("7. Close Workshop");
  return printf("> ");
}

//----- (0000000000001765) ----------------------------------------------------
unsigned __int64 sub_1765()
{
  signed int v0; // ebx
  signed int v2; // [rsp+Ch] [rbp-24h] BYREF
  size_t size; // [rsp+10h] [rbp-20h] BYREF
  unsigned __int64 v4; // [rsp+18h] [rbp-18h]

  v4 = __readfsqword(0x28u);
  printf("Gift Slot: ");
  __isoc99_scanf("%d", &v2);
  if ( (unsigned int)v2 < 0x10 )
  {
    if ( qword_40C0[v2] )
    {
      puts("There's already a gift in this slot!");
    }
    else
    {
      printf("Gift Size: ");
      __isoc99_scanf("%lu", &size);
      if ( size <= 0x1000 && size > 0x4F )
      {
        v0 = v2;
        qword_40C0[v0] = malloc(size);
        qword_4140[v2] = size;
        if ( !qword_40C0[v2] )
          puts("Failed to prepare the gift!");
      }
      else
      {
        puts("That size won't fit in Santa's sleigh!");
      }
    }
  }
  else
  {
    puts("That shelf doesn't exist!");
  }
  return v4 - __readfsqword(0x28u);
}
// 1240: using guessed type __int64 __isoc99_scanf(const char *, ...);
// 40C0: using guessed type _QWORD qword_40C0[16];
// 4140: using guessed type _QWORD qword_4140[16];

//----- (00000000000018E6) ----------------------------------------------------
void sub_18E6()
{
  void *ptr; // [rsp+8h] [rbp-8h]

  ptr = malloc(0x10u);
  printf("\nHo...Ho...Ho..%p\n", ptr);
  free(ptr);
}

//----- (000000000000192A) ----------------------------------------------------
unsigned __int64 sub_192A()
{
  unsigned int v1; // [rsp+0h] [rbp-10h] BYREF
  int v2; // [rsp+4h] [rbp-Ch]
  unsigned __int64 v3; // [rsp+8h] [rbp-8h]

  v3 = __readfsqword(0x28u);
  printf("Gift Slot: ");
  __isoc99_scanf("%d", &v1);
  getchar();
  if ( v1 < 0x10 )
  {
    if ( qword_40C0[v1] )
    {
      printf("Card Message: ");
      v2 = read(0, (void *)qword_40C0[v1], qword_4140[v1]);
      *(_BYTE *)(qword_40C0[v1] + v2) = 0;
    }
    else
    {
      puts("No gift in this slot!");
    }
  }
  else
  {
    puts("That shelf doesn't exist!");
  }
  return v3 - __readfsqword(0x28u);
}
// 1240: using guessed type __int64 __isoc99_scanf(const char *, ...);
// 40C0: using guessed type _QWORD qword_40C0[16];
// 4140: using guessed type _QWORD qword_4140[16];

//----- (0000000000001A57) ----------------------------------------------------
unsigned __int64 sub_1A57()
{
  unsigned int v1; // [rsp+4h] [rbp-Ch] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  printf("Gift Slot: ");
  __isoc99_scanf("%d", &v1);
  if ( v1 < 0x10 )
  {
    if ( qword_40C0[v1] )
    {
      printf("Gift Contents: ");
      write(1, (const void *)qword_40C0[v1], qword_4140[v1]);
      putchar(10);
    }
    else
    {
      puts("No gift in this slot!");
    }
  }
  else
  {
    puts("That shelf doesn't exist!");
  }
  return v2 - __readfsqword(0x28u);
}
// 1240: using guessed type __int64 __isoc99_scanf(const char *, ...);
// 40C0: using guessed type _QWORD qword_40C0[16];
// 4140: using guessed type _QWORD qword_4140[16];

//----- (0000000000001B63) ----------------------------------------------------
unsigned __int64 sub_1B63()
{
  unsigned int v1; // [rsp+4h] [rbp-Ch] BYREF
  unsigned __int64 v2; // [rsp+8h] [rbp-8h]

  v2 = __readfsqword(0x28u);
  printf("Gift Slot: ");
  __isoc99_scanf("%d", &v1);
  if ( v1 < 0x10 )
  {
    if ( qword_40C0[v1] )
    {
      free((void *)qword_40C0[v1]);
      qword_40C0[v1] = 0;
      qword_4140[v1] = 0;
      puts("Gift delivered!");
    }
    else
    {
      puts("No gift in this slot!");
    }
  }
  else
  {
    puts("That shelf doesn't exist!");
  }
  return v2 - __readfsqword(0x28u);
}
// 1240: using guessed type __int64 __isoc99_scanf(const char *, ...);
// 40C0: using guessed type _QWORD qword_40C0[16];
// 4140: using guessed type _QWORD qword_4140[16];

//----- (0000000000001C7B) ----------------------------------------------------
void __fastcall __noreturn main(int a1, char **a2, char **a3)
{
  int v3; // [rsp+14h] [rbp-Ch] BYREF
  unsigned __int64 v4; // [rsp+18h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  sub_1500();
  sub_13F1();
  sub_18E6();
  while ( 1 )
  {
    sub_16DD();
    __isoc99_scanf("%d", &v3);
    switch ( v3 )
    {
      case 1:
        sub_1765();
        break;
      case 2:
        sub_192A();
        break;
      case 3:
        sub_1A57();
        break;
      case 4:
        sub_1B63();
        break;
      case 5:
        sub_1623();
        break;
      case 6:
        sub_1349();
        break;
      case 7:
        puts("Merry Christmas and Happy Hacking!");
        exit(0);
      default:
        puts("That's not on Santa's list!");
        break;
    }
  }
}
// 1240: using guessed type __int64 __isoc99_scanf(const char *, ...);

//----- (0000000000001D84) ----------------------------------------------------
void term_proc()
{
  ;
}

// nfuncs=75 queued=37 decompiled=37 lumina nreq=0 worse=0 better=0
// ALL OK, 37 function(s) have been successfully decompiled
