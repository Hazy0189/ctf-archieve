/* This file was generated by the Hex-Rays decompiler version 9.2.0.250908.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

__int64 (**init_proc())(void);
void sub_1020();
void sub_1030();
void sub_1040();
void sub_1050();
void sub_1060();
void sub_1070();
void sub_1080();
void sub_1090();
void sub_10A0();
void sub_10B0();
void sub_10C0();
void sub_10D0();
void sub_10E0();
void sub_10F0();
void sub_1100();
void sub_1110();
void sub_1120();
void sub_1130();
void sub_1140();
void sub_1150();
void sub_1160();
void sub_1170();
// int _cxa_finalize(void *);
// void free(void *ptr);
// int putchar(int c);
// int puts(const char *s);
// size_t strlen(const char *s);
// int printf(const char *format, ...);
// void *memset(void *s, int c, size_t n);
// size_t strcspn(const char *s, const char *reject);
// ssize_t read(int fd, void *buf, size_t nbytes);
// void srand(unsigned int seed);
// char *fgets(char *s, int n, FILE *stream);
// __int64 __isoc23_scanf(const char *, ...); weak
// int getchar(void);
// void *memcpy(void *dest, const void *src, size_t n);
// time_t time(time_t *timer);
// void *malloc(size_t size);
// int setvbuf(FILE *stream, char *buf, int modes, size_t n);
// int atoi(const char *nptr);
// void __noreturn exit(int status);
// size_t fwrite(const void *ptr, size_t size, size_t n, FILE *s);
// int rand(void);
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)());
void *deregister_tm_clones();
__int64 register_tm_clones();
void *_do_global_dtors_aux();
__int64 frame_dummy(); // weak
int banner();
__int64 __fastcall mini_regex_match(const char *a1, const char *a2, _DWORD *a3);
int print_menu();
unsigned __int64 __fastcall learn(int a1, const char *a2);
int __fastcall forget(int a1);
int __fastcall remember(int a1);
unsigned __int64 __fastcall add_special_spell(unsigned int a1);
int __fastcall main(int argc, const char **argv, const char **envp);
void term_proc();
// int _libc_start_main(int (*main)(int, char **, char **), int argc, char **ubp_av, void (*init)(), void (*fini)(), void (*rtld_fini)(), void *stack_end);
// int __cxa_finalize(void *);
// __int64 _gmon_start__(void); weak

//-------------------------------------------------------------------------
// Data declarations

const char asc_30A8[] = "\n"; // idb
const char byte_34BD = '\0'; // idb
void *_dso_handle = &_dso_handle; // idb
char *spells = "amaterasu"; // weak
_UNKNOWN _TMC_END__; // weak
FILE *stdout; // idb
FILE *stdin; // idb
FILE *stderr; // idb
char completed_0; // weak
_UNKNOWN spell_list; // weak
int special_spell; // weak


//----- (0000000000001000) ----------------------------------------------------
// Alternative name is '_init'
__int64 (**init_proc())(void)
{
  __int64 (**result)(void); // rax

  result = &_gmon_start__;
  if ( &_gmon_start__ )
    return (__int64 (**)(void))_gmon_start__();
  return result;
}
// 51D0: using guessed type __int64 _gmon_start__(void);

//----- (0000000000001020) ----------------------------------------------------
void sub_1020()
{
  JUMPOUT(0);
}
// 1026: control flows out of bounds to 0

//----- (0000000000001030) ----------------------------------------------------
void sub_1030()
{
  sub_1020();
}

//----- (0000000000001040) ----------------------------------------------------
void sub_1040()
{
  sub_1020();
}

//----- (0000000000001050) ----------------------------------------------------
void sub_1050()
{
  sub_1020();
}

//----- (0000000000001060) ----------------------------------------------------
void sub_1060()
{
  sub_1020();
}

//----- (0000000000001070) ----------------------------------------------------
void sub_1070()
{
  sub_1020();
}

//----- (0000000000001080) ----------------------------------------------------
void sub_1080()
{
  sub_1020();
}

//----- (0000000000001090) ----------------------------------------------------
void sub_1090()
{
  sub_1020();
}

//----- (00000000000010A0) ----------------------------------------------------
void sub_10A0()
{
  sub_1020();
}

//----- (00000000000010B0) ----------------------------------------------------
void sub_10B0()
{
  sub_1020();
}

//----- (00000000000010C0) ----------------------------------------------------
void sub_10C0()
{
  sub_1020();
}

//----- (00000000000010D0) ----------------------------------------------------
void sub_10D0()
{
  sub_1020();
}

//----- (00000000000010E0) ----------------------------------------------------
void sub_10E0()
{
  sub_1020();
}

//----- (00000000000010F0) ----------------------------------------------------
void sub_10F0()
{
  sub_1020();
}

//----- (0000000000001100) ----------------------------------------------------
void sub_1100()
{
  sub_1020();
}

//----- (0000000000001110) ----------------------------------------------------
void sub_1110()
{
  sub_1020();
}

//----- (0000000000001120) ----------------------------------------------------
void sub_1120()
{
  sub_1020();
}

//----- (0000000000001130) ----------------------------------------------------
void sub_1130()
{
  sub_1020();
}

//----- (0000000000001140) ----------------------------------------------------
void sub_1140()
{
  sub_1020();
}

//----- (0000000000001150) ----------------------------------------------------
void sub_1150()
{
  sub_1020();
}

//----- (0000000000001160) ----------------------------------------------------
void sub_1160()
{
  sub_1020();
}

//----- (0000000000001170) ----------------------------------------------------
void sub_1170()
{
  sub_1020();
}

//----- (00000000000012E0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall __noreturn start(__int64 a1, __int64 a2, void (*a3)())
{
  __int64 v3; // rax
  int v4; // esi
  __int64 v5; // [rsp-8h] [rbp-8h] BYREF
  char *retaddr; // [rsp+0h] [rbp+0h] BYREF

  v4 = v5;
  v5 = v3;
  _libc_start_main((int (*)(int, char **, char **))main, v4, &retaddr, 0, 0, a3, &v5);
  __halt();
}
// 12EA: positive sp value 8 has been found
// 12F1: variable 'v3' is possibly undefined

//----- (0000000000001310) ----------------------------------------------------
void *deregister_tm_clones()
{
  return &_TMC_END__;
}

//----- (0000000000001340) ----------------------------------------------------
__int64 register_tm_clones()
{
  return 0;
}

//----- (0000000000001380) ----------------------------------------------------
void *_do_global_dtors_aux()
{
  void *result; // rax

  if ( !completed_0 )
  {
    if ( &__cxa_finalize )
      _cxa_finalize(_dso_handle);
    result = deregister_tm_clones();
    completed_0 = 1;
  }
  return result;
}
// 50A8: using guessed type char completed_0;

//----- (00000000000013C0) ----------------------------------------------------
__int64 frame_dummy()
{
  return register_tm_clones();
}
// 13C0: using guessed type __int64 frame_dummy();

//----- (00000000000013C9) ----------------------------------------------------
int banner()
{
  return puts(asc_30A8);
}

//----- (00000000000013EF) ----------------------------------------------------
__int64 __fastcall mini_regex_match(const char *a1, const char *a2, _DWORD *a3)
{
  int v4; // eax
  char v6; // [rsp+27h] [rbp-29h]
  int i; // [rsp+28h] [rbp-28h]
  int v8; // [rsp+2Ch] [rbp-24h]
  int v9; // [rsp+30h] [rbp-20h]
  unsigned int v10; // [rsp+34h] [rbp-1Ch]
  int v11; // [rsp+38h] [rbp-18h]
  int v12; // [rsp+3Ch] [rbp-14h]

  v11 = strlen(a1);
  v12 = strlen(a2);
  if ( !v12 )
    return 0xFFFFFFFFLL;
  if ( a2[v12 - 1] == 36 )
    v4 = v12 - 1;
  else
    v4 = v12;
  for ( i = 0; i < v11 && (*a2 != 94 || !i); ++i )
  {
    v8 = i;
    v9 = *a2 == 94;
    v10 = 0;
    while ( v9 < v4 && v8 < v11 )
    {
      v6 = a2[v9];
      if ( v6 == 46 )
      {
        if ( v4 > v9 + 1 && a2[v9 + 1] == 43 )
        {
          if ( v8 >= v11 )
            break;
          ++v8;
          ++v10;
          while ( v8 < v11 )
          {
            ++v8;
            ++v10;
          }
          v9 += 2;
        }
        else if ( v4 > v9 + 1 && a2[v9 + 1] == 63 )
        {
          if ( v8 < v11 )
            ++v8;
          v9 += 2;
        }
        else
        {
          ++v8;
          ++v10;
          ++v9;
        }
      }
      else if ( v4 > v9 + 1 && a2[v9 + 1] == 43 )
      {
        if ( v6 != a1[v8] )
          break;
        ++v8;
        ++v10;
        while ( v8 < v11 && v6 == a1[v8] )
        {
          ++v8;
          ++v10;
        }
        v9 += 2;
      }
      else if ( v4 > v9 + 1 && a2[v9 + 1] == 63 )
      {
        if ( v6 == a1[v8] )
          ++v8;
        v9 += 2;
      }
      else
      {
        if ( v6 != a1[v8] )
          break;
        ++v8;
        ++v10;
        ++v9;
      }
    }
    if ( v9 == v4 && (a2[v12 - 1] != 36 || v8 == v11) )
    {
      *a3 = i;
      return v10;
    }
  }
  return 0xFFFFFFFFLL;
}

//----- (000000000000169E) ----------------------------------------------------
int print_menu()
{
  puts("\n=== Wizard Menu ===");
  puts("1. Learn the spell");
  puts("2. Dodge the spell");
  puts("3. Forget the spell");
  puts("4. Remember the spell");
  puts("5. Add your special spell");
  puts("6. Exit");
  return printf(">> ");
}

//----- (0000000000001726) ----------------------------------------------------
unsigned __int64 __fastcall learn(int a1, const char *a2)
{
  size_t v2; // rbx
  size_t v3; // rax
  int v5; // [rsp+18h] [rbp-58h] BYREF
  int v6; // [rsp+1Ch] [rbp-54h]
  char s[56]; // [rsp+20h] [rbp-50h] BYREF
  unsigned __int64 v8; // [rsp+58h] [rbp-18h]

  v8 = __readfsqword(0x28u);
  if ( *((_QWORD *)&spell_list + a1) )
  {
    puts("the place is already occupied!");
  }
  else
  {
    printf("Enter your guess: ");
    if ( fgets(s, 48, stdin) )
    {
      s[strcspn(s, "\n")] = 0;
      v5 = -1;
      v6 = mini_regex_match(a2, s, &v5);
      if ( v6 >= 0 && (v2 = strlen(s), v2 >= strlen(a2)) )
      {
        puts("You learned the spell by copying his actions and words, wollah!");
        *((_QWORD *)&spell_list + a1) = malloc(v6);
        if ( !*((_QWORD *)&spell_list + a1) )
        {
          puts("malloc failed");
          exit(1);
        }
        v3 = strlen(a2);
        memcpy(*((void **)&spell_list + a1), s, v3);
        puts("The spell is saved in your SPELL container");
      }
      else
      {
        puts("The enemy spell hit you hard, you fall to ground");
      }
    }
    else
    {
      puts("Input error.");
    }
  }
  return v8 - __readfsqword(0x28u);
}

//----- (0000000000001901) ----------------------------------------------------
int __fastcall forget(int a1)
{
  void *v1; // rax

  if ( *((_QWORD *)&spell_list + a1) )
  {
    puts(&byte_34BD);
    free(*((void **)&spell_list + a1));
    v1 = &spell_list;
    *((_QWORD *)&spell_list + a1) = 0;
  }
  else
  {
    LODWORD(v1) = puts("no spell is here ");
  }
  return (int)v1;
}

//----- (000000000000198C) ----------------------------------------------------
int __fastcall remember(int a1)
{
  if ( !*((_QWORD *)&spell_list + a1) )
    return puts("no spell is here.. ");
  puts("The SPELL container is opening...");
  printf("here is your spell >> ");
  fwrite(
    *((const void **)&spell_list + a1),
    1u,
    (*(_QWORD *)(*((_QWORD *)&spell_list + a1) - 8LL) & 0xFFFFFFFFFFFFFFF8LL) - 8,
    stdout);
  return putchar(10);
}

//----- (0000000000001A5B) ----------------------------------------------------
unsigned __int64 __fastcall add_special_spell(unsigned int a1)
{
  unsigned int size; // [rsp+1Ch] [rbp-44h] BYREF
  char size_4[56]; // [rsp+20h] [rbp-40h] BYREF
  unsigned __int64 v4; // [rsp+58h] [rbp-8h]

  v4 = __readfsqword(0x28u);
  if ( special_spell )
  {
    puts("you already have/had a special spell");
  }
  else
  {
    puts("You can add special spell only once, so add it wisely.");
    printf("length of your spell(1-48) >> ");
    __isoc23_scanf("%u", &size);
    getchar();
    if ( size <= 0x2F )
    {
      printf("Enter your special spell: ");
      if ( fgets(size_4, 48, stdin) )
      {
        size_4[strcspn(size_4, "\n")] = 0;
        special_spell = 1;
        *((_QWORD *)&spell_list + a1) = malloc(size);
        if ( !*((_QWORD *)&spell_list + a1) )
        {
          puts("malloc failed");
          exit(1);
        }
        memcpy(*((void **)&spell_list + a1), size_4, size);
        puts("Your special spell is added. If you forget it , it will be lost forever..");
      }
      else
      {
        puts("Input error.");
      }
    }
    else
    {
      puts("I told you, It has to be in limits");
    }
  }
  return v4 - __readfsqword(0x28u);
}
// 1240: using guessed type __int64 __isoc23_scanf(const char *, ...);
// 5100: using guessed type int special_spell;

//----- (0000000000001C0D) ----------------------------------------------------
int __fastcall main(int argc, const char **argv, const char **envp)
{
  unsigned int v3; // eax
  unsigned int v5; // [rsp+0h] [rbp-30h] BYREF
  int v6; // [rsp+4h] [rbp-2Ch]
  void *v7; // [rsp+8h] [rbp-28h]
  void *v8; // [rsp+10h] [rbp-20h]
  const char *v9; // [rsp+18h] [rbp-18h]
  char buf[2]; // [rsp+26h] [rbp-Ah] BYREF
  unsigned __int64 v11; // [rsp+28h] [rbp-8h]

  v11 = __readfsqword(0x28u);
  setvbuf(stdout, 0, 2, 0);
  setvbuf(stdin, 0, 2, 0);
  setvbuf(stderr, 0, 2, 0);
  v3 = time(0);
  srand(v3);
  banner();
  puts("=== Wizard Duel Arena ===");
  puts("A duel of spells begins.");
  puts(&byte_34BD);
  memset(&spell_list, 0, 0x40u);
  while ( 1 )
  {
    print_menu();
    read(0, buf, 2u);
    v6 = atoi(buf);
    switch ( v6 )
    {
      case 1:
        v9 = (&spells)[rand() % 8];
        puts("what's the place for your spell");
        printf(">> ");
        __isoc23_scanf("%u", &v5);
        getchar();
        if ( v5 <= 7 )
          learn(v5, v9);
        break;
      case 2:
        v9 = (&spells)[rand() % 8];
        puts("You Move swiftly like a flash and dodged the incoming spell");
        break;
      case 3:
        puts("what's the place for your spell");
        printf(">> ");
        __isoc23_scanf("%u", &v5);
        getchar();
        if ( v5 <= 7 )
          forget(v5);
        break;
      case 4:
        puts("what's the place for your spell");
        printf(">> ");
        __isoc23_scanf("%u", &v5);
        getchar();
        if ( v5 <= 7 )
          remember(v5);
        break;
      case 5:
        puts("what's the place for your spell");
        printf(">> ");
        __isoc23_scanf("%u", &v5);
        getchar();
        if ( v5 <= 7 )
          add_special_spell(v5);
        break;
      case 6:
        puts("You cannot leave the wizard duel that easily!!");
        printf("before leaving you need to summon all your magic and knowledge to me >> ");
        v7 = malloc(0xE8u);
        read(0, v7, 0xE8u);
        printf("hey hey do you really think you can trick me, where are you going without telling me your special spell >> ");
        v8 = malloc(0xE8u);
        read(0, v8, 0xE8u);
        puts("exiting..");
        exit(0);
      default:
        puts("Invalid choice. Try again.");
        break;
    }
  }
}
// 1240: using guessed type __int64 __isoc23_scanf(const char *, ...);
// 5020: using guessed type char *spells;

//----- (0000000000001FF8) ----------------------------------------------------
// Alternative name is '_fini'
void term_proc()
{
  ;
}

// nfuncs=83 queued=37 decompiled=37 lumina nreq=0 worse=0 better=0
// ALL OK, 37 function(s) have been successfully decompiled
